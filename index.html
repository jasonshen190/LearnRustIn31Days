
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Rust è®­ç»ƒè¥å®Œæ•´è®¡åˆ’ï¼ˆ31å¤© + é¡¹ç›®éªŒæ”¶ï¼‰</title>
    <style>
        body { font-family: sans-serif; padding: 2rem; background: #fdfdfd; line-height: 1.6; }
        h1 { color: #a00000; }
        h2 { margin-top: 2em; color: #333; }
        p.date { color: #888; margin-bottom: 0.3em; }
        pre { background: #f4f4f4; padding: 1em; border-left: 3px solid #ccc; }
        a { color: #007acc; }
        #toc {
            background: #f9f9f9;
            border: 1px solid #aaa;
            padding: 1em;
            margin-bottom: 2em;
        }
        #toc h2 {
            margin-top: 0;
        }
        #toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        #toc ul li a {
            text-decoration: none;
        }
        #back-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #007acc;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            text-decoration: none;
            display: none;
        }
    </style>
</head>
<body>
    <h1>Rust WebSocket é¡¹ç›®è®­ç»ƒè¥ï¼šæ¯æ—¥ä»»åŠ¡ + ç»“æ„æ¨¡æ¿ + æœ€ç»ˆéªŒæ”¶</h1>
    <div id="toc">
        <h2>Table of Contents</h2>
        <ul></ul>
    </div>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-01</strong></p>
        <h2>Day 1 - å®‰è£… Rust å’Œæœ¬åœ°å¼€å‘ç¯å¢ƒ</h2>
        <p>ä½ å°†åœ¨æœ¬åœ°å®‰è£… Rust å·¥å…·é“¾ï¼ˆå« rustc, cargo, rustupï¼‰ï¼ŒéªŒè¯ç‰ˆæœ¬ï¼Œå¹¶æˆåŠŸåˆ›å»ºå’Œè¿è¡Œç¬¬ä¸€ä¸ª Rust ç¨‹åºã€‚</p>
        <p>ğŸ”— <a href="https://www.rust-lang.org/tools/install" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: å®‰è£… Rust</strong></p>
        <pre># macOS å’Œ Linux
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Windows (åœ¨ PowerShell ä¸­è¿è¡Œ)
# è®¿é—® https://rustup.rs/ ä¸‹è½½ rustup-init.exe</pre>

        <p><strong>æ­¥éª¤ 2: é…ç½®ç¯å¢ƒå˜é‡</strong></p>
        <pre># æ·»åŠ åˆ° shell é…ç½®æ–‡ä»¶ (~/.bashrc, ~/.zshrc ç­‰)
source ~/.cargo/env

# éªŒè¯å®‰è£…
rustc --version
cargo --version
rustup --version</pre>

        <p><strong>æ­¥éª¤ 3: åˆ›å»ºç¬¬ä¸€ä¸ªé¡¹ç›®</strong></p>
        <pre># åˆ›å»ºæ–°é¡¹ç›®
cargo new day01_hello_rust
cd day01_hello_rust

# æŸ¥çœ‹é¡¹ç›®ç»“æ„
tree . # æˆ–ä½¿ç”¨ ls -la</pre>

        <p><strong>æ­¥éª¤ 4: ç¼–å†™å’Œè¿è¡Œä»£ç </strong></p>
        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day01_hello_rust/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs     # ä¸»è¦æºä»£ç æ–‡ä»¶
â”œâ”€â”€ Cargo.toml      # é¡¹ç›®é…ç½®å’Œä¾èµ–ç®¡ç†
â””â”€â”€ .gitignore      # Git å¿½ç•¥æ–‡ä»¶</pre>

        <p><strong>main.rs ç¤ºä¾‹ä»£ç ï¼š</strong></p>
        <pre>fn main() {
    println!("Hello, Rust World!");
    println!("Welcome to the 31-day Rust WebSocket journey!");
    
    // æ˜¾ç¤ºä¸€äº›ç³»ç»Ÿä¿¡æ¯
    println!("Rust version: {}", env!("RUSTC_VERSION"));
    println!("Build target: {}", env!("TARGET"));
}</pre>

        <p><strong>Cargo.toml é…ç½®ï¼š</strong></p>
        <pre>[package]
name = "day01_hello_rust"
version = "0.1.0"
edition = "2021"

[dependencies]
# ä»Šå¤©ä¸éœ€è¦å¤–éƒ¨ä¾èµ–</pre>

        <p><strong>æ­¥éª¤ 5: ç¼–è¯‘å’Œè¿è¡Œ</strong></p>
        <pre># è¿è¡Œé¡¹ç›®ï¼ˆè‡ªåŠ¨ç¼–è¯‘ï¼‰
cargo run

# ä»…ç¼–è¯‘ï¼ˆä¸è¿è¡Œï¼‰
cargo build

# å‘å¸ƒæ¨¡å¼ç¼–è¯‘ï¼ˆä¼˜åŒ–ï¼‰
cargo build --release

# æ£€æŸ¥ä»£ç ï¼ˆå¿«é€Ÿè¯­æ³•æ£€æŸ¥ï¼‰
cargo check</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>ä¿®æ”¹ main.rsï¼Œæ·»åŠ ä½ çš„åå­—å’Œå­¦ä¹ ç›®æ ‡</li>
            <li>å°è¯•ä½¿ç”¨ `cargo run --verbose` æŸ¥çœ‹è¯¦ç»†ç¼–è¯‘è¿‡ç¨‹</li>
            <li>åˆ›å»ºä¸€ä¸ªè®¡ç®—å™¨å‡½æ•°ï¼Œè¿›è¡Œç®€å•çš„åŠ å‡ä¹˜é™¤è¿ç®—</li>
        </ul>

        <p><strong>æ‰©å±•ç»ƒä¹ ä»£ç ï¼š</strong></p>
        <pre>fn main() {
    println!("=== Day 1: Rust Environment Setup ===");
    
    // åŸºæœ¬è®¡ç®—å™¨
    let a = 10;
    let b = 3;
    
    println!("æ•°å­— {} å’Œ {} çš„è¿ç®—ç»“æœï¼š", a, b);
    println!("åŠ æ³•: {} + {} = {}", a, b, add(a, b));
    println!("å‡æ³•: {} - {} = {}", a, b, subtract(a, b));
    println!("ä¹˜æ³•: {} Ã— {} = {}", a, b, multiply(a, b));
    println!("é™¤æ³•: {} Ã· {} = {:.2}", a, b, divide(a, b));
}

fn add(x: i32, y: i32) -> i32 {
    x + y
}

fn subtract(x: i32, y: i32) -> i32 {
    x - y
}

fn multiply(x: i32, y: i32) -> i32 {
    x * y
}

fn divide(x: i32, y: i32) -> f64 {
    x as f64 / y as f64
}</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-02</strong></p>
        <h2>Day 2 - å˜é‡ã€ç±»å‹ä¸åŸºæœ¬å‡½æ•°</h2>
        <p>ä½ å°†å­¦ä¼šä½¿ç”¨ `let`ã€`mut` å£°æ˜å˜é‡ï¼ŒåŒºåˆ†åŸºæœ¬æ•°æ®ç±»å‹ï¼ˆæ•´æ•°ã€æµ®ç‚¹ã€å¸ƒå°”ã€å­—ç¬¦ä¸²ç­‰ï¼‰ï¼Œå¹¶å†™å‡ºå¸¦å‚æ•°å’Œè¿”å›å€¼çš„å‡½æ•°ã€‚</p>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®</strong></p>
        <pre>cargo new day02_variables_types
cd day02_variables_types</pre>

        <p><strong>æ­¥éª¤ 2: ç†è§£å˜é‡å£°æ˜</strong></p>
        <pre>fn main() {
    // ä¸å¯å˜å˜é‡ï¼ˆé»˜è®¤ï¼‰
    let x = 5;
    println!("x çš„å€¼æ˜¯: {}", x);
    
    // x = 6; // è¿™è¡Œä¼šç¼–è¯‘é”™è¯¯ï¼
    
    // å¯å˜å˜é‡
    let mut y = 10;
    println!("y çš„åˆå§‹å€¼: {}", y);
    y = 15; // å¯ä»¥ä¿®æ”¹
    println!("y çš„æ–°å€¼: {}", y);
    
    // å˜é‡é®è”½ï¼ˆshadowingï¼‰
    let z = 5;
    let z = z + 1; // åˆ›å»ºæ–°å˜é‡ï¼Œé®è”½æ—§çš„
    let z = z * 2;
    println!("z çš„æœ€ç»ˆå€¼: {}", z); // è¾“å‡º 12
}</pre>

        <p><strong>æ­¥éª¤ 3: åŸºæœ¬æ•°æ®ç±»å‹å®è·µ</strong></p>
        <pre>fn main() {
    println!("=== Rust åŸºæœ¬æ•°æ®ç±»å‹ ===");
    
    // æ•´æ•°ç±»å‹
    let small_int: i8 = 127;           // 8ä½æœ‰ç¬¦å·æ•´æ•°
    let big_int: i64 = 9223372036854775807; // 64ä½æœ‰ç¬¦å·æ•´æ•°
    let unsigned: u32 = 4294967295;    // 32ä½æ— ç¬¦å·æ•´æ•°
    
    println!("å°æ•´æ•°: {}, å¤§æ•´æ•°: {}, æ— ç¬¦å·: {}", small_int, big_int, unsigned);
    
    // æµ®ç‚¹ç±»å‹
    let float32: f32 = 3.14159;
    let float64: f64 = 2.718281828459045;
    
    println!("32ä½æµ®ç‚¹: {:.3}, 64ä½æµ®ç‚¹: {:.6}", float32, float64);
    
    // å¸ƒå°”ç±»å‹
    let is_rust_awesome: bool = true;
    let is_learning_hard: bool = false;
    
    println!("Rustå¾ˆæ£’å—? {}, å­¦ä¹ å›°éš¾å—? {}", is_rust_awesome, is_learning_hard);
    
    // å­—ç¬¦ç±»å‹ï¼ˆæ³¨æ„å•å¼•å·ï¼‰
    let heart_emoji: char = 'â¤';
    let letter: char = 'R';
    
    println!("å­—ç¬¦: {} {}", heart_emoji, letter);
    
    // å­—ç¬¦ä¸²ç±»å‹
    let greeting: &str = "Hello, Rust!";      // å­—ç¬¦ä¸²åˆ‡ç‰‡
    let owned_string: String = String::from("æˆ‘åœ¨å­¦ä¹  Rust"); // æ‹¥æœ‰æ‰€æœ‰æƒçš„å­—ç¬¦ä¸²
    
    println!("å­—ç¬¦ä¸²åˆ‡ç‰‡: {}", greeting);
    println!("String ç±»å‹: {}", owned_string);
}</pre>

        <p><strong>æ­¥éª¤ 4: å‡½æ•°å®šä¹‰ä¸è°ƒç”¨</strong></p>
        <pre>fn main() {
    println!("=== å‡½æ•°ç»ƒä¹  ===");
    
    // è°ƒç”¨æ— å‚æ•°å‡½æ•°
    say_hello();
    
    // è°ƒç”¨å¸¦å‚æ•°å‡½æ•°
    greet_user("å¼ ä¸‰");
    greet_user_with_age("æå››", 25);
    
    // è°ƒç”¨æœ‰è¿”å›å€¼çš„å‡½æ•°
    let sum = add_numbers(10, 20);
    println!("10 + 20 = {}", sum);
    
    let area = calculate_circle_area(5.0);
    println!("åŠå¾„ä¸º5çš„åœ†é¢ç§¯: {:.2}", area);
    
    // ä½¿ç”¨è¡¨è¾¾å¼è¿”å›å€¼çš„å‡½æ•°
    let max = find_maximum(15, 8);
    println!("15 å’Œ 8 çš„æœ€å¤§å€¼: {}", max);
}

// æ— å‚æ•°ï¼Œæ— è¿”å›å€¼
fn say_hello() {
    println!("ä½ å¥½ï¼Œä¸–ç•Œï¼");
}

// å¸¦å‚æ•°ï¼Œæ— è¿”å›å€¼
fn greet_user(name: &str) {
    println!("æ¬¢è¿ä½ ï¼Œ{}ï¼", name);
}

fn greet_user_with_age(name: &str, age: u32) {
    println!("ä½ å¥½ {}ï¼Œä½ ä»Šå¹´ {} å²äº†", name, age);
}

// å¸¦å‚æ•°ï¼Œæœ‰è¿”å›å€¼
fn add_numbers(a: i32, b: i32) -> i32 {
    return a + b; // æ˜¾å¼è¿”å›
}

fn calculate_circle_area(radius: f64) -> f64 {
    3.14159 * radius * radius // è¡¨è¾¾å¼è¿”å›ï¼ˆæ— åˆ†å·ï¼‰
}

// æ›´å¤æ‚çš„å‡½æ•°ç¤ºä¾‹
fn find_maximum(a: i32, b: i32) -> i32 {
    if a > b {
        a // è¿”å› a
    } else {
        b // è¿”å› b
    }
}</pre>

        <p><strong>æ­¥éª¤ 5: ç±»å‹æ¨æ–­ä¸æ˜¾å¼æ ‡æ³¨</strong></p>
        <pre>fn main() {
    // Rust çš„ç±»å‹æ¨æ–­å¾ˆå¼ºå¤§
    let auto_int = 42;          // è‡ªåŠ¨æ¨æ–­ä¸º i32
    let auto_float = 3.14;      // è‡ªåŠ¨æ¨æ–­ä¸º f64
    let auto_string = "hello";  // è‡ªåŠ¨æ¨æ–­ä¸º &str
    
    // æœ‰æ—¶éœ€è¦æ˜¾å¼æ ‡æ³¨
    let parsed_number: i32 = "42".parse().expect("ä¸æ˜¯æœ‰æ•ˆæ•°å­—");
    let bytes: Vec<u8> = vec![1, 2, 3, 4, 5];
    
    println!("è§£æçš„æ•°å­—: {}", parsed_number);
    println!("å­—èŠ‚æ•°ç»„: {:?}", bytes);
    
    // ç±»å‹åˆ«å
    type UserId = u64;
    type UserName = String;
    
    let user_id: UserId = 12345;
    let user_name: UserName = String::from("Rustå­¦ä¹ è€…");
    
    println!("ç”¨æˆ·ID: {}, ç”¨æˆ·å: {}", user_id, user_name);
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œè®¡ç®—ä¸¤ä¸ªæ•°çš„å¹³å‡å€¼</li>
            <li>ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œåˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºå¶æ•°</li>
            <li>å®ç°ä¸€ä¸ªç®€å•çš„BMIè®¡ç®—å™¨å‡½æ•°</li>
            <li>å°è¯•ä¸åŒçš„æ•°å€¼ç±»å‹è½¬æ¢</li>
        </ul>

        <p><strong>ç»¼åˆç»ƒä¹ ä»£ç ï¼š</strong></p>
        <pre>fn main() {
    println!("=== Day 2 ç»¼åˆç»ƒä¹  ===");
    
    // BMI è®¡ç®—å™¨
    let height = 1.75; // ç±³
    let weight = 70.0; // å…¬æ–¤
    let bmi = calculate_bmi(weight, height);
    println!("èº«é«˜ {}mï¼Œä½“é‡ {}kgï¼ŒBMI: {:.1}", height, weight, bmi);
    
    // å¶æ•°æ£€æŸ¥
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    for num in numbers {
        if is_even(num) {
            println!("{} æ˜¯å¶æ•°", num);
        } else {
            println!("{} æ˜¯å¥‡æ•°", num);
        }
    }
    
    // å¹³å‡å€¼è®¡ç®—
    let avg = average(85.5, 92.0);
    println!("ä¸¤æ¬¡è€ƒè¯•æˆç»©çš„å¹³å‡åˆ†: {:.1}", avg);
    
    // ç±»å‹è½¬æ¢ç¤ºä¾‹
    let int_val = 42i32;
    let float_val = int_val as f64;
    let back_to_int = float_val as i32;
    
    println!("æ•´æ•°: {} -> æµ®ç‚¹: {} -> æ•´æ•°: {}", int_val, float_val, back_to_int);
}

fn calculate_bmi(weight: f64, height: f64) -> f64 {
    weight / (height * height)
}

fn is_even(number: i32) -> bool {
    number % 2 == 0
}

fn average(a: f64, b: f64) -> f64 {
    (a + b) / 2.0
}

// æ¸©åº¦è½¬æ¢å‡½æ•°
fn celsius_to_fahrenheit(celsius: f64) -> f64 {
    celsius * 9.0 / 5.0 + 32.0
}

fn fahrenheit_to_celsius(fahrenheit: f64) -> f64 {
    (fahrenheit - 32.0) * 5.0 / 9.0
}</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day02_variables_types/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-03</strong></p>
        <h2>Day 3 - æ§åˆ¶æµï¼šifã€loop ä¸ match</h2>
        <p>ä½ å°†èƒ½æ ¹æ®æ¡ä»¶æ‰§è¡Œä¸åŒä»£ç ï¼Œç”¨ loop/while é‡å¤æ‰§è¡Œä»»åŠ¡ï¼Œå¹¶ä½¿ç”¨ `match` æ›¿ä»£åµŒå¥—çš„ if åˆ¤æ–­ã€‚</p>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®</strong></p>
        <pre>cargo new day03_control_flow
cd day03_control_flow</pre>

        <p><strong>æ­¥éª¤ 2: if æ¡ä»¶è¯­å¥</strong></p>
        <pre>fn main() {
    println!("=== if æ¡ä»¶è¯­å¥ç»ƒä¹  ===");
    
    let number = 42;
    
    // åŸºæœ¬ if è¯­å¥
    if number > 0 {
        println!("{} æ˜¯æ­£æ•°", number);
    }
    
    // if-else è¯­å¥
    if number % 2 == 0 {
        println!("{} æ˜¯å¶æ•°", number);
    } else {
        println!("{} æ˜¯å¥‡æ•°", number);
    }
    
    // if-else if-else é“¾
    let temperature = 25;
    if temperature > 30 {
        println!("å¤©æ°”å¾ˆçƒ­ï¼");
    } else if temperature > 20 {
        println!("å¤©æ°”åˆšå¥½");
    } else if temperature > 10 {
        println!("æœ‰ç‚¹å‡‰");
    } else {
        println!("å¾ˆå†·ï¼");
    }
    
    // if è¡¨è¾¾å¼ï¼ˆå¯ä»¥è¿”å›å€¼ï¼‰
    let condition = true;
    let result = if condition {
        "æ¡ä»¶ä¸ºçœŸ"
    } else {
        "æ¡ä»¶ä¸ºå‡"
    };
    println!("ç»“æœ: {}", result);
    
    // æ›´å¤æ‚çš„æ¡ä»¶åˆ¤æ–­
    let age = 18;
    let has_license = true;
    
    if age >= 18 && has_license {
        println!("å¯ä»¥å¼€è½¦");
    } else if age >= 18 {
        println!("å·²æˆå¹´ä½†æ²¡æœ‰é©¾ç…§");
    } else {
        println!("æœªæˆå¹´ï¼Œä¸èƒ½å¼€è½¦");
    }
}</pre>

        <p><strong>æ­¥éª¤ 3: å¾ªç¯è¯­å¥ - loop, while, for</strong></p>
        <pre>fn main() {
    println!("=== å¾ªç¯è¯­å¥ç»ƒä¹  ===");
    
    // 1. loop æ— é™å¾ªç¯ï¼ˆéœ€è¦æ‰‹åŠ¨ breakï¼‰
    println!("--- loop å¾ªç¯ ---");
    let mut counter = 0;
    loop {
        counter += 1;
        println!("å¾ªç¯ç¬¬ {} æ¬¡", counter);
        
        if counter == 3 {
            break; // è·³å‡ºå¾ªç¯
        }
    }
    
    // loop å¯ä»¥è¿”å›å€¼
    let mut multiply = 1;
    let result = loop {
        multiply *= 2;
        if multiply > 10 {
            break multiply; // è¿”å› multiply çš„å€¼
        }
    };
    println!("loop è¿”å›å€¼: {}", result);
    
    // 2. while æ¡ä»¶å¾ªç¯
    println!("--- while å¾ªç¯ ---");
    let mut number = 3;
    while number != 0 {
        println!("å€’è®¡æ—¶: {}", number);
        number -= 1;
    }
    println!("å‘å°„ï¼");
    
    // 3. for å¾ªç¯
    println!("--- for å¾ªç¯ ---");
    
    // éå†æ•°ç»„
    let numbers = [1, 2, 3, 4, 5];
    for num in numbers {
        println!("æ•°å­—: {}", num);
    }
    
    // ä½¿ç”¨èŒƒå›´
    for i in 1..=5 {  // 1 åˆ° 5ï¼ˆåŒ…å«5ï¼‰
        println!("èŒƒå›´å¾ªç¯: {}", i);
    }
    
    // å€’åºå¾ªç¯
    for i in (1..4).rev() {
        println!("å€’åº: {}", i);
    }
    
    // å¸¦ç´¢å¼•çš„å¾ªç¯
    let fruits = ["è‹¹æœ", "é¦™è•‰", "æ©™å­"];
    for (index, fruit) in fruits.iter().enumerate() {
        println!("ç¬¬{}ä¸ªæ°´æœ: {}", index + 1, fruit);
    }
}</pre>

        <p><strong>æ­¥éª¤ 4: match æ¨¡å¼åŒ¹é…</strong></p>
        <pre>fn main() {
    println!("=== match æ¨¡å¼åŒ¹é…ç»ƒä¹  ===");
    
    // åŸºæœ¬ match ç”¨æ³•
    let number = 3;
    match number {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        3 => println!("ä¸‰"),
        4 => println!("å››"),
        5 => println!("äº”"),
        _ => println!("å…¶ä»–æ•°å­—"), // _ æ˜¯é€šé…ç¬¦ï¼ŒåŒ¹é…æ‰€æœ‰å…¶ä»–æƒ…å†µ
    }
    
    // match åŒ¹é…èŒƒå›´
    let score = 85;
    match score {
        90..=100 => println!("ä¼˜ç§€"),
        80..=89 => println!("è‰¯å¥½"),
        70..=79 => println!("ä¸€èˆ¬"),
        60..=69 => println!("åŠæ ¼"),
        _ => println!("ä¸åŠæ ¼"),
    }
    
    // match è¡¨è¾¾å¼ï¼ˆè¿”å›å€¼ï¼‰
    let grade = match score {
        90..=100 => 'A',
        80..=89 => 'B',
        70..=79 => 'C',
        60..=69 => 'D',
        _ => 'F',
    };
    println!("æˆç»©ç­‰çº§: {}", grade);
    
    // åŒ¹é…å¤šä¸ªå€¼
    let day = 3;
    match day {
        1 | 2 | 3 | 4 | 5 => println!("å·¥ä½œæ—¥"),
        6 | 7 => println!("å‘¨æœ«"),
        _ => println!("æ— æ•ˆçš„æ—¥æœŸ"),
    }
    
    // åŒ¹é…æ¡ä»¶ï¼ˆå®ˆå«ï¼‰
    let number = Some(4);
    match number {
        Some(x) if x < 5 => println!("å°äº5çš„æ•°: {}", x),
        Some(x) => println!("å¤§äºç­‰äº5çš„æ•°: {}", x),
        None => println!("æ²¡æœ‰æ•°å­—"),
    }
}</pre>

        <p><strong>æ­¥éª¤ 5: åµŒå¥—å¾ªç¯å’Œæ ‡ç­¾</strong></p>
        <pre>fn main() {
    println!("=== åµŒå¥—å¾ªç¯å’Œæ ‡ç­¾ ===");
    
    // åµŒå¥—å¾ªç¯
    for i in 1..=3 {
        for j in 1..=3 {
            println!("i={}, j={}", i, j);
        }
    }
    
    // ä½¿ç”¨æ ‡ç­¾æ§åˆ¶å¤–å±‚å¾ªç¯
    'outer: for i in 1..=3 {
        for j in 1..=3 {
            if i == 2 && j == 2 {
                println!("åœ¨ i={}, j={} æ—¶è·³å‡ºå¤–å±‚å¾ªç¯", i, j);
                break 'outer; // è·³å‡ºå¤–å±‚å¾ªç¯
            }
            println!("i={}, j={}", i, j);
        }
    }
    
    // continue è·³è¿‡æœ¬æ¬¡å¾ªç¯
    println!("è·³è¿‡å¶æ•°:");
    for i in 1..=10 {
        if i % 2 == 0 {
            continue; // è·³è¿‡å¶æ•°
        }
        println!("å¥‡æ•°: {}", i);
    }
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>ç¼–å†™ä¸€ä¸ªçŒœæ•°å­—æ¸¸æˆï¼ˆä½¿ç”¨ loop å’Œ matchï¼‰</li>
            <li>å®ç°ä¸€ä¸ªç®€å•çš„è®¡ç®—å™¨ï¼Œæ ¹æ®æ“ä½œç¬¦æ‰§è¡Œä¸åŒè¿ç®—</li>
            <li>åˆ›å»ºä¸€ä¸ªä¹ä¹ä¹˜æ³•è¡¨</li>
            <li>ç¼–å†™ä¸€ä¸ªå‡½æ•°åˆ¤æ–­å¹´ä»½æ˜¯å¦ä¸ºé—°å¹´</li>
        </ul>

        <p><strong>ç»¼åˆç»ƒä¹ ä»£ç ï¼š</strong></p>
        <pre>fn main() {
    println!("=== Day 3 ç»¼åˆç»ƒä¹  ===");
    
    // 1. ç®€å•è®¡ç®—å™¨
    let a = 10;
    let b = 3;
    let operator = '+';
    
    let result = calculate(a, b, operator);
    println!("{} {} {} = {}", a, operator, b, result);
    
    // 2. å¹´ä»½åˆ¤æ–­
    let years = [2020, 2021, 2022, 2023, 2024];
    for year in years {
        if is_leap_year(year) {
            println!("{} æ˜¯é—°å¹´", year);
        } else {
            println!("{} ä¸æ˜¯é—°å¹´", year);
        }
    }
    
    // 3. ä¹ä¹ä¹˜æ³•è¡¨
    println!("ä¹ä¹ä¹˜æ³•è¡¨:");
    print_multiplication_table();
    
    // 4. æ•°å­—åˆ†ç±»
    let numbers = [1, 4, 9, 16, 25, 30, 36, 49, 64, 81, 100];
    for num in numbers {
        classify_number(num);
    }
}

fn calculate(a: i32, b: i32, op: char) -> i32 {
    match op {
        '+' => a + b,
        '-' => a - b,
        '*' => a * b,
        '/' => {
            if b != 0 {
                a / b
            } else {
                println!("é”™è¯¯ï¼šé™¤é›¶æ“ä½œ");
                0
            }
        }
        _ => {
            println!("ä¸æ”¯æŒçš„æ“ä½œç¬¦: {}", op);
            0
        }
    }
}

fn is_leap_year(year: i32) -> bool {
    if year % 400 == 0 {
        true
    } else if year % 100 == 0 {
        false
    } else if year % 4 == 0 {
        true
    } else {
        false
    }
}

fn print_multiplication_table() {
    for i in 1..=9 {
        for j in 1..=i {
            print!("{}Ã—{}={:2} ", j, i, i * j);
        }
        println!(); // æ¢è¡Œ
    }
}

fn classify_number(num: i32) {
    let sqrt_num = (num as f64).sqrt() as i32;
    
    match num {
        n if n < 0 => println!("{} æ˜¯è´Ÿæ•°", n),
        0 => println!("0 æ˜¯é›¶"),
        n if sqrt_num * sqrt_num == n => println!("{} æ˜¯å®Œå…¨å¹³æ–¹æ•°", n),
        n if n % 2 == 0 => println!("{} æ˜¯å¶æ•°", n),
        n => println!("{} æ˜¯å¥‡æ•°", n),
    }
}</pre>

        <p><strong>é«˜çº§ç»ƒä¹ ï¼šç®€å•çŒœæ•°å­—æ¸¸æˆ</strong></p>
        <pre>use std::io;

fn main() {
    println!("=== çŒœæ•°å­—æ¸¸æˆ ===");
    
    let secret_number = 42; // åœ¨å®é™…é¡¹ç›®ä¸­å¯ä»¥ç”¨éšæœºæ•°
    let mut attempts = 0;
    let max_attempts = 5;
    
    println!("æˆ‘æƒ³äº†ä¸€ä¸ª1åˆ°100ä¹‹é—´çš„æ•°å­—ï¼Œä½ æœ‰{}æ¬¡æœºä¼šçŒœå¯¹å®ƒï¼", max_attempts);
    
    loop {
        attempts += 1;
        println!("ç¬¬{}æ¬¡å°è¯•ï¼Œè¯·è¾“å…¥ä½ çš„çŒœæµ‹:", attempts);
        
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("è¯»å–è¾“å…¥å¤±è´¥");
        
        let guess: i32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—ï¼");
                attempts -= 1; // ä¸ç®—ä½œæœ‰æ•ˆå°è¯•
                continue;
            }
        };
        
        match guess {
            n if n < 1 || n > 100 => {
                println!("è¯·è¾“å…¥1åˆ°100ä¹‹é—´çš„æ•°å­—ï¼");
                attempts -= 1;
            }
            n if n < secret_number => println!("å¤ªå°äº†ï¼"),
            n if n > secret_number => println!("å¤ªå¤§äº†ï¼"),
            _ => {
                println!("æ­å–œä½ ï¼çŒœå¯¹äº†ï¼ç­”æ¡ˆå°±æ˜¯ {}", secret_number);
                println!("ä½ ç”¨äº† {} æ¬¡å°è¯•", attempts);
                break;
            }
        }
        
        if attempts >= max_attempts {
            println!("å¾ˆé—æ†¾ï¼Œä½ ç”¨å®Œäº†æ‰€æœ‰æœºä¼šã€‚ç­”æ¡ˆæ˜¯ {}", secret_number);
            break;
        }
    }
}</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day03_control_flow/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-04</strong></p>
        <h2>Day 4 - æ‰€æœ‰æƒä¸å¼•ç”¨ï¼šä¸ºä»€ä¹ˆ Rust ä¸å´©æºƒ</h2>
        <p>ä½ å°†ç¼–å†™ä¸€ä¸ªå‡½æ•°å¤„ç†å­—ç¬¦ä¸²å‚æ•°ï¼Œè§‚å¯Ÿæ‰€æœ‰æƒç§»åŠ¨å’Œå€Ÿç”¨è§„åˆ™ï¼Œå¹¶èƒ½è§£é‡Šä¸ºä½•ç¼–è¯‘å™¨ç¦æ­¢é‡å¤å¯å˜å€Ÿç”¨ã€‚</p>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®</strong></p>
        <pre>cargo new day04_ownership
cd day04_ownership</pre>

        <p><strong>æ­¥éª¤ 2: ç†è§£æ‰€æœ‰æƒåŸºæœ¬æ¦‚å¿µ</strong></p>
        <pre>fn main() {
    println!("=== æ‰€æœ‰æƒåŸºæœ¬æ¦‚å¿µ ===");
    
    // 1. æ ˆä¸Šçš„æ•°æ®ï¼ˆCopy ç±»å‹ï¼‰
    let x = 5;
    let y = x; // å¤åˆ¶ï¼Œx ä»ç„¶æœ‰æ•ˆ
    println!("x: {}, y: {}", x, y); // éƒ½å¯ä»¥ä½¿ç”¨
    
    // 2. å †ä¸Šçš„æ•°æ®ï¼ˆé Copy ç±»å‹ï¼‰
    let s1 = String::from("hello");
    let s2 = s1; // ç§»åŠ¨ï¼ˆmoveï¼‰ï¼Œs1 ä¸å†æœ‰æ•ˆ
    // println!("{}", s1); // è¿™è¡Œä¼šç¼–è¯‘é”™è¯¯ï¼
    println!("s2: {}", s2);
    
    // 3. å…‹éš†æ•°æ®
    let s3 = String::from("world");
    let s4 = s3.clone(); // æ·±æ‹·è´
    println!("s3: {}, s4: {}", s3, s4); // éƒ½å¯ä»¥ä½¿ç”¨
    
    // 4. å‡½æ•°è°ƒç”¨ä¸­çš„æ‰€æœ‰æƒ
    let msg = String::from("Hello, Rust!");
    take_ownership(msg); // msg çš„æ‰€æœ‰æƒè¢«ç§»åŠ¨
    // println!("{}", msg); // è¿™è¡Œä¼šç¼–è¯‘é”™è¯¯ï¼
    
    let num = 42;
    makes_copy(num); // æ•°å­—ç±»å‹ä¼šè¢«å¤åˆ¶
    println!("num ä»ç„¶æœ‰æ•ˆ: {}", num); // ä»ç„¶å¯ä»¥ä½¿ç”¨
}

fn take_ownership(some_string: String) {
    println!("æ¥æ”¶åˆ°å­—ç¬¦ä¸²: {}", some_string);
} // some_string ç¦»å¼€ä½œç”¨åŸŸï¼Œå†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) {
    println!("æ¥æ”¶åˆ°æ•°å­—: {}", some_integer);
} // some_integer ç¦»å¼€ä½œç”¨åŸŸï¼Œä½†å› ä¸ºæ˜¯ Copy ç±»å‹ï¼Œæ²¡æœ‰ç‰¹æ®Šå¤„ç†</pre>

        <p><strong>æ­¥éª¤ 3: å¼•ç”¨å’Œå€Ÿç”¨</strong></p>
        <pre>fn main() {
    println!("=== å¼•ç”¨å’Œå€Ÿç”¨ ===");
    
    let s1 = String::from("hello");
    
    // ä¸å¯å˜å¼•ç”¨
    let len = calculate_length(&s1); // å€Ÿç”¨ s1
    println!("'{}' çš„é•¿åº¦æ˜¯ {}", s1, len); // s1 ä»ç„¶æœ‰æ•ˆ
    
    // å¯å˜å¼•ç”¨
    let mut s2 = String::from("hello");
    change(&mut s2);
    println!("ä¿®æ”¹å: {}", s2);
    
    // å¼•ç”¨è§„åˆ™æ¼”ç¤º
    let mut s3 = String::from("hello");
    
    // å¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨
    let r1 = &s3;
    let r2 = &s3;
    println!("r1: {}, r2: {}", r1, r2);
    // r1 å’Œ r2 ä½œç”¨åŸŸç»“æŸ
    
    // ç„¶åå¯ä»¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨
    let r3 = &mut s3;
    r3.push_str(", world!");
    println!("r3: {}", r3);
    // ä¸èƒ½åŒæ—¶æœ‰å¯å˜å’Œä¸å¯å˜å¼•ç”¨
    
    // æ‚¬å‚å¼•ç”¨é¢„é˜²
    // let reference_to_nothing = dangle(); // è¿™ä¼šç¼–è¯‘é”™è¯¯
    let valid_string = no_dangle();
    println!("æœ‰æ•ˆçš„å­—ç¬¦ä¸²: {}", valid_string);
}

fn calculate_length(s: &String) -> usize {
    s.len()
} // s ç¦»å¼€ä½œç”¨åŸŸï¼Œä½†å› ä¸ºå®ƒåªæ˜¯å¼•ç”¨ï¼Œä¸ä¼šé‡Šæ”¾å†…å­˜

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}

// è¿™ä¸ªå‡½æ•°ä¼šäº§ç”Ÿæ‚¬å‚å¼•ç”¨ï¼Œç¼–è¯‘å™¨ä¼šé˜»æ­¢
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s // è¿”å›å¯¹å³å°†è¢«é‡Šæ”¾å†…å­˜çš„å¼•ç”¨
// }

fn no_dangle() -> String {
    let s = String::from("hello");
    s // ç›´æ¥è¿”å›æ‰€æœ‰æƒ
}</pre>

        <p><strong>æ­¥éª¤ 4: åˆ‡ç‰‡ï¼ˆsliceï¼‰</strong></p>
        <pre>fn main() {
    println!("=== åˆ‡ç‰‡ç»ƒä¹  ===");
    
    let s = String::from("hello world");
    
    // å­—ç¬¦ä¸²åˆ‡ç‰‡
    let hello = &s[0..5];   // æˆ– &s[..5]
    let world = &s[6..11];  // æˆ– &s[6..]
    let whole = &s[..];     // æ•´ä¸ªå­—ç¬¦ä¸²çš„åˆ‡ç‰‡
    
    println!("åŸå­—ç¬¦ä¸²: {}", s);
    println!("hello: {}, world: {}", hello, world);
    println!("æ•´ä¸ªå­—ç¬¦ä¸²: {}", whole);
    
    // ä½¿ç”¨åˆ‡ç‰‡çš„å‡½æ•°
    let first_word = first_word(&s);
    println!("ç¬¬ä¸€ä¸ªå•è¯: {}", first_word);
    
    // å­—ç¬¦ä¸²å­—é¢é‡å°±æ˜¯åˆ‡ç‰‡
    let s_literal = "Hello, world!"; // ç±»å‹æ˜¯ &str
    let first = first_word(s_literal);
    println!("å­—é¢é‡çš„ç¬¬ä¸€ä¸ªå•è¯: {}", first);
    
    // æ•°ç»„åˆ‡ç‰‡
    let arr = [1, 2, 3, 4, 5];
    let slice = &arr[1..4];
    println!("æ•°ç»„åˆ‡ç‰‡: {:?}", slice);
    
    // åˆ‡ç‰‡ä½œä¸ºå‚æ•°çš„ä¼˜åŠ¿
    let my_string = String::from("hello world");
    let word1 = first_word(&my_string[0..6]); // String çš„åˆ‡ç‰‡
    let word2 = first_word(&my_string[..]);    // æ•´ä¸ª String çš„åˆ‡ç‰‡
    let word3 = first_word("hello world");     // å­—ç¬¦ä¸²å­—é¢é‡
    
    println!("word1: {}, word2: {}, word3: {}", 
             first_word(&word1), first_word(&word2), word3);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..] // æ²¡æœ‰ç©ºæ ¼ï¼Œè¿”å›æ•´ä¸ªå­—ç¬¦ä¸²
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>ç¼–å†™å‡½æ•°è®¡ç®—å­—ç¬¦ä¸²ä¸­å•è¯çš„æ•°é‡ï¼ˆä½¿ç”¨å€Ÿç”¨ï¼‰</li>
            <li>å®ç°ä¸€ä¸ªå‡½æ•°äº¤æ¢ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å†…å®¹ï¼ˆä½¿ç”¨å¯å˜å¼•ç”¨ï¼‰</li>
            <li>åˆ›å»ºä¸€ä¸ªå‡½æ•°è¿”å›å­—ç¬¦ä¸²çš„æœ€åä¸€ä¸ªå•è¯</li>
            <li>ç¼–å†™ä»£ç æ¼”ç¤ºæ‰€æœ‰æƒè§„åˆ™çš„å„ç§åœºæ™¯</li>
        </ul>

        <p><strong>ç»¼åˆç»ƒä¹ ä»£ç ï¼š</strong></p>
        <pre>fn main() {
    println!("=== Day 4 ç»¼åˆç»ƒä¹  ===");
    
    // 1. å•è¯è®¡æ•°
    let sentence = "Rust is a systems programming language";
    let word_count = count_words(sentence);
    println!("å¥å­ '{}' æœ‰ {} ä¸ªå•è¯", sentence, word_count);
    
    // 2. å­—ç¬¦ä¸²äº¤æ¢
    let mut str1 = String::from("Hello");
    let mut str2 = String::from("World");
    println!("äº¤æ¢å‰: str1='{}', str2='{}'", str1, str2);
    swap_strings(&mut str1, &mut str2);
    println!("äº¤æ¢å: str1='{}', str2='{}'", str1, str2);
    
    // 3. æœ€åä¸€ä¸ªå•è¯
    let text = "Learn Rust programming language";
    let last = last_word(text);
    println!("'{}' çš„æœ€åä¸€ä¸ªå•è¯æ˜¯: '{}'", text, last);
    
    // 4. æ‰€æœ‰æƒè½¬ç§»æ¼”ç¤º
    let original = String::from("Original string");
    let processed = process_and_return(original);
    // println!("{}", original); // ç¼–è¯‘é”™è¯¯ï¼šoriginal å·²è¢«ç§»åŠ¨
    println!("å¤„ç†åçš„å­—ç¬¦ä¸²: {}", processed);
    
    // 5. å€Ÿç”¨vsæ‹¥æœ‰æ‰€æœ‰æƒçš„å¯¹æ¯”
    let data = String::from("Some data");
    
    // ä½¿ç”¨å€Ÿç”¨ï¼Œdata ä»ç„¶æœ‰æ•ˆ
    let length = get_length(&data);
    println!("æ•°æ® '{}' çš„é•¿åº¦æ˜¯ {}", data, length);
    
    // data ä»ç„¶å¯ä»¥ä½¿ç”¨
    println!("data ä»ç„¶æœ‰æ•ˆ: {}", data);
}

fn count_words(text: &str) -> usize {
    if text.trim().is_empty() {
        return 0;
    }
    
    text.split_whitespace().count()
}

fn swap_strings(str1: &mut String, str2: &mut String) {
    std::mem::swap(str1, str2);
}

fn last_word(text: &str) -> &str {
    let words: Vec<&str> = text.split_whitespace().collect();
    if words.is_empty() {
        ""
    } else {
        words[words.len() - 1]
    }
}

fn process_and_return(mut input: String) -> String {
    input.push_str(" - processed");
    input.to_uppercase()
}

fn get_length(s: &String) -> usize {
    s.len()
}

// æ›´é«˜çº§çš„å€Ÿç”¨ç¤ºä¾‹
fn advanced_borrowing_example() {
    let mut data = vec![1, 2, 3, 4, 5];
    
    // ä¸å¯å˜å€Ÿç”¨
    let sum = calculate_sum(&data);
    println!("æ•°ç»„ {:?} çš„å’Œæ˜¯ {}", data, sum);
    
    // å¯å˜å€Ÿç”¨
    modify_vec(&mut data);
    println!("ä¿®æ”¹åçš„æ•°ç»„: {:?}", data);
    
    // åˆ‡ç‰‡
    let slice = &data[1..4];
    println!("åˆ‡ç‰‡ [1..4]: {:?}", slice);
}

fn calculate_sum(numbers: &Vec<i32>) -> i32 {
    numbers.iter().sum()
}

fn modify_vec(numbers: &mut Vec<i32>) {
    for num in numbers.iter_mut() {
        *num *= 2;
    }
}</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day04_ownership/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-05</strong></p>
        <h2>Day 5 - ç»“æ„ä½“å®šä¹‰ä¸æ–¹æ³•æ·»åŠ </h2>
        <p>ä½ å°†å®šä¹‰ä¸€ä¸ª `User` ç»“æ„ä½“ï¼ŒåŒ…å«ç”¨æˆ·åå’Œç™»å½•æ¬¡æ•°ï¼Œå¹¶ä¸ºå…¶æ·»åŠ æ–¹æ³•å¦‚ `login()` ä¸ `describe()`ã€‚</p>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/ch05-00-structs.html" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®</strong></p>
        <pre>cargo new day05_structs
cd day05_structs</pre>

        <p><strong>æ­¥éª¤ 2: å®šä¹‰å’Œä½¿ç”¨ç»“æ„ä½“</strong></p>
        <pre>// å®šä¹‰ User ç»“æ„ä½“
#[derive(Debug)] // è‡ªåŠ¨å®ç° Debug traitï¼Œä¾¿äºæ‰“å°
struct User {
    username: String,
    email: String,
    login_count: u32,
    active: bool,
}

fn main() {
    println!("=== ç»“æ„ä½“åŸºç¡€ä½¿ç”¨ ===");
    
    // åˆ›å»ºç»“æ„ä½“å®ä¾‹
    let user1 = User {
        username: String::from("å¼ ä¸‰"),
        email: String::from("zhangsan@example.com"),
        login_count: 0,
        active: true,
    };
    
    println!("ç”¨æˆ·ä¿¡æ¯: {:?}", user1);
    println!("ç”¨æˆ·å: {}", user1.username);
    println!("é‚®ç®±: {}", user1.email);
    
    // å¯å˜ç»“æ„ä½“å®ä¾‹
    let mut user2 = User {
        username: String::from("æå››"),
        email: String::from("lisi@example.com"),
        login_count: 5,
        active: true,
    };
    
    user2.login_count += 1; // ä¿®æ”¹å­—æ®µ
    println!("æå››ç™»å½•æ¬¡æ•°æ›´æ–°ä¸º: {}", user2.login_count);
    
    // ä½¿ç”¨å‡½æ•°åˆ›å»ºç»“æ„ä½“
    let user3 = build_user(
        String::from("ç‹äº”"), 
        String::from("wangwu@example.com")
    );
    println!("é€šè¿‡å‡½æ•°åˆ›å»ºçš„ç”¨æˆ·: {:?}", user3);
    
    // ç»“æ„ä½“æ›´æ–°è¯­æ³•
    let user4 = User {
        username: String::from("èµµå…­"),
        email: String::from("zhaoliu@example.com"),
        ..user1 // ä½¿ç”¨ user1 çš„å…¶ä»–å­—æ®µå€¼
    };
    println!("ä½¿ç”¨æ›´æ–°è¯­æ³•åˆ›å»ºçš„ç”¨æˆ·: {:?}", user4);
}

fn build_user(username: String, email: String) -> User {
    User {
        username, // å­—æ®µåˆå§‹åŒ–ç®€å†™
        email,    // ç­‰åŒäº email: email
        login_count: 0,
        active: true,
    }
}</pre>

        <p><strong>æ­¥éª¤ 3: ä¸ºç»“æ„ä½“æ·»åŠ æ–¹æ³•</strong></p>
        <pre>#[derive(Debug)]
struct User {
    username: String,
    email: String,
    login_count: u32,
    active: bool,
}

// å®ç°å—ï¼ˆimpl blockï¼‰
impl User {
    // å…³è”å‡½æ•°ï¼ˆç±»ä¼¼é™æ€æ–¹æ³•ï¼‰
    fn new(username: String, email: String) -> User {
        User {
            username,
            email,
            login_count: 0,
            active: true,
        }
    }
    
    // æ–¹æ³•ï¼ˆéœ€è¦ self å‚æ•°ï¼‰
    fn login(&mut self) {
        self.login_count += 1;
        println!("ç”¨æˆ· {} ç™»å½•ï¼Œæ€»ç™»å½•æ¬¡æ•°: {}", self.username, self.login_count);
    }
    
    fn describe(&self) -> String {
        format!("ç”¨æˆ·: {}, é‚®ç®±: {}, ç™»å½•æ¬¡æ•°: {}, çŠ¶æ€: {}",
                self.username, 
                self.email, 
                self.login_count,
                if self.active { "æ´»è·ƒ" } else { "éæ´»è·ƒ" })
    }
    
    fn deactivate(&mut self) {
        self.active = false;
        println!("ç”¨æˆ· {} å·²è¢«åœç”¨", self.username);
    }
    
    fn is_frequent_user(&self) -> bool {
        self.login_count > 10
    }
    
    // æ¶ˆè´¹ self çš„æ–¹æ³•
    fn delete_account(self) -> String {
        format!("ç”¨æˆ· {} çš„è´¦æˆ·å·²è¢«åˆ é™¤", self.username)
    }
}

fn main() {
    println!("=== ç»“æ„ä½“æ–¹æ³•ç»ƒä¹  ===");
    
    // ä½¿ç”¨å…³è”å‡½æ•°åˆ›å»ºå®ä¾‹
    let mut user = User::new(
        String::from("Alice"),
        String::from("alice@example.com")
    );
    
    println!("æ–°ç”¨æˆ·: {}", user.describe());
    
    // è°ƒç”¨æ–¹æ³•
    user.login();
    user.login();
    user.login();
    
    println!("ç”¨æˆ·æè¿°: {}", user.describe());
    println!("æ˜¯å¦ä¸ºé¢‘ç¹ç”¨æˆ·: {}", user.is_frequent_user());
    
    // å¤šæ¬¡ç™»å½•åå†æ£€æŸ¥
    for _ in 0..10 {
        user.login();
    }
    
    println!("å¤šæ¬¡ç™»å½•åæ˜¯å¦ä¸ºé¢‘ç¹ç”¨æˆ·: {}", user.is_frequent_user());
    
    user.deactivate();
    println!("åœç”¨åçš„ç”¨æˆ·: {}", user.describe());
    
    // åˆ é™¤è´¦æˆ·ï¼ˆæ¶ˆè´¹ selfï¼‰
    let deletion_message = user.delete_account();
    println!("{}", deletion_message);
    // println!("{:?}", user); // ç¼–è¯‘é”™è¯¯ï¼šuser å·²è¢«ç§»åŠ¨
}</pre>

        <p><strong>æ­¥éª¤ 4: å…ƒç»„ç»“æ„ä½“å’Œå•å…ƒç»“æ„ä½“</strong></p>
        <pre>fn main() {
    println!("=== ç‰¹æ®Šç±»å‹çš„ç»“æ„ä½“ ===");
    
    // å…ƒç»„ç»“æ„ä½“
    #[derive(Debug)]
    struct Color(i32, i32, i32); // RGB
    
    #[derive(Debug)]
    struct Point(i32, i32, i32); // 3Dåæ ‡
    
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
    
    println!("é»‘è‰²: {:?}", black);
    println!("åŸç‚¹: {:?}", origin);
    println!("é»‘è‰²çš„çº¢è‰²åˆ†é‡: {}", black.0);
    
    // å•å…ƒç»“æ„ä½“ï¼ˆæ²¡æœ‰å­—æ®µï¼‰
    #[derive(Debug)]
    struct AlwaysEqual;
    
    let subject = AlwaysEqual;
    println!("å•å…ƒç»“æ„ä½“: {:?}", subject);
    
    // ä½¿ç”¨ç»“æ„ä½“çš„å®é™…ä¾‹å­
    let rectangle = Rectangle { width: 30, height: 50 };
    println!("çŸ©å½¢: {:?}", rectangle);
    println!("çŸ©å½¢é¢ç§¯: {}", rectangle.area());
    println!("çŸ©å½¢å‘¨é•¿: {}", rectangle.perimeter());
    
    let square = Rectangle::square(25);
    println!("æ­£æ–¹å½¢: {:?}, é¢ç§¯: {}", square, square.area());
    
    // æ¯”è¾ƒçŸ©å½¢
    let rect1 = Rectangle { width: 10, height: 20 };
    let rect2 = Rectangle { width: 20, height: 10 };
    
    println!("rect1 èƒ½å®¹çº³ rect2 å—? {}", rect1.can_hold(rect2));
}

#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    fn perimeter(&self) -> u32 {
        2 * (self.width + self.height)
    }
    
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
    
    fn can_hold(&self, other: Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>åˆ›å»ºä¸€ä¸ª `Book` ç»“æ„ä½“ï¼ŒåŒ…å«æ ‡é¢˜ã€ä½œè€…ã€é¡µæ•°ã€æ˜¯å¦å¯å€Ÿé˜…</li>
            <li>ä¸º `Book` æ·»åŠ å€Ÿé˜…ã€å½’è¿˜ã€è·å–ä¿¡æ¯ç­‰æ–¹æ³•</li>
            <li>å®ç°ä¸€ä¸ª `Library` ç»“æ„ä½“ï¼Œç®¡ç†å¤šæœ¬ä¹¦ç±</li>
            <li>åˆ›å»ºä¸€ä¸ª `BankAccount` ç»“æ„ä½“ï¼Œå®ç°å­˜æ¬¾ã€å–æ¬¾åŠŸèƒ½</li>
        </ul>

        <p><strong>ç»¼åˆç»ƒä¹ ä»£ç ï¼š</strong></p>
        <pre>#[derive(Debug, Clone)]
struct Book {
    title: String,
    author: String,
    pages: u32,
    available: bool,
}

impl Book {
    fn new(title: String, author: String, pages: u32) -> Book {
        Book {
            title,
            author,
            pages,
            available: true,
        }
    }
    
    fn borrow_book(&mut self) -> Result<String, String> {
        if self.available {
            self.available = false;
            Ok(format!("æˆåŠŸå€Ÿé˜…ã€Š{}ã€‹", self.title))
        } else {
            Err(format!("ã€Š{}ã€‹å·²è¢«å€Ÿå‡º", self.title))
        }
    }
    
    fn return_book(&mut self) -> String {
        self.available = true;
        format!("ã€Š{}ã€‹å·²å½’è¿˜", self.title)
    }
    
    fn info(&self) -> String {
        format!("ã€Š{}ã€‹- ä½œè€…: {}, é¡µæ•°: {}, çŠ¶æ€: {}",
                self.title,
                self.author,
                self.pages,
                if self.available { "å¯å€Ÿ" } else { "å·²å€Ÿå‡º" })
    }
}

#[derive(Debug)]
struct BankAccount {
    account_number: String,
    holder_name: String,
    balance: f64,
}

impl BankAccount {
    fn new(account_number: String, holder_name: String) -> BankAccount {
        BankAccount {
            account_number,
            holder_name,
            balance: 0.0,
        }
    }
    
    fn deposit(&mut self, amount: f64) -> Result<String, String> {
        if amount > 0.0 {
            self.balance += amount;
            Ok(format!("å­˜æ¬¾ {:.2} å…ƒæˆåŠŸï¼Œä½™é¢: {:.2} å…ƒ", amount, self.balance))
        } else {
            Err("å­˜æ¬¾é‡‘é¢å¿…é¡»å¤§äº0".to_string())
        }
    }
    
    fn withdraw(&mut self, amount: f64) -> Result<String, String> {
        if amount <= 0.0 {
            return Err("å–æ¬¾é‡‘é¢å¿…é¡»å¤§äº0".to_string());
        }
        
        if amount > self.balance {
            return Err("ä½™é¢ä¸è¶³".to_string());
        }
        
        self.balance -= amount;
        Ok(format!("å–æ¬¾ {:.2} å…ƒæˆåŠŸï¼Œä½™é¢: {:.2} å…ƒ", amount, self.balance))
    }
    
    fn get_balance(&self) -> f64 {
        self.balance
    }
    
    fn account_info(&self) -> String {
        format!("è´¦æˆ·: {}, æˆ·ä¸»: {}, ä½™é¢: {:.2} å…ƒ",
                self.account_number,
                self.holder_name,
                self.balance)
    }
}

fn main() {
    println!("=== Day 5 ç»¼åˆç»ƒä¹  ===");
    
    // å›¾ä¹¦ç®¡ç†ç³»ç»Ÿ
    println!("--- å›¾ä¹¦ç®¡ç† ---");
    let mut book1 = Book::new(
        "Rustç¼–ç¨‹è¯­è¨€".to_string(),
        "Steve Klabnik".to_string(),
        500
    );
    
    let mut book2 = Book::new(
        "æ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿ".to_string(),
        "Randal E. Bryant".to_string(),
        800
    );
    
    println!("{}", book1.info());
    println!("{}", book2.info());
    
    // å€Ÿé˜…æ“ä½œ
    match book1.borrow_book() {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("é”™è¯¯: {}", err),
    }
    
    // å†æ¬¡å€Ÿé˜…åŒä¸€æœ¬ä¹¦
    match book1.borrow_book() {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("é”™è¯¯: {}", err),
    }
    
    // å½’è¿˜ä¹¦ç±
    println!("{}", book1.return_book());
    
    // é“¶è¡Œè´¦æˆ·ç³»ç»Ÿ
    println!("\n--- é“¶è¡Œè´¦æˆ· ---");
    let mut account = BankAccount::new(
        "6228480000000000000".to_string(),
        "å¼ ä¸‰".to_string()
    );
    
    println!("{}", account.account_info());
    
    // å­˜æ¬¾
    match account.deposit(1000.0) {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("é”™è¯¯: {}", err),
    }
    
    match account.deposit(500.0) {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("é”™è¯¯: {}", err),
    }
    
    // å–æ¬¾
    match account.withdraw(200.0) {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("é”™è¯¯: {}", err),
    }
    
    // å°è¯•å–æ¬¾è¶…è¿‡ä½™é¢
    match account.withdraw(2000.0) {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("é”™è¯¯: {}", err),
    }
    
    println!("\næœ€ç»ˆè´¦æˆ·ä¿¡æ¯: {}", account.account_info());
}</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day05_structs/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-06</strong></p>
        <h2>Day 6 - æšä¸¾ä¸ matchï¼šå¤„ç†çŠ¶æ€æˆ–å‘½ä»¤</h2>
        <p>ä½ å°†å†™ä¸€ä¸ª `UserMessage` æšä¸¾ç±»å‹ï¼Œç”¨äºè¡¨ç¤ºæ–‡æœ¬æ¶ˆæ¯ã€å¿ƒè·³ã€å…³é—­è¿æ¥ç­‰ï¼Œå¹¶ä½¿ç”¨ `match` åˆ†åˆ«å¤„ç†è¿™äº›å˜ä½“ã€‚ä½ å°†ç†è§£å¦‚ä½•æ›¿ä»£å­—ç¬¦ä¸²ç±»å‹åŒ¹é…ï¼Œå¹¶å°†ä»£ç å†™å¾—æ›´å®‰å…¨ã€‚</p>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/ch06-00-enums.html" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®</strong></p>
        <pre>cargo new day06_enums
cd day06_enums</pre>

        <p><strong>æ­¥éª¤ 2: åŸºæœ¬æšä¸¾å®šä¹‰å’Œä½¿ç”¨</strong></p>
        <pre>#[derive(Debug)]
enum IpAddrKind {
    V4,
    V6,
}

#[derive(Debug)]
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

fn main() {
    println!("=== æšä¸¾åŸºç¡€ ===");
    
    // ç®€å•æšä¸¾
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
    
    println!("IPv4 ç±»å‹: {:?}", four);
    println!("IPv6 ç±»å‹: {:?}", six);
    
    // å¸¦æ•°æ®çš„æšä¸¾
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));
    
    println!("æœ¬åœ°åœ°å€: {:?}", home);
    println!("å›ç¯åœ°å€: {:?}", loopback);
    
    // ä½¿ç”¨å‡½æ•°å¤„ç†æšä¸¾
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
    
    process_ip_address(home);
    process_ip_address(loopback);
}

fn route(ip_kind: IpAddrKind) {
    match ip_kind {
        IpAddrKind::V4 => println!("è·¯ç”±åˆ° IPv4 åœ°å€"),
        IpAddrKind::V6 => println!("è·¯ç”±åˆ° IPv6 åœ°å€"),
    }
}

fn process_ip_address(ip: IpAddr) {
    match ip {
        IpAddr::V4(a, b, c, d) => {
            println!("å¤„ç† IPv4 åœ°å€: {}.{}.{}.{}", a, b, c, d);
        }
        IpAddr::V6(addr) => {
            println!("å¤„ç† IPv6 åœ°å€: {}", addr);
        }
    }
}</pre>

        <p><strong>æ­¥éª¤ 3: WebSocket æ¶ˆæ¯ç±»å‹æšä¸¾</strong></p>
        <pre>#[derive(Debug, Clone)]
enum UserMessage {
    Text(String),
    Heartbeat,
    Close { code: u16, reason: String },
    Binary(Vec<u8>),
    Join { room: String, username: String },
    Leave { room: String },
}

#[derive(Debug)]
enum ConnectionStatus {
    Connected,
    Connecting,
    Disconnected,
    Error(String),
}

fn main() {
    println!("=== WebSocket æ¶ˆæ¯å¤„ç† ===");
    
    // åˆ›å»ºä¸åŒç±»å‹çš„æ¶ˆæ¯
    let messages = vec![
        UserMessage::Text("Hello, WebSocket!".to_string()),
        UserMessage::Heartbeat,
        UserMessage::Join {
            room: "general".to_string(),
            username: "Alice".to_string(),
        },
        UserMessage::Binary(vec![0x48, 0x65, 0x6c, 0x6c, 0x6f]), // "Hello" in bytes
        UserMessage::Leave { room: "general".to_string() },
        UserMessage::Close {
            code: 1000,
            reason: "Normal closure".to_string(),
        },
    ];
    
    for message in messages {
        handle_message(message);
    }
    
    // è¿æ¥çŠ¶æ€å¤„ç†
    println!("\n=== è¿æ¥çŠ¶æ€å¤„ç† ===");
    let statuses = vec![
        ConnectionStatus::Connecting,
        ConnectionStatus::Connected,
        ConnectionStatus::Error("Network timeout".to_string()),
        ConnectionStatus::Disconnected,
    ];
    
    for status in statuses {
        handle_connection_status(status);
    }
}

fn handle_message(msg: UserMessage) {
    match msg {
        UserMessage::Text(content) => {
            println!("ğŸ“ æ”¶åˆ°æ–‡æœ¬æ¶ˆæ¯: {}", content);
            // è¿™é‡Œå¯ä»¥æ·»åŠ æ–‡æœ¬æ¶ˆæ¯çš„å¤„ç†é€»è¾‘
        }
        UserMessage::Heartbeat => {
            println!("ğŸ’“ æ”¶åˆ°å¿ƒè·³åŒ…");
            // å‘é€å¿ƒè·³å“åº”
        }
        UserMessage::Close { code, reason } => {
            println!("ğŸ”Œ è¿æ¥å…³é—­ - ä»£ç : {}, åŸå› : {}", code, reason);
            // æ¸…ç†èµ„æº
        }
        UserMessage::Binary(data) => {
            println!("ğŸ“¦ æ”¶åˆ°äºŒè¿›åˆ¶æ•°æ®: {} å­—èŠ‚", data.len());
            // å¤„ç†äºŒè¿›åˆ¶æ•°æ®
            if let Ok(text) = String::from_utf8(data) {
                println!("    è½¬æ¢ä¸ºæ–‡æœ¬: {}", text);
            }
        }
        UserMessage::Join { room, username } => {
            println!("ğŸšª ç”¨æˆ· {} åŠ å…¥æˆ¿é—´ {}", username, room);
            // å°†ç”¨æˆ·æ·»åŠ åˆ°æˆ¿é—´
        }
        UserMessage::Leave { room } => {
            println!("ğŸšª ç”¨æˆ·ç¦»å¼€æˆ¿é—´ {}", room);
            // ä»æˆ¿é—´ç§»é™¤ç”¨æˆ·
        }
    }
}

fn handle_connection_status(status: ConnectionStatus) {
    match status {
        ConnectionStatus::Connecting => {
            println!("ğŸ”„ æ­£åœ¨è¿æ¥...");
        }
        ConnectionStatus::Connected => {
            println!("âœ… è¿æ¥å·²å»ºç«‹");
        }
        ConnectionStatus::Disconnected => {
            println!("âŒ è¿æ¥å·²æ–­å¼€");
        }
        ConnectionStatus::Error(err_msg) => {
            println!("âš ï¸ è¿æ¥é”™è¯¯: {}", err_msg);
            // è¿™é‡Œå¯ä»¥æ·»åŠ é”™è¯¯å¤„ç†é€»è¾‘
        }
    }
}</pre>

        <p><strong>æ­¥éª¤ 4: Option å’Œ Result æ·±å…¥ç†è§£</strong></p>
        <pre>fn main() {
    println!("=== Option å’Œ Result ä½¿ç”¨ ===");
    
    // Option å¤„ç†å¯èƒ½ä¸ºç©ºçš„å€¼
    let numbers = vec![1, 2, 3, 4, 5];
    
    match find_number(&numbers, 3) {
        Some(index) => println!("æ‰¾åˆ°æ•°å­— 3 åœ¨ç´¢å¼• {}", index),
        None => println!("æ²¡æœ‰æ‰¾åˆ°æ•°å­— 3"),
    }
    
    match find_number(&numbers, 10) {
        Some(index) => println!("æ‰¾åˆ°æ•°å­— 10 åœ¨ç´¢å¼• {}", index),
        None => println!("æ²¡æœ‰æ‰¾åˆ°æ•°å­— 10"),
    }
    
    // Result å¤„ç†å¯èƒ½å¤±è´¥çš„æ“ä½œ
    match divide(10.0, 2.0) {
        Ok(result) => println!("10 Ã· 2 = {}", result),
        Err(err) => println!("é™¤æ³•é”™è¯¯: {}", err),
    }
    
    match divide(10.0, 0.0) {
        Ok(result) => println!("10 Ã· 0 = {}", result),
        Err(err) => println!("é™¤æ³•é”™è¯¯: {}", err),
    }
    
    // é“¾å¼è°ƒç”¨å’Œ ? æ“ä½œç¬¦çš„æ›¿ä»£
    println!("\n=== å¤„ç†å¤šä¸ªå¯èƒ½å¤±è´¥çš„æ“ä½œ ===");
    
    match parse_and_double("42") {
        Ok(result) => println!("è§£æå¹¶ç¿»å€ç»“æœ: {}", result),
        Err(err) => println!("æ“ä½œå¤±è´¥: {}", err),
    }
    
    match parse_and_double("abc") {
        Ok(result) => println!("è§£æå¹¶ç¿»å€ç»“æœ: {}", result),
        Err(err) => println!("æ“ä½œå¤±è´¥: {}", err),
    }
    
    // Option çš„å¸¸ç”¨æ–¹æ³•
    println!("\n=== Option çš„å¸¸ç”¨æ–¹æ³• ===");
    
    let some_value = Some(42);
    let none_value: Option<i32> = None;
    
    println!("some_value.is_some(): {}", some_value.is_some());
    println!("none_value.is_none(): {}", none_value.is_none());
    
    // unwrap_or æä¾›é»˜è®¤å€¼
    println!("some_value.unwrap_or(0): {}", some_value.unwrap_or(0));
    println!("none_value.unwrap_or(0): {}", none_value.unwrap_or(0));
    
    // map è½¬æ¢ Option ä¸­çš„å€¼
    let doubled = some_value.map(|x| x * 2);
    println!("some_value ç¿»å€: {:?}", doubled);
}

fn find_number(numbers: &[i32], target: i32) -> Option<usize> {
    for (index, &number) in numbers.iter().enumerate() {
        if number == target {
            return Some(index);
        }
    }
    None
}

fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())
    } else {
        Ok(a / b)
    }
}

fn parse_and_double(s: &str) -> Result<i32, String> {
    match s.parse::<i32>() {
        Ok(num) => Ok(num * 2),
        Err(_) => Err(format!("æ— æ³•è§£æ '{}' ä¸ºæ•°å­—", s)),
    }
}</pre>

        <p><strong>æ­¥éª¤ 5: æšä¸¾çš„æ–¹æ³•å®ç°</strong></p>
        <pre>#[derive(Debug, Clone)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn process(&self) {
        match self {
            Message::Quit => {
                println!("é€€å‡ºåº”ç”¨ç¨‹åº");
            }
            Message::Move { x, y } => {
                println!("ç§»åŠ¨åˆ°åæ ‡ ({}, {})", x, y);
            }
            Message::Write(text) => {
                println!("æ˜¾ç¤ºæ–‡æœ¬: {}", text);
            }
            Message::ChangeColor(r, g, b) => {
                println!("æ”¹å˜é¢œè‰²ä¸º RGB({}, {}, {})", r, g, b);
            }
        }
    }
    
    fn is_quit(&self) -> bool {
        matches!(self, Message::Quit)
    }
    
    fn get_description(&self) -> String {
        match self {
            Message::Quit => "é€€å‡ºæ¶ˆæ¯".to_string(),
            Message::Move { .. } => "ç§»åŠ¨æ¶ˆæ¯".to_string(),
            Message::Write(_) => "æ–‡æœ¬æ¶ˆæ¯".to_string(),
            Message::ChangeColor(_, _, _) => "é¢œè‰²å˜æ›´æ¶ˆæ¯".to_string(),
        }
    }
}

fn main() {
    println!("=== æšä¸¾æ–¹æ³•æ¼”ç¤º ===");
    
    let messages = vec![
        Message::Move { x: 10, y: 20 },
        Message::Write("Hello, Rust!".to_string()),
        Message::ChangeColor(255, 0, 0),
        Message::Quit,
    ];
    
    for msg in &messages {
        println!("æ¶ˆæ¯ç±»å‹: {}", msg.get_description());
        msg.process();
        println!("æ˜¯å¦ä¸ºé€€å‡ºæ¶ˆæ¯: {}", msg.is_quit());
        println!();
    }
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>åˆ›å»ºä¸€ä¸ª `OrderStatus` æšä¸¾ï¼Œè¡¨ç¤ºè®¢å•çš„ä¸åŒçŠ¶æ€</li>
            <li>å®ç°ä¸€ä¸ª `HttpResponse` æšä¸¾ï¼Œå¤„ç†ä¸åŒçš„HTTPå“åº”</li>
            <li>è®¾è®¡ä¸€ä¸ªæ¸¸æˆçŠ¶æ€æšä¸¾ï¼ŒåŒ…å«å¼€å§‹ã€æ¸¸æˆä¸­ã€æš‚åœã€ç»“æŸç­‰çŠ¶æ€</li>
            <li>åˆ›å»ºä¸€ä¸ªè¡¨ç¤ºä¸åŒå‡ ä½•å½¢çŠ¶çš„æšä¸¾ï¼Œå¹¶è®¡ç®—é¢ç§¯</li>
        </ul>

        <p><strong>ç»¼åˆç»ƒä¹ ä»£ç ï¼š</strong></p>
        <pre>#[derive(Debug, Clone)]
enum OrderStatus {
    Pending,
    Processing { estimated_time: u32 }, // åˆ†é’Ÿ
    Shipped { tracking_number: String },
    Delivered { delivery_time: String },
    Cancelled { reason: String },
}

#[derive(Debug)]
enum HttpResponse {
    Ok { body: String },
    NotFound,
    InternalServerError { message: String },
    BadRequest { error: String },
}

#[derive(Debug)]
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl OrderStatus {
    fn description(&self) -> String {
        match self {
            OrderStatus::Pending => "è®¢å•å¾…å¤„ç†".to_string(),
            OrderStatus::Processing { estimated_time } => {
                format!("è®¢å•å¤„ç†ä¸­ï¼Œé¢„è®¡ {} åˆ†é’Ÿå®Œæˆ", estimated_time)
            }
            OrderStatus::Shipped { tracking_number } => {
                format!("è®¢å•å·²å‘è´§ï¼Œå¿«é€’å•å·: {}", tracking_number)
            }
            OrderStatus::Delivered { delivery_time } => {
                format!("è®¢å•å·²é€è¾¾ï¼Œé€è¾¾æ—¶é—´: {}", delivery_time)
            }
            OrderStatus::Cancelled { reason } => {
                format!("è®¢å•å·²å–æ¶ˆï¼ŒåŸå› : {}", reason)
            }
        }
    }
    
    fn is_completed(&self) -> bool {
        matches!(self, OrderStatus::Delivered { .. } | OrderStatus::Cancelled { .. })
    }
}

impl HttpResponse {
    fn status_code(&self) -> u16 {
        match self {
            HttpResponse::Ok { .. } => 200,
            HttpResponse::NotFound => 404,
            HttpResponse::InternalServerError { .. } => 500,
            HttpResponse::BadRequest { .. } => 400,
        }
    }
    
    fn handle(&self) {
        match self {
            HttpResponse::Ok { body } => {
                println!("âœ… è¯·æ±‚æˆåŠŸ (200): {}", body);
            }
            HttpResponse::NotFound => {
                println!("âŒ é¡µé¢æœªæ‰¾åˆ° (404)");
            }
            HttpResponse::InternalServerError { message } => {
                println!("ğŸ’¥ æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ (500): {}", message);
            }
            HttpResponse::BadRequest { error } => {
                println!("âš ï¸ è¯·æ±‚é”™è¯¯ (400): {}", error);
            }
        }
    }
}

impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Circle { radius } => std::f64::consts::PI * radius * radius,
            Shape::Rectangle { width, height } => width * height,
            Shape::Triangle { base, height } => 0.5 * base * height,
        }
    }
    
    fn perimeter(&self) -> f64 {
        match self {
            Shape::Circle { radius } => 2.0 * std::f64::consts::PI * radius,
            Shape::Rectangle { width, height } => 2.0 * (width + height),
            Shape::Triangle { base, height } => {
                // å‡è®¾æ˜¯ç­‰è…°ä¸‰è§’å½¢ï¼Œè®¡ç®—è¿‘ä¼¼å‘¨é•¿
                let side = (height * height + (base / 2.0) * (base / 2.0)).sqrt();
                base + 2.0 * side
            }
        }
    }
}

fn main() {
    println!("=== Day 6 ç»¼åˆç»ƒä¹  ===");
    
    // è®¢å•çŠ¶æ€ç®¡ç†
    println!("--- è®¢å•çŠ¶æ€ç®¡ç† ---");
    let order_statuses = vec![
        OrderStatus::Pending,
        OrderStatus::Processing { estimated_time: 30 },
        OrderStatus::Shipped { tracking_number: "SF1234567890".to_string() },
        OrderStatus::Delivered { delivery_time: "2025-08-06 14:30".to_string() },
        OrderStatus::Cancelled { reason: "ç”¨æˆ·å–æ¶ˆ".to_string() },
    ];
    
    for status in &order_statuses {
        println!("{}", status.description());
        println!("è®¢å•æ˜¯å¦å®Œæˆ: {}", status.is_completed());
        println!();
    }
    
    // HTTP å“åº”å¤„ç†
    println!("--- HTTP å“åº”å¤„ç† ---");
    let responses = vec![
        HttpResponse::Ok { body: "ç”¨æˆ·æ•°æ®è·å–æˆåŠŸ".to_string() },
        HttpResponse::NotFound,
        HttpResponse::BadRequest { error: "ç¼ºå°‘å¿…è¦å‚æ•°".to_string() },
        HttpResponse::InternalServerError { message: "æ•°æ®åº“è¿æ¥å¤±è´¥".to_string() },
    ];
    
    for response in &responses {
        println!("çŠ¶æ€ç : {}", response.status_code());
        response.handle();
        println!();
    }
    
    // å‡ ä½•å½¢çŠ¶è®¡ç®—
    println!("--- å‡ ä½•å½¢çŠ¶è®¡ç®— ---");
    let shapes = vec![
        Shape::Circle { radius: 5.0 },
        Shape::Rectangle { width: 10.0, height: 8.0 },
        Shape::Triangle { base: 12.0, height: 9.0 },
    ];
    
    for shape in &shapes {
        println!("å½¢çŠ¶: {:?}", shape);
        println!("é¢ç§¯: {:.2}", shape.area());
        println!("å‘¨é•¿: {:.2}", shape.perimeter());
        println!();
    }
}</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day06_enums/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-07</strong></p>
        <h2>Day 7 - Option ä¸ Resultï¼šæ„å»ºå®‰å…¨è¿”å›å€¼</h2>
        <p>ä½ å°†å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ ¹æ®ç”¨æˆ·åè¿”å›ç”¨æˆ·ç»“æ„ä½“ï¼ˆä½¿ç”¨ Optionï¼‰ï¼Œä»¥åŠä¸€ä¸ªå¯èƒ½å¤±è´¥çš„æ³¨å†Œæµç¨‹ï¼ˆè¿”å› Resultï¼‰ã€‚ä½ å°†çŸ¥é“ä»€ä¹ˆæ—¶å€™ä½¿ç”¨å“ªç§ç±»å‹ï¼Œä»¥åŠå¦‚ä½•ç”¨ `?` ä¼˜é›…åœ°ä¼ æ’­é”™è¯¯ã€‚</p>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®</strong></p>
        <pre>cargo new day07_option_result
cd day07_option_result</pre>

        <p><strong>æ­¥éª¤ 2: Option æ·±å…¥ç†è§£</strong></p>
        <pre>#[derive(Debug, Clone)]
struct User {
    id: u32,
    username: String,
    email: String,
    age: Option<u8>, // å¹´é¾„å¯èƒ½ä¸æä¾›
}

fn main() {
    println!("=== Option æ·±å…¥ä½¿ç”¨ ===");
    
    // åˆ›å»ºç”¨æˆ·æ•°æ®åº“
    let users = vec![
        User {
            id: 1,
            username: "alice".to_string(),
            email: "alice@example.com".to_string(),
            age: Some(25),
        },
        User {
            id: 2,
            username: "bob".to_string(),
            email: "bob@example.com".to_string(),
            age: None, // æ²¡æœ‰æä¾›å¹´é¾„
        },
        User {
            id: 3,
            username: "charlie".to_string(),
            email: "charlie@example.com".to_string(),
            age: Some(30),
        },
    ];
    
    // æ ¹æ®ç”¨æˆ·åæŸ¥æ‰¾ç”¨æˆ·
    match find_user_by_username(&users, "alice") {
        Some(user) => {
            println!("æ‰¾åˆ°ç”¨æˆ·: {:?}", user);
            display_user_age(&user);
        }
        None => println!("ç”¨æˆ·ä¸å­˜åœ¨"),
    }
    
    match find_user_by_username(&users, "david") {
        Some(user) => println!("æ‰¾åˆ°ç”¨æˆ·: {:?}", user),
        None => println!("ç”¨æˆ· david ä¸å­˜åœ¨"),
    }
    
    // Option çš„å¸¸ç”¨æ–¹æ³•æ¼”ç¤º
    demonstrate_option_methods(&users);
}

fn find_user_by_username(users: &[User], username: &str) -> Option<&User> {
    for user in users {
        if user.username == username {
            return Some(user);
        }
    }
    None
}

fn display_user_age(user: &User) {
    match user.age {
        Some(age) => println!("ç”¨æˆ· {} çš„å¹´é¾„æ˜¯ {}", user.username, age),
        None => println!("ç”¨æˆ· {} æ²¡æœ‰æä¾›å¹´é¾„ä¿¡æ¯", user.username),
    }
}

fn demonstrate_option_methods(users: &[User]) {
    println!("\n=== Option æ–¹æ³•æ¼”ç¤º ===");
    
    for user in users {
        // unwrap_or æä¾›é»˜è®¤å€¼
        let age = user.age.unwrap_or(0);
        println!("{} çš„å¹´é¾„ï¼ˆé»˜è®¤0ï¼‰: {}", user.username, age);
        
        // map è½¬æ¢ Option ä¸­çš„å€¼
        let age_next_year = user.age.map(|a| a + 1);
        match age_next_year {
            Some(age) => println!("{} æ˜å¹´ {} å²", user.username, age),
            None => println!("{} å¹´é¾„æœªçŸ¥ï¼Œæ— æ³•è®¡ç®—æ˜å¹´å¹´é¾„", user.username),
        }
        
        // and_then é“¾å¼è°ƒç”¨
        let age_category = user.age.and_then(|age| {
            if age < 18 {
                Some("æœªæˆå¹´")
            } else if age < 60 {
                Some("æˆå¹´äºº")
            } else {
                Some("è€å¹´äºº")
            }
        });
        
        if let Some(category) = age_category {
            println!("{} å±äº: {}", user.username, category);
        }
        
        println!();
    }
}</pre>

        <p><strong>æ­¥éª¤ 3: Result é”™è¯¯å¤„ç†</strong></p>
        <pre>#[derive(Debug)]
enum RegistrationError {
    UsernameAlreadyExists,
    InvalidEmail,
    PasswordTooShort,
    InvalidAge,
}

impl std::fmt::Display for RegistrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            RegistrationError::UsernameAlreadyExists => write!(f, "ç”¨æˆ·åå·²å­˜åœ¨"),
            RegistrationError::InvalidEmail => write!(f, "é‚®ç®±æ ¼å¼æ— æ•ˆ"),
            RegistrationError::PasswordTooShort => write!(f, "å¯†ç é•¿åº¦ä¸è¶³"),
            RegistrationError::InvalidAge => write!(f, "å¹´é¾„æ— æ•ˆ"),
        }
    }
}

#[derive(Debug)]
struct NewUser {
    username: String,
    email: String,
    password: String,
    age: u8,
}

fn main() {
    println!("=== Result é”™è¯¯å¤„ç† ===");
    
    let mut existing_users = vec![
        "alice".to_string(),
        "bob".to_string(),
    ];
    
    // æˆåŠŸæ³¨å†Œ
    match register_user(
        &existing_users,
        "charlie",
        "charlie@example.com",
        "secure123",
        25,
    ) {
        Ok(user) => {
            println!("æ³¨å†ŒæˆåŠŸ: {:?}", user);
            existing_users.push(user.username);
        }
        Err(err) => println!("æ³¨å†Œå¤±è´¥: {}", err),
    }
    
    // å„ç§å¤±è´¥æƒ…å†µ
    let test_cases = vec![
        ("alice", "alice@example.com", "password123", 25), // ç”¨æˆ·åå·²å­˜åœ¨
        ("david", "invalid-email", "password123", 25),     // é‚®ç®±æ— æ•ˆ
        ("eve", "eve@example.com", "123", 25),             // å¯†ç å¤ªçŸ­
        ("frank", "frank@example.com", "password123", 200), // å¹´é¾„æ— æ•ˆ
    ];
    
    for (username, email, password, age) in test_cases {
        match register_user(&existing_users, username, email, password, age) {
            Ok(user) => println!("æ³¨å†ŒæˆåŠŸ: {:?}", user),
            Err(err) => println!("æ³¨å†Œå¤±è´¥ {}: {}", username, err),
        }
    }
    
    // æ¼”ç¤º Result çš„æ–¹æ³•
    demonstrate_result_methods();
}

fn register_user(
    existing_users: &[String],
    username: &str,
    email: &str,
    password: &str,
    age: u8,
) -> Result<NewUser, RegistrationError> {
    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    if existing_users.contains(&username.to_string()) {
        return Err(RegistrationError::UsernameAlreadyExists);
    }
    
    // éªŒè¯é‚®ç®±æ ¼å¼
    if !email.contains('@') || !email.contains('.') {
        return Err(RegistrationError::InvalidEmail);
    }
    
    // éªŒè¯å¯†ç é•¿åº¦
    if password.len() < 6 {
        return Err(RegistrationError::PasswordTooShort);
    }
    
    // éªŒè¯å¹´é¾„
    if age > 150 {
        return Err(RegistrationError::InvalidAge);
    }
    
    Ok(NewUser {
        username: username.to_string(),
        email: email.to_string(),
        password: password.to_string(),
        age,
    })
}

fn demonstrate_result_methods() {
    println!("\n=== Result æ–¹æ³•æ¼”ç¤º ===");
    
    let result1: Result<i32, &str> = Ok(42);
    let result2: Result<i32, &str> = Err("å‡ºé”™äº†");
    
    // unwrap_or æä¾›é»˜è®¤å€¼
    println!("result1.unwrap_or(0): {}", result1.unwrap_or(0));
    println!("result2.unwrap_or(0): {}", result2.unwrap_or(0));
    
    // map è½¬æ¢æˆåŠŸå€¼
    let doubled = result1.map(|x| x * 2);
    println!("result1 ç¿»å€: {:?}", doubled);
    
    // map_err è½¬æ¢é”™è¯¯å€¼
    let mapped_error = result2.map_err(|e| format!("é”™è¯¯: {}", e));
    println!("æ˜ å°„é”™è¯¯: {:?}", mapped_error);
}</pre>

        <p><strong>æ­¥éª¤ 4: ? æ“ä½œç¬¦çš„ä½¿ç”¨</strong></p>
        <pre>use std::fs;
use std::io;

fn main() {
    println!("=== ? æ“ä½œç¬¦æ¼”ç¤º ===");
    
    // ä¼ ç»Ÿé”™è¯¯å¤„ç†æ–¹å¼
    match read_file_traditional("config.txt") {
        Ok(content) => println!("æ–‡ä»¶å†…å®¹ï¼ˆä¼ ç»Ÿæ–¹å¼ï¼‰: {}", content),
        Err(err) => println!("è¯»å–å¤±è´¥: {}", err),
    }
    
    // ä½¿ç”¨ ? æ“ä½œç¬¦
    match read_file_with_question_mark("config.txt") {
        Ok(content) => println!("æ–‡ä»¶å†…å®¹ï¼ˆ? æ“ä½œç¬¦ï¼‰: {}", content),
        Err(err) => println!("è¯»å–å¤±è´¥: {}", err),
    }
    
    // åˆ›å»ºä¸€ä¸ªæµ‹è¯•æ–‡ä»¶å†è¯•è¯•
    let _ = fs::write("test.txt", "Hello, Rust!");
    
    match read_file_with_question_mark("test.txt") {
        Ok(content) => println!("æˆåŠŸè¯»å– test.txt: {}", content),
        Err(err) => println!("è¯»å– test.txt å¤±è´¥: {}", err),
    }
    
    // æ¼”ç¤ºå¤æ‚çš„é”™è¯¯ä¼ æ’­
    match process_user_data("123", "john@example.com") {
        Ok(result) => println!("å¤„ç†ç»“æœ: {}", result),
        Err(err) => println!("å¤„ç†å¤±è´¥: {}", err),
    }
    
    match process_user_data("abc", "john@example.com") {
        Ok(result) => println!("å¤„ç†ç»“æœ: {}", result),
        Err(err) => println!("å¤„ç†å¤±è´¥: {}", err),
    }
}

// ä¼ ç»Ÿé”™è¯¯å¤„ç†æ–¹å¼
fn read_file_traditional(filename: &str) -> Result<String, io::Error> {
    match fs::read_to_string(filename) {
        Ok(content) => Ok(content),
        Err(err) => Err(err),
    }
}

// ä½¿ç”¨ ? æ“ä½œç¬¦
fn read_file_with_question_mark(filename: &str) -> Result<String, io::Error> {
    let content = fs::read_to_string(filename)?; // å¦‚æœå‡ºé”™ï¼Œç›´æ¥è¿”å›é”™è¯¯
    Ok(content)
}

#[derive(Debug)]
enum ProcessError {
    ParseError(std::num::ParseIntError),
    InvalidEmail(String),
    IoError(io::Error),
}

impl From<std::num::ParseIntError> for ProcessError {
    fn from(err: std::num::ParseIntError) -> ProcessError {
        ProcessError::ParseError(err)
    }
}

impl From<io::Error> for ProcessError {
    fn from(err: io::Error) -> ProcessError {
        ProcessError::IoError(err)
    }
}

impl std::fmt::Display for ProcessError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ProcessError::ParseError(err) => write!(f, "è§£æé”™è¯¯: {}", err),
            ProcessError::InvalidEmail(email) => write!(f, "æ— æ•ˆé‚®ç®±: {}", email),
            ProcessError::IoError(err) => write!(f, "IOé”™è¯¯: {}", err),
        }
    }
}

fn process_user_data(id_str: &str, email: &str) -> Result<String, ProcessError> {
    // è§£æ ID
    let id: u32 = id_str.parse()?; // ä½¿ç”¨ ? è‡ªåŠ¨è½¬æ¢ ParseIntError
    
    // éªŒè¯é‚®ç®±
    if !email.contains('@') {
        return Err(ProcessError::InvalidEmail(email.to_string()));
    }
    
    // å°è¯•è¯»å–ç”¨æˆ·é…ç½®æ–‡ä»¶
    let config = match fs::read_to_string("user_config.txt") {
        Ok(content) => content,
        Err(_) => "default config".to_string(), // æä¾›é»˜è®¤é…ç½®
    };
    
    Ok(format!("ç”¨æˆ·ID: {}, é‚®ç®±: {}, é…ç½®: {}", id, email, config))
}</pre>

        <p><strong>æ­¥éª¤ 5: ç»„åˆ Option å’Œ Result</strong></p>
        <pre>use std::collections::HashMap;

#[derive(Debug, Clone)]
struct UserProfile {
    id: u32,
    username: String,
    email: String,
    preferences: HashMap<String, String>,
}

#[derive(Debug)]
enum UserError {
    NotFound,
    InvalidPreference(String),
    DatabaseError(String),
}

impl std::fmt::Display for UserError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            UserError::NotFound => write!(f, "ç”¨æˆ·æœªæ‰¾åˆ°"),
            UserError::InvalidPreference(key) => write!(f, "æ— æ•ˆçš„åå¥½è®¾ç½®: {}", key),
            UserError::DatabaseError(msg) => write!(f, "æ•°æ®åº“é”™è¯¯: {}", msg),
        }
    }
}

struct UserService {
    users: HashMap<u32, UserProfile>,
}

impl UserService {
    fn new() -> Self {
        let mut users = HashMap::new();
        
        let mut alice_prefs = HashMap::new();
        alice_prefs.insert("theme".to_string(), "dark".to_string());
        alice_prefs.insert("language".to_string(), "zh".to_string());
        
        users.insert(1, UserProfile {
            id: 1,
            username: "alice".to_string(),
            email: "alice@example.com".to_string(),
            preferences: alice_prefs,
        });
        
        let mut bob_prefs = HashMap::new();
        bob_prefs.insert("theme".to_string(), "light".to_string());
        
        users.insert(2, UserProfile {
            id: 2,
            username: "bob".to_string(),
            email: "bob@example.com".to_string(),
            preferences: bob_prefs,
        });
        
        UserService { users }
    }
    
    // è¿”å› Option
    fn find_user(&self, id: u32) -> Option<&UserProfile> {
        self.users.get(&id)
    }
    
    // è¿”å› Result
    fn get_user(&self, id: u32) -> Result<&UserProfile, UserError> {
        self.users.get(&id).ok_or(UserError::NotFound)
    }
    
    // ç»„åˆä½¿ç”¨ï¼šå…ˆæŸ¥æ‰¾ç”¨æˆ·ï¼Œå†è·å–åå¥½è®¾ç½®
    fn get_user_preference(&self, id: u32, key: &str) -> Result<String, UserError> {
        let user = self.get_user(id)?; // å¦‚æœç”¨æˆ·ä¸å­˜åœ¨ï¼Œç›´æ¥è¿”å›é”™è¯¯
        
        user.preferences
            .get(key)
            .cloned()
            .ok_or_else(|| UserError::InvalidPreference(key.to_string()))
    }
    
    // å¯é€‰çš„åå¥½è®¾ç½®ï¼Œè¿”å› Option
    fn get_optional_preference(&self, id: u32, key: &str) -> Option<String> {
        self.find_user(id)
            .and_then(|user| user.preferences.get(key))
            .cloned()
    }
    
    // æ‰¹é‡è·å–ç”¨æˆ·åå¥½
    fn get_multiple_preferences(&self, id: u32, keys: &[&str]) -> Result<HashMap<String, Option<String>>, UserError> {
        let user = self.get_user(id)?;
        
        let mut result = HashMap::new();
        for &key in keys {
            let value = user.preferences.get(key).cloned();
            result.insert(key.to_string(), value);
        }
        
        Ok(result)
    }
}

fn main() {
    println!("=== Option å’Œ Result ç»„åˆä½¿ç”¨ ===");
    
    let service = UserService::new();
    
    // ä½¿ç”¨ Option æŸ¥æ‰¾
    match service.find_user(1) {
        Some(user) => println!("æ‰¾åˆ°ç”¨æˆ·ï¼ˆOptionï¼‰: {}", user.username),
        None => println!("ç”¨æˆ·ä¸å­˜åœ¨"),
    }
    
    // ä½¿ç”¨ Result æŸ¥æ‰¾
    match service.get_user(1) {
        Ok(user) => println!("è·å–ç”¨æˆ·ï¼ˆResultï¼‰: {}", user.username),
        Err(err) => println!("è·å–å¤±è´¥: {}", err),
    }
    
    // è·å–åå¥½è®¾ç½®
    match service.get_user_preference(1, "theme") {
        Ok(theme) => println!("Alice çš„ä¸»é¢˜è®¾ç½®: {}", theme),
        Err(err) => println!("è·å–åå¥½å¤±è´¥: {}", err),
    }
    
    match service.get_user_preference(1, "font-size") {
        Ok(font_size) => println!("Alice çš„å­—ä½“å¤§å°: {}", font_size),
        Err(err) => println!("è·å–åå¥½å¤±è´¥: {}", err),
    }
    
    // è·å–ä¸å­˜åœ¨ç”¨æˆ·çš„åå¥½
    match service.get_user_preference(999, "theme") {
        Ok(theme) => println!("ç”¨æˆ·999çš„ä¸»é¢˜: {}", theme),
        Err(err) => println!("è·å–å¤±è´¥: {}", err),
    }
    
    // è·å–å¯é€‰åå¥½è®¾ç½®
    if let Some(lang) = service.get_optional_preference(1, "language") {
        println!("Alice çš„è¯­è¨€è®¾ç½®: {}", lang);
    } else {
        println!("Alice æ²¡æœ‰è®¾ç½®è¯­è¨€åå¥½");
    }
    
    // æ‰¹é‡è·å–åå¥½è®¾ç½®
    match service.get_multiple_preferences(1, &["theme", "language", "font-size"]) {
        Ok(prefs) => {
            println!("Alice çš„åå¥½è®¾ç½®:");
            for (key, value) in prefs {
                match value {
                    Some(v) => println!("  {}: {}", key, v),
                    None => println!("  {}: æœªè®¾ç½®", key),
                }
            }
        }
        Err(err) => println!("è·å–åå¥½è®¾ç½®å¤±è´¥: {}", err),
    }
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>å®ç°ä¸€ä¸ªé…ç½®æ–‡ä»¶è¯»å–å™¨ï¼Œä½¿ç”¨ Result å¤„ç†æ–‡ä»¶ä¸å­˜åœ¨ã€æ ¼å¼é”™è¯¯ç­‰æƒ…å†µ</li>
            <li>åˆ›å»ºä¸€ä¸ªç”¨æˆ·è®¤è¯ç³»ç»Ÿï¼Œä½¿ç”¨ Option è¡¨ç¤ºå¯é€‰çš„ç”¨æˆ·ä¿¡æ¯</li>
            <li>ç¼–å†™ä¸€ä¸ªæ•°æ®éªŒè¯å™¨ï¼Œç»„åˆä½¿ç”¨å¤šä¸ª Result è¿”å›çš„å‡½æ•°</li>
            <li>å®ç°ä¸€ä¸ªç¼“å­˜ç³»ç»Ÿï¼Œä½¿ç”¨ Option è¡¨ç¤ºç¼“å­˜å‘½ä¸­/æœªå‘½ä¸­</li>
        </ul>

        <p><strong>ç»¼åˆç»ƒä¹ ä»£ç ï¼š</strong></p>
        <pre>use std::collections::HashMap;
use std::fs;

#[derive(Debug)]
enum ConfigError {
    FileNotFound,
    InvalidFormat(String),
    MissingKey(String),
}

impl std::fmt::Display for ConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ConfigError::FileNotFound => write!(f, "é…ç½®æ–‡ä»¶æœªæ‰¾åˆ°"),
            ConfigError::InvalidFormat(msg) => write!(f, "é…ç½®æ ¼å¼é”™è¯¯: {}", msg),
            ConfigError::MissingKey(key) => write!(f, "ç¼ºå°‘å¿…éœ€çš„é…ç½®é¡¹: {}", key),
        }
    }
}

#[derive(Debug)]
struct AppConfig {
    server_host: String,
    server_port: Option<u16>,
    database_url: String,
    debug_mode: bool,
    max_connections: Option<u32>,
}

struct ConfigLoader;

impl ConfigLoader {
    fn load_config(filename: &str) -> Result<AppConfig, ConfigError> {
        // è¯»å–æ–‡ä»¶
        let content = fs::read_to_string(filename)
            .map_err(|_| ConfigError::FileNotFound)?;
        
        // è§£æé…ç½®
        let mut config_map = HashMap::new();
        
        for line in content.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue; // è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
            }
            
            let parts: Vec<&str> = line.split('=').collect();
            if parts.len() != 2 {
                return Err(ConfigError::InvalidFormat(
                    format!("æ— æ•ˆçš„é…ç½®è¡Œ: {}", line)
                ));
            }
            
            config_map.insert(parts[0].trim().to_string(), parts[1].trim().to_string());
        }
        
        // æ„å»ºé…ç½®å¯¹è±¡
        let server_host = config_map
            .get("server_host")
            .ok_or_else(|| ConfigError::MissingKey("server_host".to_string()))?
            .clone();
        
        let database_url = config_map
            .get("database_url")
            .ok_or_else(|| ConfigError::MissingKey("database_url".to_string()))?
            .clone();
        
        // å¯é€‰é…ç½®é¡¹
        let server_port = config_map
            .get("server_port")
            .and_then(|s| s.parse().ok());
        
        let debug_mode = config_map
            .get("debug_mode")
            .map(|s| s.to_lowercase() == "true")
            .unwrap_or(false);
        
        let max_connections = config_map
            .get("max_connections")
            .and_then(|s| s.parse().ok());
        
        Ok(AppConfig {
            server_host,
            server_port,
            database_url,
            debug_mode,
            max_connections,
        })
    }
    
    fn get_effective_port(config: &AppConfig) -> u16 {
        config.server_port.unwrap_or(8080) // é»˜è®¤ç«¯å£
    }
    
    fn get_effective_max_connections(config: &AppConfig) -> u32 {
        config.max_connections.unwrap_or(100) // é»˜è®¤è¿æ¥æ•°
    }
}

// ç¼“å­˜ç³»ç»Ÿç¤ºä¾‹
struct Cache<K, V> {
    data: HashMap<K, V>,
}

impl<K: std::hash::Hash + Eq + Clone, V: Clone> Cache<K, V> {
    fn new() -> Self {
        Cache {
            data: HashMap::new(),
        }
    }
    
    fn get(&self, key: &K) -> Option<V> {
        self.data.get(key).cloned()
    }
    
    fn set(&mut self, key: K, value: V) {
        self.data.insert(key, value);
    }
    
    fn get_or_compute<F>(&mut self, key: K, compute: F) -> V
    where
        F: FnOnce() -> V,
    {
        match self.get(&key) {
            Some(value) => {
                println!("ç¼“å­˜å‘½ä¸­: {:?}", key);
                value
            }
            None => {
                println!("ç¼“å­˜æœªå‘½ä¸­ï¼Œè®¡ç®—æ–°å€¼: {:?}", key);
                let value = compute();
                self.set(key, value.clone());
                value
            }
        }
    }
}

fn main() {
    println!("=== Day 7 ç»¼åˆç»ƒä¹  ===");
    
    // åˆ›å»ºæµ‹è¯•é…ç½®æ–‡ä»¶
    let config_content = r#"
# æœåŠ¡å™¨é…ç½®
server_host=localhost
server_port=3000
database_url=postgresql://localhost/myapp
debug_mode=true
max_connections=200
"#;
    
    let _ = fs::write("app.config", config_content);
    
    // åŠ è½½é…ç½®
    match ConfigLoader::load_config("app.config") {
        Ok(config) => {
            println!("é…ç½®åŠ è½½æˆåŠŸ: {:?}", config);
            println!("æœ‰æ•ˆç«¯å£: {}", ConfigLoader::get_effective_port(&config));
            println!("æœ€å¤§è¿æ¥æ•°: {}", ConfigLoader::get_effective_max_connections(&config));
        }
        Err(err) => println!("é…ç½®åŠ è½½å¤±è´¥: {}", err),
    }
    
    // æµ‹è¯•ç¼“å­˜ç³»ç»Ÿ
    println!("\n=== ç¼“å­˜ç³»ç»Ÿæµ‹è¯• ===");
    let mut cache = Cache::new();
    
    // æ¨¡æ‹Ÿè€—æ—¶è®¡ç®—
    let expensive_computation = || {
        println!("æ‰§è¡Œå¤æ‚è®¡ç®—...");
        std::thread::sleep(std::time::Duration::from_millis(100));
        42
    };
    
    // ç¬¬ä¸€æ¬¡è®¿é—® - ç¼“å­˜æœªå‘½ä¸­
    let result1 = cache.get_or_compute("key1", expensive_computation);
    println!("ç»“æœ1: {}", result1);
    
    // ç¬¬äºŒæ¬¡è®¿é—® - ç¼“å­˜å‘½ä¸­
    let result2 = cache.get_or_compute("key1", expensive_computation);
    println!("ç»“æœ2: {}", result2);
    
    // ç›´æ¥è·å–ç¼“å­˜
    match cache.get(&"key1") {
        Some(value) => println!("ç›´æ¥ä»ç¼“å­˜è·å– key1: {}", value),
        None => println!("key1 ä¸åœ¨ç¼“å­˜ä¸­"),
    }
    
    match cache.get(&"nonexistent") {
        Some(value) => println!("è·å–åˆ°å€¼: {}", value),
        None => println!("nonexistent ä¸åœ¨ç¼“å­˜ä¸­"),
    }
    
    // æ¸…ç†æµ‹è¯•æ–‡ä»¶
    let _ = fs::remove_file("app.config");
    let _ = fs::remove_file("test.txt");
}</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day07_option_result/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-08</strong></p>
        <h2>Day 8 - é¡¹ç›®æ¨¡å—æ‹†åˆ†ä¸ mod è¯­æ³•</h2>
        <p>ä½ å°†æŠŠç¨‹åºæ‹†åˆ†æˆå¤šä¸ªæ–‡ä»¶ï¼š`main.rs`, `handlers.rs`, `models.rs`ï¼Œé€šè¿‡ `mod`, `pub` ç®¡ç†é¡¹ç›®ç»“æ„ï¼Œå»ºç«‹æ¨¡å—åŒ–æ€ç»´ï¼Œæ–¹ä¾¿åç»­æ‰©å±•ä¸æµ‹è¯•ã€‚</p>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®</strong></p>
        <pre>cargo new day08_modules
cd day08_modules</pre>

        <p><strong>æ­¥éª¤ 2: ç†è§£æ¨¡å—ç³»ç»ŸåŸºç¡€</strong></p>
        <p><strong>src/main.rs - ä¸»æ–‡ä»¶</strong></p>
        <pre>// å£°æ˜æ¨¡å—
mod math_utils;     // å¯¹åº” math_utils.rs æ–‡ä»¶
mod models;         // å¯¹åº” models.rs æ–‡ä»¶
mod handlers;       // å¯¹åº” handlers.rs æ–‡ä»¶

// ä½¿ç”¨æ¨¡å—ä¸­çš„é¡¹
use math_utils::{add, multiply};
use models::User;
use handlers::user_handler;

fn main() {
    println!("=== æ¨¡å—ç³»ç»Ÿæ¼”ç¤º ===");
    
    // ä½¿ç”¨æ•°å­¦å·¥å…·æ¨¡å—
    let sum = add(5, 3);
    let product = multiply(4, 6);
    println!("5 + 3 = {}", sum);
    println!("4 Ã— 6 = {}", product);
    
    // ä½¿ç”¨æ¨¡å‹
    let user = User::new("Alice".to_string(), "alice@example.com".to_string());
    println!("åˆ›å»ºç”¨æˆ·: {:?}", user);
    
    // ä½¿ç”¨å¤„ç†å™¨
    user_handler::process_user(&user);
    user_handler::validate_user(&user);
    
    // æ¼”ç¤ºä¸åŒçš„å¯¼å…¥æ–¹å¼
    demonstrate_import_styles();
}

fn demonstrate_import_styles() {
    println!("\n=== ä¸åŒçš„å¯¼å…¥æ–¹å¼ ===");
    
    // å®Œæ•´è·¯å¾„è°ƒç”¨
    let result1 = math_utils::subtract(10, 3);
    println!("å®Œæ•´è·¯å¾„è°ƒç”¨: 10 - 3 = {}", result1);
    
    // ä½¿ç”¨ use è¯­å¥ç®€åŒ–
    use math_utils::divide;
    let result2 = divide(15.0, 3.0);
    println!("use è¯­å¥ç®€åŒ–: 15 Ã· 3 = {}", result2);
    
    // ä½¿ç”¨åˆ«å
    use math_utils::power as pow;
    let result3 = pow(2, 8);
    println!("ä½¿ç”¨åˆ«å: 2^8 = {}", result3);
}</pre>

        <p><strong>æ­¥éª¤ 3: åˆ›å»ºæ•°å­¦å·¥å…·æ¨¡å—</strong></p>
        <p><strong>src/math_utils.rs</strong></p>
        <pre>// å…¬å…±å‡½æ•°ï¼Œå¯ä»¥è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}

pub fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

pub fn divide(a: f64, b: f64) -> f64 {
    if b != 0.0 {
        a / b
    } else {
        panic!("é™¤æ•°ä¸èƒ½ä¸ºé›¶")
    }
}

pub fn power(base: i32, exp: u32) -> i32 {
    base.pow(exp)
}

// ç§æœ‰å‡½æ•°ï¼Œåªèƒ½åœ¨å½“å‰æ¨¡å—å†…ä½¿ç”¨
fn private_helper() -> &'static str {
    "è¿™æ˜¯ä¸€ä¸ªç§æœ‰å‡½æ•°"
}

// åµŒå¥—æ¨¡å—
pub mod advanced {
    pub fn factorial(n: u32) -> u32 {
        if n <= 1 {
            1
        } else {
            n * factorial(n - 1)
        }
    }
    
    pub fn fibonacci(n: u32) -> u32 {
        match n {
            0 => 0,
            1 => 1,
            _ => fibonacci(n - 1) + fibonacci(n - 2),
        }
    }
    
    // ä½¿ç”¨çˆ¶æ¨¡å—çš„ç§æœ‰å‡½æ•°
    pub fn test_private() -> &'static str {
        super::private_helper() // ä½¿ç”¨ super è®¿é—®çˆ¶æ¨¡å—
    }
}

// å…¬å…±å¸¸é‡
pub const PI: f64 = 3.14159265359;
pub const E: f64 = 2.71828182846;

// å…¬å…±ç»“æ„ä½“
#[derive(Debug)]
pub struct Calculator {
    pub name: String,
    version: f32, // ç§æœ‰å­—æ®µ
}

impl Calculator {
    pub fn new(name: String) -> Self {
        Calculator {
            name,
            version: 1.0,
        }
    }
    
    pub fn get_version(&self) -> f32 {
        self.version
    }
    
    pub fn calculate(&self, op: &str, a: f64, b: f64) -> Result<f64, String> {
        match op {
            "+" => Ok(a + b),
            "-" => Ok(a - b),
            "*" => Ok(a * b),
            "/" => {
                if b != 0.0 {
                    Ok(a / b)
                } else {
                    Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())
                }
            }
            _ => Err(format!("ä¸æ”¯æŒçš„æ“ä½œç¬¦: {}", op)),
        }
    }
}</pre>

        <p><strong>æ­¥éª¤ 4: åˆ›å»ºæ•°æ®æ¨¡å‹æ¨¡å—</strong></p>
        <p><strong>src/models.rs</strong></p>
        <pre>// å¯¼å…¥æ ‡å‡†åº“æ¨¡å—
use std::collections::HashMap;

// ç”¨æˆ·æ¨¡å‹
#[derive(Debug, Clone)]
pub struct User {
    pub id: Option<u32>,
    pub username: String,
    pub email: String,
    pub active: bool,
    metadata: HashMap<String, String>, // ç§æœ‰å­—æ®µ
}

impl User {
    pub fn new(username: String, email: String) -> Self {
        User {
            id: None,
            username,
            email,
            active: true,
            metadata: HashMap::new(),
        }
    }
    
    pub fn with_id(mut self, id: u32) -> Self {
        self.id = Some(id);
        self
    }
    
    pub fn add_metadata(&mut self, key: String, value: String) {
        self.metadata.insert(key, value);
    }
    
    pub fn get_metadata(&self, key: &str) -> Option<&String> {
        self.metadata.get(key)
    }
    
    pub fn deactivate(&mut self) {
        self.active = false;
    }
}

// æ¶ˆæ¯æ¨¡å‹
#[derive(Debug, Clone)]
pub struct Message {
    pub id: u32,
    pub sender_id: u32,
    pub recipient_id: Option<u32>, // None è¡¨ç¤ºå¹¿æ’­æ¶ˆæ¯
    pub content: String,
    pub timestamp: u64,
    pub message_type: MessageType,
}

#[derive(Debug, Clone)]
pub enum MessageType {
    Text,
    Image { url: String },
    File { name: String, size: u64 },
    System,
}

impl Message {
    pub fn new_text(sender_id: u32, content: String) -> Self {
        Message {
            id: generate_id(),
            sender_id,
            recipient_id: None,
            content,
            timestamp: current_timestamp(),
            message_type: MessageType::Text,
        }
    }
    
    pub fn new_private(sender_id: u32, recipient_id: u32, content: String) -> Self {
        Message {
            id: generate_id(),
            sender_id,
            recipient_id: Some(recipient_id),
            content,
            timestamp: current_timestamp(),
            message_type: MessageType::Text,
        }
    }
    
    pub fn is_private(&self) -> bool {
        self.recipient_id.is_some()
    }
}

// èŠå¤©å®¤æ¨¡å‹
#[derive(Debug)]
pub struct ChatRoom {
    pub id: u32,
    pub name: String,
    pub users: Vec<User>,
    pub messages: Vec<Message>,
    pub max_users: usize,
}

impl ChatRoom {
    pub fn new(id: u32, name: String, max_users: usize) -> Self {
        ChatRoom {
            id,
            name,
            users: Vec::new(),
            messages: Vec::new(),
            max_users,
        }
    }
    
    pub fn add_user(&mut self, user: User) -> Result<(), String> {
        if self.users.len() >= self.max_users {
            return Err("èŠå¤©å®¤å·²æ»¡".to_string());
        }
        
        if self.users.iter().any(|u| u.username == user.username) {
            return Err("ç”¨æˆ·åå·²å­˜åœ¨".to_string());
        }
        
        self.users.push(user);
        Ok(())
    }
    
    pub fn remove_user(&mut self, username: &str) -> Option<User> {
        if let Some(pos) = self.users.iter().position(|u| u.username == username) {
            Some(self.users.remove(pos))
        } else {
            None
        }
    }
    
    pub fn add_message(&mut self, message: Message) {
        self.messages.push(message);
    }
    
    pub fn get_recent_messages(&self, count: usize) -> &[Message] {
        let start = if self.messages.len() > count {
            self.messages.len() - count
        } else {
            0
        };
        &self.messages[start..]
    }
}

// å·¥å…·å‡½æ•°
fn generate_id() -> u32 {
    use std::sync::atomic::{AtomicU32, Ordering};
    static COUNTER: AtomicU32 = AtomicU32::new(1);
    COUNTER.fetch_add(1, Ordering::SeqCst)
}

fn current_timestamp() -> u64 {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs()
}

// å…¬å…±æšä¸¾
#[derive(Debug, Clone)]
pub enum UserRole {
    Admin,
    Moderator,
    User,
    Guest,
}

impl UserRole {
    pub fn has_permission(&self, permission: &str) -> bool {
        match (self, permission) {
            (UserRole::Admin, _) => true,
            (UserRole::Moderator, "kick") | (UserRole::Moderator, "mute") => true,
            (UserRole::User, "send_message") => true,
            (UserRole::Guest, "read_only") => true,
            _ => false,
        }
    }
}</pre>

        <p><strong>æ­¥éª¤ 5: åˆ›å»ºå¤„ç†å™¨æ¨¡å—</strong></p>
        <p><strong>src/handlers.rs</strong></p>
        <pre>// å¯¼å…¥å…¶ä»–æ¨¡å—
use crate::models::{User, Message, ChatRoom, UserRole};

// ç”¨æˆ·å¤„ç†å™¨å­æ¨¡å—
pub mod user_handler {
    use super::*;
    
    pub fn process_user(user: &User) {
        println!("å¤„ç†ç”¨æˆ·: {}", user.username);
        
        match &user.id {
            Some(id) => println!("  ç”¨æˆ·ID: {}", id),
            None => println!("  ç”¨æˆ·ID: æœªåˆ†é…"),
        }
        
        println!("  é‚®ç®±: {}", user.email);
        println!("  çŠ¶æ€: {}", if user.active { "æ´»è·ƒ" } else { "éæ´»è·ƒ" });
    }
    
    pub fn validate_user(user: &User) -> Result<(), String> {
        if user.username.len() < 3 {
            return Err("ç”¨æˆ·åé•¿åº¦ä¸èƒ½å°‘äº3ä¸ªå­—ç¬¦".to_string());
        }
        
        if !user.email.contains('@') {
            return Err("é‚®ç®±æ ¼å¼æ— æ•ˆ".to_string());
        }
        
        if !user.active {
            return Err("ç”¨æˆ·è´¦æˆ·å·²åœç”¨".to_string());
        }
        
        println!("âœ… ç”¨æˆ· {} éªŒè¯é€šè¿‡", user.username);
        Ok(())
    }
    
    pub fn format_user_info(user: &User) -> String {
        format!(
            "ç”¨æˆ·: {} ({}), çŠ¶æ€: {}",
            user.username,
            user.email,
            if user.active { "æ´»è·ƒ" } else { "éæ´»è·ƒ" }
        )
    }
}

// æ¶ˆæ¯å¤„ç†å™¨å­æ¨¡å—
pub mod message_handler {
    use super::*;
    
    pub fn process_message(message: &Message) {
        println!("å¤„ç†æ¶ˆæ¯ ID: {}", message.id);
        println!("  å‘é€è€…: {}", message.sender_id);
        
        match message.recipient_id {
            Some(recipient) => println!("  æ¥æ”¶è€…: {} (ç§ä¿¡)", recipient),
            None => println!("  ç±»å‹: å…¬å¼€æ¶ˆæ¯"),
        }
        
        println!("  å†…å®¹: {}", message.content);
        println!("  æ—¶é—´æˆ³: {}", message.timestamp);
    }
    
    pub fn validate_message(message: &Message) -> Result<(), String> {
        if message.content.trim().is_empty() {
            return Err("æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º".to_string());
        }
        
        if message.content.len() > 1000 {
            return Err("æ¶ˆæ¯é•¿åº¦ä¸èƒ½è¶…è¿‡1000ä¸ªå­—ç¬¦".to_string());
        }
        
        // ç®€å•çš„å†…å®¹è¿‡æ»¤
        let forbidden_words = ["spam", "å¹¿å‘Š", "è¿è§„"];
        for word in &forbidden_words {
            if message.content.contains(word) {
                return Err(format!("æ¶ˆæ¯åŒ…å«ç¦æ­¢è¯æ±‡: {}", word));
            }
        }
        
        Ok(())
    }
    
    pub fn format_message(message: &Message) -> String {
        let time = format_timestamp(message.timestamp);
        match message.recipient_id {
            Some(_) => format!("[{}] ç§ä¿¡: {}", time, message.content),
            None => format!("[{}] å…¬å¼€: {}", time, message.content),
        }
    }
    
    fn format_timestamp(timestamp: u64) -> String {
        // ç®€åŒ–çš„æ—¶é—´æ ¼å¼åŒ–
        format!("æ—¶é—´æˆ³:{}", timestamp)
    }
}

// èŠå¤©å®¤å¤„ç†å™¨å­æ¨¡å—
pub mod room_handler {
    use super::*;
    
    pub fn setup_room(name: &str, max_users: usize) -> ChatRoom {
        let room = ChatRoom::new(generate_room_id(), name.to_string(), max_users);
        println!("åˆ›å»ºèŠå¤©å®¤: {} (æœ€å¤§ç”¨æˆ·æ•°: {})", name, max_users);
        room
    }
    
    pub fn join_room(room: &mut ChatRoom, user: User) -> Result<(), String> {
        match room.add_user(user.clone()) {
            Ok(()) => {
                println!("ç”¨æˆ· {} åŠ å…¥èŠå¤©å®¤ {}", user.username, room.name);
                
                // å‘é€ç³»ç»Ÿæ¶ˆæ¯
                let system_message = Message {
                    id: crate::models::generate_id(),
                    sender_id: 0, // ç³»ç»Ÿæ¶ˆæ¯ä½¿ç”¨ID 0
                    recipient_id: None,
                    content: format!("{} åŠ å…¥äº†èŠå¤©å®¤", user.username),
                    timestamp: crate::models::current_timestamp(),
                    message_type: crate::models::MessageType::System,
                };
                room.add_message(system_message);
                
                Ok(())
            }
            Err(e) => Err(e),
        }
    }
    
    pub fn leave_room(room: &mut ChatRoom, username: &str) -> Result<(), String> {
        match room.remove_user(username) {
            Some(user) => {
                println!("ç”¨æˆ· {} ç¦»å¼€èŠå¤©å®¤ {}", user.username, room.name);
                
                // å‘é€ç³»ç»Ÿæ¶ˆæ¯
                let system_message = Message {
                    id: crate::models::generate_id(),
                    sender_id: 0,
                    recipient_id: None,
                    content: format!("{} ç¦»å¼€äº†èŠå¤©å®¤", user.username),
                    timestamp: crate::models::current_timestamp(),
                    message_type: crate::models::MessageType::System,
                };
                room.add_message(system_message);
                
                Ok(())
            }
            None => Err(format!("ç”¨æˆ· {} ä¸åœ¨èŠå¤©å®¤ä¸­", username)),
        }
    }
    
    pub fn send_message(room: &mut ChatRoom, sender_id: u32, content: String) -> Result<(), String> {
        // éªŒè¯å‘é€è€…æ˜¯å¦åœ¨æˆ¿é—´ä¸­
        if !room.users.iter().any(|u| u.id == Some(sender_id)) {
            return Err("å‘é€è€…ä¸åœ¨èŠå¤©å®¤ä¸­".to_string());
        }
        
        let message = Message::new_text(sender_id, content);
        
        // éªŒè¯æ¶ˆæ¯
        message_handler::validate_message(&message)?;
        
        room.add_message(message);
        println!("æ¶ˆæ¯å·²å‘é€åˆ°èŠå¤©å®¤ {}", room.name);
        
        Ok(())
    }
    
    pub fn get_room_stats(room: &ChatRoom) -> String {
        format!(
            "èŠå¤©å®¤ {}: {} ç”¨æˆ·åœ¨çº¿, {} æ¡æ¶ˆæ¯, å®¹é‡ {}/{}",
            room.name,
            room.users.len(),
            room.messages.len(),
            room.users.len(),
            room.max_users
        )
    }
    
    fn generate_room_id() -> u32 {
        use std::sync::atomic::{AtomicU32, Ordering};
        static ROOM_COUNTER: AtomicU32 = AtomicU32::new(1000);
        ROOM_COUNTER.fetch_add(1, Ordering::SeqCst)
    }
}

// æƒé™å¤„ç†å™¨
pub mod permission_handler {
    use super::*;
    
    pub fn check_permission(role: &UserRole, action: &str) -> bool {
        let has_perm = role.has_permission(action);
        println!(
            "æƒé™æ£€æŸ¥: {:?} å°è¯•æ‰§è¡Œ '{}' - {}",
            role,
            action,
            if has_perm { "å…è®¸" } else { "æ‹’ç»" }
        );
        has_perm
    }
    
    pub fn execute_with_permission<F>(
        role: &UserRole,
        action: &str,
        operation: F,
    ) -> Result<(), String>
    where
        F: FnOnce() -> Result<(), String>,
    {
        if check_permission(role, action) {
            operation()
        } else {
            Err(format!("æƒé™ä¸è¶³ï¼Œæ— æ³•æ‰§è¡Œ: {}", action))
        }
    }
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>åˆ›å»ºä¸€ä¸ª `config` æ¨¡å—ï¼Œç®¡ç†åº”ç”¨ç¨‹åºé…ç½®</li>
            <li>å®ç°ä¸€ä¸ª `database` æ¨¡å—ï¼Œæ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ</li>
            <li>è®¾è®¡ä¸€ä¸ª `utils` æ¨¡å—ï¼ŒåŒ…å«å¸¸ç”¨å·¥å…·å‡½æ•°</li>
            <li>æ„å»ºä¸€ä¸ªå¤šå±‚çº§çš„æ¨¡å—ç»“æ„ï¼Œä½“éªŒæ·±åº¦åµŒå¥—æ¨¡å—</li>
        </ul>

        <p><strong>ç»¼åˆç»ƒä¹ ä»£ç ï¼š</strong></p>
        <p><strong>æ›´æ–°åçš„ src/main.rs</strong></p>
        <pre>mod math_utils;
mod models;
mod handlers;

use math_utils::{Calculator, advanced};
use models::{User, Message, ChatRoom, UserRole};
use handlers::{user_handler, message_handler, room_handler, permission_handler};

fn main() {
    println!("=== Day 8 ç»¼åˆç»ƒä¹ ï¼šæ¨¡å—åŒ–èŠå¤©åº”ç”¨ ===");
    
    // åˆ›å»ºç”¨æˆ·
    let mut alice = User::new("Alice".to_string(), "alice@example.com".to_string())
        .with_id(1);
    alice.add_metadata("location".to_string(), "Beijing".to_string());
    
    let bob = User::new("Bob".to_string(), "bob@example.com".to_string())
        .with_id(2);
    
    let charlie = User::new("Charlie".to_string(), "charlie@example.com".to_string())
        .with_id(3);
    
    // ç”¨æˆ·éªŒè¯
    match user_handler::validate_user(&alice) {
        Ok(()) => println!("Alice éªŒè¯æˆåŠŸ"),
        Err(e) => println!("Alice éªŒè¯å¤±è´¥: {}", e),
    }
    
    // åˆ›å»ºèŠå¤©å®¤
    let mut general_room = room_handler::setup_room("General", 10);
    
    // ç”¨æˆ·åŠ å…¥èŠå¤©å®¤
    let _ = room_handler::join_room(&mut general_room, alice.clone());
    let _ = room_handler::join_room(&mut general_room, bob.clone());
    let _ = room_handler::join_room(&mut general_room, charlie.clone());
    
    println!("\n{}", room_handler::get_room_stats(&general_room));
    
    // å‘é€æ¶ˆæ¯
    let _ = room_handler::send_message(
        &mut general_room,
        1,
        "Hello everyone!".to_string(),
    );
    
    let _ = room_handler::send_message(
        &mut general_room,
        2,
        "Hi Alice! How are you?".to_string(),
    );
    
    // æ˜¾ç¤ºæœ€è¿‘æ¶ˆæ¯
    println!("\n=== æœ€è¿‘æ¶ˆæ¯ ===");
    for message in general_room.get_recent_messages(5) {
        println!("{}", message_handler::format_message(message));
    }
    
    // æƒé™ç³»ç»Ÿæ¼”ç¤º
    println!("\n=== æƒé™ç³»ç»Ÿæ¼”ç¤º ===");
    let admin = UserRole::Admin;
    let user = UserRole::User;
    let guest = UserRole::Guest;
    
    // æµ‹è¯•ä¸åŒæƒé™
    let permissions = ["send_message", "kick", "mute", "read_only"];
    let roles = [&admin, &user, &guest];
    
    for role in &roles {
        for permission in &permissions {
            permission_handler::check_permission(role, permission);
        }
        println!();
    }
    
    // ä½¿ç”¨æ•°å­¦å·¥å…·æ¨¡å—
    println!("=== æ•°å­¦å·¥å…·æ¼”ç¤º ===");
    let calc = Calculator::new("ChatRoom Calculator".to_string());
    println!("è®¡ç®—å™¨: {} v{}", calc.name, calc.get_version());
    
    match calc.calculate("+", 10.0, 5.0) {
        Ok(result) => println!("10 + 5 = {}", result),
        Err(e) => println!("è®¡ç®—é”™è¯¯: {}", e),
    }
    
    // ä½¿ç”¨åµŒå¥—æ¨¡å—
    println!("\n=== é«˜çº§æ•°å­¦å‡½æ•° ===");
    println!("5! = {}", advanced::factorial(5));
    println!("fibonacci(10) = {}", advanced::fibonacci(10));
    println!("æµ‹è¯•ç§æœ‰å‡½æ•°: {}", advanced::test_private());
    
    // ç”¨æˆ·ç¦»å¼€èŠå¤©å®¤
    let _ = room_handler::leave_room(&mut general_room, "Charlie");
    
    println!("\n{}", room_handler::get_room_stats(&general_room));
}</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day08_modules/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs          # ä¸»ç¨‹åºå…¥å£
â”‚   â”œâ”€â”€ math_utils.rs    # æ•°å­¦å·¥å…·æ¨¡å—
â”‚   â”œâ”€â”€ models.rs        # æ•°æ®æ¨¡å‹æ¨¡å—  
â”‚   â””â”€â”€ handlers.rs      # ä¸šåŠ¡å¤„ç†æ¨¡å—
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-09</strong></p>
        <h2>Day 9 - ä½¿ç”¨ Cargo crateï¼šå¼•å…¥å¤–éƒ¨åº“</h2>
        <p>ä½ å°†é€šè¿‡ `Cargo.toml` æ·»åŠ  `chrono`, `rand`, `serde` ç­‰åº“ï¼Œå¹¶å†™å‡ºä¸€ä¸ªè¯»å–é…ç½®ã€éšæœºç”Ÿæˆç”¨æˆ· ID çš„ä¾‹å­ï¼Œç†è§£ Rust çš„æ„å»ºç³»ç»Ÿå’Œä¾èµ–ç®¡ç†ã€‚</p>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/cargo/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®</strong></p>
        <pre>cargo new day09_external_crates
cd day09_external_crates</pre>

        <p><strong>æ­¥éª¤ 2: é…ç½®ä¾èµ–é¡¹</strong></p>
        <p><strong>Cargo.toml é…ç½®</strong></p>
        <pre>[package]
name = "day09_external_crates"
version = "0.1.0"
edition = "2021"

[dependencies]
# æ—¶é—´å¤„ç†åº“
chrono = { version = "0.4", features = ["serde"] }

# éšæœºæ•°ç”Ÿæˆåº“
rand = "0.8"

# åºåˆ—åŒ–/ååºåˆ—åŒ–åº“
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# é…ç½®æ–‡ä»¶å¤„ç†
toml = "0.8"

# å‘½ä»¤è¡Œå‚æ•°è§£æ
clap = { version = "4.0", features = ["derive"] }

# UUID ç”Ÿæˆ
uuid = { version = "1.0", features = ["v4", "serde"] }

# é¢œè‰²è¾“å‡º
colored = "2.0"

# é”™è¯¯å¤„ç†
anyhow = "1.0"
thiserror = "1.0"</pre>

        <p><strong>æ­¥éª¤ 3: æ—¶é—´å¤„ç† - Chrono</strong></p>
        <pre>use chrono::{DateTime, Local, Utc, NaiveDate, Duration};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct EventLog {
    id: String,
    message: String,
    timestamp: DateTime<Utc>,
    local_time: DateTime<Local>,
}

fn main() {
    println!("=== Chrono æ—¶é—´å¤„ç†æ¼”ç¤º ===");
    
    // è·å–å½“å‰æ—¶é—´
    let now_utc = Utc::now();
    let now_local = Local::now();
    
    println!("UTC æ—¶é—´: {}", now_utc.format("%Y-%m-%d %H:%M:%S"));
    println!("æœ¬åœ°æ—¶é—´: {}", now_local.format("%Y-%m-%d %H:%M:%S %Z"));
    
    // è§£ææ—¶é—´å­—ç¬¦ä¸²
    let date_str = "2025-08-09 14:30:00";
    match NaiveDate::parse_from_str("2025-08-09", "%Y-%m-%d") {
        Ok(date) => println!("è§£ææ—¥æœŸæˆåŠŸ: {}", date),
        Err(e) => println!("è§£ææ—¥æœŸå¤±è´¥: {}", e),
    }
    
    // æ—¶é—´è®¡ç®—
    let future = now_utc + Duration::days(7);
    let past = now_utc - Duration::hours(24);
    
    println!("ä¸€å‘¨å: {}", future.format("%Y-%m-%d %H:%M:%S"));
    println!("24å°æ—¶å‰: {}", past.format("%Y-%m-%d %H:%M:%S"));
    
    // åˆ›å»ºäº‹ä»¶æ—¥å¿—
    let event = EventLog {
        id: uuid::Uuid::new_v4().to_string(),
        message: "ç³»ç»Ÿå¯åŠ¨".to_string(),
        timestamp: now_utc,
        local_time: now_local,
    };
    
    // åºåˆ—åŒ–ä¸º JSON
    match serde_json::to_string_pretty(&event) {
        Ok(json) => println!("äº‹ä»¶æ—¥å¿— JSON:\n{}", json),
        Err(e) => println!("åºåˆ—åŒ–å¤±è´¥: {}", e),
    }
    
    // æ—¶é—´æ ¼å¼åŒ–ç¤ºä¾‹
    demonstrate_time_formatting();
}</pre>

        <p><strong>æ­¥éª¤ 4: éšæœºæ•°ç”Ÿæˆ - Rand</strong></p>
        <pre>use rand::{Rng, thread_rng, seq::SliceRandom};
use rand::distributions::{Alphanumeric, Standard};
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct User {
    id: String,
    username: String,
    email: String,
    age: u8,
    balance: f64,
    preferences: HashMap<String, String>,
}

fn main() {
    println!("=== Rand éšæœºæ•°ç”Ÿæˆæ¼”ç¤º ===");
    
    let mut rng = thread_rng();
    
    // åŸºæœ¬éšæœºæ•°ç”Ÿæˆ
    println!("éšæœºæ•´æ•° (1-100): {}", rng.gen_range(1..=100));
    println!("éšæœºæµ®ç‚¹æ•°: {:.2}", rng.gen::<f64>());
    println!("éšæœºå¸ƒå°”å€¼: {}", rng.gen::<bool>());
    
    // ç”Ÿæˆéšæœºå­—ç¬¦ä¸²
    let random_string: String = thread_rng()
        .sample_iter(&Alphanumeric)
        .take(10)
        .map(char::from)
        .collect();
    println!("éšæœºå­—ç¬¦ä¸²: {}", random_string);
    
    // ä»æ•°ç»„ä¸­éšæœºé€‰æ‹©
    let names = ["Alice", "Bob", "Charlie", "Diana", "Eve"];
    let random_name = names.choose(&mut rng).unwrap();
    println!("éšæœºåå­—: {}", random_name);
    
    // æ‰“ä¹±æ•°ç»„
    let mut numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    numbers.shuffle(&mut rng);
    println!("æ‰“ä¹±åçš„æ•°å­—: {:?}", numbers);
    
    // ç”Ÿæˆéšæœºç”¨æˆ·
    let users = generate_random_users(5);
    println!("\n=== ç”Ÿæˆçš„éšæœºç”¨æˆ· ===");
    for (i, user) in users.iter().enumerate() {
        println!("ç”¨æˆ· {}: {:?}", i + 1, user);
    }
    
    // éšæœºé€‰æ‹©æƒé‡
    demonstrate_weighted_selection();
}

fn generate_random_users(count: usize) -> Vec<User> {
    let mut rng = thread_rng();
    let mut users = Vec::new();
    
    let first_names = ["Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Henry"];
    let last_names = ["Smith", "Johnson", "Brown", "Davis", "Wilson", "Miller", "Taylor"];
    let domains = ["gmail.com", "yahoo.com", "hotmail.com", "example.com"];
    
    for _ in 0..count {
        let first_name = first_names.choose(&mut rng).unwrap();
        let last_name = last_names.choose(&mut rng).unwrap();
        let domain = domains.choose(&mut rng).unwrap();
        
        let username = format!("{}{}", first_name.to_lowercase(), rng.gen_range(1..999));
        let email = format!("{}@{}", username, domain);
        
        let mut preferences = HashMap::new();
        preferences.insert("theme".to_string(), 
            if rng.gen::<bool>() { "dark" } else { "light" }.to_string());
        preferences.insert("language".to_string(),
            ["en", "zh", "es", "fr"].choose(&mut rng).unwrap().to_string());
        
        let user = User {
            id: uuid::Uuid::new_v4().to_string(),
            username,
            email,
            age: rng.gen_range(18..80),
            balance: rng.gen_range(0.0..10000.0),
            preferences,
        };
        
        users.push(user);
    }
    
    users
}

fn demonstrate_weighted_selection() {
    use rand::distributions::WeightedIndex;
    use rand::prelude::*;
    
    println!("\n=== æƒé‡éšæœºé€‰æ‹©æ¼”ç¤º ===");
    
    let choices = ["å¸¸è§", "ä¸å¸¸è§", "ç¨€æœ‰", "å²è¯—", "ä¼ è¯´"];
    let weights = [50, 30, 15, 4, 1]; // æƒé‡ï¼šå¸¸è§æœ€é«˜ï¼Œä¼ è¯´æœ€ä½
    
    let dist = WeightedIndex::new(&weights).unwrap();
    let mut rng = thread_rng();
    
    let mut results = HashMap::new();
    
    // æ¨¡æ‹Ÿ1000æ¬¡æŠ½å–
    for _ in 0..1000 {
        let choice = choices[dist.sample(&mut rng)];
        *results.entry(choice).or_insert(0) += 1;
    }
    
    println!("1000æ¬¡éšæœºæŠ½å–ç»“æœ:");
    for (item, count) in &results {
        println!("  {}: {} æ¬¡ ({:.1}%)", item, count, *count as f64 / 10.0);
    }
}</pre>

        <p><strong>æ­¥éª¤ 5: åºåˆ—åŒ–/ååºåˆ—åŒ– - Serde</strong></p>
        <pre>use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;

#[derive(Debug, Serialize, Deserialize, Clone)]
struct ServerConfig {
    host: String,
    port: u16,
    max_connections: u32,
    ssl_enabled: bool,
    database: DatabaseConfig,
    features: Vec<String>,
    settings: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct DatabaseConfig {
    url: String,
    pool_size: u32,
    timeout: u64,
}

fn main() {
    println!("=== Serde åºåˆ—åŒ–æ¼”ç¤º ===");
    
    // åˆ›å»ºé…ç½®å¯¹è±¡
    let mut settings = HashMap::new();
    settings.insert("debug".to_string(), serde_json::Value::Bool(true));
    settings.insert("log_level".to_string(), serde_json::Value::String("info".to_string()));
    settings.insert("max_file_size".to_string(), serde_json::Value::Number(serde_json::Number::from(1024)));
    
    let config = ServerConfig {
        host: "localhost".to_string(),
        port: 8080,
        max_connections: 100,
        ssl_enabled: false,
        database: DatabaseConfig {
            url: "postgresql://localhost/myapp".to_string(),
            pool_size: 10,
            timeout: 30,
        },
        features: vec![
            "websocket".to_string(),
            "cors".to_string(),
            "rate_limiting".to_string(),
        ],
        settings,
    };
    
    // åºåˆ—åŒ–ä¸º JSON
    match serde_json::to_string_pretty(&config) {
        Ok(json) => {
            println!("é…ç½® JSON:\n{}", json);
            
            // ä¿å­˜åˆ°æ–‡ä»¶
            if let Err(e) = fs::write("server_config.json", &json) {
                println!("ä¿å­˜æ–‡ä»¶å¤±è´¥: {}", e);
            } else {
                println!("\né…ç½®å·²ä¿å­˜åˆ° server_config.json");
            }
        }
        Err(e) => println!("JSON åºåˆ—åŒ–å¤±è´¥: {}", e),
    }
    
    // ä» JSON å­—ç¬¦ä¸²ååºåˆ—åŒ–
    let json_str = r#"{
        "host": "0.0.0.0",
        "port": 3000,
        "max_connections": 200,
        "ssl_enabled": true,
        "database": {
            "url": "postgresql://localhost/production",
            "pool_size": 20,
            "timeout": 60
        },
        "features": ["websocket", "auth", "logging"],
        "settings": {
            "debug": false,
            "log_level": "warn"
        }
    }"#;
    
    match serde_json::from_str::<ServerConfig>(json_str) {
        Ok(loaded_config) => {
            println!("\nä» JSON åŠ è½½çš„é…ç½®:");
            println!("{:#?}", loaded_config);
        }
        Err(e) => println!("JSON ååºåˆ—åŒ–å¤±è´¥: {}", e),
    }
    
    // TOML æ ¼å¼æ¼”ç¤º
    demonstrate_toml_serialization(&config);
    
    // ä»æ–‡ä»¶åŠ è½½é…ç½®
    load_config_from_file();
}

fn demonstrate_toml_serialization(config: &ServerConfig) {
    println!("\n=== TOML åºåˆ—åŒ–æ¼”ç¤º ===");
    
    match toml::to_string_pretty(config) {
        Ok(toml_str) => {
            println!("é…ç½® TOML:\n{}", toml_str);
            
            // ä¿å­˜ TOML æ–‡ä»¶
            if let Err(e) = fs::write("server_config.toml", &toml_str) {
                println!("ä¿å­˜ TOML æ–‡ä»¶å¤±è´¥: {}", e);
            }
        }
        Err(e) => println!("TOML åºåˆ—åŒ–å¤±è´¥: {}", e),
    }
}

fn load_config_from_file() {
    println!("\n=== ä»æ–‡ä»¶åŠ è½½é…ç½® ===");
    
    // å°è¯•ä» JSON æ–‡ä»¶åŠ è½½
    if let Ok(content) = fs::read_to_string("server_config.json") {
        match serde_json::from_str::<ServerConfig>(&content) {
            Ok(config) => {
                println!("ä» JSON æ–‡ä»¶åŠ è½½æˆåŠŸ:");
                println!("æœåŠ¡å™¨: {}:{}", config.host, config.port);
                println!("æ•°æ®åº“: {}", config.database.url);
                println!("åŠŸèƒ½: {:?}", config.features);
            }
            Err(e) => println!("JSON æ–‡ä»¶è§£æå¤±è´¥: {}", e),
        }
    }
    
    // å°è¯•ä» TOML æ–‡ä»¶åŠ è½½
    if let Ok(content) = fs::read_to_string("server_config.toml") {
        match toml::from_str::<ServerConfig>(&content) {
            Ok(config) => {
                println!("\nä» TOML æ–‡ä»¶åŠ è½½æˆåŠŸ:");
                println!("æœ€å¤§è¿æ¥æ•°: {}", config.max_connections);
                println!("SSL å¯ç”¨: {}", config.ssl_enabled);
            }
            Err(e) => println!("TOML æ–‡ä»¶è§£æå¤±è´¥: {}", e),
        }
    }
}</pre>

        <p><strong>æ­¥éª¤ 6: å‘½ä»¤è¡Œå‚æ•° - Clap</strong></p>
        <pre>use clap::{Parser, Subcommand};
use colored::*;
use anyhow::{Result, Context};

#[derive(Parser)]
#[command(name = "chatroom")]
#[command(about = "ä¸€ä¸ªç®€å•çš„èŠå¤©å®¤æœåŠ¡å™¨")]
#[command(version = "1.0.0")]
struct Cli {
    /// æœåŠ¡å™¨ç›‘å¬åœ°å€
    #[arg(short, long, default_value = "127.0.0.1")]
    host: String,
    
    /// æœåŠ¡å™¨ç›‘å¬ç«¯å£
    #[arg(short, long, default_value_t = 8080)]
    port: u16,
    
    /// å¯ç”¨è°ƒè¯•æ¨¡å¼
    #[arg(short, long)]
    debug: bool,
    
    /// é…ç½®æ–‡ä»¶è·¯å¾„
    #[arg(short, long)]
    config: Option<String>,
    
    /// å­å‘½ä»¤
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// å¯åŠ¨æœåŠ¡å™¨
    Start {
        /// æœ€å¤§è¿æ¥æ•°
        #[arg(long, default_value_t = 100)]
        max_connections: u32,
        
        /// å¯ç”¨ SSL
        #[arg(long)]
        ssl: bool,
    },
    /// ç”Ÿæˆé…ç½®æ–‡ä»¶
    Config {
        /// è¾“å‡ºæ–‡ä»¶å
        #[arg(short, long, default_value = "config.json")]
        output: String,
        
        /// é…ç½®æ ¼å¼
        #[arg(short, long, default_value = "json")]
        format: String,
    },
    /// ç”¨æˆ·ç®¡ç†
    User {
        /// ç”¨æˆ·æ“ä½œ
        #[command(subcommand)]
        action: UserCommands,
    },
}

#[derive(Subcommand)]
enum UserCommands {
    /// åˆ›å»ºç”¨æˆ·
    Create {
        /// ç”¨æˆ·å
        username: String,
        /// é‚®ç®±
        email: String,
    },
    /// åˆ—å‡ºæ‰€æœ‰ç”¨æˆ·
    List,
    /// åˆ é™¤ç”¨æˆ·
    Delete {
        /// ç”¨æˆ·ID
        id: String,
    },
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    
    println!("{}", "ğŸš€ èŠå¤©å®¤æœåŠ¡å™¨".bright_blue().bold());
    println!("ä¸»æœº: {}", cli.host.bright_green());
    println!("ç«¯å£: {}", cli.port.to_string().bright_green());
    
    if cli.debug {
        println!("{}", "è°ƒè¯•æ¨¡å¼å·²å¯ç”¨".yellow());
    }
    
    if let Some(config_path) = &cli.config {
        println!("é…ç½®æ–‡ä»¶: {}", config_path.bright_cyan());
        load_custom_config(config_path)?;
    }
    
    match cli.command {
        Some(Commands::Start { max_connections, ssl }) => {
            start_server(&cli.host, cli.port, max_connections, ssl)?;
        }
        Some(Commands::Config { output, format }) => {
            generate_config_file(&output, &format)?;
        }
        Some(Commands::User { action }) => {
            handle_user_command(action)?;
        }
        None => {
            println!("{}", "ä½¿ç”¨ --help æŸ¥çœ‹å¯ç”¨å‘½ä»¤".bright_yellow());
        }
    }
    
    Ok(())
}

fn start_server(host: &str, port: u16, max_connections: u32, ssl: bool) -> Result<()> {
    println!("{}", "\nğŸ¯ å¯åŠ¨æœåŠ¡å™¨...".bright_green().bold());
    println!("åœ°å€: {}:{}", host, port);
    println!("æœ€å¤§è¿æ¥æ•°: {}", max_connections);
    println!("SSL: {}", if ssl { "å¯ç”¨".green() } else { "ç¦ç”¨".red() });
    
    // æ¨¡æ‹ŸæœåŠ¡å™¨å¯åŠ¨
    use std::thread;
    use std::time::Duration;
    
    println!("{}", "æ­£åœ¨åˆå§‹åŒ–...".bright_blue());
    thread::sleep(Duration::from_millis(500));
    
    println!("{}", "âœ… æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!".bright_green().bold());
    println!("ç›‘å¬åœ°å€: http://{}:{}", host, port);
    
    Ok(())
}

fn generate_config_file(output: &str, format: &str) -> Result<()> {
    println!("{}", "ğŸ“ ç”Ÿæˆé…ç½®æ–‡ä»¶...".bright_blue().bold());
    
    let config = ServerConfig {
        host: "0.0.0.0".to_string(),
        port: 8080,
        max_connections: 100,
        ssl_enabled: false,
        database: DatabaseConfig {
            url: "postgresql://localhost/chatroom".to_string(),
            pool_size: 10,
            timeout: 30,
        },
        features: vec!["websocket".to_string(), "cors".to_string()],
        settings: std::collections::HashMap::new(),
    };
    
    let content = match format {
        "json" => serde_json::to_string_pretty(&config)
            .context("JSON åºåˆ—åŒ–å¤±è´¥")?,
        "toml" => toml::to_string_pretty(&config)
            .context("TOML åºåˆ—åŒ–å¤±è´¥")?,
        _ => return Err(anyhow::anyhow!("ä¸æ”¯æŒçš„æ ¼å¼: {}", format)),
    };
    
    std::fs::write(output, content)
        .context(format!("å†™å…¥æ–‡ä»¶å¤±è´¥: {}", output))?;
    
    println!("{} {}", "âœ… é…ç½®æ–‡ä»¶å·²ç”Ÿæˆ:".bright_green(), output.bright_cyan());
    
    Ok(())
}

fn handle_user_command(action: UserCommands) -> Result<()> {
    match action {
        UserCommands::Create { username, email } => {
            println!("{}", "ğŸ‘¤ åˆ›å»ºç”¨æˆ·...".bright_blue().bold());
            let user_id = uuid::Uuid::new_v4().to_string();
            println!("ç”¨æˆ·å: {}", username.bright_green());
            println!("é‚®ç®±: {}", email.bright_green());
            println!("ç”¨æˆ·ID: {}", user_id.bright_cyan());
            println!("{}", "âœ… ç”¨æˆ·åˆ›å»ºæˆåŠŸ!".bright_green());
        }
        UserCommands::List => {
            println!("{}", "ğŸ“‹ ç”¨æˆ·åˆ—è¡¨:".bright_blue().bold());
            // æ¨¡æ‹Ÿç”¨æˆ·åˆ—è¡¨
            let users = [
                ("alice123", "alice@example.com"),
                ("bob_smith", "bob@example.com"),
                ("charlie_dev", "charlie@example.com"),
            ];
            
            for (i, (username, email)) in users.iter().enumerate() {
                println!("{}. {} ({})", 
                    (i + 1).to_string().bright_cyan(),
                    username.bright_green(),
                    email.bright_yellow()
                );
            }
        }
        UserCommands::Delete { id } => {
            println!("{}", "ğŸ—‘ï¸  åˆ é™¤ç”¨æˆ·...".bright_red().bold());
            println!("ç”¨æˆ·ID: {}", id.bright_cyan());
            println!("{}", "âœ… ç”¨æˆ·å·²åˆ é™¤!".bright_green());
        }
    }
    
    Ok(())
}

fn load_custom_config(config_path: &str) -> Result<()> {
    println!("{} {}", "ğŸ“– åŠ è½½é…ç½®æ–‡ä»¶:".bright_blue(), config_path.bright_cyan());
    
    let content = std::fs::read_to_string(config_path)
        .context(format!("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥: {}", config_path))?;
    
    // æ ¹æ®æ–‡ä»¶æ‰©å±•ååˆ¤æ–­æ ¼å¼
    if config_path.ends_with(".json") {
        let config: ServerConfig = serde_json::from_str(&content)
            .context("JSON é…ç½®æ–‡ä»¶è§£æå¤±è´¥")?;
        println!("{}", "âœ… JSON é…ç½®åŠ è½½æˆåŠŸ!".bright_green());
        println!("æ•°æ®åº“: {}", config.database.url.bright_cyan());
    } else if config_path.ends_with(".toml") {
        let config: ServerConfig = toml::from_str(&content)
            .context("TOML é…ç½®æ–‡ä»¶è§£æå¤±è´¥")?;
        println!("{}", "âœ… TOML é…ç½®åŠ è½½æˆåŠŸ!".bright_green());
        println!("åŠŸèƒ½: {:?}", config.features);
    } else {
        return Err(anyhow::anyhow!("ä¸æ”¯æŒçš„é…ç½®æ–‡ä»¶æ ¼å¼"));
    }
    
    Ok(())
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>åˆ›å»ºä¸€ä¸ªæ—¥å¿—ç®¡ç†ç³»ç»Ÿï¼Œä½¿ç”¨ chrono è®°å½•æ—¶é—´æˆ³</li>
            <li>å®ç°ä¸€ä¸ªæ•°æ®ç”Ÿæˆå™¨ï¼Œä½¿ç”¨ rand ç”Ÿæˆæµ‹è¯•æ•°æ®</li>
            <li>æ„å»ºä¸€ä¸ªé…ç½®ç®¡ç†å™¨ï¼Œæ”¯æŒ JSON å’Œ TOML æ ¼å¼</li>
            <li>å¼€å‘ä¸€ä¸ªå‘½ä»¤è¡Œå·¥å…·ï¼Œä½¿ç”¨ clap å¤„ç†ç”¨æˆ·è¾“å…¥</li>
        </ul>

        <p><strong>ç»¼åˆç»ƒä¹ ï¼šå®Œæ•´çš„ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ</strong></p>
        <pre>// è¿è¡Œç¤ºä¾‹:
// cargo run -- --host 0.0.0.0 --port 3000 start --max-connections 200 --ssl
// cargo run -- config --output my_config.toml --format toml
// cargo run -- user create "alice" "alice@example.com"
// cargo run -- user list
// cargo run -- --debug --config my_config.toml start</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day09_external_crates/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ server_config.json    # ç”Ÿæˆçš„é…ç½®æ–‡ä»¶
â”œâ”€â”€ server_config.toml    # ç”Ÿæˆçš„é…ç½®æ–‡ä»¶
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-10</strong></p>
        <h2>Day 10 - æµ‹è¯•åŸºç¡€ï¼šéªŒè¯ä»£ç æ­£ç¡®æ€§</h2>
        <p>ä½ å°†ä¸ºä¹‹å‰çš„ç»“æ„ä½“æ–¹æ³•ç¼–å†™å•å…ƒæµ‹è¯•ï¼Œå­¦ä¹ ä½¿ç”¨ `#[test]` å’Œ `assert_eq!`ï¼Œå¹¶ä½¿ç”¨ `cargo test` è¿è¡Œæµ‹è¯•ã€‚ä½ è¿˜å°†äº†è§£å¦‚ä½•ç»„ç»‡é›†æˆæµ‹è¯•ã€‚</p>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/ch11-00-testing.html" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®å’ŒåŸºç¡€ä»£ç </strong></p>
        <pre>cargo new day10_testing
cd day10_testing</pre>

        <p><strong>src/lib.rs - åˆ›å»ºåº“æ–‡ä»¶</strong></p>
        <pre>pub mod calculator;
pub mod user;
pub mod message;

// å…¬å…±åº“æ¥å£
pub use calculator::Calculator;
pub use user::User;
pub use message::{Message, MessageType};</pre>

        <p><strong>src/calculator.rs</strong></p>
        <pre>#[derive(Debug, PartialEq)]
pub struct Calculator {
    pub name: String,
    pub version: String,
}

impl Calculator {
    pub fn new(name: String) -> Self {
        Calculator {
            name,
            version: "1.0.0".to_string(),
        }
    }
    
    pub fn add(&self, a: f64, b: f64) -> f64 {
        a + b
    }
    
    pub fn subtract(&self, a: f64, b: f64) -> f64 {
        a - b
    }
    
    pub fn multiply(&self, a: f64, b: f64) -> f64 {
        a * b
    }
    
    pub fn divide(&self, a: f64, b: f64) -> Result<f64, String> {
        if b == 0.0 {
            Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())
        } else {
            Ok(a / b)
        }
    }
    
    pub fn power(&self, base: f64, exp: f64) -> f64 {
        base.powf(exp)
    }
    
    pub fn sqrt(&self, x: f64) -> Result<f64, String> {
        if x < 0.0 {
            Err("ä¸èƒ½è®¡ç®—è´Ÿæ•°çš„å¹³æ–¹æ ¹".to_string())
        } else {
            Ok(x.sqrt())
        }
    }
}

// åœ¨æ¨¡å—å†…éƒ¨çš„æµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_calculator_creation() {
        let calc = Calculator::new("Test Calc".to_string());
        assert_eq!(calc.name, "Test Calc");
        assert_eq!(calc.version, "1.0.0");
    }
    
    #[test]
    fn test_addition() {
        let calc = Calculator::new("Test".to_string());
        assert_eq!(calc.add(2.0, 3.0), 5.0);
        assert_eq!(calc.add(-1.0, 1.0), 0.0);
        assert_eq!(calc.add(0.0, 0.0), 0.0);
    }
    
    #[test]
    fn test_subtraction() {
        let calc = Calculator::new("Test".to_string());
        assert_eq!(calc.subtract(5.0, 3.0), 2.0);
        assert_eq!(calc.subtract(1.0, 1.0), 0.0);
        assert_eq!(calc.subtract(-2.0, -3.0), 1.0);
    }
    
    #[test]
    fn test_multiplication() {
        let calc = Calculator::new("Test".to_string());
        assert_eq!(calc.multiply(4.0, 5.0), 20.0);
        assert_eq!(calc.multiply(-2.0, 3.0), -6.0);
        assert_eq!(calc.multiply(0.0, 100.0), 0.0);
    }
    
    #[test]
    fn test_division() {
        let calc = Calculator::new("Test".to_string());
        
        // æ­£å¸¸é™¤æ³•
        assert_eq!(calc.divide(10.0, 2.0), Ok(5.0));
        assert_eq!(calc.divide(-6.0, 3.0), Ok(-2.0));
        
        // é™¤ä»¥é›¶çš„æƒ…å†µ
        assert!(calc.divide(5.0, 0.0).is_err());
        assert_eq!(calc.divide(5.0, 0.0), Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string()));
    }
    
    #[test]
    fn test_power() {
        let calc = Calculator::new("Test".to_string());
        assert_eq!(calc.power(2.0, 3.0), 8.0);
        assert_eq!(calc.power(5.0, 0.0), 1.0);
        assert!((calc.power(2.0, 0.5) - 1.4142135623730951).abs() < f64::EPSILON);
    }
    
    #[test]
    fn test_sqrt() {
        let calc = Calculator::new("Test".to_string());
        
        // æ­£å¸¸å¹³æ–¹æ ¹
        assert_eq!(calc.sqrt(4.0), Ok(2.0));
        assert_eq!(calc.sqrt(9.0), Ok(3.0));
        assert_eq!(calc.sqrt(0.0), Ok(0.0));
        
        // è´Ÿæ•°å¹³æ–¹æ ¹
        assert!(calc.sqrt(-1.0).is_err());
        assert_eq!(calc.sqrt(-1.0), Err("ä¸èƒ½è®¡ç®—è´Ÿæ•°çš„å¹³æ–¹æ ¹".to_string()));
    }
    
    #[test]
    #[should_panic(expected = "assertion failed")]
    fn test_should_panic_example() {
        // è¿™ä¸ªæµ‹è¯•åº”è¯¥ panic
        assert_eq!(1, 2);
    }
    
    #[test]
    #[ignore]
    fn test_ignored() {
        // è¿™ä¸ªæµ‹è¯•é»˜è®¤ä¼šè¢«å¿½ç•¥
        assert_eq!(1, 1);
    }
}</pre>

        <p><strong>src/user.rs</strong></p>
        <pre>use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub struct User {
    pub id: u32,
    pub username: String,
    pub email: String,
    pub active: bool,
    pub metadata: HashMap<String, String>,
}

impl User {
    pub fn new(id: u32, username: String, email: String) -> Result<Self, String> {
        if username.len() < 3 {
            return Err("ç”¨æˆ·åé•¿åº¦ä¸èƒ½å°‘äº3ä¸ªå­—ç¬¦".to_string());
        }
        
        if !email.contains('@') {
            return Err("é‚®ç®±æ ¼å¼ä¸æ­£ç¡®".to_string());
        }
        
        Ok(User {
            id,
            username,
            email,
            active: true,
            metadata: HashMap::new(),
        })
    }
    
    pub fn deactivate(&mut self) {
        self.active = false;
    }
    
    pub fn activate(&mut self) {
        self.active = true;
    }
    
    pub fn add_metadata(&mut self, key: String, value: String) {
        self.metadata.insert(key, value);
    }
    
    pub fn get_metadata(&self, key: &str) -> Option<&String> {
        self.metadata.get(key)
    }
    
    pub fn remove_metadata(&mut self, key: &str) -> Option<String> {
        self.metadata.remove(key)
    }
    
    pub fn is_valid_email(email: &str) -> bool {
        email.contains('@') && email.contains('.') && email.len() > 5
    }
    
    pub fn update_email(&mut self, new_email: String) -> Result<(), String> {
        if !Self::is_valid_email(&new_email) {
            return Err("é‚®ç®±æ ¼å¼ä¸æ­£ç¡®".to_string());
        }
        
        self.email = new_email;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_user_creation_success() {
        let user = User::new(1, "alice".to_string(), "alice@example.com".to_string());
        assert!(user.is_ok());
        
        let user = user.unwrap();
        assert_eq!(user.id, 1);
        assert_eq!(user.username, "alice");
        assert_eq!(user.email, "alice@example.com");
        assert!(user.active);
        assert!(user.metadata.is_empty());
    }
    
    #[test]
    fn test_user_creation_invalid_username() {
        let user = User::new(1, "ab".to_string(), "test@example.com".to_string());
        assert!(user.is_err());
        assert_eq!(user.unwrap_err(), "ç”¨æˆ·åé•¿åº¦ä¸èƒ½å°‘äº3ä¸ªå­—ç¬¦");
    }
    
    #[test]
    fn test_user_creation_invalid_email() {
        let user = User::new(1, "alice".to_string(), "invalid-email".to_string());
        assert!(user.is_err());
        assert_eq!(user.unwrap_err(), "é‚®ç®±æ ¼å¼ä¸æ­£ç¡®");
    }
    
    #[test]
    fn test_user_activation() {
        let mut user = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
        
        assert!(user.active);
        
        user.deactivate();
        assert!(!user.active);
        
        user.activate();
        assert!(user.active);
    }
    
    #[test]
    fn test_user_metadata() {
        let mut user = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
        
        // æ·»åŠ å‚æ•°
        user.add_metadata("theme".to_string(), "dark".to_string());
        user.add_metadata("language".to_string(), "zh".to_string());
        
        // è·å–å‚æ•°
        assert_eq!(user.get_metadata("theme"), Some(&"dark".to_string()));
        assert_eq!(user.get_metadata("language"), Some(&"zh".to_string()));
        assert_eq!(user.get_metadata("nonexistent"), None);
        
        // åˆ é™¤å‚æ•°
        let removed = user.remove_metadata("theme");
        assert_eq!(removed, Some("dark".to_string()));
        assert_eq!(user.get_metadata("theme"), None);
    }
    
    #[test]
    fn test_email_validation() {
        assert!(User::is_valid_email("test@example.com"));
        assert!(User::is_valid_email("user.name+tag@domain.co.uk"));
        
        assert!(!User::is_valid_email("invalid"));
        assert!(!User::is_valid_email("test@"));
        assert!(!User::is_valid_email("@example.com"));
        assert!(!User::is_valid_email("test.com"));
        assert!(!User::is_valid_email("a@b"));
    }
    
    #[test]
    fn test_email_update() {
        let mut user = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
        
        // æ­£å¸¸æ›´æ–°
        let result = user.update_email("alice.new@example.com".to_string());
        assert!(result.is_ok());
        assert_eq!(user.email, "alice.new@example.com");
        
        // æ— æ•ˆé‚®ç®±æ›´æ–°
        let result = user.update_email("invalid-email".to_string());
        assert!(result.is_err());
        assert_eq!(user.email, "alice.new@example.com"); // é‚®ç®±ä¸åº”è¯¥å˜åŒ–
    }
}</pre>

        <p><strong>src/message.rs</strong></p>
        <pre>use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Clone, PartialEq)]
pub enum MessageType {
    Text,
    Image { url: String },
    File { name: String, size: u64 },
    System,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Message {
    pub id: u64,
    pub sender_id: u32,
    pub content: String,
    pub message_type: MessageType,
    pub timestamp: u64,
    pub edited: bool,
}

impl Message {
    pub fn new_text(sender_id: u32, content: String) -> Result<Self, String> {
        if content.trim().is_empty() {
            return Err("æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º".to_string());
        }
        
        if content.len() > 1000 {
            return Err("æ¶ˆæ¯é•¿åº¦ä¸èƒ½è¶…è¿‡1000ä¸ªå­—ç¬¦".to_string());
        }
        
        Ok(Message {
            id: Self::generate_id(),
            sender_id,
            content,
            message_type: MessageType::Text,
            timestamp: Self::current_timestamp(),
            edited: false,
        })
    }
    
    pub fn new_image(sender_id: u32, url: String, caption: Option<String>) -> Result<Self, String> {
        if url.trim().is_empty() {
            return Err("å›¾ç‰‡URLä¸èƒ½ä¸ºç©º".to_string());
        }
        
        let content = caption.unwrap_or_else(|| "[å›¾ç‰‡]".to_string());
        
        Ok(Message {
            id: Self::generate_id(),
            sender_id,
            content,
            message_type: MessageType::Image { url },
            timestamp: Self::current_timestamp(),
            edited: false,
        })
    }
    
    pub fn new_system(content: String) -> Self {
        Message {
            id: Self::generate_id(),
            sender_id: 0, // ç³»ç»Ÿæ¶ˆæ¯ä½¿ç”¨ID 0
            content,
            message_type: MessageType::System,
            timestamp: Self::current_timestamp(),
            edited: false,
        }
    }
    
    pub fn edit_content(&mut self, new_content: String) -> Result<(), String> {
        if new_content.trim().is_empty() {
            return Err("æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º".to_string());
        }
        
        if new_content.len() > 1000 {
            return Err("æ¶ˆæ¯é•¿åº¦ä¸èƒ½è¶…è¿‡1000ä¸ªå­—ç¬¦".to_string());
        }
        
        self.content = new_content;
        self.edited = true;
        Ok(())
    }
    
    pub fn is_system_message(&self) -> bool {
        matches!(self.message_type, MessageType::System)
    }
    
    pub fn format_timestamp(&self) -> String {
        // ç®€å•çš„æ—¶é—´æ ¼å¼åŒ–
        format!("æ—¶é—´æˆ³: {}", self.timestamp)
    }
    
    fn generate_id() -> u64 {
        use std::sync::atomic::{AtomicU64, Ordering};
        static COUNTER: AtomicU64 = AtomicU64::new(1);
        COUNTER.fetch_add(1, Ordering::SeqCst)
    }
    
    fn current_timestamp() -> u64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_text_message_creation() {
        let message = Message::new_text(1, "Hello, world!".to_string());
        assert!(message.is_ok());
        
        let message = message.unwrap();
        assert_eq!(message.sender_id, 1);
        assert_eq!(message.content, "Hello, world!");
        assert_eq!(message.message_type, MessageType::Text);
        assert!(!message.edited);
        assert!(!message.is_system_message());
    }
    
    #[test]
    fn test_text_message_empty_content() {
        let message = Message::new_text(1, "".to_string());
        assert!(message.is_err());
        assert_eq!(message.unwrap_err(), "æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º");
        
        let message = Message::new_text(1, "   ".to_string());
        assert!(message.is_err());
    }
    
    #[test]
    fn test_text_message_too_long() {
        let long_content = "a".repeat(1001);
        let message = Message::new_text(1, long_content);
        assert!(message.is_err());
        assert_eq!(message.unwrap_err(), "æ¶ˆæ¯é•¿åº¦ä¸èƒ½è¶…è¿‡1000ä¸ªå­—ç¬¦");
    }
    
    #[test]
    fn test_image_message_creation() {
        let message = Message::new_image(
            1, 
            "https://example.com/image.jpg".to_string(),
            Some("ç¾ä¸½çš„é£æ™¯".to_string())
        );
        assert!(message.is_ok());
        
        let message = message.unwrap();
        assert_eq!(message.content, "ç¾ä¸½çš„é£æ™¯");
        assert_eq!(message.message_type, MessageType::Image { 
            url: "https://example.com/image.jpg".to_string() 
        });
    }
    
    #[test]
    fn test_image_message_without_caption() {
        let message = Message::new_image(
            1, 
            "https://example.com/image.jpg".to_string(),
            None
        );
        assert!(message.is_ok());
        
        let message = message.unwrap();
        assert_eq!(message.content, "[å›¾ç‰‡]");
    }
    
    #[test]
    fn test_image_message_empty_url() {
        let message = Message::new_image(1, "".to_string(), None);
        assert!(message.is_err());
        assert_eq!(message.unwrap_err(), "å›¾ç‰‡URLä¸èƒ½ä¸ºç©º");
    }
    
    #[test]
    fn test_system_message() {
        let message = Message::new_system("ç”¨æˆ· Alice åŠ å…¥äº†èŠå¤©å®¤".to_string());
        
        assert_eq!(message.sender_id, 0);
        assert_eq!(message.content, "ç”¨æˆ· Alice åŠ å…¥äº†èŠå¤©å®¤");
        assert_eq!(message.message_type, MessageType::System);
        assert!(message.is_system_message());
    }
    
    #[test]
    fn test_message_editing() {
        let mut message = Message::new_text(1, "Original content".to_string()).unwrap();
        assert!(!message.edited);
        
        let result = message.edit_content("Edited content".to_string());
        assert!(result.is_ok());
        assert_eq!(message.content, "Edited content");
        assert!(message.edited);
    }
    
    #[test]
    fn test_message_editing_invalid() {
        let mut message = Message::new_text(1, "Original content".to_string()).unwrap();
        
        // ç©ºå†…å®¹
        let result = message.edit_content("".to_string());
        assert!(result.is_err());
        assert_eq!(message.content, "Original content"); // å†…å®¹ä¸åº”è¯¥å˜åŒ–
        assert!(!message.edited);
        
        // è¿‡é•¿å†…å®¹
        let long_content = "a".repeat(1001);
        let result = message.edit_content(long_content);
        assert!(result.is_err());
        assert_eq!(message.content, "Original content");
    }
    
    #[test]
    fn test_message_id_uniqueness() {
        let msg1 = Message::new_text(1, "Message 1".to_string()).unwrap();
        let msg2 = Message::new_text(1, "Message 2".to_string()).unwrap();
        
        assert_ne!(msg1.id, msg2.id);
    }
    
    #[test]
    fn test_message_timestamp() {
        let msg = Message::new_text(1, "Test message".to_string()).unwrap();
        
        // æ—¶é—´æˆ³åº”è¯¥æ˜¯åˆç†çš„ï¼ˆåœ¨å½“å‰æ—¶é—´é™„è¿‘ï¼‰
        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        assert!(msg.timestamp <= current_time);
        assert!(msg.timestamp > current_time - 10); // åœ¨10ç§’å†…
    }
}</pre>

        <p><strong>æ­¥éª¤ 2: é›†æˆæµ‹è¯•</strong></p>
        <p><strong>tests/integration_test.rs</strong></p>
        <pre>use day10_testing::{Calculator, User, Message, MessageType};
use std::collections::HashMap;

#[test]
fn test_calculator_user_integration() {
    // åˆ›å»ºç”¨æˆ·å’Œè®¡ç®—å™¨
    let mut user = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
    let calc = Calculator::new("Alice's Calculator".to_string());
    
    // ç”¨æˆ·æ·»åŠ è®¡ç®—å™¨ä¿¡æ¯åˆ°å…ƒæ•°æ®
    user.add_metadata("calculator_name".to_string(), calc.name.clone());
    user.add_metadata("calculator_version".to_string(), calc.version.clone());
    
    // éªŒè¯é›†æˆ
    assert_eq!(user.get_metadata("calculator_name"), Some(&calc.name));
    assert_eq!(user.get_metadata("calculator_version"), Some(&calc.version));
    
    // æ¨¡æ‹Ÿè®¡ç®—æ“ä½œ
    let result = calc.add(10.0, 5.0);
    assert_eq!(result, 15.0);
}

#[test]
fn test_message_system_integration() {
    // åˆ›å»ºç”¨æˆ·
    let user1 = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
    let user2 = User::new(2, "bob".to_string(), "bob@example.com".to_string()).unwrap();
    
    // åˆ›å»ºæ¶ˆæ¯
    let mut messages = Vec::new();
    
    // ç³»ç»Ÿæ¶ˆæ¯
    messages.push(Message::new_system(format!("{} åŠ å…¥äº†èŠå¤©å®¤", user1.username)));
    messages.push(Message::new_system(format!("{} åŠ å…¥äº†èŠå¤©å®¤", user2.username)));
    
    // ç”¨æˆ·æ¶ˆæ¯
    messages.push(Message::new_text(user1.id, "Hello everyone!".to_string()).unwrap());
    messages.push(Message::new_text(user2.id, "Hi Alice!".to_string()).unwrap());
    
    // éªŒè¯æ¶ˆæ¯ç³»ç»Ÿ
    assert_eq!(messages.len(), 4);
    assert!(messages[0].is_system_message());
    assert!(messages[1].is_system_message());
    assert!(!messages[2].is_system_message());
    assert!(!messages[3].is_system_message());
    
    // éªŒè¯æ¶ˆæ¯å†…å®¹
    assert_eq!(messages[2].sender_id, user1.id);
    assert_eq!(messages[3].sender_id, user2.id);
}

#[test]
fn test_full_chat_scenario() {
    // å®Œæ•´çš„èŠå¤©åœºæ™¯æµ‹è¯•
    let mut users = HashMap::new();
    let mut messages = Vec::new();
    
    // åˆ›å»ºå¤šä¸ªç”¨æˆ·
    let alice = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
    let bob = User::new(2, "bob".to_string(), "bob@example.com".to_string()).unwrap();
    let charlie = User::new(3, "charlie".to_string(), "charlie@example.com".to_string()).unwrap();
    
    users.insert(alice.id, alice);
    users.insert(bob.id, bob);
    users.insert(charlie.id, charlie);
    
    // æ¨¡æ‹ŸèŠå¤©æµç¨‹
    // 1. ç”¨æˆ·åŠ å…¥
    for user in users.values() {
        messages.push(Message::new_system(format!("{} åŠ å…¥äº†èŠå¤©å®¤", user.username)));
    }
    
    // 2. ç”¨æˆ·å‘é€æ¶ˆæ¯
    messages.push(Message::new_text(1, "Hello everyone!".to_string()).unwrap());
    messages.push(Message::new_text(2, "Hi Alice! How are you?".to_string()).unwrap());
    messages.push(Message::new_text(3, "Good morning!".to_string()).unwrap());
    
    // 3. ç”¨æˆ·å‘é€å›¾ç‰‡
    messages.push(Message::new_image(
        1, 
        "https://example.com/vacation.jpg".to_string(),
        Some("æˆ‘çš„åº¦å‡ç…§ç‰‡".to_string())
    ).unwrap());
    
    // 4. ç¼–è¾‘æ¶ˆæ¯
    if let Some(last_text_msg) = messages.iter_mut().find(|m| m.message_type == MessageType::Text && m.sender_id == 3) {
        last_text_msg.edit_content("Good morning everyone! ğŸŒ…".to_string()).unwrap();
    }
    
    // éªŒè¯æ•´ä¸ªæµç¨‹
    assert_eq!(users.len(), 3);
    assert_eq!(messages.len(), 7); // 3ä¸ªç³»ç»Ÿæ¶ˆæ¯ + 3ä¸ªæ–‡æœ¬æ¶ˆæ¯ + 1ä¸ªå›¾ç‰‡æ¶ˆæ¯
    
    // éªŒè¯æœ€åä¸€æ¡æ–‡æœ¬æ¶ˆæ¯è¢«ç¼–è¾‘
    let edited_msg = messages.iter().find(|m| m.edited).unwrap();
    assert_eq!(edited_msg.content, "Good morning everyone! ğŸŒ…");
    assert_eq!(edited_msg.sender_id, 3);
    
    // éªŒè¯æ¶ˆæ¯ç±»å‹åˆ†å¸ƒ
    let system_count = messages.iter().filter(|m| m.is_system_message()).count();
    let text_count = messages.iter().filter(|m| matches!(m.message_type, MessageType::Text)).count();
    let image_count = messages.iter().filter(|m| matches!(m.message_type, MessageType::Image { .. })).count();
    
    assert_eq!(system_count, 3);
    assert_eq!(text_count, 3);
    assert_eq!(image_count, 1);
}</pre>

        <p><strong>æ­¥éª¤ 3: æ€§èƒ½æµ‹è¯•å’Œæ•°æ®é©±åŠ¨æµ‹è¯•</strong></p>
        <p><strong>tests/benchmark_test.rs</strong></p>
        <pre>#[cfg(test)]
mod performance_tests {
    use day10_testing::*;
    use std::time::Instant;
    
    #[test]
    fn test_calculator_performance() {
        let calc = Calculator::new("Perf Test".to_string());
        let start = Instant::now();
        
        // æ‰§è¡Œå¤§é‡è®¡ç®—
        for i in 0..10000 {
            let _ = calc.add(i as f64, (i + 1) as f64);
            let _ = calc.multiply(i as f64, 2.0);
        }
        
        let duration = start.elapsed();
        println!("ğŸ•°ï¸  10000æ¬¡è®¡ç®—æ“ä½œè€—æ—¶: {:?}", duration);
        
        // ç¡®ä¿æ€§èƒ½åœ¨åˆç†èŒƒå›´å†…ï¼ˆå°äº100msï¼‰
        assert!(duration.as_millis() < 100);
    }
    
    #[test]
    fn test_message_creation_performance() {
        let start = Instant::now();
        let mut messages = Vec::new();
        
        // åˆ›å»ºå¤§é‡æ¶ˆæ¯
        for i in 0..1000 {
            let msg = Message::new_text(1, format!("æ¶ˆæ¯ {}", i)).unwrap();
            messages.push(msg);
        }
        
        let duration = start.elapsed();
        println!("ğŸ•°ï¸  1000æ¡æ¶ˆæ¯åˆ›å»ºè€—æ—¶: {:?}", duration);
        
        assert_eq!(messages.len(), 1000);
        assert!(duration.as_millis() < 100);
    }
}

// æ•°æ®é©±åŠ¨æµ‹è¯•
#[cfg(test)]
mod data_driven_tests {
    use day10_testing::*;
    
    #[test]
    fn test_calculator_operations_data_driven() {
        let calc = Calculator::new("Data Test".to_string());
        
        // æµ‹è¯•æ•°æ®é›†
        let test_cases = vec![
            // (a, b, expected_add, expected_multiply)
            (1.0, 2.0, 3.0, 2.0),
            (0.0, 5.0, 5.0, 0.0),
            (-3.0, 4.0, 1.0, -12.0),
            (2.5, 1.5, 4.0, 3.75),
            (100.0, -50.0, 50.0, -5000.0),
        ];
        
        for (i, (a, b, expected_add, expected_multiply)) in test_cases.iter().enumerate() {
            let add_result = calc.add(*a, *b);
            let multiply_result = calc.multiply(*a, *b);
            
            assert_eq!(add_result, *expected_add, "æµ‹è¯•ç”¨ä¾‹ {} åŠ æ³•å¤±è´¥", i);
            assert_eq!(multiply_result, *expected_multiply, "æµ‹è¯•ç”¨ä¾‹ {} ä¹˜æ³•å¤±è´¥", i);
        }
    }
    
    #[test]
    fn test_user_validation_data_driven() {
        let test_cases = vec![
            // (id, username, email, should_succeed)
            (1, "alice", "alice@example.com", true),
            (2, "bob123", "bob@test.org", true),
            (3, "charlie_dev", "charlie.dev@company.co.uk", true),
            (4, "ab", "valid@email.com", false), // ç”¨æˆ·åå¤ªçŸ­
            (5, "validuser", "invalid-email", false), // é‚®ç®±æ— æ•ˆ
            (6, "u", "bad", false), // éƒ½æ— æ•ˆ
        ];
        
        for (i, (id, username, email, should_succeed)) in test_cases.iter().enumerate() {
            let result = User::new(*id, username.to_string(), email.to_string());
            
            if *should_succeed {
                assert!(result.is_ok(), "æµ‹è¯•ç”¨ä¾‹ {} åº”è¯¥æˆåŠŸä½†å¤±è´¥äº†: {:?}", i, result.err());
                let user = result.unwrap();
                assert_eq!(user.username, *username);
                assert_eq!(user.email, *email);
            } else {
                assert!(result.is_err(), "æµ‹è¯•ç”¨ä¾‹ {} åº”è¯¥å¤±è´¥ä½†æˆåŠŸäº†", i);
            }
        }
    }
}</pre>

        <p><strong>æ­¥éª¤ 4: æµ‹è¯•å·¥å…·å’Œå‘½ä»¤</strong></p>
        <pre># è¿è¡Œæ‰€æœ‰æµ‹è¯•
cargo test

# è¿è¡Œç‰¹å®šæµ‹è¯•
cargo test test_calculator

# è¿è¡Œå¿½ç•¥çš„æµ‹è¯•
cargo test -- --ignored

# è¿è¡Œå•ä¸ªçº¿ç¨‹æµ‹è¯•
cargo test -- --test-threads=1

# æ˜¾ç¤ºæµ‹è¯•è¾“å‡º
cargo test -- --nocapture

# ç”Ÿæˆæµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Š
cargo install cargo-tarpaulin
cargo tarpaulin --out Html

# è¿è¡Œæ€§èƒ½æµ‹è¯•
cargo test performance -- --nocapture</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>ä¸ºä¹‹å‰çš„æ¨¡å—ä»£ç ç¼–å†™å®Œæ•´çš„å•å…ƒæµ‹è¯•</li>
            <li>åˆ›å»ºé›†æˆæµ‹è¯•éªŒè¯æ¨¡å—é—´çš„äº¤äº’</li>
            <li>ç¼–å†™æ€§èƒ½æµ‹è¯•ç¡®ä¿ä»£ç æ•ˆç‡</li>
            <li>ä½¿ç”¨æ•°æ®é©±åŠ¨æ–¹æ³•æµ‹è¯•å¤šç§åœºæ™¯</li>
        </ul>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day10_testing/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs           # åº“å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ calculator.rs    # è®¡ç®—å™¨æ¨¡å—åŠæµ‹è¯•
â”‚   â”œâ”€â”€ user.rs          # ç”¨æˆ·æ¨¡å—åŠæµ‹è¯•
â”‚   â””â”€â”€ message.rs       # æ¶ˆæ¯æ¨¡å—åŠæµ‹è¯•
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ integration_test.rs  # é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ benchmark_test.rs    # æ€§èƒ½æµ‹è¯•
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-11</strong></p>
        <h2>Day 11 - å¼•å…¥ tokio å¹¶è¿è¡Œç¬¬ä¸€ä¸ª async å‡½æ•°</h2>
        <p>ä½ å°†å®‰è£… `tokio` å¹¶å†™ä¸€ä¸ª `async fn` å»¶è¿Ÿ 1 ç§’åæ‰“å°ä¿¡æ¯çš„ä¾‹å­ï¼Œå¹¶äº†è§£ `.await` çš„è°ƒç”¨æ–¹å¼ä»¥åŠ `#[tokio::main]` çš„ä½œç”¨ã€‚</p>
        <p>ğŸ”— <a href="https://tokio.rs/tokio/tutorial" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®å’Œé…ç½®ä¾èµ–</strong></p>
        <pre>cargo new day11_async_basics
cd day11_async_basics</pre>

        <p><strong>Cargo.toml</strong></p>
        <pre>[package]
name = "day11_async_basics"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
futures = "0.3"
chrono = { version = "0.4", features = ["serde"] }
rand = "0.8"</pre>

        <p><strong>æ­¥éª¤ 2: åŸºæœ¬ async/await ä½¿ç”¨</strong></p>
        <pre>use tokio::time::{sleep, Duration, Instant};
use chrono::{DateTime, Utc};

#[tokio::main]
async fn main() {
    println!("=== Tokio Async åŸºç¡€æ¼”ç¤º ===");
    
    // åŸºæœ¬å»¶è¿Ÿæ“ä½œ
    println!("ğŸ•°ï¸  å¼€å§‹æ—¶é—´: {}", Utc::now().format("%H:%M:%S"));
    
    simple_delay().await;
    
    println!("ğŸ•°ï¸  ç»“æŸæ—¶é—´: {}", Utc::now().format("%H:%M:%S"));
    
    // æ¼”ç¤ºä¸åŒçš„ async å‡½æ•°
    demonstrate_async_functions().await;
    
    // æ¼”ç¤ºå¹¶å‘æ‰§è¡Œ
    demonstrate_concurrency().await;
    
    // æ¼”ç¤ºé”™è¯¯å¤„ç†
    demonstrate_error_handling().await;
}

// ç®€å•çš„å»¶è¿Ÿå‡½æ•°
async fn simple_delay() {
    println!("ğŸ˜´ å¼€å§‹ç¡çœ  1 ç§’...");
    sleep(Duration::from_secs(1)).await;
    println!("ğŸ˜Š ç¡é†’äº†ï¼");
}

// è¿”å›å€¼çš„ async å‡½æ•°
async fn fetch_data(id: u32) -> String {
    println!("ğŸ“€ æ­£åœ¨è·å–æ•°æ® ID: {}", id);
    
    // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚å»¶è¿Ÿ
    let delay = Duration::from_millis(500 + (id * 100) as u64);
    sleep(delay).await;
    
    format!("æ•°æ®åŒ… {} çš„å†…å®¹", id)
}

// å¯èƒ½å¤±è´¥çš„ async å‡½æ•°
async fn risky_operation(should_fail: bool) -> Result<String, String> {
    println!("âš ï¸  æ‰§è¡Œé£é™©æ“ä½œ...");
    
    sleep(Duration::from_millis(300)).await;
    
    if should_fail {
        Err("æ“ä½œå¤±è´¥ï¼".to_string())
    } else {
        Ok("æ“ä½œæˆåŠŸï¼".to_string())
    }
}

async fn demonstrate_async_functions() {
    println!("\n=== Async å‡½æ•°æ¼”ç¤º ===");
    
    // è°ƒç”¨å¸¦è¿”å›å€¼çš„ async å‡½æ•°
    let data = fetch_data(1).await;
    println!("è·å–åˆ°æ•°æ®: {}", data);
    
    // è°ƒç”¨å¤šä¸ª async å‡½æ•°ï¼ˆä¸²è¡Œï¼‰
    let start = Instant::now();
    let data1 = fetch_data(2).await;
    let data2 = fetch_data(3).await;
    let duration = start.elapsed();
    
    println!("ä¸²è¡Œè·å–æ•°æ®:");
    println!("  {}", data1);
    println!("  {}", data2);
    println!("  æ€»è€—æ—¶: {:?}", duration);
}

async fn demonstrate_concurrency() {
    println!("\n=== å¹¶å‘æ‰§è¡Œæ¼”ç¤º ===");
    
    // ä½¿ç”¨ tokio::join! å¹¶å‘æ‰§è¡Œ
    let start = Instant::now();
    let (data1, data2, data3) = tokio::join!(
        fetch_data(4),
        fetch_data(5),
        fetch_data(6)
    );
    let duration = start.elapsed();
    
    println!("å¹¶å‘è·å–æ•°æ®:");
    println!("  {}", data1);
    println!("  {}", data2);
    println!("  {}", data3);
    println!("  æ€»è€—æ—¶: {:?}", duration);
    
    // ä½¿ç”¨ tokio::select! ç­‰å¾…ç¬¬ä¸€ä¸ªå®Œæˆçš„ä»»åŠ¡
    println!("\nä½¿ç”¨ select! ç­‰å¾…ç¬¬ä¸€ä¸ªå®Œæˆçš„ä»»åŠ¡:");
    
    tokio::select! {
        result = fetch_data(7) => {
            println!("ç¬¬ä¸€ä¸ªå®Œæˆçš„ä»»åŠ¡: {}", result);
        }
        result = fetch_data(8) => {
            println!("ç¬¬ä¸€ä¸ªå®Œæˆçš„ä»»åŠ¡: {}", result);
        }
        _ = sleep(Duration::from_millis(200)) => {
            println!("è¶…æ—¶ï¼æ‰€æœ‰ä»»åŠ¡éƒ½å¤ªæ…¢äº†");
        }
    }
}

async fn demonstrate_error_handling() {
    println!("\n=== å¼‚æ­¥é”™è¯¯å¤„ç†æ¼”ç¤º ===");
    
    // å¤„ç†æˆåŠŸçš„æƒ…å†µ
    match risky_operation(false).await {
        Ok(result) => println!("âœ… {}", result),
        Err(error) => println!("âŒ {}", error),
    }
    
    // å¤„ç†å¤±è´¥çš„æƒ…å†µ
    match risky_operation(true).await {
        Ok(result) => println!("âœ… {}", result),
        Err(error) => println!("âŒ {}", error),
    }
    
    // ä½¿ç”¨ ? æ“ä½œç¬¦
    if let Err(e) = handle_multiple_operations().await {
        println!("å¤šä¸ªæ“ä½œå¤±è´¥: {}", e);
    }
}

async fn handle_multiple_operations() -> Result<(), String> {
    // æ¨¡æ‹Ÿå¤šä¸ªå¯èƒ½å¤±è´¥çš„æ“ä½œ
    let _result1 = risky_operation(false).await?;
    let _result2 = risky_operation(false).await?;
    
    println!("âœ… æ‰€æœ‰æ“ä½œéƒ½æˆåŠŸäº†ï¼");
    Ok(())
}</pre>

        <p><strong>æ­¥éª¤ 3: ä»»åŠ¡ç”Ÿæˆå’Œç®¡ç†</strong></p>
        <pre>use tokio::task;
use rand::Rng;

#[tokio::main]
async fn main() {
    println!("=== Tokio ä»»åŠ¡ç®¡ç†æ¼”ç¤º ===");
    
    // ç”Ÿæˆå•ä¸ªä»»åŠ¡
    demonstrate_single_task().await;
    
    // ç”Ÿæˆå¤šä¸ªä»»åŠ¡
    demonstrate_multiple_tasks().await;
    
    // ä»»åŠ¡å–æ¶ˆ
    demonstrate_task_cancellation().await;
    
    // ä»»åŠ¡ç»“æœæ”¶é›†
    demonstrate_task_results().await;
}

async fn worker_task(id: u32, work_duration: u64) -> String {
    println!("ğŸ‘· å·¥ä½œè€… {} å¼€å§‹å·¥ä½œ", id);
    
    let mut rng = rand::thread_rng();
    
    // æ¨¡æ‹Ÿå·¥ä½œè¿›åº¦
    for i in 1..=5 {
        let step_duration = Duration::from_millis(work_duration / 5);
        sleep(step_duration).await;
        
        if rng.gen_bool(0.1) { // 10% çš„å‡ ç‡æ‰“å°è¿›åº¦
            println!("ğŸ‘· å·¥ä½œè€… {} è¿›åº¦: {}/5", id, i);
        }
    }
    
    let result = format!("å·¥ä½œè€… {} å®Œæˆäº†ä»»åŠ¡ï¼ˆè€—æ—¶ {}msï¼‰", id, work_duration);
    println!("âœ… {}", result);
    result
}

async fn demonstrate_single_task() {
    println!("\n--- å•ä¸ªä»»åŠ¡æ¼”ç¤º ---");
    
    // ç”Ÿæˆä¸€ä¸ªä»»åŠ¡
    let handle = task::spawn(worker_task(1, 1000));
    
    // åœ¨ä»»åŠ¡è¿è¡Œæ—¶åšå…¶ä»–äº‹æƒ…
    for i in 1..=3 {
        println!("ğŸ’­ ä¸»çº¿ç¨‹æ­£åœ¨æ€è€ƒ... {}", i);
        sleep(Duration::from_millis(300)).await;
    }
    
    // ç­‰å¾…ä»»åŠ¡å®Œæˆ
    match handle.await {
        Ok(result) => println!("ä»»åŠ¡ç»“æœ: {}", result),
        Err(e) => println!("ä»»åŠ¡å¤±è´¥: {}", e),
    }
}

async fn demonstrate_multiple_tasks() {
    println!("\n--- å¤šä¸ªä»»åŠ¡æ¼”ç¤º ---");
    
    let start = Instant::now();
    
    // åˆ›å»ºå¤šä¸ªä»»åŠ¡
    let mut handles = Vec::new();
    
    for i in 1..=5 {
        let duration = (i * 200) as u64;
        let handle = task::spawn(worker_task(i, duration));
        handles.push(handle);
    }
    
    println!("ğŸš€ å¯åŠ¨äº† {} ä¸ªå¹¶å‘ä»»åŠ¡", handles.len());
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    let mut results = Vec::new();
    for handle in handles {
        match handle.await {
            Ok(result) => results.push(result),
            Err(e) => println!("ä»»åŠ¡å¤±è´¥: {}", e),
        }
    }
    
    let total_duration = start.elapsed();
    println!("\nâœ… æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼Œæ€»è€—æ—¶: {:?}", total_duration);
    println!("ç»“æœæ•°é‡: {}", results.len());
}

async fn long_running_task(id: u32) -> Result<String, String> {
    for i in 1..=10 {
        // æ£€æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
        tokio::task::yield_now().await; // è®©å‡º CPU æ—¶é—´ç‰‡
        
        println!("ğŸ”„ ä»»åŠ¡ {} æ­¥éª¤ {}/10", id, i);
        sleep(Duration::from_millis(500)).await;
    }
    
    Ok(format!("ä»»åŠ¡ {} æ­£å¸¸å®Œæˆ", id))
}

async fn demonstrate_task_cancellation() {
    println!("\n--- ä»»åŠ¡å–æ¶ˆæ¼”ç¤º ---");
    
    let handle = task::spawn(long_running_task(99));
    
    // è®©ä»»åŠ¡è¿è¡Œä¸€æ®µæ—¶é—´
    sleep(Duration::from_millis(2000)).await;
    
    println!("âš ï¸  å‡†å¤‡å–æ¶ˆä»»åŠ¡...");
    handle.abort();
    
    match handle.await {
        Ok(result) => println!("ä»»åŠ¡ç»“æœ: {:?}", result),
        Err(e) if e.is_cancelled() => println!("âœ… ä»»åŠ¡å·²è¢«æˆåŠŸå–æ¶ˆ"),
        Err(e) => println!("ä»»åŠ¡å‡ºé”™: {}", e),
    }
}

async fn demonstrate_task_results() {
    println!("\n--- ä»»åŠ¡ç»“æœæ”¶é›†æ¼”ç¤º ---");
    
    // ä½¿ç”¨ futures::future::join_all æ”¶é›†ç»“æœ
    let tasks: Vec<_> = (1..=3)
        .map(|i| task::spawn(worker_task(i + 10, (i * 300) as u64)))
        .collect();
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆå¹¶æ”¶é›†ç»“æœ
    let results = futures::future::join_all(tasks).await;
    
    println!("\næ”¶é›†çš„ä»»åŠ¡ç»“æœ:");
    for (i, result) in results.into_iter().enumerate() {
        match result {
            Ok(task_result) => println!("  ä»»åŠ¡ {}: {}", i + 1, task_result),
            Err(e) => println!("  ä»»åŠ¡ {} å¤±è´¥: {}", i + 1, e),
        }
    }
}</pre>

        <p><strong>æ­¥éª¤ 4: å®šæ—¶å™¨å’Œé—´éš”æ‰§è¡Œ</strong></p>
        <pre>use tokio::time::{interval, timeout};

#[tokio::main]
async fn main() {
    println!("=== Tokio å®šæ—¶å™¨å’Œè¶…æ—¶æ¼”ç¤º ===");
    
    // å®šæ—¶æ‰§è¡Œä»»åŠ¡
    demonstrate_intervals().await;
    
    // è¶…æ—¶å¤„ç†
    demonstrate_timeouts().await;
    
    // ç»„åˆå®šæ—¶å™¨å’Œä»»åŠ¡
    demonstrate_timed_tasks().await;
}

async fn demonstrate_intervals() {
    println!("\n--- é—´éš”æ‰§è¡Œæ¼”ç¤º ---");
    
    let mut interval = interval(Duration::from_millis(500));
    let mut counter = 0;
    
    println!("ğŸ•°ï¸  æ¯ 500ms æ‰§è¡Œä¸€æ¬¡ï¼Œå…±æ‰§è¡Œ 5 æ¬¡:");
    
    for _ in 0..5 {
        interval.tick().await;
        counter += 1;
        println!("  â€¢ Tick {}: {}", counter, Utc::now().format("%H:%M:%S%.3f"));
    }
}

async fn slow_operation(duration_ms: u64) -> Result<String, String> {
    println!("ğŸŒ æ…¢æ“ä½œå¼€å§‹ï¼ˆéœ€è¦ {}msï¼‰", duration_ms);
    sleep(Duration::from_millis(duration_ms)).await;
    Ok(format!("æ…¢æ“ä½œå®Œæˆï¼ˆè€—æ—¶ {}msï¼‰", duration_ms))
}

async fn demonstrate_timeouts() {
    println!("\n--- è¶…æ—¶å¤„ç†æ¼”ç¤º ---");
    
    // æˆåŠŸçš„æƒ…å†µï¼ˆåœ¨è¶…æ—¶æ—¶é—´å†…å®Œæˆï¼‰
    match timeout(Duration::from_millis(1000), slow_operation(500)).await {
        Ok(Ok(result)) => println!("âœ… æ“ä½œæˆåŠŸ: {}", result),
        Ok(Err(e)) => println!("âŒ æ“ä½œå¤±è´¥: {}", e),
        Err(_) => println!("â° æ“ä½œè¶…æ—¶"),
    }
    
    // è¶…æ—¶çš„æƒ…å†µ
    match timeout(Duration::from_millis(800), slow_operation(1500)).await {
        Ok(Ok(result)) => println!("âœ… æ“ä½œæˆåŠŸ: {}", result),
        Ok(Err(e)) => println!("âŒ æ“ä½œå¤±è´¥: {}", e),
        Err(_) => println!("â° æ“ä½œè¶…æ—¶ï¼ˆ800ms è¶…æ—¶é™åˆ¶ï¼‰"),
    }
}

async fn heartbeat_task(id: u32, interval_ms: u64, max_beats: u32) {
    let mut interval = interval(Duration::from_millis(interval_ms));
    let mut count = 0;
    
    println!("ğŸ’“ å¿ƒè·³ä»»åŠ¡ {} å¼€å§‹ï¼ˆé—´éš” {}msï¼‰", id, interval_ms);
    
    while count < max_beats {
        interval.tick().await;
        count += 1;
        println!("  ğŸ’“ ä»»åŠ¡ {} å¿ƒè·³ #{}", id, count);
    }
    
    println!("â¤ï¸  å¿ƒè·³ä»»åŠ¡ {} å®Œæˆï¼ˆå…± {} æ¬¡å¿ƒè·³ï¼‰", id, count);
}

async fn demonstrate_timed_tasks() {
    println!("\n--- å®šæ—¶ä»»åŠ¡ç»„åˆæ¼”ç¤º ---");
    
    // å¯åŠ¨å¤šä¸ªä¸åŒé—´éš”çš„å¿ƒè·³ä»»åŠ¡
    let heartbeat1 = task::spawn(heartbeat_task(1, 300, 8));
    let heartbeat2 = task::spawn(heartbeat_task(2, 500, 5));
    let heartbeat3 = task::spawn(heartbeat_task(3, 700, 4));
    
    // ç­‰å¾…æ‰€æœ‰å¿ƒè·³ä»»åŠ¡å®Œæˆ
    let _ = tokio::join!(heartbeat1, heartbeat2, heartbeat3);
    
    println!("âœ… æ‰€æœ‰å¿ƒè·³ä»»åŠ¡å®Œæˆï¼");
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>åˆ›å»ºä¸€ä¸ªå¼‚æ­¥æ–‡ä»¶ä¸‹è½½å™¨ï¼Œæ¨¡æ‹Ÿä¸‹è½½è¿›åº¦</li>
            <li>å®ç°ä¸€ä¸ªå®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨ï¼Œæ”¯æŒä¸åŒé—´éš”</li>
            <li>æ„å»ºä¸€ä¸ªå¹¶å‘ç½‘ç»œè¯·æ±‚å¤„ç†å™¨</li>
            <li>è®¾è®¡ä¸€ä¸ªå¼‚æ­¥æ¶ˆæ¯é˜Ÿåˆ—ç³»ç»Ÿ</li>
        </ul>

        <p><strong>ç»¼åˆç»ƒä¹ ï¼šå¼‚æ­¥ä»»åŠ¡ç®¡ç†å™¨</strong></p>
        <pre>use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct TaskStatus {
    id: u32,
    name: String,
    status: String,
    progress: u32,
    start_time: DateTime<Utc>,
}

struct TaskManager {
    tasks: Arc<Mutex<HashMap<u32, TaskStatus>>>,
    next_id: Arc<Mutex<u32>>,
}

impl TaskManager {
    fn new() -> Self {
        TaskManager {
            tasks: Arc::new(Mutex::new(HashMap::new())),
            next_id: Arc::new(Mutex::new(1)),
        }
    }
    
    async fn spawn_task<F, Fut>(&self, name: String, task_fn: F) -> u32 
    where
        F: FnOnce(u32) -> Fut + Send + 'static,
        Fut: std::future::Future<Output = ()> + Send,
    {
        let id = {
            let mut next_id = self.next_id.lock().await;
            let current_id = *next_id;
            *next_id += 1;
            current_id
        };
        
        let task_status = TaskStatus {
            id,
            name: name.clone(),
            status: "Running".to_string(),
            progress: 0,
            start_time: Utc::now(),
        };
        
        {
            let mut tasks = self.tasks.lock().await;
            tasks.insert(id, task_status);
        }
        
        let tasks_clone = Arc::clone(&self.tasks);
        
        tokio::spawn(async move {
            task_fn(id).await;
            
            // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå®Œæˆ
            let mut tasks = tasks_clone.lock().await;
            if let Some(task) = tasks.get_mut(&id) {
                task.status = "Completed".to_string();
                task.progress = 100;
            }
        });
        
        id
    }
    
    async fn get_task_status(&self, id: u32) -> Option<TaskStatus> {
        let tasks = self.tasks.lock().await;
        tasks.get(&id).cloned()
    }
    
    async fn list_all_tasks(&self) -> Vec<TaskStatus> {
        let tasks = self.tasks.lock().await;
        tasks.values().cloned().collect()
    }
    
    async fn update_progress(&self, id: u32, progress: u32) {
        let mut tasks = self.tasks.lock().await;
        if let Some(task) = tasks.get_mut(&id) {
            task.progress = progress;
        }
    }
}

#[tokio::main]
async fn main() {
    println!("=== Day 11 ç»¼åˆç»ƒä¹ ï¼šå¼‚æ­¥ä»»åŠ¡ç®¡ç†å™¨ ===");
    
    let manager = TaskManager::new();
    
    // å¯åŠ¨å¤šä¸ªä»»åŠ¡
    let task1_id = manager.spawn_task(
        "æ•°æ®å¤„ç†".to_string(),
        |id| async move {
            simulate_data_processing(id).await;
        }
    ).await;
    
    let task2_id = manager.spawn_task(
        "æ–‡ä»¶ä¸‹è½½".to_string(),
        |id| async move {
            simulate_file_download(id).await;
        }
    ).await;
    
    let task3_id = manager.spawn_task(
        "é‚®ä»¶å‘é€".to_string(),
        |id| async move {
            simulate_email_sending(id).await;
        }
    ).await;
    
    println!("å¯åŠ¨äº† 3 ä¸ªä»»åŠ¡: {}, {}, {}", task1_id, task2_id, task3_id);
    
    // å®šæœŸæ£€æŸ¥ä»»åŠ¡çŠ¶æ€
    let status_checker = task::spawn(async move {
        let mut interval = interval(Duration::from_millis(1000));
        
        for _ in 0..8 {
            interval.tick().await;
            
            let tasks = manager.list_all_tasks().await;
            println!("\nâœ¨ ä»»åŠ¡çŠ¶æ€æ›´æ–°:");
            
            for task in tasks {
                let duration = Utc::now().signed_duration_since(task.start_time);
                println!("  â€¢ ä»»åŠ¡ {}: {} - {}% - è¿è¡Œæ—¶é—´: {}s", 
                    task.id, 
                    task.name, 
                    task.progress,
                    duration.num_seconds()
                );
            }
        }
    });
    
    status_checker.await.unwrap();
    
    println!("\nâœ… ä»»åŠ¡ç®¡ç†å™¨æ¼”ç¤ºå®Œæˆï¼");
}

async fn simulate_data_processing(task_id: u32) {
    for i in 1..=10 {
        sleep(Duration::from_millis(400)).await;
        println!("ğŸ“€ ä»»åŠ¡ {} æ•°æ®å¤„ç†è¿›åº¦: {}%", task_id, i * 10);
    }
}

async fn simulate_file_download(task_id: u32) {
    for i in 1..=5 {
        sleep(Duration::from_millis(800)).await;
        println!("ğŸ“ ä»»åŠ¡ {} æ–‡ä»¶ä¸‹è½½è¿›åº¦: {}%", task_id, i * 20);
    }
}

async fn simulate_email_sending(task_id: u32) {
    for i in 1..=6 {
        sleep(Duration::from_millis(600)).await;
        println!("ğŸ“§ ä»»åŠ¡ {} é‚®ä»¶å‘é€è¿›åº¦: {}%", task_id, (i * 100) / 6);
    }
}</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day11_async_basics/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-12</strong></p>
        <h2>Day 12 - å¼‚æ­¥ä»»åŠ¡ä¸å…±äº«çŠ¶æ€</h2>
        <p>ä½ å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ `tokio::spawn` å¯åŠ¨å¼‚æ­¥ä»»åŠ¡ï¼Œå¦‚ä½•ä½¿ç”¨ `Arc<Mutex<>>`æ¥å…±äº«çŠ¶æ€ï¼ˆå¦‚è¿æ¥åˆ—è¡¨æˆ–åœ¨çº¿äººæ•°ï¼‰ï¼Œå¹¶é¿å…ç«æ€æ¡ä»¶ã€‚</p>
        <p>ğŸ”— <a href="https://tokio.rs/tokio/tutorial/spawn" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®å’Œé…ç½®ä¾èµ–</strong></p>
        <pre>cargo new day12_shared_state
cd day12_shared_state</pre>

        <p><strong>Cargo.toml</strong></p>
        <pre>[package]
name = "day12_shared_state"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
rand = "0.8"
chrono = { version = "0.4", features = ["serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"</pre>

        <p><strong>æ­¥éª¤ 2: Arc å’Œ Mutex åŸºç¡€ä½¿ç”¨</strong></p>
        <pre>use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use std::collections::HashMap;
use rand::Rng;

#[tokio::main]
async fn main() {
    println!("=== å…±äº«çŠ¶æ€åŸºç¡€æ¼”ç¤º ===");
    
    // æ¼”ç¤ºåŸºæœ¬å…±äº«è®¡æ•°å™¨
    demonstrate_shared_counter().await;
    
    // æ¼”ç¤ºå¤šä»»åŠ¡è®¿é—®å…±äº«æ•°æ®
    demonstrate_shared_data().await;
    
    // æ¼”ç¤ºå¤æ‚å…±äº«çŠ¶æ€
    demonstrate_user_connections().await;
}

// ç®€å•çš„å…±äº«è®¡æ•°å™¨
async fn demonstrate_shared_counter() {
    println!("\n--- å…±äº«è®¡æ•°å™¨æ¼”ç¤º ---");
    
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    // åˆ›å»º 5 ä¸ªä»»åŠ¡ï¼Œæ¯ä¸ªä»»åŠ¡é€’å¢è®¡æ•°å™¨ 10 æ¬¡
    for i in 1..=5 {
        let counter_clone = Arc::clone(&counter);
        
        let handle = tokio::spawn(async move {
            for j in 1..=10 {
                // è·å–é”å¹¶æ›´æ–°è®¡æ•°å™¨
                {
                    let mut count = counter_clone.lock().unwrap();
                    *count += 1;
                    println!("ğŸ”¢ ä»»åŠ¡ {} ç¬¬ {} æ¬¡é€’å¢ï¼Œå½“å‰å€¼: {}", i, j, *count);
                } // é”åœ¨è¿™é‡Œè¢«é‡Šæ”¾
                
                // æ¨¡æ‹Ÿä¸€äº›å·¥ä½œ
                sleep(Duration::from_millis(100)).await;
            }
        });
        
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    for handle in handles {
        handle.await.unwrap();
    }
    
    let final_count = *counter.lock().unwrap();
    println!("âœ… æœ€ç»ˆè®¡æ•°å™¨å€¼: {}", final_count);
}

// å…±äº«å¤æ‚æ•°æ®ç»“æ„
async fn demonstrate_shared_data() {
    println!("\n--- å…±äº«æ•°æ®ç»“æ„æ¼”ç¤º ---");
    
    let shared_map = Arc::new(Mutex::new(HashMap::<String, i32>::new()));
    let mut handles = vec![];
    
    // åˆ›å»ºå¤šä¸ªä»»åŠ¡æ¥æ“ä½œå…±äº« HashMap
    for i in 1..=3 {
        let map_clone = Arc::clone(&shared_map);
        
        let handle = tokio::spawn(async move {
            let mut rng = rand::thread_rng();
            
            for j in 1..=5 {
                let key = format!("task_{}_item_{}", i, j);
                let value = rng.gen_range(1..100);
                
                // æ’å…¥æ•°æ®
                {
                    let mut map = map_clone.lock().unwrap();
                    map.insert(key.clone(), value);
                    println!("ğŸ“ ä»»åŠ¡ {} æ’å…¥: {} = {}", i, key, value);
                }
                
                sleep(Duration::from_millis(200)).await;
            }
        });
        
        handles.push(handle);
    }
    
    // è¯»å–ä»»åŠ¡
    let reader_handle = {
        let map_clone = Arc::clone(&shared_map);
        tokio::spawn(async move {
            for _ in 1..=8 {
                sleep(Duration::from_millis(500)).await;
                
                let map = map_clone.lock().unwrap();
                println!("ğŸ” å½“å‰ map å¤§å°: {} ä¸ªå…ƒç´ ", map.len());
                
                if !map.is_empty() {
                    let sample_key = map.keys().next().unwrap();
                    let sample_value = map.get(sample_key).unwrap();
                    println!("  ç¤ºä¾‹æ•°æ®: {} = {}", sample_key, sample_value);
                }
            }
        })
    };
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    for handle in handles {
        handle.await.unwrap();
    }
    reader_handle.await.unwrap();
    
    let final_map = shared_map.lock().unwrap();
    println!("âœ… æœ€ç»ˆ map åŒ…å« {} ä¸ªå…ƒç´ ", final_map.len());
}

// ç”¨æˆ·è¿æ¥ç®¡ç†ç¤ºä¾‹
#[derive(Debug, Clone)]
struct UserConnection {
    id: u32,
    username: String,
    connected_at: chrono::DateTime<chrono::Utc>,
    last_activity: chrono::DateTime<chrono::Utc>,
}

impl UserConnection {
    fn new(id: u32, username: String) -> Self {
        let now = chrono::Utc::now();
        UserConnection {
            id,
            username,
            connected_at: now,
            last_activity: now,
        }
    }
    
    fn update_activity(&mut self) {
        self.last_activity = chrono::Utc::now();
    }
}

async fn demonstrate_user_connections() {
    println!("\n--- ç”¨æˆ·è¿æ¥ç®¡ç†æ¼”ç¤º ---");
    
    let connections = Arc::new(Mutex::new(HashMap::<u32, UserConnection>::new()));
    let mut handles = vec![];
    
    // æ¨¡æ‹Ÿç”¨æˆ·è¿æ¥
    for i in 1..=5 {
        let connections_clone = Arc::clone(&connections);
        
        let handle = tokio::spawn(async move {
            let username = format!("user_{}", i);
            let user_conn = UserConnection::new(i, username.clone());
            
            // ç”¨æˆ·è¿æ¥
            {
                let mut conns = connections_clone.lock().unwrap();
                conns.insert(i, user_conn);
                println!("ğŸ‘¤ ç”¨æˆ· {} å·²è¿æ¥", username);
            }
            
            // æ¨¡æ‹Ÿç”¨æˆ·æ´»åŠ¨
            for j in 1..=rand::thread_rng().gen_range(3..8) {
                sleep(Duration::from_millis(rand::thread_rng().gen_range(300..800))).await;
                
                {
                    let mut conns = connections_clone.lock().unwrap();
                    if let Some(conn) = conns.get_mut(&i) {
                        conn.update_activity();
                        println!("ğŸ“± ç”¨æˆ· {} æ´»åŠ¨ #{}", username, j);
                    }
                }
            }
            
            // ç”¨æˆ·æ–­å¼€è¿æ¥
            {
                let mut conns = connections_clone.lock().unwrap();
                conns.remove(&i);
                println!("ğŸšª ç”¨æˆ· {} å·²æ–­å¼€è¿æ¥", username);
            }
        });
        
        handles.push(handle);
    }
    
    // è¿æ¥çŠ¶æ€ç›‘æ§ä»»åŠ¡
    let monitor_handle = {
        let connections_clone = Arc::clone(&connections);
        tokio::spawn(async move {
            for i in 1..=15 {
                sleep(Duration::from_millis(400)).await;
                
                let conns = connections_clone.lock().unwrap();
                let active_count = conns.len();
                
                if active_count > 0 {
                    println!("ğŸ“Š ç¬¬ {} æ¬¡æ£€æŸ¥: {} ä¸ªæ´»è·ƒè¿æ¥", i, active_count);
                    
                    for conn in conns.values() {
                        let duration = chrono::Utc::now().signed_duration_since(conn.last_activity);
                        println!("  â€¢ {}: æœ€åæ´»åŠ¨ {}s å‰", 
                               conn.username, 
                               duration.num_seconds());
                    }
                } else {
                    println!("ğŸ“Š ç¬¬ {} æ¬¡æ£€æŸ¥: æ²¡æœ‰æ´»è·ƒè¿æ¥", i);
                }
            }
        })
    };
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    for handle in handles {
        handle.await.unwrap();
    }
    monitor_handle.await.unwrap();
    
    println!("âœ… ç”¨æˆ·è¿æ¥ç®¡ç†æ¼”ç¤ºå®Œæˆ");
}</pre>

        <p><strong>æ­¥éª¤ 3: Tokio åŒæ­¥åŸè¯­</strong></p>
        <pre>use tokio::sync::{RwLock, Semaphore, broadcast, mpsc};
use std::sync::Arc;

#[tokio::main]
async fn main() {
    println!("=== Tokio åŒæ­¥åŸè¯­æ¼”ç¤º ===");
    
    // RwLock æ¼”ç¤º
    demonstrate_rwlock().await;
    
    // Semaphore æ¼”ç¤º
    demonstrate_semaphore().await;
    
    // Broadcast channel æ¼”ç¤º
    demonstrate_broadcast().await;
    
    // MPSC channel æ¼”ç¤º
    demonstrate_mpsc().await;
}

async fn demonstrate_rwlock() {
    println!("\n--- RwLock æ¼”ç¤º ---");
    
    let data = Arc::new(RwLock::new(HashMap::<String, i32>::new()));
    let mut handles = vec![];
    
    // å†™å…¥ä»»åŠ¡ï¼ˆå°‘æ•°ï¼‰
    for i in 1..=2 {
        let data_clone = Arc::clone(&data);
        
        let handle = tokio::spawn(async move {
            for j in 1..=3 {
                {
                    let mut write_guard = data_clone.write().await;
                    let key = format!("writer_{}_item_{}", i, j);
                    write_guard.insert(key.clone(), j * 10);
                    println!("âœï¸  å†™å…¥è€… {} æ·»åŠ : {}", i, key);
                }
                sleep(Duration::from_millis(300)).await;
            }
        });
        
        handles.push(handle);
    }
    
    // è¯»å–ä»»åŠ¡ï¼ˆå¤šæ•°ï¼‰
    for i in 1..=5 {
        let data_clone = Arc::clone(&data);
        
        let handle = tokio::spawn(async move {
            for _ in 1..=4 {
                {
                    let read_guard = data_clone.read().await;
                    let count = read_guard.len();
                    println!("ğŸ” è¯»å–è€… {} çœ‹åˆ° {} ä¸ªå…ƒç´ ", i, count);
                    
                    if !read_guard.is_empty() {
                        let first_key = read_guard.keys().next().unwrap();
                        println!("    ç¤ºä¾‹æ•°æ®: {}", first_key);
                    }
                }
                sleep(Duration::from_millis(200)).await;
            }
        });
        
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    let final_data = data.read().await;
    println!("âœ… RwLock æ¼”ç¤ºå®Œæˆï¼Œæœ€ç»ˆæ•°æ®æ•°é‡: {}", final_data.len());
}

async fn demonstrate_semaphore() {
    println!("\n--- Semaphore æ¼”ç¤º ---");
    
    // åˆ›å»ºä¸€ä¸ªå…è®¸æœ€å¤š 3 ä¸ªå¹¶å‘è®¿é—®çš„ä¿¡å·é‡
    let semaphore = Arc::new(Semaphore::new(3));
    let mut handles = vec![];
    
    // åˆ›å»º 8 ä¸ªä»»åŠ¡ï¼Œä½†åªå…è®¸ 3 ä¸ªåŒæ—¶è®¿é—®èµ„æº
    for i in 1..=8 {
        let semaphore_clone = Arc::clone(&semaphore);
        
        let handle = tokio::spawn(async move {
            println!("ğŸ”„ ä»»åŠ¡ {} ç­‰å¾…è·å–è®¸å¯...", i);
            
            let _permit = semaphore_clone.acquire().await.unwrap();
            println!("âœ… ä»»åŠ¡ {} è·å¾—è®¸å¯ï¼Œå¼€å§‹æ‰§è¡Œ", i);
            
            // æ¨¡æ‹Ÿèµ„æºå¯†é›†å‹æ“ä½œ
            sleep(Duration::from_millis(1000)).await;
            
            println!("ğŸ ä»»åŠ¡ {} å®Œæˆï¼Œé‡Šæ”¾è®¸å¯", i);
            // _permit åœ¨è¿™é‡Œè¢«è‡ªåŠ¨é‡Šæ”¾
        });
        
        handles.push(handle);
        
        // ç¨å¾®å»¶è¿Ÿå¯åŠ¨ï¼Œä»¥ä¾¿è§‚å¯Ÿæ•ˆæœ
        sleep(Duration::from_millis(100)).await;
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("âœ… Semaphore æ¼”ç¤ºå®Œæˆ");
}

async fn demonstrate_broadcast() {
    println!("\n--- Broadcast Channel æ¼”ç¤º ---");
    
    let (tx, _rx) = broadcast::channel::<String>(10);
    let mut handles = vec![];
    
    // åˆ›å»ºå¤šä¸ªæ¥æ”¶è€…
    for i in 1..=4 {
        let mut rx = tx.subscribe();
        
        let handle = tokio::spawn(async move {
            println!("ğŸ“¡ æ¥æ”¶è€… {} å¼€å§‹ç›‘å¬", i);
            
            while let Ok(message) = rx.recv().await {
                println!("ğŸ“¨ æ¥æ”¶è€… {} æ”¶åˆ°: {}", i, message);
                
                if message == "exit" {
                    break;
                }
            }
            
            println!("ğŸšª æ¥æ”¶è€… {} é€€å‡º", i);
        });
        
        handles.push(handle);
    }
    
    // å‘é€è€…ä»»åŠ¡
    let sender_handle = tokio::spawn(async move {
        sleep(Duration::from_millis(500)).await;
        
        let messages = vec![
            "æ¬¢è¿æ¥åˆ°å¹¿æ’­é¢‘é“ï¼",
            "è¿™æ˜¯ç¬¬ä¸€æ¡æ¶ˆæ¯",
            "è¿™æ˜¯ç¬¬äºŒæ¡æ¶ˆæ¯",
            "è¿™æ˜¯æœ€åä¸€æ¡æ¶ˆæ¯",
            "exit"
        ];
        
        for (i, message) in messages.iter().enumerate() {
            println!("ğŸ“¢ å‘é€æ¶ˆæ¯ {}: {}", i + 1, message);
            
            if let Err(e) = tx.send(message.to_string()) {
                println!("å‘é€å¤±è´¥: {}", e);
            }
            
            sleep(Duration::from_millis(800)).await;
        }
    });
    
    sender_handle.await.unwrap();
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("âœ… Broadcast æ¼”ç¤ºå®Œæˆ");
}

async fn demonstrate_mpsc() {
    println!("\n--- MPSC Channel æ¼”ç¤º ---");
    
    let (tx, mut rx) = mpsc::channel::<String>(32);
    
    // å¤šä¸ªå‘é€è€…
    let mut sender_handles = vec![];
    
    for i in 1..=4 {
        let tx_clone = tx.clone();
        
        let handle = tokio::spawn(async move {
            for j in 1..=3 {
                let message = format!("å‘é€è€… {} çš„æ¶ˆæ¯ {}", i, j);
                
                if let Err(e) = tx_clone.send(message.clone()).await {
                    println!("å‘é€å¤±è´¥: {}", e);
                } else {
                    println!("ğŸ“¤ å·²å‘é€: {}", message);
                }
                
                sleep(Duration::from_millis(300)).await;
            }
            
            println!("ğŸ å‘é€è€… {} å®Œæˆ", i);
        });
        
        sender_handles.push(handle);
    }
    
    // å•ä¸ªæ¥æ”¶è€…
    let receiver_handle = tokio::spawn(async move {
        let mut count = 0;
        
        while let Some(message) = rx.recv().await {
            count += 1;
            println!("ğŸ“¥ æ¥æ”¶åˆ°ç¬¬ {} æ¡æ¶ˆæ¯: {}", count, message);
        }
        
        println!("ğŸ æ¥æ”¶è€…å®Œæˆï¼Œå…±å¤„ç† {} æ¡æ¶ˆæ¯", count);
    });
    
    // ç­‰å¾…æ‰€æœ‰å‘é€è€…å®Œæˆ
    for handle in sender_handles {
        handle.await.unwrap();
    }
    
    // å…³é—­å‘é€ç«¯
    drop(tx);
    
    // ç­‰å¾…æ¥æ”¶è€…å®Œæˆ
    receiver_handle.await.unwrap();
    
    println!("âœ… MPSC æ¼”ç¤ºå®Œæˆ");
}</pre>

        <p><strong>æ­¥éª¤ 4: æ­»é”é˜²èŒƒå’Œæ€§èƒ½ä¼˜åŒ–</strong></p>
        <pre>use tokio::sync::{Mutex as TokioMutex, RwLock};
use std::sync::Arc;
use std::time::Instant;

#[tokio::main]
async fn main() {
    println!("=== æ­»é”é˜²èŒƒå’Œæ€§èƒ½ä¼˜åŒ– ===");
    
    // æ­»é”é˜²èŒƒæ¼”ç¤º
    demonstrate_deadlock_prevention().await;
    
    // æ€§èƒ½æ¯”è¾ƒï¼šstd::sync::Mutex vs tokio::sync::Mutex
    compare_mutex_performance().await;
    
    // RwLock æ€§èƒ½æ¼”ç¤º
    demonstrate_rwlock_performance().await;
}

async fn demonstrate_deadlock_prevention() {
    println!("\n--- æ­»é”é˜²èŒƒæ¼”ç¤º ---");
    
    let resource_a = Arc::new(TokioMutex::new(0));
    let resource_b = Arc::new(TokioMutex::new(0));
    
    let mut handles = vec![];
    
    // ä»»åŠ¡ 1ï¼šå…ˆé” A å†é” B
    {
        let resource_a = Arc::clone(&resource_a);
        let resource_b = Arc::clone(&resource_b);
        
        let handle = tokio::spawn(async move {
            for i in 1..=3 {
                println!("ğŸ”’ ä»»åŠ¡ 1 ç¬¬ {} æ¬¡å°è¯•è·å–èµ„æº A", i);
                let _guard_a = resource_a.lock().await;
                println!("âœ… ä»»åŠ¡ 1 è·å¾—èµ„æº A");
                
                sleep(Duration::from_millis(100)).await;
                
                println!("ğŸ”’ ä»»åŠ¡ 1 å°è¯•è·å–èµ„æº B");
                let _guard_b = resource_b.lock().await;
                println!("âœ… ä»»åŠ¡ 1 è·å¾—èµ„æº A å’Œ B");
                
                sleep(Duration::from_millis(200)).await;
                
                println!("ğŸ”“ ä»»åŠ¡ 1 é‡Šæ”¾æ‰€æœ‰èµ„æº");
            }
        });
        
        handles.push(handle);
    }
    
    // ä»»åŠ¡ 2ï¼šä¹Ÿæ˜¯å…ˆé” A å†é” Bï¼ˆé˜²æ­¢æ­»é”ï¼‰
    {
        let resource_a = Arc::clone(&resource_a);
        let resource_b = Arc::clone(&resource_b);
        
        let handle = tokio::spawn(async move {
            for i in 1..=3 {
                println!("ğŸ”’ ä»»åŠ¡ 2 ç¬¬ {} æ¬¡å°è¯•è·å–èµ„æº A", i);
                let _guard_a = resource_a.lock().await;
                println!("âœ… ä»»åŠ¡ 2 è·å¾—èµ„æº A");
                
                sleep(Duration::from_millis(150)).await;
                
                println!("ğŸ”’ ä»»åŠ¡ 2 å°è¯•è·å–èµ„æº B");
                let _guard_b = resource_b.lock().await;
                println!("âœ… ä»»åŠ¡ 2 è·å¾—èµ„æº A å’Œ B");
                
                sleep(Duration::from_millis(200)).await;
                
                println!("ğŸ”“ ä»»åŠ¡ 2 é‡Šæ”¾æ‰€æœ‰èµ„æº");
            }
        });
        
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("âœ… æ­»é”é˜²èŒƒæ¼”ç¤ºå®Œæˆï¼ˆæ²¡æœ‰å‘ç”Ÿæ­»é”ï¼‰");
}

async fn compare_mutex_performance() {
    println!("\n--- Mutex æ€§èƒ½æ¯”è¾ƒ ---");
    
    const ITERATIONS: usize = 1000;
    const TASKS: usize = 10;
    
    // æµ‹è¯• tokio::sync::Mutex
    let tokio_mutex = Arc::new(TokioMutex::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..TASKS {
        let mutex = Arc::clone(&tokio_mutex);
        let handle = tokio::spawn(async move {
            for _ in 0..ITERATIONS {
                let mut guard = mutex.lock().await;
                *guard += 1;
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    let tokio_duration = start.elapsed();
    let tokio_result = *tokio_mutex.lock().await;
    
    println!("ğŸ Tokio Mutex ç»“æœ: {}, è€—æ—¶: {:?}", tokio_result, tokio_duration);
    
    // æµ‹è¯• std::sync::Mutex åœ¨ spawn_blocking ä¸­
    let std_mutex = Arc::new(std::sync::Mutex::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..TASKS {
        let mutex = Arc::clone(&std_mutex);
        let handle = tokio::task::spawn_blocking(move || {
            for _ in 0..ITERATIONS {
                let mut guard = mutex.lock().unwrap();
                *guard += 1;
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    let std_duration = start.elapsed();
    let std_result = *std_mutex.lock().unwrap();
    
    println!("ğŸ Std Mutex ç»“æœ: {}, è€—æ—¶: {:?}", std_result, std_duration);
    
    println!("â„¹ï¸  æ€§èƒ½æ¯”è¾ƒ: Tokio Mutex é€‚åˆ async ç¯å¢ƒï¼ŒStd Mutex é€‚åˆ CPU å¯†é›†å‹ä»»åŠ¡");
}

async fn demonstrate_rwlock_performance() {
    println!("\n--- RwLock æ€§èƒ½æ¼”ç¤º ---");
    
    let data = Arc::new(RwLock::new(HashMap::<String, i32>::new()));
    
    // åˆå§‹åŒ–æ•°æ®
    {
        let mut write_guard = data.write().await;
        for i in 0..100 {
            write_guard.insert(format!("key_{}", i), i);
        }
    }
    
    let start = Instant::now();
    let mut handles = vec![];
    
    // å¤§é‡è¯»å–ä»»åŠ¡
    for i in 0..50 {
        let data = Arc::clone(&data);
        let handle = tokio::spawn(async move {
            for j in 0..10 {
                let read_guard = data.read().await;
                let key = format!("key_{}", (i + j) % 100);
                let _value = read_guard.get(&key);
            }
        });
        handles.push(handle);
    }
    
    // å°‘é‡å†™å…¥ä»»åŠ¡
    for i in 0..5 {
        let data = Arc::clone(&data);
        let handle = tokio::spawn(async move {
            let mut write_guard = data.write().await;
            let key = format!("new_key_{}", i);
            write_guard.insert(key, i * 1000);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    let duration = start.elapsed();
    let final_size = data.read().await.len();
    
    println!("âœ… RwLock æ€§èƒ½æµ‹è¯•å®Œæˆ");
    println!("  æœ€ç»ˆæ•°æ®å¤§å°: {} ä¸ªå…ƒç´ ", final_size);
    println!("  æ€»è€—æ—¶: {:?}", duration);
    println!("â„¹ï¸  RwLock å…è®¸å¤šä¸ªå¹¶å‘è¯»å–ï¼Œä½†å†™å…¥æ˜¯æ’ä»–çš„");
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>å®ç°ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨æœåŠ¡</li>
            <li>æ„å»ºä¸€ä¸ªå¤šç”¨æˆ·èŠå¤©å®¤åŸå‹</li>
            <li>åˆ›å»ºä¸€ä¸ªå¹¶å‘ä»»åŠ¡è°ƒåº¦å™¨</li>
            <li>è®¾è®¡ä¸€ä¸ªåˆ†å¸ƒå¼ç¼“å­˜ç³»ç»Ÿ</li>
        </ul>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day12_shared_state/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-13</strong></p>
        <h2>Day 13 - åˆ›å»º axum é¡¹ç›®å¹¶è¿è¡Œ HTTP è·¯ç”±</h2>
        <p>ä½ å°†åˆå§‹åŒ– `axum` é¡¹ç›®ï¼Œæ·»åŠ  `/ping` è·¯ç”±ï¼Œè¿”å› JSON å“åº”ï¼Œå¹¶é…ç½® `Router`ï¼Œç†è§£æå–å™¨çš„å·¥ä½œæœºåˆ¶ã€‚</p>
        <p>ğŸ”— <a href="https://docs.rs/axum/latest/axum/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®å’Œé…ç½®ä¾èµ–</strong></p>
        <pre>cargo new day13_axum_server
cd day13_axum_server</pre>

        <p><strong>Cargo.toml</strong></p>
        <pre>[package]
name = "day13_axum_server"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.7"
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
tracing = "0.1"
tracing-subscriber = "0.3"
thiserror = "1.0"
anyhow = "1.0"</pre>

        <p><strong>æ­¥éª¤ 2: åŸºæœ¬ Axum æœåŠ¡å™¨</strong></p>
        <pre>use axum::{
    extract::{Path, Query},
    http::StatusCode,
    response::{Html, Json},
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tower_http::cors::CorsLayer;
use tracing::{info, warn};

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::init();
    
    info!("ğŸš€ å¯åŠ¨ Axum æœåŠ¡å™¨...");
    
    // æ„å»ºè·¯ç”±
    let app = create_router();
    
    // å¯åŠ¨æœåŠ¡å™¨
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    
    info!("ğŸ§ æœåŠ¡å™¨å·²å¯åŠ¨ï¼Œç›‘å¬åœ°å€: http://0.0.0.0:3000");
    
    axum::serve(listener, app).await.unwrap();
}

fn create_router() -> Router {
    Router::new()
        // åŸºæœ¬è·¯ç”±
        .route("/", get(root_handler))
        .route("/ping", get(ping_handler))
        .route("/health", get(health_check))
        
        // è·¯å¾„å‚æ•°
        .route("/user/:id", get(get_user))
        .route("/user/:id/profile", get(get_user_profile))
        
        // æŸ¥è¯¢å‚æ•°
        .route("/search", get(search_handler))
        .route("/items", get(list_items))
        
        // POST è·¯ç”±
        .route("/users", post(create_user))
        .route("/echo", post(echo_handler))
        
        // æ·»åŠ  CORS æ”¯æŒ
        .layer(CorsLayer::permissive())
        
        // å…¨å±€é”™è¯¯å¤„ç†
        .fallback(not_found_handler)
}

// å“åº”ç»“æ„ä½“
#[derive(Serialize)]
struct ApiResponse<T> {
    success: bool,
    message: String,
    data: Option<T>,
    timestamp: String,
}

impl<T> ApiResponse<T> {
    fn success(data: T, message: &str) -> Self {
        Self {
            success: true,
            message: message.to_string(),
            data: Some(data),
            timestamp: chrono::Utc::now().to_rfc3339(),
        }
    }
    
    fn error(message: &str) -> ApiResponse<()> {
        ApiResponse {
            success: false,
            message: message.to_string(),
            data: None,
            timestamp: chrono::Utc::now().to_rfc3339(),
        }
    }
}

// è·¯ç”±å¤„ç†å™¨

async fn root_handler() -> Html<&'static str> {
    info!("ğŸ  è®¿é—®æ ¹è·¯å¾„");
    Html(r#"
    <html>
        <head><title>Axum æœåŠ¡å™¨</title></head>
        <body>
            <h1>ğŸš€ æ¬¢è¿æ¥åˆ° Axum æœåŠ¡å™¨ï¼</h1>
            <p>è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨ Rust Axum æ„å»ºçš„ Web æœåŠ¡å™¨ã€‚</p>
            <ul>
                <li><a href="/ping">/ping</a> - å¥åº·æ£€æŸ¥</li>
                <li><a href="/health">/health</a> - è¯¦ç»†å¥åº·çŠ¶æ€</li>
                <li><a href="/user/123">/user/123</a> - è·å–ç”¨æˆ·ä¿¡æ¯</li>
                <li><a href="/search?q=rust&limit=10">/search?q=rust&limit=10</a> - æœç´¢</li>
            </ul>
        </body>
    </html>
    "#)
}

async fn ping_handler() -> Json<ApiResponse<&'static str>> {
    info!("ğŸ“ Ping è¯·æ±‚");
    Json(ApiResponse::success("pong", "æœåŠ¡å™¨è¿è¡Œæ­£å¸¸"))
}

#[derive(Debug, Serialize)]
struct HealthStatus {
    status: String,
    uptime: String,
    version: String,
    server_time: String,
}

async fn health_check() -> Json<ApiResponse<HealthStatus>> {
    info!("â¤ï¸  å¥åº·æ£€æŸ¥è¯·æ±‚");
    
    let health = HealthStatus {
        status: "healthy".to_string(),
        uptime: "running".to_string(),
        version: env!("CARGO_PKG_VERSION").to_string(),
        server_time: chrono::Utc::now().to_rfc3339(),
    };
    
    Json(ApiResponse::success(health, "æœåŠ¡å™¨çŠ¶æ€è‰¯å¥½"))
}

#[derive(Debug, Serialize)]
struct User {
    id: u32,
    username: String,
    email: String,
    created_at: String,
}

async fn get_user(Path(user_id): Path<u32>) -> Json<ApiResponse<User>> {
    info!("ğŸ‘¤ è·å–ç”¨æˆ·ä¿¡æ¯: ID = {}", user_id);
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    let user = User {
        id: user_id,
        username: format!("user_{}", user_id),
        email: format!("user_{}@example.com", user_id),
        created_at: chrono::Utc::now().to_rfc3339(),
    };
    
    Json(ApiResponse::success(user, "ç”¨æˆ·ä¿¡æ¯è·å–æˆåŠŸ"))
}

#[derive(Debug, Serialize)]
struct UserProfile {
    user_id: u32,
    display_name: String,
    bio: String,
    followers: u32,
    following: u32,
}

async fn get_user_profile(Path(user_id): Path<u32>) -> Json<ApiResponse<UserProfile>> {
    info!("ğŸ“‹ è·å–ç”¨æˆ·èµ„æ–™: ID = {}", user_id);
    
    let profile = UserProfile {
        user_id,
        display_name: format!("User {}çš„æ˜¾ç¤ºå", user_id),
        bio: "è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ç”¨æˆ·çš„ä¸ªäººç®€ä»‹ã€‚".to_string(),
        followers: user_id * 10,
        following: user_id * 5,
    };
    
    Json(ApiResponse::success(profile, "ç”¨æˆ·èµ„æ–™è·å–æˆåŠŸ"))
}

#[derive(Debug, Deserialize)]
struct SearchParams {
    q: Option<String>,
    limit: Option<usize>,
    offset: Option<usize>,
}

#[derive(Debug, Serialize)]
struct SearchResult {
    query: String,
    results: Vec<SearchItem>,
    total: usize,
    limit: usize,
    offset: usize,
}

#[derive(Debug, Serialize)]
struct SearchItem {
    id: String,
    title: String,
    description: String,
    score: f64,
}

async fn search_handler(Query(params): Query<SearchParams>) -> Json<ApiResponse<SearchResult>> {
    let query = params.q.unwrap_or_else(|| "default".to_string());
    let limit = params.limit.unwrap_or(10).min(100); // æœ€å¤§ 100 ä¸ªç»“æœ
    let offset = params.offset.unwrap_or(0);
    
    info!("ğŸ” æœç´¢è¯·æ±‚: query='{}', limit={}, offset={}", query, limit, offset);
    
    // æ¨¡æ‹Ÿæœç´¢ç»“æœ
    let items: Vec<SearchItem> = (0..limit)
        .map(|i| SearchItem {
            id: uuid::Uuid::new_v4().to_string(),
            title: format!("{} ç»“æœ {}", query, i + 1),
            description: format!("è¿™æ˜¯å…³äº '{}' çš„ç¬¬ {} ä¸ªæœç´¢ç»“æœã€‚", query, i + 1),
            score: 1.0 - (i as f64 * 0.1),
        })
        .collect();
    
    let result = SearchResult {
        query: query.clone(),
        total: 1000, // æ¨¡æ‹Ÿæ€»æ•°
        results: items,
        limit,
        offset,
    };
    
    Json(ApiResponse::success(result, &format!("æœç´¢ '{}' å®Œæˆ", query)))
}

#[derive(Debug, Deserialize)]
struct ListParams {
    page: Option<usize>,
    per_page: Option<usize>,
    category: Option<String>,
}

#[derive(Debug, Serialize)]
struct ItemList {
    items: Vec<Item>,
    pagination: Pagination,
}

#[derive(Debug, Serialize)]
struct Item {
    id: String,
    name: String,
    category: String,
    price: f64,
    in_stock: bool,
}

#[derive(Debug, Serialize)]
struct Pagination {
    page: usize,
    per_page: usize,
    total_pages: usize,
    total_items: usize,
}

async fn list_items(Query(params): Query<ListParams>) -> Json<ApiResponse<ItemList>> {
    let page = params.page.unwrap_or(1).max(1);
    let per_page = params.per_page.unwrap_or(20).min(100).max(1);
    let category = params.category.unwrap_or_else(|| "all".to_string());
    
    info!("ğŸ“ åˆ—è¡¨è¯·æ±‚: page={}, per_page={}, category='{}'", page, per_page, category);
    
    // æ¨¡æ‹Ÿæ•°æ®
    let items: Vec<Item> = (0..per_page)
        .map(|i| {
            let item_id = (page - 1) * per_page + i + 1;
            Item {
                id: format!("item_{}", item_id),
                name: format!("å•†å“ {}", item_id),
                category: category.clone(),
                price: (item_id as f64) * 9.99,
                in_stock: item_id % 3 != 0, // æ¨¡æ‹Ÿåº“å­˜çŠ¶æ€
            }
        })
        .collect();
    
    let total_items = 500; // æ¨¡æ‹Ÿæ€»æ•°
    let total_pages = (total_items + per_page - 1) / per_page;
    
    let item_list = ItemList {
        items,
        pagination: Pagination {
            page,
            per_page,
            total_pages,
            total_items,
        },
    };
    
    Json(ApiResponse::success(item_list, "å•†å“åˆ—è¡¨è·å–æˆåŠŸ"))
}

#[derive(Debug, Deserialize)]
struct CreateUserRequest {
    username: String,
    email: String,
    full_name: Option<String>,
}

#[derive(Debug, Serialize)]
struct CreateUserResponse {
    id: String,
    username: String,
    email: String,
    full_name: Option<String>,
    created_at: String,
}

async fn create_user(Json(payload): Json<CreateUserRequest>) -> Result<Json<ApiResponse<CreateUserResponse>>, StatusCode> {
    info!("ğŸ†• åˆ›å»ºç”¨æˆ·è¯·æ±‚: {:?}", payload);
    
    // éªŒè¯è¾“å…¥
    if payload.username.is_empty() {
        warn!("ç”¨æˆ·åä¸èƒ½ä¸ºç©º");
        return Err(StatusCode::BAD_REQUEST);
    }
    
    if !payload.email.contains('@') {
        warn!("é‚®ç®±æ ¼å¼ä¸æ­£ç¡®");
        return Err(StatusCode::BAD_REQUEST);
    }
    
    // æ¨¡æ‹Ÿåˆ›å»ºç”¨æˆ·é€»è¾‘
    let user = CreateUserResponse {
        id: uuid::Uuid::new_v4().to_string(),
        username: payload.username,
        email: payload.email,
        full_name: payload.full_name,
        created_at: chrono::Utc::now().to_rfc3339(),
    };
    
    Ok(Json(ApiResponse::success(user, "ç”¨æˆ·åˆ›å»ºæˆåŠŸ")))
}

#[derive(Debug, Deserialize, Serialize)]
struct EchoMessage {
    message: String,
    timestamp: Option<String>,
}

async fn echo_handler(Json(payload): Json<EchoMessage>) -> Json<ApiResponse<EchoMessage>> {
    info!("ğŸ”Š Echo è¯·æ±‚: {:?}", payload);
    
    let mut response = payload;
    response.timestamp = Some(chrono::Utc::now().to_rfc3339());
    
    Json(ApiResponse::success(response, "Echo æˆåŠŸ"))
}

async fn not_found_handler() -> (StatusCode, Json<ApiResponse<()>>) {
    warn!("ğŸš« 404 - è·¯å¾„æœªæ‰¾åˆ°");
    (
        StatusCode::NOT_FOUND,
        Json(ApiResponse::error("è¯·æ±‚çš„èµ„æºæœªæ‰¾åˆ°")),
    )
}</pre>

        <p><strong>æ­¥éª¤ 3: ä¸­é—´ä»¶å’Œé”™è¯¯å¤„ç†</strong></p>
        <pre>use axum::{
    extract::Request,
    middleware::{self, Next},
    response::Response,
};
use tower::ServiceBuilder;
use tower_http::{
    trace::TraceLayer,
    timeout::TimeoutLayer,
    compression::CompressionLayer,
};
use std::time::Duration;

// æ›´æ–° create_router å‡½æ•°
fn create_router() -> Router {
    Router::new()
        // API è·¯ç”±
        .route("/", get(root_handler))
        .route("/ping", get(ping_handler))
        .route("/health", get(health_check))
        .route("/user/:id", get(get_user))
        .route("/user/:id/profile", get(get_user_profile))
        .route("/search", get(search_handler))
        .route("/items", get(list_items))
        .route("/users", post(create_user))
        .route("/echo", post(echo_handler))
        
        // å—ä¿æŠ¤çš„è·¯ç”±
        .route("/protected", get(protected_handler))
        .route_layer(middleware::from_fn(auth_middleware))
        
        // å…¨å±€ä¸­é—´ä»¶
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CompressionLayer::new())
                .layer(TimeoutLayer::new(Duration::from_secs(30)))
                .layer(middleware::from_fn(request_logging_middleware))
                .layer(CorsLayer::permissive())
        )
        
        .fallback(not_found_handler)
}

// è¯·æ±‚æ—¥å¿•ä¸­é—´ä»¶
async fn request_logging_middleware(
    request: Request,
    next: Next,
) -> Response {
    let method = request.method().clone();
    let uri = request.uri().clone();
    let start = std::time::Instant::now();
    
    let response = next.run(request).await;
    
    let duration = start.elapsed();
    let status = response.status();
    
    info!(
        "ğŸ“‹ {} {} - {} ({:?})",
        method,
        uri,
        status.as_u16(),
        duration
    );
    
    response
}

// ç®€å•è®¤è¯ä¸­é—´ä»¶
async fn auth_middleware(
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    // æ£€æŸ¥ Authorization header
    let auth_header = request
        .headers()
        .get("authorization")
        .and_then(|value| value.to_str().ok());
    
    match auth_header {
        Some(token) if token.starts_with("Bearer ") => {
            let token = &token[7..]; // ç§»é™¤ "Bearer " å‰ç¼€
            
            if token == "valid-token-123" {
                info!("âœ… è®¤è¯æˆåŠŸ");
                Ok(next.run(request).await)
            } else {
                warn!("âŒ æ— æ•ˆçš„ token");
                Err(StatusCode::UNAUTHORIZED)
            }
        }
        _ => {
            warn!("âŒ ç¼ºå°‘ Authorization header");
            Err(StatusCode::UNAUTHORIZED)
        }
    }
}

#[derive(Serialize)]
struct ProtectedData {
    message: String,
    user_id: String,
    access_level: String,
}

async fn protected_handler() -> Json<ApiResponse<ProtectedData>> {
    info!("ğŸ”’ è®¿é—®å—ä¿æŠ¤çš„èµ„æº");
    
    let data = ProtectedData {
        message: "è¿™æ˜¯å—ä¿æŠ¤çš„æ•°æ®".to_string(),
        user_id: "user_123".to_string(),
        access_level: "admin".to_string(),
    };
    
    Json(ApiResponse::success(data, "å—ä¿æŠ¤èµ„æºè®¿é—®æˆåŠŸ"))
}</pre>

        <p><strong>æ­¥éª¤ 4: çŠ¶æ€ç®¡ç†</strong></p>
        <pre>use axum::extract::State;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

// åº”ç”¨çŠ¶æ€
#[derive(Clone)]
struct AppState {
    users: Arc<Mutex<HashMap<String, StoredUser>>>,
    visit_count: Arc<Mutex<u64>>,
    server_start_time: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize)]
struct StoredUser {
    id: String,
    username: String,
    email: String,
    created_at: String,
}

impl AppState {
    fn new() -> Self {
        Self {
            users: Arc::new(Mutex::new(HashMap::new())),
            visit_count: Arc::new(Mutex::new(0)),
            server_start_time: chrono::Utc::now(),
        }
    }
}

// æ›´æ–° main å‡½æ•°
#[tokio::main]
async fn main() {
    tracing_subscriber::init();
    
    info!("ğŸš€ å¯åŠ¨ Axum æœåŠ¡å™¨...");
    
    // åˆ›å»ºåº”ç”¨çŠ¶æ€
    let state = AppState::new();
    
    // æ„å»ºè·¯ç”±
    let app = create_stateful_router().with_state(state);
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    
    info!("ğŸ§ æœåŠ¡å™¨å·²å¯åŠ¨ï¼Œç›‘å¬åœ°å€: http://0.0.0.0:3000");
    
    axum::serve(listener, app).await.unwrap();
}

fn create_stateful_router() -> Router<AppState> {
    Router::new()
        .route("/", get(stateful_root_handler))
        .route("/stats", get(get_stats))
        .route("/users", post(create_stateful_user))
        .route("/users/:id", get(get_stateful_user))
        .route("/users", get(list_all_users))
        
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(middleware::from_fn(visit_counter_middleware))
                .layer(CorsLayer::permissive())
        )
        
        .fallback(not_found_handler)
}

// è®¿é—®è®¡æ•°ä¸­é—´ä»¶
async fn visit_counter_middleware(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    // å¢åŠ è®¿é—®è®¡æ•°
    {
        let mut count = state.visit_count.lock().unwrap();
        *count += 1;
    }
    
    next.run(request).await
}

async fn stateful_root_handler(State(state): State<AppState>) -> Html<String> {
    let visit_count = *state.visit_count.lock().unwrap();
    let user_count = state.users.lock().unwrap().len();
    
    let html = format!(r#"
    <html>
        <head><title>Axum çŠ¶æ€ç®¡ç†æœåŠ¡å™¨</title></head>
        <body>
            <h1>ğŸš€ Axum æœåŠ¡å™¨çŠ¶æ€</h1>
            <ul>
                <li>ğŸ“Š è®¿é—®æ¬¡æ•°: {}</li>
                <li>ğŸ‘¥ ç”¨æˆ·æ•°é‡: {}</li>
                <li><a href="/stats">/stats</a> - æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯</li>
                <li><a href="/users">/users</a> - æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ·</li>
            </ul>
        </body>
    </html>
    "#, visit_count, user_count);
    
    Html(html)
}

#[derive(Serialize)]
struct ServerStats {
    visit_count: u64,
    user_count: usize,
    uptime_seconds: i64,
    server_start_time: String,
}

async fn get_stats(State(state): State<AppState>) -> Json<ApiResponse<ServerStats>> {
    let visit_count = *state.visit_count.lock().unwrap();
    let user_count = state.users.lock().unwrap().len();
    let uptime = chrono::Utc::now().signed_duration_since(state.server_start_time);
    
    let stats = ServerStats {
        visit_count,
        user_count,
        uptime_seconds: uptime.num_seconds(),
        server_start_time: state.server_start_time.to_rfc3339(),
    };
    
    Json(ApiResponse::success(stats, "æœåŠ¡å™¨ç»Ÿè®¡ä¿¡æ¯"))
}

async fn create_stateful_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<ApiResponse<StoredUser>>, StatusCode> {
    if payload.username.is_empty() || !payload.email.contains('@') {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    let user_id = uuid::Uuid::new_v4().to_string();
    let user = StoredUser {
        id: user_id.clone(),
        username: payload.username,
        email: payload.email,
        created_at: chrono::Utc::now().to_rfc3339(),
    };
    
    // å­˜å‚¨ç”¨æˆ·
    {
        let mut users = state.users.lock().unwrap();
        users.insert(user_id, user.clone());
    }
    
    info!("ğŸ†• ç”¨æˆ·å·²åˆ›å»º: {}", user.username);
    
    Ok(Json(ApiResponse::success(user, "ç”¨æˆ·åˆ›å»ºæˆåŠŸ")))
}

async fn get_stateful_user(
    State(state): State<AppState>,
    Path(user_id): Path<String>,
) -> Result<Json<ApiResponse<StoredUser>>, StatusCode> {
    let users = state.users.lock().unwrap();
    
    match users.get(&user_id) {
        Some(user) => Ok(Json(ApiResponse::success(user.clone(), "ç”¨æˆ·ä¿¡æ¯è·å–æˆåŠŸ"))),
        None => Err(StatusCode::NOT_FOUND),
    }
}

async fn list_all_users(
    State(state): State<AppState>,
) -> Json<ApiResponse<Vec<StoredUser>>> {
    let users = state.users.lock().unwrap();
    let user_list: Vec<StoredUser> = users.values().cloned().collect();
    
    Json(ApiResponse::success(user_list, "ç”¨æˆ·åˆ—è¡¨è·å–æˆåŠŸ"))
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>æ·»åŠ æ›´å¤š REST API ç«¯ç‚¹ï¼ˆPUT, DELETEï¼‰</li>
            <li>å®ç°ç”¨æˆ·è®¤è¯å’Œæˆæƒç³»ç»Ÿ</li>
            <li>æ·»åŠ è¯·æ±‚é™é€Ÿä¸­é—´ä»¶</li>
            <li>å®ç°æ–‡ä»¶ä¸Šä¼ å’Œä¸‹è½½åŠŸèƒ½</li>
        </ul>

        <p><strong>æµ‹è¯•å‘½ä»¤ï¼š</strong></p>
        <pre># å¯åŠ¨æœåŠ¡å™¨
cargo run

# æµ‹è¯• API ç«¯ç‚¹
curl http://localhost:3000/ping
curl http://localhost:3000/health
curl http://localhost:3000/user/123
curl "http://localhost:3000/search?q=rust&limit=5"

# POST è¯·æ±‚
curl -X POST http://localhost:3000/users \
  -H "Content-Type: application/json" \
  -d '{"username":"alice","email":"alice@example.com"}'

# å—ä¿æŠ¤çš„èµ„æº
curl http://localhost:3000/protected \
  -H "Authorization: Bearer valid-token-123"</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day13_axum_server/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-14</strong></p>
        <h2>Day 14 - å®šä¹‰ JSON è¯·æ±‚ä¸å“åº”ç±»å‹</h2>
        <p>ä½ å°†å®šä¹‰ç»“æ„ä½“ï¼Œä½¿ç”¨ `serde::{Serialize, Deserialize}` å°†å…¶è½¬æ¢ä¸º JSONï¼Œå¹¶ç¼–å†™æ”¯æŒ POST è¯·æ±‚çš„æ¥å£ï¼ˆå¦‚ `/login`ï¼‰ã€‚</p>
        <p>ğŸ”— <a href="https://docs.rs/serde/latest/serde/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®å’Œé…ç½®ä¾èµ–</strong></p>
        <pre>cargo new day14_json_api
cd day14_json_api</pre>

        <p><strong>Cargo.toml</strong></p>
        <pre>[package]
name = "day14_json_api"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.7"
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace", "validate-request"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
tracing = "0.1"
tracing-subscriber = "0.3"
validator = { version = "0.18", features = ["derive"] }
bcrypt = "0.15"
jsonwebtoken = "9.2"
thiserror = "1.0"
anyhow = "1.0"</pre>

        <p><strong>æ­¥éª¤ 2: å®šä¹‰ JSON æ•°æ®ç»“æ„</strong></p>
        <pre>use axum::{
    extract::{Json, Path, State},
    http::StatusCode,
    response::Json as ResponseJson,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use validator::Validate;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use uuid::Uuid;
use chrono::{DateTime, Utc};

// ===== é€šç”¨å“åº”ç»“æ„ =====

#[derive(Debug, Serialize)]
struct ApiResponse<T> {
    success: bool,
    message: String,
    data: Option<T>,
    timestamp: DateTime<Utc>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error_code: Option<String>,
}

impl<T> ApiResponse<T> {
    fn success(data: T, message: &str) -> Self {
        Self {
            success: true,
            message: message.to_string(),
            data: Some(data),
            timestamp: Utc::now(),
            error_code: None,
        }
    }
    
    fn error(message: &str, error_code: Option<&str>) -> ApiResponse<()> {
        ApiResponse {
            success: false,
            message: message.to_string(),
            data: None,
            timestamp: Utc::now(),
            error_code: error_code.map(|s| s.to_string()),
        }
    }
}

// ===== ç”¨æˆ·ç›¸å…³æ•°æ®ç»“æ„ =====

#[derive(Debug, Clone, Serialize, Deserialize)]
struct User {
    id: String,
    username: String,
    email: String,
    full_name: Option<String>,
    avatar_url: Option<String>,
    is_active: bool,
    role: UserRole,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
    #[serde(skip_serializing)] // ä¸åœ¨ JSON ä¸­è¿”å›å¯†ç å“ˆå¸Œ
    password_hash: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
enum UserRole {
    Admin,
    Moderator,
    User,
    Guest,
}

#[derive(Debug, Deserialize, Validate)]
struct CreateUserRequest {
    #[validate(length(min = 3, max = 30))]
    username: String,
    
    #[validate(email)]
    email: String,
    
    #[validate(length(min = 6))]
    password: String,
    
    #[validate(length(min = 1, max = 100))]
    full_name: Option<String>,
    
    #[validate(url)]
    avatar_url: Option<String>,
}

#[derive(Debug, Deserialize, Validate)]
struct UpdateUserRequest {
    #[validate(length(min = 1, max = 100))]
    full_name: Option<String>,
    
    #[validate(url)]
    avatar_url: Option<String>,
    
    #[validate(email)]
    email: Option<String>,
}

#[derive(Debug, Deserialize, Validate)]
struct LoginRequest {
    #[validate(length(min = 1))]
    username: String,
    
    #[validate(length(min = 1))]
    password: String,
}

#[derive(Debug, Serialize)]
struct LoginResponse {
    user: UserInfo,
    token: String,
    expires_at: DateTime<Utc>,
}

#[derive(Debug, Serialize)]
struct UserInfo {
    id: String,
    username: String,
    email: String,
    full_name: Option<String>,
    avatar_url: Option<String>,
    role: UserRole,
}

impl From<User> for UserInfo {
    fn from(user: User) -> Self {
        Self {
            id: user.id,
            username: user.username,
            email: user.email,
            full_name: user.full_name,
            avatar_url: user.avatar_url,
            role: user.role,
        }
    }
}

// ===== æ–‡ç« ç›¸å…³æ•°æ®ç»“æ„ =====

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Article {
    id: String,
    title: String,
    content: String,
    summary: Option<String>,
    author_id: String,
    category: ArticleCategory,
    tags: Vec<String>,
    status: ArticleStatus,
    view_count: u64,
    like_count: u64,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
    published_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
enum ArticleCategory {
    Technology,
    Science,
    Business,
    Entertainment,
    Sports,
    Health,
    Other,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
enum ArticleStatus {
    Draft,
    Published,
    Archived,
}

#[derive(Debug, Deserialize, Validate)]
struct CreateArticleRequest {
    #[validate(length(min = 1, max = 200))]
    title: String,
    
    #[validate(length(min = 10))]
    content: String,
    
    #[validate(length(max = 500))]
    summary: Option<String>,
    
    category: ArticleCategory,
    tags: Vec<String>,
}

#[derive(Debug, Deserialize, Validate)]
struct UpdateArticleRequest {
    #[validate(length(min = 1, max = 200))]
    title: Option<String>,
    
    #[validate(length(min = 10))]
    content: Option<String>,
    
    #[validate(length(max = 500))]
    summary: Option<String>,
    
    category: Option<ArticleCategory>,
    tags: Option<Vec<String>>,
    status: Option<ArticleStatus>,
}

#[derive(Debug, Serialize)]
struct ArticleListItem {
    id: String,
    title: String,
    summary: Option<String>,
    author: UserInfo,
    category: ArticleCategory,
    tags: Vec<String>,
    status: ArticleStatus,
    view_count: u64,
    like_count: u64,
    created_at: DateTime<Utc>,
    published_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize)]
struct ArticleQueryParams {
    page: Option<u32>,
    per_page: Option<u32>,
    category: Option<ArticleCategory>,
    author_id: Option<String>,
    status: Option<ArticleStatus>,
    search: Option<String>,
}

#[derive(Debug, Serialize)]
struct PaginatedResponse<T> {
    items: Vec<T>,
    pagination: PaginationInfo,
}

#[derive(Debug, Serialize)]
struct PaginationInfo {
    page: u32,
    per_page: u32,
    total_items: u64,
    total_pages: u32,
    has_next: bool,
    has_prev: bool,
}

// ===== è¯„è®ºç›¸å…³æ•°æ®ç»“æ„ =====

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Comment {
    id: String,
    article_id: String,
    author_id: String,
    content: String,
    parent_id: Option<String>, // æ”¯æŒå›å¤è¯„è®º
    like_count: u64,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize, Validate)]
struct CreateCommentRequest {
    #[validate(length(min = 1, max = 1000))]
    content: String,
    
    parent_id: Option<String>,
}

#[derive(Debug, Serialize)]
struct CommentWithAuthor {
    id: String,
    content: String,
    author: UserInfo,
    parent_id: Option<String>,
    replies: Vec<CommentWithAuthor>,
    like_count: u64,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}

// ===== åº”ç”¨çŠ¶æ€ =====

#[derive(Clone)]
struct AppState {
    users: Arc<Mutex<HashMap<String, User>>>,
    articles: Arc<Mutex<HashMap<String, Article>>>,
    comments: Arc<Mutex<HashMap<String, Comment>>>,
    jwt_secret: String,
}

impl AppState {
    fn new() -> Self {
        Self {
            users: Arc::new(Mutex::new(HashMap::new())),
            articles: Arc::new(Mutex::new(HashMap::new())),
            comments: Arc::new(Mutex::new(HashMap::new())),
            jwt_secret: "your-secret-key".to_string(),
        }
    }
}</pre>

        <p><strong>æ­¥éª¤ 3: ç”¨æˆ·ç®¡ç† API</strong></p>
        <pre>use tower_http::cors::CorsLayer;
use tracing::{info, warn, error};

#[tokio::main]
async fn main() {
    tracing_subscriber::init();
    
    info!("ğŸš€ å¯åŠ¨ JSON API æœåŠ¡å™¨...");
    
    let state = AppState::new();
    let app = create_api_router().with_state(state);
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    
    info!("ğŸ§ æœåŠ¡å™¨å·²å¯åŠ¨ï¼Œç›‘å¬åœ°å€: http://0.0.0.0:3000");
    
    axum::serve(listener, app).await.unwrap();
}

fn create_api_router() -> Router<AppState> {
    Router::new()
        // èº«ä»½éªŒè¯
        .route("/api/auth/register", post(register_user))
        .route("/api/auth/login", post(login_user))
        
        // ç”¨æˆ·ç®¡ç†
        .route("/api/users", get(list_users))
        .route("/api/users/:id", get(get_user))
        .route("/api/users/:id", put(update_user))
        .route("/api/users/:id", delete(delete_user))
        
        // æ–‡ç« ç®¡ç†
        .route("/api/articles", get(list_articles))
        .route("/api/articles", post(create_article))
        .route("/api/articles/:id", get(get_article))
        .route("/api/articles/:id", put(update_article))
        .route("/api/articles/:id", delete(delete_article))
        .route("/api/articles/:id/like", post(like_article))
        
        // è¯„è®ºç®¡ç†
        .route("/api/articles/:article_id/comments", get(list_comments))
        .route("/api/articles/:article_id/comments", post(create_comment))
        .route("/api/comments/:id", put(update_comment))
        .route("/api/comments/:id", delete(delete_comment))
        
        .layer(CorsLayer::permissive())
        .fallback(api_not_found)
}

// ===== èº«ä»½éªŒè¯ API =====

async fn register_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<ResponseJson<ApiResponse<UserInfo>>, StatusCode> {
    // éªŒè¯è¾“å…¥
    if let Err(errors) = payload.validate() {
        warn!("ç”¨æˆ·æ³¨å†ŒéªŒè¯å¤±è´¥: {:?}", errors);
        return Err(StatusCode::BAD_REQUEST);
    }
    
    info!("ğŸ†• ç”¨æˆ·æ³¨å†Œè¯·æ±‚: {}", payload.username);
    
    let mut users = state.users.lock().unwrap();
    
    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    if users.values().any(|u| u.username == payload.username) {
        warn!("ç”¨æˆ·åå·²å­˜åœ¨: {}", payload.username);
        return Err(StatusCode::CONFLICT);
    }
    
    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    if users.values().any(|u| u.email == payload.email) {
        warn!("é‚®ç®±å·²å­˜åœ¨: {}", payload.email);
        return Err(StatusCode::CONFLICT);
    }
    
    // åˆ›å»ºç”¨æˆ·
    let user_id = Uuid::new_v4().to_string();
    let password_hash = bcrypt::hash(&payload.password, bcrypt::DEFAULT_COST)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    let user = User {
        id: user_id.clone(),
        username: payload.username,
        email: payload.email,
        full_name: payload.full_name,
        avatar_url: payload.avatar_url,
        is_active: true,
        role: UserRole::User,
        created_at: Utc::now(),
        updated_at: Utc::now(),
        password_hash,
    };
    
    let user_info = UserInfo::from(user.clone());
    users.insert(user_id, user);
    
    info!("âœ… ç”¨æˆ·æ³¨å†ŒæˆåŠŸ: {}", user_info.username);
    
    Ok(ResponseJson(ApiResponse::success(
        user_info,
        "ç”¨æˆ·æ³¨å†ŒæˆåŠŸ",
    )))
}

async fn login_user(
    State(state): State<AppState>,
    Json(payload): Json<LoginRequest>,
) -> Result<ResponseJson<ApiResponse<LoginResponse>>, StatusCode> {
    if let Err(_) = payload.validate() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    info!("ğŸ”‘ ç”¨æˆ·ç™»å½•è¯·æ±‚: {}", payload.username);
    
    let users = state.users.lock().unwrap();
    
    // æŸ¥æ‰¾ç”¨æˆ·
    let user = users
        .values()
        .find(|u| u.username == payload.username)
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    // éªŒè¯å¯†ç 
    if !bcrypt::verify(&payload.password, &user.password_hash)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
    {
        warn!("å¯†ç é”™è¯¯: {}", payload.username);
        return Err(StatusCode::UNAUTHORIZED);
    }
    
    // ç”Ÿæˆ JWT token
    let token = generate_jwt_token(&user.id, &state.jwt_secret)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    let expires_at = Utc::now() + chrono::Duration::hours(24);
    
    let response = LoginResponse {
        user: UserInfo::from(user.clone()),
        token,
        expires_at,
    };
    
    info!("âœ… ç”¨æˆ·ç™»å½•æˆåŠŸ: {}", user.username);
    
    Ok(ResponseJson(ApiResponse::success(
        response,
        "ç™»å½•æˆåŠŸ",
    )))
}

fn generate_jwt_token(user_id: &str, secret: &str) -> Result<String, jsonwebtoken::errors::Error> {
    use jsonwebtoken::{encode, Header, EncodingKey};
    use serde::{Serialize};
    
    #[derive(Serialize)]
    struct Claims {
        sub: String,
        exp: usize,
    }
    
    let expiration = Utc::now()
        .checked_add_signed(chrono::Duration::hours(24))
        .expect("æ— æ•ˆçš„æ—¶é—´æˆ³")
        .timestamp() as usize;
    
    let claims = Claims {
        sub: user_id.to_string(),
        exp: expiration,
    };
    
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_ref()))
}

// ===== ç”¨æˆ·ç®¡ç† API =====

async fn list_users(
    State(state): State<AppState>,
) -> ResponseJson<ApiResponse<Vec<UserInfo>>> {
    let users = state.users.lock().unwrap();
    let user_list: Vec<UserInfo> = users
        .values()
        .filter(|u| u.is_active)
        .map(|u| UserInfo::from(u.clone()))
        .collect();
    
    ResponseJson(ApiResponse::success(
        user_list,
        "ç”¨æˆ·åˆ—è¡¨è·å–æˆåŠŸ",
    ))
}

async fn get_user(
    State(state): State<AppState>,
    Path(user_id): Path<String>,
) -> Result<ResponseJson<ApiResponse<UserInfo>>, StatusCode> {
    let users = state.users.lock().unwrap();
    
    let user = users
        .get(&user_id)
        .filter(|u| u.is_active)
        .ok_or(StatusCode::NOT_FOUND)?;
    
    Ok(ResponseJson(ApiResponse::success(
        UserInfo::from(user.clone()),
        "ç”¨æˆ·ä¿¡æ¯è·å–æˆåŠŸ",
    )))
}

async fn update_user(
    State(state): State<AppState>,
    Path(user_id): Path<String>,
    Json(payload): Json<UpdateUserRequest>,
) -> Result<ResponseJson<ApiResponse<UserInfo>>, StatusCode> {
    if let Err(_) = payload.validate() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    let mut users = state.users.lock().unwrap();
    
    let user = users.get_mut(&user_id).ok_or(StatusCode::NOT_FOUND)?;
    
    // æ›´æ–°å­—æ®µ
    if let Some(full_name) = payload.full_name {
        user.full_name = Some(full_name);
    }
    
    if let Some(avatar_url) = payload.avatar_url {
        user.avatar_url = Some(avatar_url);
    }
    
    if let Some(email) = payload.email {
        // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²è¢«å…¶ä»–ç”¨æˆ·ä½¿ç”¨
        if users.values().any(|u| u.id != user_id && u.email == email) {
            return Err(StatusCode::CONFLICT);
        }
        user.email = email;
    }
    
    user.updated_at = Utc::now();
    
    info!("âœ… ç”¨æˆ·ä¿¡æ¯æ›´æ–°æˆåŠŸ: {}", user.username);
    
    Ok(ResponseJson(ApiResponse::success(
        UserInfo::from(user.clone()),
        "ç”¨æˆ·ä¿¡æ¯æ›´æ–°æˆåŠŸ",
    )))
}

async fn delete_user(
    State(state): State<AppState>,
    Path(user_id): Path<String>,
) -> Result<ResponseJson<ApiResponse<()>>, StatusCode> {
    let mut users = state.users.lock().unwrap();
    
    let user = users.get_mut(&user_id).ok_or(StatusCode::NOT_FOUND)?;
    
    // è½¯åˆ é™¤ï¼šæ ‡è®°ä¸ºéæ´»è·ƒçŠ¶æ€
    user.is_active = false;
    user.updated_at = Utc::now();
    
    info!("âœ… ç”¨æˆ·å·²ç¦ç”¨: {}", user.username);
    
    Ok(ResponseJson(ApiResponse::success(
        (),
        "ç”¨æˆ·å·²åˆ é™¤",
    )))
}</pre>

        <p><strong>æ­¥éª¤ 4: æ–‡ç« ç®¡ç† API</strong></p>
        <pre>use axum::extract::Query;

// ===== æ–‡ç« ç®¡ç† API =====

async fn create_article(
    State(state): State<AppState>,
    Json(payload): Json<CreateArticleRequest>,
) -> Result<ResponseJson<ApiResponse<Article>>, StatusCode> {
    if let Err(_) = payload.validate() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    info!("ğŸ“ åˆ›å»ºæ–‡ç« : {}", payload.title);
    
    let article_id = Uuid::new_v4().to_string();
    let now = Utc::now();
    
    let article = Article {
        id: article_id.clone(),
        title: payload.title,
        content: payload.content,
        summary: payload.summary,
        author_id: "system".to_string(), // åœ¨å®é™…åº”ç”¨ä¸­ä» JWT ä¸­è·å–
        category: payload.category,
        tags: payload.tags,
        status: ArticleStatus::Draft,
        view_count: 0,
        like_count: 0,
        created_at: now,
        updated_at: now,
        published_at: None,
    };
    
    let mut articles = state.articles.lock().unwrap();
    articles.insert(article_id, article.clone());
    
    Ok(ResponseJson(ApiResponse::success(
        article,
        "æ–‡ç« åˆ›å»ºæˆåŠŸ",
    )))
}

async fn list_articles(
    State(state): State<AppState>,
    Query(params): Query<ArticleQueryParams>,
) -> ResponseJson<ApiResponse<PaginatedResponse<ArticleListItem>>> {
    let page = params.page.unwrap_or(1).max(1);
    let per_page = params.per_page.unwrap_or(10).min(50).max(1);
    
    info!("ğŸ“ è·å–æ–‡ç« åˆ—è¡¨: page={}, per_page={}", page, per_page);
    
    let articles = state.articles.lock().unwrap();
    let users = state.users.lock().unwrap();
    
    let mut filtered_articles: Vec<&Article> = articles
        .values()
        .filter(|article| {
            // æŒ‰ç±»åˆ«è¿‡æ»¤
            if let Some(ref category) = params.category {
                if article.category != *category {
                    return false;
                }
            }
            
            // æŒ‰ä½œè€…è¿‡æ»¤
            if let Some(ref author_id) = params.author_id {
                if article.author_id != *author_id {
                    return false;
                }
            }
            
            // æŒ‰çŠ¶æ€è¿‡æ»¤
            if let Some(ref status) = params.status {
                if article.status != *status {
                    return false;
                }
            }
            
            // æœç´¢è¿‡æ»¤
            if let Some(ref search) = params.search {
                let search_lower = search.to_lowercase();
                if !article.title.to_lowercase().contains(&search_lower)
                    && !article.content.to_lowercase().contains(&search_lower)
                {
                    return false;
                }
            }
            
            true
        })
        .collect();
    
    // æŒ‰åˆ›å»ºæ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
    filtered_articles.sort_by(|a, b| b.created_at.cmp(&a.created_at));
    
    let total_items = filtered_articles.len() as u64;
    let total_pages = ((total_items as f64) / (per_page as f64)).ceil() as u32;
    
    // åˆ†é¡µ
    let start = ((page - 1) * per_page) as usize;
    let end = (start + per_page as usize).min(filtered_articles.len());
    let page_articles = if start < filtered_articles.len() {
        &filtered_articles[start..end]
    } else {
        &[]
    };
    
    // è½¬æ¢ä¸ºåˆ—è¡¨é¡¹æ ¼å¼
    let items: Vec<ArticleListItem> = page_articles
        .iter()
        .filter_map(|article| {
            users.get(&article.author_id).map(|author| ArticleListItem {
                id: article.id.clone(),
                title: article.title.clone(),
                summary: article.summary.clone(),
                author: UserInfo::from(author.clone()),
                category: article.category.clone(),
                tags: article.tags.clone(),
                status: article.status.clone(),
                view_count: article.view_count,
                like_count: article.like_count,
                created_at: article.created_at,
                published_at: article.published_at,
            })
        })
        .collect();
    
    let response = PaginatedResponse {
        items,
        pagination: PaginationInfo {
            page,
            per_page,
            total_items,
            total_pages,
            has_next: page < total_pages,
            has_prev: page > 1,
        },
    };
    
    ResponseJson(ApiResponse::success(
        response,
        "æ–‡ç« åˆ—è¡¨è·å–æˆåŠŸ",
    ))
}

async fn get_article(
    State(state): State<AppState>,
    Path(article_id): Path<String>,
) -> Result<ResponseJson<ApiResponse<Article>>, StatusCode> {
    let mut articles = state.articles.lock().unwrap();
    
    let article = articles.get_mut(&article_id).ok_or(StatusCode::NOT_FOUND)?;
    
    // å¢åŠ é˜…è¯»æ•°
    article.view_count += 1;
    
    info!("ğŸ‘ï¸  æ–‡ç« è¢«æŸ¥çœ‹: {} (ID: {})", article.title, article_id);
    
    Ok(ResponseJson(ApiResponse::success(
        article.clone(),
        "æ–‡ç« è·å–æˆåŠŸ",
    )))
}

async fn update_article(
    State(state): State<AppState>,
    Path(article_id): Path<String>,
    Json(payload): Json<UpdateArticleRequest>,
) -> Result<ResponseJson<ApiResponse<Article>>, StatusCode> {
    if let Err(_) = payload.validate() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    let mut articles = state.articles.lock().unwrap();
    let article = articles.get_mut(&article_id).ok_or(StatusCode::NOT_FOUND)?;
    
    // æ›´æ–°å­—æ®µ
    if let Some(title) = payload.title {
        article.title = title;
    }
    
    if let Some(content) = payload.content {
        article.content = content;
    }
    
    if let Some(summary) = payload.summary {
        article.summary = Some(summary);
    }
    
    if let Some(category) = payload.category {
        article.category = category;
    }
    
    if let Some(tags) = payload.tags {
        article.tags = tags;
    }
    
    if let Some(status) = payload.status {
        if status == ArticleStatus::Published && article.published_at.is_none() {
            article.published_at = Some(Utc::now());
        }
        article.status = status;
    }
    
    article.updated_at = Utc::now();
    
    info!("âœ… æ–‡ç« æ›´æ–°æˆåŠŸ: {}", article.title);
    
    Ok(ResponseJson(ApiResponse::success(
        article.clone(),
        "æ–‡ç« æ›´æ–°æˆåŠŸ",
    )))
}

async fn delete_article(
    State(state): State<AppState>,
    Path(article_id): Path<String>,
) -> Result<ResponseJson<ApiResponse<()>>, StatusCode> {
    let mut articles = state.articles.lock().unwrap();
    
    let article = articles.remove(&article_id).ok_or(StatusCode::NOT_FOUND)?;
    
    info!("âœ… æ–‡ç« å·²åˆ é™¤: {}", article.title);
    
    Ok(ResponseJson(ApiResponse::success(
        (),
        "æ–‡ç« åˆ é™¤æˆåŠŸ",
    )))
}

async fn like_article(
    State(state): State<AppState>,
    Path(article_id): Path<String>,
) -> Result<ResponseJson<ApiResponse<Article>>, StatusCode> {
    let mut articles = state.articles.lock().unwrap();
    
    let article = articles.get_mut(&article_id).ok_or(StatusCode::NOT_FOUND)?;
    
    article.like_count += 1;
    
    info!("ğŸ‘ æ–‡ç« è¢«ç‚¹èµ: {} (ID: {})", article.title, article_id);
    
    Ok(ResponseJson(ApiResponse::success(
        article.clone(),
        "ç‚¹èµæˆåŠŸ",
    )))
}

// ===== é€šç”¨é”™è¯¯å¤„ç† =====

async fn api_not_found() -> (StatusCode, ResponseJson<ApiResponse<()>>) {
    (
        StatusCode::NOT_FOUND,
        ResponseJson(ApiResponse::error("è¯·æ±‚çš„ API ç«¯ç‚¹ä¸å­˜åœ¨", Some("API_NOT_FOUND"))),
    )
}</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>å®ç°è¯„è®ºç³»ç»Ÿ API</li>
            <li>æ·»åŠ æ–‡ä»¶ä¸Šä¼ å’Œå›¾ç‰‡å¤„ç†åŠŸèƒ½</li>
            <li>åˆ›å»ºé€šçŸ¥ç³»ç»Ÿ API</li>
            <li>å®ç°æ•°æ®å¯¼å‡ºåŠŸèƒ½ï¼ˆCSV/JSONï¼‰</li>
        </ul>

        <p><strong>æµ‹è¯•å‘½ä»¤ï¼š</strong></p>
        <pre># ç”¨æˆ·æ³¨å†Œ
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "alice",
    "email": "alice@example.com",
    "password": "password123",
    "full_name": "Alice Smith"
  }'

# ç”¨æˆ·ç™»å½•
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "alice",
    "password": "password123"
  }'

# åˆ›å»ºæ–‡ç« 
curl -X POST http://localhost:3000/api/articles \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Rust å­¦ä¹ æŒ‡å—",
    "content": "è¿™æ˜¯ä¸€ç¯‡å…³äº Rust ç¼–ç¨‹è¯­è¨€çš„æ–‡ç« ...",
    "summary": "ä»‹ç» Rust åŸºç¡€çŸ¥è¯†",
    "category": "technology",
    "tags": ["rust", "programming", "tutorial"]
  }'

# è·å–æ–‡ç« åˆ—è¡¨
curl "http://localhost:3000/api/articles?page=1&per_page=5&category=technology"

# è·å–å•ä¸ªæ–‡ç« 
curl http://localhost:3000/api/articles/{article_id}

# æœç´¢æ–‡ç« 
curl "http://localhost:3000/api/articles?search=rust&page=1&per_page=10"</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day14_json_api/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-15</strong></p>
        <h2>Day 15 - WebSocket æ¥å…¥ä¸å‡çº§æ¡æ‰‹</h2>
        <p>ä½ å°†é€šè¿‡ `axum::extract::ws` å®ç° `/ws` è·¯ç”±ï¼Œå®Œæˆå®¢æˆ·ç«¯è¿æ¥å‡çº§ï¼Œå¹¶ä½¿ç”¨ `WebSocket::send`, `WebSocket::recv` ä¸å®¢æˆ·ç«¯é€šä¿¡ã€‚</p>
        <p>ğŸ”— <a href="https://docs.rs/axum/latest/axum/extract/ws/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®å¹¶é…ç½®ä¾èµ–</strong></p>
        <pre>cargo new day15_websocket_basic
cd day15_websocket_basic</pre>

        <p><strong>é…ç½® Cargo.tomlï¼š</strong></p>
        <pre>[package]
name = "day15_websocket_basic"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.20"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"</pre>

        <p><strong>æ­¥éª¤ 2: å®ç°åŸºç¡€ WebSocket æœåŠ¡å™¨</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade},
    response::Html,
    routing::get,
    Router,
};
use std::net::SocketAddr;
use tokio::net::TcpListener;
use tower_http::cors::CorsLayer;
use tracing::{info, warn, error};

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::init();
    
    // æ„å»ºåº”ç”¨è·¯ç”±
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .layer(CorsLayer::permissive());
    
    // å¯åŠ¨æœåŠ¡å™¨
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!("WebSocket æœåŠ¡å™¨å¯åŠ¨åœ¨ http://{}", addr);
    info!("WebSocket ç«¯ç‚¹: ws://{}/ws", addr);
    
    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// æä¾›ç®€å•çš„æµ‹è¯•é¡µé¢
async fn index_handler() -> Html<&'static str> {
    Html(include_str!("../static/index.html"))
}

// WebSocket å‡çº§å¤„ç†å™¨
async fn websocket_handler(ws: WebSocketUpgrade) -> axum::response::Response {
    info!("æ”¶åˆ° WebSocket å‡çº§è¯·æ±‚");
    ws.on_upgrade(handle_websocket)
}

// å¤„ç† WebSocket è¿æ¥
async fn handle_websocket(mut socket: WebSocket) {
    info!("WebSocket è¿æ¥å·²å»ºç«‹");
    
    // å‘é€æ¬¢è¿æ¶ˆæ¯
    if socket.send(axum::extract::ws::Message::Text(
        "æ¬¢è¿è¿æ¥ WebSocket æœåŠ¡å™¨ï¼".to_string()
    )).await.is_err() {
        error!("å‘é€æ¬¢è¿æ¶ˆæ¯å¤±è´¥");
        return;
    }
    
    // æŒç»­å¤„ç†æ¶ˆæ¯
    while let Some(msg) = socket.recv().await {
        match msg {
            Ok(axum::extract::ws::Message::Text(text)) => {
                info!("æ”¶åˆ°æ–‡æœ¬æ¶ˆæ¯: {}", text);
                
                // å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
                let response = handle_text_message(&text);
                
                if socket.send(axum::extract::ws::Message::Text(response)).await.is_err() {
                    error!("å‘é€å“åº”æ¶ˆæ¯å¤±è´¥");
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Binary(data)) => {
                info!("æ”¶åˆ°äºŒè¿›åˆ¶æ¶ˆæ¯ï¼Œé•¿åº¦: {} å­—èŠ‚", data.len());
                
                // å›æ˜¾äºŒè¿›åˆ¶æ•°æ®
                if socket.send(axum::extract::ws::Message::Binary(data)).await.is_err() {
                    error!("å‘é€äºŒè¿›åˆ¶å“åº”å¤±è´¥");
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Close(_)) => {
                info!("å®¢æˆ·ç«¯ä¸»åŠ¨å…³é—­è¿æ¥");
                break;
            }
            Ok(axum::extract::ws::Message::Ping(data)) => {
                info!("æ”¶åˆ° Ping æ¶ˆæ¯");
                if socket.send(axum::extract::ws::Message::Pong(data)).await.is_err() {
                    error!("å‘é€ Pong å“åº”å¤±è´¥");
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Pong(_)) => {
                info!("æ”¶åˆ° Pong æ¶ˆæ¯");
            }
            Err(e) => {
                error!("WebSocket é”™è¯¯: {}", e);
                break;
            }
        }
    }
    
    info!("WebSocket è¿æ¥å·²å…³é—­");
}

// å¤„ç†æ–‡æœ¬æ¶ˆæ¯çš„ä¸šåŠ¡é€»è¾‘
fn handle_text_message(text: &str) -> String {
    match text.trim().to_lowercase().as_str() {
        "hello" | "hi" => "ä½ å¥½ï¼æˆ‘æ˜¯ WebSocket æœåŠ¡å™¨".to_string(),
        "time" => {
            use std::time::{SystemTime, UNIX_EPOCH};
            let timestamp = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();
            format!("å½“å‰æ—¶é—´æˆ³: {}", timestamp)
        }
        "ping" => "pong".to_string(),
        "help" => {
            "å¯ç”¨å‘½ä»¤:\n- hello: é—®å€™\n- time: è·å–æ—¶é—´\n- ping: æµ‹è¯•è¿æ¥\n- help: æ˜¾ç¤ºå¸®åŠ©".to_string()
        }
        _ => format!("æ”¶åˆ°æ¶ˆæ¯: {} (é•¿åº¦: {} å­—ç¬¦)", text, text.len()),
    }
}</pre>

        <p><strong>æ­¥éª¤ 3: åˆ›å»ºæµ‹è¯•é¡µé¢</strong></p>
        <p><strong>åˆ›å»º static/index.htmlï¼š</strong></p>
        <pre>mkdir static</pre>
        
        <p><strong>static/index.html å†…å®¹ï¼š</strong></p>
        <pre>&lt;!DOCTYPE html>
&lt;html lang="zh-CN">
&lt;head>
    &lt;meta charset="UTF-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
    &lt;title>WebSocket æµ‹è¯•é¡µé¢&lt;/title>
    &lt;style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .connected { background-color: #d4edda; color: #155724; }
        .disconnected { background-color: #f8d7da; color: #721c24; }
        .connecting { background-color: #fff3cd; color: #856404; }
        #messages {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            background-color: #fafafa;
            font-family: monospace;
        }
        .message {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        .sent { background-color: #e3f2fd; text-align: right; }
        .received { background-color: #f1f8e9; }
        .system { background-color: #fff3e0; font-style: italic; }
        input[type="text"] {
            width: 70%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .connect-btn { background-color: #28a745; color: white; }
        .disconnect-btn { background-color: #dc3545; color: white; }
        .send-btn { background-color: #007bff; color: white; }
        .clear-btn { background-color: #6c757d; color: white; }
    &lt;/style>
&lt;/head>
&lt;body>
    &lt;div class="container">
        &lt;h1>WebSocket æµ‹è¯•é¡µé¢&lt;/h1>
        
        &lt;div class="controls">
            &lt;div id="status" class="status disconnected">æœªè¿æ¥&lt;/div>
            
            &lt;div>
                &lt;input type="text" id="wsUrl" value="ws://localhost:3000/ws" placeholder="WebSocket URL">
                &lt;button id="connectBtn" class="connect-btn">è¿æ¥&lt;/button>
                &lt;button id="disconnectBtn" class="disconnect-btn" disabled>æ–­å¼€&lt;/button>
            &lt;/div>
        &lt;/div>
        
        &lt;div id="messages">&lt;/div>
        
        &lt;div class="input-area">
            &lt;input type="text" id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯..." disabled>
            &lt;button id="sendBtn" class="send-btn" disabled>å‘é€&lt;/button>
            &lt;button id="clearBtn" class="clear-btn">æ¸…ç©º&lt;/button>
        &lt;/div>
        
        &lt;div class="quick-commands">
            &lt;h3>å¿«é€Ÿå‘½ä»¤ï¼š&lt;/h3>
            &lt;button class="send-btn" onclick="sendQuickMessage('hello')">Hello&lt;/button>
            &lt;button class="send-btn" onclick="sendQuickMessage('time')">è·å–æ—¶é—´&lt;/button>
            &lt;button class="send-btn" onclick="sendQuickMessage('ping')">Ping&lt;/button>
            &lt;button class="send-btn" onclick="sendQuickMessage('help')">å¸®åŠ©&lt;/button>
        &lt;/div>
    &lt;/div>

    &lt;script>
        let ws = null;
        const status = document.getElementById('status');
        const messages = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const wsUrl = document.getElementById('wsUrl');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const sendBtn = document.getElementById('sendBtn');
        const clearBtn = document.getElementById('clearBtn');

        function addMessage(content, type = 'system') {
            const div = document.createElement('div');
            div.className = `message ${type}`;
            div.innerHTML = `&lt;span class="time">[${new Date().toLocaleTimeString()}]&lt;/span> ${content}`;
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
        }

        function updateStatus(text, className) {
            status.textContent = text;
            status.className = `status ${className}`;
        }

        function connect() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                addMessage('å·²ç»è¿æ¥äº†ï¼', 'system');
                return;
            }

            const url = wsUrl.value.trim();
            if (!url) {
                addMessage('è¯·è¾“å…¥ WebSocket URL', 'system');
                return;
            }

            updateStatus('è¿æ¥ä¸­...', 'connecting');
            addMessage(`æ­£åœ¨è¿æ¥ ${url}...`, 'system');

            ws = new WebSocket(url);

            ws.onopen = function(event) {
                updateStatus('å·²è¿æ¥', 'connected');
                addMessage('WebSocket è¿æ¥æˆåŠŸï¼', 'system');
                
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                messageInput.disabled = false;
                sendBtn.disabled = false;
            };

            ws.onmessage = function(event) {
                addMessage(event.data, 'received');
            };

            ws.onclose = function(event) {
                updateStatus('æœªè¿æ¥', 'disconnected');
                addMessage(`è¿æ¥å·²å…³é—­ (ä»£ç : ${event.code})`, 'system');
                
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                messageInput.disabled = true;
                sendBtn.disabled = true;
            };

            ws.onerror = function(error) {
                updateStatus('è¿æ¥é”™è¯¯', 'disconnected');
                addMessage('WebSocket è¿æ¥å‡ºé”™', 'system');
                console.error('WebSocketé”™è¯¯:', error);
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
            }
        }

        function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(message);
                addMessage(message, 'sent');
                messageInput.value = '';
            } else {
                addMessage('æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'system');
            }
        }

        function sendQuickMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(message);
                addMessage(message, 'sent');
            } else {
                addMessage('æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'system');
            }
        }

        function clearMessages() {
            messages.innerHTML = '';
        }

        // äº‹ä»¶ç›‘å¬
        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);
        sendBtn.addEventListener('click', sendMessage);
        clearBtn.addEventListener('click', clearMessages);

        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆåçš„æç¤º
        addMessage('é¡µé¢åŠ è½½å®Œæˆï¼Œç‚¹å‡»"è¿æ¥"æŒ‰é’®å¼€å§‹æµ‹è¯•', 'system');
    &lt;/script>
&lt;/body>
&lt;/html></pre>

        <p><strong>æ­¥éª¤ 4: æ”¹è¿›ç‰ˆ main.rsï¼ˆæ”¯æŒé™æ€æ–‡ä»¶æœåŠ¡ï¼‰</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade},
    http::StatusCode,
    response::Html,
    routing::get,
    Router,
};
use std::net::SocketAddr;
use tokio::net::TcpListener;
use tower::ServiceBuilder;
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{info, warn, error};

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .init();
    
    // æ„å»ºåº”ç”¨è·¯ç”±
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .nest_service("/static", ServeDir::new("static"))
        .layer(
            ServiceBuilder::new()
                .layer(CorsLayer::permissive())
        );
    
    // å¯åŠ¨æœåŠ¡å™¨
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!("ğŸš€ WebSocket æœåŠ¡å™¨å¯åŠ¨åœ¨ http://{}", addr);
    info!("ğŸ“¡ WebSocket ç«¯ç‚¹: ws://{}/ws", addr);
    info!("ğŸŒ æµ‹è¯•é¡µé¢: http://{}/", addr);
    
    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// ä¸»é¡µå¤„ç†å™¨
async fn index_handler() -> Result<Html<String>, StatusCode> {
    match tokio::fs::read_to_string("static/index.html").await {
        Ok(content) => Ok(Html(content)),
        Err(_) => Ok(Html(r#"
&lt;h1>WebSocket æœåŠ¡å™¨&lt;/h1>
&lt;p>è¯·åœ¨æµè§ˆå™¨ä¸­è®¿é—® ws://localhost:3000/ws&lt;/p>
&lt;script>
const ws = new WebSocket('ws://localhost:3000/ws');
ws.onopen = () => console.log('è¿æ¥æˆåŠŸ');
ws.onmessage = (e) => console.log('æ”¶åˆ°æ¶ˆæ¯:', e.data);
ws.onclose = () => console.log('è¿æ¥å…³é—­');
&lt;/script>
        "#.to_string())),
    }
}

// WebSocket å‡çº§å¤„ç†å™¨
async fn websocket_handler(ws: WebSocketUpgrade) -> axum::response::Response {
    info!("ğŸ”— æ”¶åˆ° WebSocket å‡çº§è¯·æ±‚");
    ws.on_upgrade(handle_websocket)
}

// å¤„ç† WebSocket è¿æ¥
async fn handle_websocket(mut socket: WebSocket) {
    let client_id = uuid::Uuid::new_v4().to_string()[..8].to_string();
    info!("âœ… WebSocket è¿æ¥å·²å»ºç«‹ï¼Œå®¢æˆ·ç«¯ ID: {}", client_id);
    
    // å‘é€æ¬¢è¿æ¶ˆæ¯
    let welcome_msg = format!("ğŸ‰ æ¬¢è¿è¿æ¥ WebSocket æœåŠ¡å™¨ï¼\nå®¢æˆ·ç«¯ ID: {}\nè¾“å…¥ 'help' æŸ¥çœ‹å¯ç”¨å‘½ä»¤", client_id);
    if socket.send(axum::extract::ws::Message::Text(welcome_msg)).await.is_err() {
        error!("âŒ å‘é€æ¬¢è¿æ¶ˆæ¯å¤±è´¥ï¼Œå®¢æˆ·ç«¯: {}", client_id);
        return;
    }
    
    // æ¶ˆæ¯è®¡æ•°å™¨
    let mut message_count = 0;
    
    // æŒç»­å¤„ç†æ¶ˆæ¯
    while let Some(msg) = socket.recv().await {
        message_count += 1;
        
        match msg {
            Ok(axum::extract::ws::Message::Text(text)) => {
                info!("ğŸ“© å®¢æˆ·ç«¯ {} å‘é€æ¶ˆæ¯ (#{}) : {}", client_id, message_count, text);
                
                // å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
                let response = handle_text_message(&text, &client_id, message_count);
                
                if socket.send(axum::extract::ws::Message::Text(response)).await.is_err() {
                    error!("âŒ å‘é€å“åº”æ¶ˆæ¯å¤±è´¥ï¼Œå®¢æˆ·ç«¯: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Binary(data)) => {
                info!("ğŸ“¦ å®¢æˆ·ç«¯ {} å‘é€äºŒè¿›åˆ¶æ¶ˆæ¯ï¼Œé•¿åº¦: {} å­—èŠ‚", client_id, data.len());
                
                // åˆ›å»ºå“åº”æ¶ˆæ¯
                let response = format!("âœ… æ”¶åˆ° {} å­—èŠ‚çš„äºŒè¿›åˆ¶æ•°æ®", data.len());
                if socket.send(axum::extract::ws::Message::Text(response)).await.is_err() {
                    error!("âŒ å‘é€äºŒè¿›åˆ¶å“åº”å¤±è´¥ï¼Œå®¢æˆ·ç«¯: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Close(close_frame)) => {
                info!("ğŸ‘‹ å®¢æˆ·ç«¯ {} ä¸»åŠ¨å…³é—­è¿æ¥: {:?}", client_id, close_frame);
                break;
            }
            Ok(axum::extract::ws::Message::Ping(data)) => {
                info!("ğŸ“ æ”¶åˆ°å®¢æˆ·ç«¯ {} çš„ Ping æ¶ˆæ¯", client_id);
                if socket.send(axum::extract::ws::Message::Pong(data)).await.is_err() {
                    error!("âŒ å‘é€ Pong å“åº”å¤±è´¥ï¼Œå®¢æˆ·ç«¯: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Pong(_)) => {
                info!("ğŸ“ æ”¶åˆ°å®¢æˆ·ç«¯ {} çš„ Pong æ¶ˆæ¯", client_id);
            }
            Err(e) => {
                error!("ğŸ’¥ WebSocket é”™è¯¯ï¼Œå®¢æˆ·ç«¯ {}: {}", client_id, e);
                break;
            }
        }
    }
    
    info!("ğŸ”Œ WebSocket è¿æ¥å·²å…³é—­ï¼Œå®¢æˆ·ç«¯: {} (å…±å¤„ç† {} æ¡æ¶ˆæ¯)", client_id, message_count);
}

// å¤„ç†æ–‡æœ¬æ¶ˆæ¯çš„ä¸šåŠ¡é€»è¾‘
fn handle_text_message(text: &str, client_id: &str, message_count: usize) -> String {
    let command = text.trim().to_lowercase();
    
    match command.as_str() {
        "hello" | "hi" | "ä½ å¥½" => {
            format!("ğŸ‘‹ ä½ å¥½ï¼æˆ‘æ˜¯ WebSocket æœåŠ¡å™¨\nå®¢æˆ·ç«¯ ID: {}\nè¿™æ˜¯ä½ å‘é€çš„ç¬¬ {} æ¡æ¶ˆæ¯", client_id, message_count)
        }
        "time" | "æ—¶é—´" => {
            use chrono::{Local, Utc};
            format!("ğŸ•’ å½“å‰æ—¶é—´ä¿¡æ¯:\næœ¬åœ°æ—¶é—´: {}\nUTC æ—¶é—´: {}\næ—¶é—´æˆ³: {}", 
                Local::now().format("%Y-%m-%d %H:%M:%S"),
                Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
                std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_secs()
            )
        }
        "ping" => "ğŸ“ pong".to_string(),
        "status" | "çŠ¶æ€" => {
            format!("ğŸ“Š è¿æ¥çŠ¶æ€:\nâœ… è¿æ¥æ­£å¸¸\nğŸ“¨ å·²å¤„ç†æ¶ˆæ¯: {} æ¡\nğŸ†” å®¢æˆ·ç«¯ ID: {}", message_count, client_id)
        }
        "help" | "å¸®åŠ©" => {
            "ğŸ“š å¯ç”¨å‘½ä»¤:\n\
            â€¢ hello/hi/ä½ å¥½ - é—®å€™æœåŠ¡å™¨\n\
            â€¢ time/æ—¶é—´ - è·å–å½“å‰æ—¶é—´\n\
            â€¢ ping - æµ‹è¯•è¿æ¥\n\
            â€¢ status/çŠ¶æ€ - æŸ¥çœ‹è¿æ¥çŠ¶æ€\n\
            â€¢ help/å¸®åŠ© - æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯\n\
            â€¢ echo <æ¶ˆæ¯> - å›æ˜¾æ¶ˆæ¯\n\
            â€¢ count - æ˜¾ç¤ºæ¶ˆæ¯è®¡æ•°\n\
            \nğŸ’¡ ä½ ä¹Ÿå¯ä»¥å‘é€ä»»æ„æ–‡æœ¬ï¼ŒæœåŠ¡å™¨ä¼šå›å¤ç¡®è®¤ä¿¡æ¯".to_string()
        }
        _ if command.starts_with("echo ") => {
            let echo_text = &text[5..];
            format!("ğŸ”Š å›æ˜¾: {}", echo_text)
        }
        "count" | "è®¡æ•°" => {
            format!("ğŸ”¢ æ¶ˆæ¯è®¡æ•°: è¿™æ˜¯ä½ å‘é€çš„ç¬¬ {} æ¡æ¶ˆæ¯", message_count)
        }
        _ => {
            format!("ğŸ“ æ”¶åˆ°æ¶ˆæ¯: \"{}\"\nğŸ“ æ¶ˆæ¯é•¿åº¦: {} å­—ç¬¦\nğŸ”¢ æ¶ˆæ¯ç¼–å·: #{}\n\nğŸ’¡ è¾“å…¥ 'help' æŸ¥çœ‹å¯ç”¨å‘½ä»¤", 
                text, text.len(), message_count)
        }
    }
}

// æ·»åŠ  UUID ä¾èµ–ä»¥ç”Ÿæˆå®¢æˆ·ç«¯ ID
// åœ¨ Cargo.toml ä¸­æ·»åŠ : uuid = { version = "1.0", features = ["v4"] }
// chrono = { version = "0.4", features = ["serde"] }</pre>

        <p><strong>æ­¥éª¤ 5: æ›´æ–°ä¾èµ–å¹¶æµ‹è¯•</strong></p>
        <pre># æ›´æ–° Cargo.toml æ·»åŠ æ–°ä¾èµ–
[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.20"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }</pre>

        <p><strong>è¿è¡Œæµ‹è¯•ï¼š</strong></p>
        <pre># å¯åŠ¨æœåŠ¡å™¨
cargo run

# åœ¨å¦ä¸€ä¸ªç»ˆç«¯ä½¿ç”¨ websocat æµ‹è¯•ï¼ˆå¦‚æœå·²å®‰è£…ï¼‰
websocat ws://localhost:3000/ws

# æˆ–è€…åœ¨æµè§ˆå™¨ä¸­è®¿é—® http://localhost:3000</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>å®ç°ä¸€ä¸ªç®€å•çš„å‘½ä»¤ç³»ç»Ÿï¼Œæ”¯æŒå¤šç§æŒ‡ä»¤å“åº”</li>
            <li>æ·»åŠ è¿æ¥è®¡æ•°åŠŸèƒ½ï¼Œæ˜¾ç¤ºå½“å‰æ´»è·ƒè¿æ¥æ•°</li>
            <li>å®ç°æ¶ˆæ¯å†å²è®°å½•åŠŸèƒ½</li>
            <li>æ·»åŠ å¿ƒè·³æ£€æµ‹æœºåˆ¶</li>
            <li>åˆ›å»ºä¸€ä¸ªç®€å•çš„ Web æµ‹è¯•ç•Œé¢</li>
        </ul>

        <p><strong>æ­¥éª¤ 6: å‘½ä»¤è¡Œå®¢æˆ·ç«¯æµ‹è¯•å·¥å…·</strong></p>
        <p><strong>åˆ›å»º client.rsï¼š</strong></p>
        <pre>// src/client.rs
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};
use futures_util::{SinkExt, StreamExt};
use std::io::{self, Write};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸš€ WebSocket å®¢æˆ·ç«¯å¯åŠ¨");
    
    let url = "ws://127.0.0.1:3000/ws";
    println!("ğŸ”— è¿æ¥åˆ°: {}", url);
    
    let (ws_stream, _) = connect_async(url).await?;
    println!("âœ… WebSocket è¿æ¥æˆåŠŸï¼");
    
    let (mut write, mut read) = ws_stream.split();
    
    // å¯åŠ¨æ¥æ”¶æ¶ˆæ¯çš„ä»»åŠ¡
    let read_handle = tokio::spawn(async move {
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    println!("ğŸ“© æœåŠ¡å™¨: {}", text);
                }
                Ok(Message::Binary(data)) => {
                    println!("ğŸ“¦ æ”¶åˆ°äºŒè¿›åˆ¶æ•°æ®: {} å­—èŠ‚", data.len());
                }
                Ok(Message::Close(_)) => {
                    println!("ğŸ‘‹ æœåŠ¡å™¨å…³é—­äº†è¿æ¥");
                    break;
                }
                Err(e) => {
                    println!("âŒ æ¥æ”¶æ¶ˆæ¯é”™è¯¯: {}", e);
                    break;
                }
                _ => {}
            }
        }
    });
    
    // ä¸»çº¿ç¨‹å¤„ç†ç”¨æˆ·è¾“å…¥
    println!("\nğŸ’¡ è¾“å…¥æ¶ˆæ¯å¹¶æŒ‰å›è½¦å‘é€ï¼Œè¾“å…¥ 'quit' é€€å‡º");
    println!("ğŸ“š å¯ç”¨å‘½ä»¤: hello, time, ping, status, help, echo <æ¶ˆæ¯>");
    
    loop {
        print!("ğŸ‘¤ ä½ : ");
        io::stdout().flush().unwrap();
        
        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();
        
        if input == "quit" || input == "exit" {
            break;
        }
        
        if !input.is_empty() {
            if write.send(Message::Text(input.to_string())).await.is_err() {
                println!("âŒ å‘é€æ¶ˆæ¯å¤±è´¥");
                break;
            }
        }
    }
    
    println!("ğŸ‘‹ æ­£åœ¨å…³é—­è¿æ¥...");
    let _ = write.send(Message::Close(None)).await;
    read_handle.abort();
    
    Ok(())
}</pre>

        <p><strong>ç¼–è¯‘å¹¶è¿è¡Œå®¢æˆ·ç«¯ï¼š</strong></p>
        <pre># ç¼–è¯‘å®¢æˆ·ç«¯
rustc --edition 2021 src/client.rs -o client \
  --extern tokio_tungstenite \
  --extern tokio \
  --extern futures_util

# æˆ–è€…æ·»åŠ åˆ° Cargo.toml çš„ [[bin]] éƒ¨åˆ†
[[bin]]
name = "client"
path = "src/client.rs"

# ç„¶åè¿è¡Œ
cargo run --bin client</pre>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day15_websocket_basic/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â””â”€â”€ client.rs
â”œâ”€â”€ static/
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-16</strong></p>
        <h2>Day 16 - WebSocket Echo å®ç°</h2>
        <p>ä½ å°†å†™ä¸€ä¸ªå®Œæ•´çš„ Echo æœåŠ¡ï¼šå®¢æˆ·ç«¯å‘ä»€ä¹ˆï¼ŒæœåŠ¡ç«¯è¿”å›ä»€ä¹ˆï¼Œå¹¶æ”¯æŒæŒç»­é€šä¿¡ï¼Œç›´åˆ°å®¢æˆ·ç«¯æ–­å¼€è¿æ¥ã€‚</p>
        <p>ğŸ”— <a href="https://github.com/tokio-rs/axum/blob/main/examples/websockets/chat.rs" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®å¹¶é…ç½®ä¾èµ–</strong></p>
        <pre>cargo new day16_websocket_echo
cd day16_websocket_echo</pre>

        <p><strong>é…ç½® Cargo.tomlï¼š</strong></p>
        <pre>[package]
name = "day16_websocket_echo"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.20"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
futures-util = "0.3"

[[bin]]
name = "server"
path = "src/main.rs"

[[bin]]
name = "client"
path = "src/client.rs"</pre>

        <p><strong>æ­¥éª¤ 2: å®ç° Echo WebSocket æœåŠ¡å™¨</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade},
    http::StatusCode,
    response::Html,
    routing::get,
    Router,
};
use futures_util::{SinkExt, StreamExt};
use std::{net::SocketAddr, sync::atomic::{AtomicUsize, Ordering}};
use tokio::net::TcpListener;
use tower::ServiceBuilder;
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{info, warn, error, debug};

// å…¨å±€è¿æ¥è®¡æ•°å™¨
static CONNECTED_USERS: AtomicUsize = AtomicUsize::new(0);

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .with_level(true)
        .init();
    
    // æ„å»ºåº”ç”¨è·¯ç”±
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .route("/stats", get(stats_handler))
        .nest_service("/static", ServeDir::new("static"))
        .layer(
            ServiceBuilder::new()
                .layer(CorsLayer::permissive())
        );
    
    // å¯åŠ¨æœåŠ¡å™¨
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!("ğŸš€ WebSocket Echo æœåŠ¡å™¨å¯åŠ¨åœ¨ http://{}", addr);
    info!("ğŸ“¡ WebSocket ç«¯ç‚¹: ws://{}/ws", addr);
    info!("ğŸŒ æµ‹è¯•é¡µé¢: http://{}/", addr);
    info!("ğŸ“Š ç»Ÿè®¡é¡µé¢: http://{}/stats", addr);
    
    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// ä¸»é¡µå¤„ç†å™¨
async fn index_handler() -> Html<&'static str> {
    Html(include_str!("../templates/echo.html"))
}

// ç»Ÿè®¡é¡µé¢å¤„ç†å™¨
async fn stats_handler() -> Result<axum::Json<serde_json::Value>, StatusCode> {
    let stats = serde_json::json!({
        "connected_users": CONNECTED_USERS.load(Ordering::Relaxed),
        "server_uptime": chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC").to_string(),
        "service_type": "WebSocket Echo Server"
    });
    Ok(axum::Json(stats))
}

// WebSocket å‡çº§å¤„ç†å™¨
async fn websocket_handler(ws: WebSocketUpgrade) -> axum::response::Response {
    let current_connections = CONNECTED_USERS.fetch_add(1, Ordering::Relaxed) + 1;
    info!("ğŸ”— æ”¶åˆ° WebSocket å‡çº§è¯·æ±‚ (å½“å‰è¿æ¥æ•°: {})", current_connections);
    ws.on_upgrade(handle_websocket)
}

// å¤„ç† WebSocket è¿æ¥ - Echo å®ç°
async fn handle_websocket(socket: WebSocket) {
    let client_id = uuid::Uuid::new_v4().to_string()[..8].to_string();
    let connected_time = chrono::Utc::now();
    info!("âœ… Echo è¿æ¥å·²å»ºç«‹ï¼Œå®¢æˆ·ç«¯ ID: {} (è¿æ¥æ—¶é—´: {})", 
          client_id, connected_time.format("%H:%M:%S"));
    
    // åˆ†ç¦» socket ä¸ºå‘é€å’Œæ¥æ”¶éƒ¨åˆ†
    let (mut sender, mut receiver) = socket.split();
    
    // å‘é€æ¬¢è¿æ¶ˆæ¯
    let welcome_msg = serde_json::json!({
        "type": "welcome",
        "client_id": client_id,
        "message": "ğŸ‰ æ¬¢è¿è¿æ¥ WebSocket Echo æœåŠ¡å™¨ï¼",
        "server_time": chrono::Utc::now().to_rfc3339(),
        "instructions": "å‘é€ä»»ä½•æ¶ˆæ¯ï¼ŒæœåŠ¡å™¨å°†åŸæ ·è¿”å›ã€‚å‘é€ JSON å¯è·å¾—ç»“æ„åŒ–å“åº”ã€‚"
    });
    
    if sender.send(axum::extract::ws::Message::Text(
        serde_json::to_string(&welcome_msg).unwrap()
    )).await.is_err() {
        error!("âŒ å‘é€æ¬¢è¿æ¶ˆæ¯å¤±è´¥ï¼Œå®¢æˆ·ç«¯: {}", client_id);
        CONNECTED_USERS.fetch_sub(1, Ordering::Relaxed);
        return;
    }
    
    // æ¶ˆæ¯ç»Ÿè®¡
    let mut messages_echoed = 0;
    let mut bytes_processed = 0;
    
    // Echo æ¶ˆæ¯å¾ªç¯
    while let Some(msg) = receiver.next().await {
        match msg {
            Ok(axum::extract::ws::Message::Text(text)) => {
                debug!("ğŸ“© å®¢æˆ·ç«¯ {} å‘é€æ–‡æœ¬: {}", client_id, text);
                messages_echoed += 1;
                bytes_processed += text.len();
                
                // å°è¯•è§£æä¸º JSONï¼Œå¦‚æœæ˜¯ JSON åˆ™å¢å¼ºå“åº”
                let echo_response = if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(&text) {
                    // JSON æ¶ˆæ¯çš„å¢å¼ºå›æ˜¾
                    let enhanced_response = serde_json::json!({
                        "type": "json_echo",
                        "client_id": client_id,
                        "echo_count": messages_echoed,
                        "original_message": json_value,
                        "message_size": text.len(),
                        "server_time": chrono::Utc::now().to_rfc3339(),
                        "processing_info": {
                            "is_json": true,
                            "json_valid": true
                        }
                    });
                    serde_json::to_string(&enhanced_response).unwrap()
                } else {
                    // æ™®é€šæ–‡æœ¬æ¶ˆæ¯çš„ç®€å•å›æ˜¾
                    let simple_response = serde_json::json!({
                        "type": "text_echo", 
                        "client_id": client_id,
                        "echo_count": messages_echoed,
                        "original_message": text,
                        "message_size": text.len(),
                        "server_time": chrono::Utc::now().to_rfc3339(),
                        "processing_info": {
                            "is_json": false,
                            "message_type": "plain_text"
                        }
                    });
                    serde_json::to_string(&simple_response).unwrap()
                };
                
                if sender.send(axum::extract::ws::Message::Text(echo_response)).await.is_err() {
                    error!("âŒ Echo å“åº”å‘é€å¤±è´¥ï¼Œå®¢æˆ·ç«¯: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Binary(data)) => {
                debug!("ğŸ“¦ å®¢æˆ·ç«¯ {} å‘é€äºŒè¿›åˆ¶æ•°æ®: {} å­—èŠ‚", client_id, data.len());
                messages_echoed += 1;
                bytes_processed += data.len();
                
                // äºŒè¿›åˆ¶æ•°æ®çš„ Echo å“åº”ï¼ˆåŒ…å«å…ƒæ•°æ®ï¼‰
                let binary_info = serde_json::json!({
                    "type": "binary_echo_info",
                    "client_id": client_id,
                    "echo_count": messages_echoed,
                    "data_size": data.len(),
                    "server_time": chrono::Utc::now().to_rfc3339(),
                    "note": "äºŒè¿›åˆ¶æ•°æ®å·²åŸæ ·è¿”å›"
                });
                
                // å…ˆå‘é€ä¿¡æ¯ï¼Œå†å‘é€åŸå§‹äºŒè¿›åˆ¶æ•°æ®
                if sender.send(axum::extract::ws::Message::Text(
                    serde_json::to_string(&binary_info).unwrap()
                )).await.is_err() {
                    error!("âŒ äºŒè¿›åˆ¶ä¿¡æ¯å‘é€å¤±è´¥ï¼Œå®¢æˆ·ç«¯: {}", client_id);
                    break;
                }
                
                if sender.send(axum::extract::ws::Message::Binary(data)).await.is_err() {
                    error!("âŒ äºŒè¿›åˆ¶æ•°æ® Echo å¤±è´¥ï¼Œå®¢æˆ·ç«¯: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Close(close_frame)) => {
                info!("ğŸ‘‹ å®¢æˆ·ç«¯ {} ä¸»åŠ¨å…³é—­è¿æ¥: {:?}", client_id, close_frame);
                break;
            }
            Ok(axum::extract::ws::Message::Ping(data)) => {
                debug!("ğŸ“ æ”¶åˆ°å®¢æˆ·ç«¯ {} çš„ Ping", client_id);
                if sender.send(axum::extract::ws::Message::Pong(data)).await.is_err() {
                    error!("âŒ Pong å“åº”å¤±è´¥ï¼Œå®¢æˆ·ç«¯: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Pong(_)) => {
                debug!("ğŸ“ æ”¶åˆ°å®¢æˆ·ç«¯ {} çš„ Pong", client_id);
            }
            Err(e) => {
                error!("ğŸ’¥ WebSocket é”™è¯¯ï¼Œå®¢æˆ·ç«¯ {}: {}", client_id, e);
                break;
            }
        }
    }
    
    // è¿æ¥ç»“æŸç»Ÿè®¡
    let session_duration = chrono::Utc::now() - connected_time;
    let remaining_connections = CONNECTED_USERS.fetch_sub(1, Ordering::Relaxed) - 1;
    
    info!("ğŸ”Œ Echo è¿æ¥å·²å…³é—­ï¼Œå®¢æˆ·ç«¯: {} | ä¼šè¯æ—¶é•¿: {}ç§’ | æ¶ˆæ¯æ•°: {} | å¤„ç†å­—èŠ‚: {} | å‰©ä½™è¿æ¥: {}", 
          client_id, 
          session_duration.num_seconds(),
          messages_echoed,
          bytes_processed,
          remaining_connections
    );
}</pre>

        <p><strong>æ­¥éª¤ 3: åˆ›å»ºæµ‹è¯•é¡µé¢</strong></p>
        <p><strong>åˆ›å»º templates/echo.htmlï¼š</strong></p>
        <pre>mkdir templates</pre>
        
        <p><strong>templates/echo.html å†…å®¹ï¼š</strong></p>
        <pre>&lt;!DOCTYPE html>
&lt;html lang="zh-CN">
&lt;head>
    &lt;meta charset="UTF-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
    &lt;title>WebSocket Echo æµ‹è¯•&lt;/title>
    &lt;style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
        }
        .status {
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
        }
        .connected { background: linear-gradient(135deg, #4CAF50, #45a049); color: white; }
        .disconnected { background: linear-gradient(135deg, #f44336, #da190b); color: white; }
        .connecting { background: linear-gradient(135deg, #ff9800, #f57c00); color: white; }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
            align-items: center;
        }
        input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .connect-btn { background: linear-gradient(135deg, #28a745, #20c997); color: white; }
        .disconnect-btn { background: linear-gradient(135deg, #dc3545, #c82333); color: white; }
        .send-btn { background: linear-gradient(135deg, #007bff, #0056b3); color: white; }
        .clear-btn { background: linear-gradient(135deg, #6c757d, #545b62); color: white; }
        .json-btn { background: linear-gradient(135deg, #17a2b8, #138496); color: white; }
        #messages {
            height: 400px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
            padding: 15px;
            margin: 20px 0;
            background: #f8f9fa;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            border-radius: 8px;
        }
        .message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 6px;
            word-wrap: break-word;
        }
        .sent { 
            background: linear-gradient(135deg, #e3f2fd, #bbdefb); 
            text-align: right; 
            border-left: 4px solid #2196F3;
        }
        .received { 
            background: linear-gradient(135deg, #f1f8e9, #c8e6c9); 
            border-left: 4px solid #4CAF50;
        }
        .system { 
            background: linear-gradient(135deg, #fff3e0, #ffe0b2); 
            font-style: italic; 
            border-left: 4px solid #FF9800;
        }
        .json-display {
            background: #2d3748;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 6px;
            margin: 5px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            white-space: pre-wrap;
            font-size: 12px;
        }
        .quick-commands {
            margin: 20px 0;
        }
        .quick-commands h3 {
            color: #495057;
            margin-bottom: 15px;
        }
        .command-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
    &lt;/style>
&lt;/head>
&lt;body>
    &lt;div class="container">
        &lt;h1>ğŸ”„ WebSocket Echo æœåŠ¡å™¨æµ‹è¯•&lt;/h1>
        
        &lt;div class="stats">
            &lt;div class="stat-item">
                &lt;div class="stat-value" id="messageCount">0&lt;/div>
                &lt;div class="stat-label">æ¶ˆæ¯æ•°é‡&lt;/div>
            &lt;/div>
            &lt;div class="stat-item">
                &lt;div class="stat-value" id="byteCount">0&lt;/div>
                &lt;div class="stat-label">å­—èŠ‚ä¼ è¾“&lt;/div>
            &lt;/div>
            &lt;div class="stat-item">
                &lt;div class="stat-value" id="connectionTime">00:00&lt;/div>
                &lt;div class="stat-label">è¿æ¥æ—¶é•¿&lt;/div>
            &lt;/div>
        &lt;/div>
        
        &lt;div id="status" class="status disconnected">æœªè¿æ¥åˆ°æœåŠ¡å™¨&lt;/div>
        
        &lt;div class="controls">
            &lt;input type="text" id="wsUrl" value="ws://localhost:3000/ws" placeholder="WebSocket URL">
            &lt;button id="connectBtn" class="connect-btn">ğŸ”— è¿æ¥&lt;/button>
            &lt;button id="disconnectBtn" class="disconnect-btn" disabled>ğŸ”Œ æ–­å¼€&lt;/button>
        &lt;/div>
        
        &lt;div id="messages">&lt;/div>
        
        &lt;div class="controls">
            &lt;input type="text" id="messageInput" placeholder="è¾“å…¥è¦å›æ˜¾çš„æ¶ˆæ¯..." disabled>
            &lt;button id="sendBtn" class="send-btn" disabled>ğŸ“¤ å‘é€&lt;/button>
            &lt;button id="clearBtn" class="clear-btn">ğŸ—‘ï¸ æ¸…ç©º&lt;/button>
        &lt;/div>
        
        &lt;div class="quick-commands">
            &lt;h3>ğŸš€ å¿«é€Ÿæµ‹è¯•å‘½ä»¤&lt;/h3>
            &lt;div class="command-grid">
                &lt;button class="json-btn" onclick="sendPredefined('simple')">ğŸ“ ç®€å•æ–‡æœ¬&lt;/button>
                &lt;button class="json-btn" onclick="sendPredefined('json')">ğŸ“Š JSON æ¶ˆæ¯&lt;/button>
                &lt;button class="json-btn" onclick="sendPredefined('large')">ğŸ“¦ å¤§æ¶ˆæ¯&lt;/button>
                &lt;button class="json-btn" onclick="sendPredefined('unicode')">ğŸŒ Unicode&lt;/button>
                &lt;button class="json-btn" onclick="sendPredefined('structured')">ğŸ—ï¸ ç»“æ„åŒ–æ•°æ®&lt;/button>
                &lt;button class="json-btn" onclick="sendBinary()">ğŸ”¢ äºŒè¿›åˆ¶æ•°æ®&lt;/button>
            &lt;/div>
        &lt;/div>
    &lt;/div>

    &lt;script>
        let ws = null;
        let messageCount = 0;
        let byteCount = 0;
        let connectionStartTime = null;
        let timerInterval = null;

        const elements = {
            status: document.getElementById('status'),
            messages: document.getElementById('messages'),
            messageInput: document.getElementById('messageInput'),
            wsUrl: document.getElementById('wsUrl'),
            connectBtn: document.getElementById('connectBtn'),
            disconnectBtn: document.getElementById('disconnectBtn'),
            sendBtn: document.getElementById('sendBtn'),
            clearBtn: document.getElementById('clearBtn'),
            messageCountEl: document.getElementById('messageCount'),
            byteCountEl: document.getElementById('byteCount'),
            connectionTimeEl: document.getElementById('connectionTime')
        };

        function addMessage(content, type = 'system') {
            const div = document.createElement('div');
            div.className = `message ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            let displayContent = content;
            
            // å°è¯•æ ¼å¼åŒ– JSON
            if (type === 'received' && typeof content === 'string') {
                try {
                    const jsonObj = JSON.parse(content);
                    displayContent = `&lt;div class="json-display">${JSON.stringify(jsonObj, null, 2)}&lt;/div>`;
                } catch (e) {
                    // ä¸æ˜¯ JSONï¼Œä¿æŒåŸæ ·
                }
            }
            
            div.innerHTML = `&lt;span style="opacity: 0.7; font-size: 11px;">[${timestamp}]&lt;/span> ${displayContent}`;
            elements.messages.appendChild(div);
            elements.messages.scrollTop = elements.messages.scrollHeight;
        }

        function updateStatus(text, className) {
            elements.status.textContent = text;
            elements.status.className = `status ${className}`;
        }

        function updateStats() {
            elements.messageCountEl.textContent = messageCount;
            elements.byteCountEl.textContent = byteCount.toLocaleString();
            
            if (connectionStartTime) {
                const elapsed = Math.floor((Date.now() - connectionStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                elements.connectionTimeEl.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function connect() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                addMessage('å·²ç»è¿æ¥äº†ï¼', 'system');
                return;
            }

            const url = elements.wsUrl.value.trim();
            if (!url) {
                addMessage('è¯·è¾“å…¥ WebSocket URL', 'system');
                return;
            }

            updateStatus('è¿æ¥ä¸­...', 'connecting');
            addMessage(`ğŸ”— æ­£åœ¨è¿æ¥ ${url}...`, 'system');

            ws = new WebSocket(url);

            ws.onopen = function(event) {
                updateStatus('âœ… å·²è¿æ¥ - Echo æ¨¡å¼', 'connected');
                addMessage('ğŸ‰ WebSocket Echo è¿æ¥æˆåŠŸï¼æœåŠ¡å™¨å°†å›æ˜¾æ‰€æœ‰æ¶ˆæ¯', 'system');
                
                elements.connectBtn.disabled = true;
                elements.disconnectBtn.disabled = false;
                elements.messageInput.disabled = false;
                elements.sendBtn.disabled = false;
                
                connectionStartTime = Date.now();
                timerInterval = setInterval(updateStats, 1000);
            };

            ws.onmessage = function(event) {
                addMessage(event.data, 'received');
                messageCount++;
                byteCount += event.data.length;
                updateStats();
            };

            ws.onclose = function(event) {
                updateStatus('âŒ æœªè¿æ¥', 'disconnected');
                addMessage(`ğŸ”Œ è¿æ¥å·²å…³é—­ (ä»£ç : ${event.code})`, 'system');
                
                elements.connectBtn.disabled = false;
                elements.disconnectBtn.disabled = true;
                elements.messageInput.disabled = true;
                elements.sendBtn.disabled = true;
                
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
            };

            ws.onerror = function(error) {
                updateStatus('âŒ è¿æ¥é”™è¯¯', 'disconnected');
                addMessage('ğŸ’¥ WebSocket è¿æ¥å‡ºé”™', 'system');
                console.error('WebSocketé”™è¯¯:', error);
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
            }
        }

        function sendMessage() {
            const message = elements.messageInput.value.trim();
            if (!message) return;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(message);
                addMessage(message, 'sent');
                elements.messageInput.value = '';
            } else {
                addMessage('âŒ æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'system');
            }
        }

        function sendPredefined(type) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('âŒ æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'system');
                return;
            }

            let message;
            switch (type) {
                case 'simple':
                    message = 'Hello, WebSocket Echo Server! ğŸŒŸ';
                    break;
                case 'json':
                    message = JSON.stringify({
                        type: 'test_message',
                        timestamp: new Date().toISOString(),
                        data: { hello: 'world', numbers: [1, 2, 3] }
                    });
                    break;
                case 'large':
                    message = 'A'.repeat(1000) + ' - This is a large message for testing!';
                    break;
                case 'unicode':
                    message = 'ğŸŒŸ Hello ä¸–ç•Œ ğŸš€ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€ ğŸ‰ Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù… ğŸŒˆ';
                    break;
                case 'structured':
                    message = JSON.stringify({
                        user: 'test_user',
                        action: 'echo_test',
                        timestamp: Date.now(),
                        metadata: {
                            client: 'web_browser',
                            version: '1.0.0'
                        },
                        payload: {
                            message: 'This is a structured test message',
                            tags: ['test', 'echo', 'websocket']
                        }
                    }, null, 2);
                    break;
            }

            ws.send(message);
            addMessage(message, 'sent');
        }

        function sendBinary() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('âŒ æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'system');
                return;
            }

            // åˆ›å»ºä¸€äº›äºŒè¿›åˆ¶æ•°æ®
            const data = new Uint8Array([1, 2, 3, 4, 5, 255, 254, 253]);
            ws.send(data);
            addMessage(`ğŸ“¦ å‘é€äºŒè¿›åˆ¶æ•°æ®: [${Array.from(data).join(', ')}]`, 'sent');
        }

        function clearMessages() {
            elements.messages.innerHTML = '';
            messageCount = 0;
            byteCount = 0;
            updateStats();
        }

        // äº‹ä»¶ç›‘å¬
        elements.connectBtn.addEventListener('click', connect);
        elements.disconnectBtn.addEventListener('click', disconnect);
        elements.sendBtn.addEventListener('click', sendMessage);
        elements.clearBtn.addEventListener('click', clearMessages);

        elements.messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆåçš„æç¤º
        addMessage('ğŸš€ Echo æµ‹è¯•é¡µé¢åŠ è½½å®Œæˆï¼Œç‚¹å‡»"è¿æ¥"æŒ‰é’®å¼€å§‹æµ‹è¯•', 'system');
        addMessage('ğŸ’¡ Echo æ¨¡å¼ï¼šæœåŠ¡å™¨å°†åŸæ ·è¿”å›ä½ å‘é€çš„æ‰€æœ‰æ¶ˆæ¯', 'system');
    &lt;/script>
&lt;/body>
&lt;/html></pre>

        <p><strong>æ­¥éª¤ 4: åˆ›å»ºå‘½ä»¤è¡Œæµ‹è¯•å®¢æˆ·ç«¯</strong></p>
        <p><strong>åˆ›å»º src/client.rsï¼š</strong></p>
        <pre>use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};
use futures_util::{SinkExt, StreamExt};
use std::io::{self, Write};
use serde_json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ”„ WebSocket Echo å®¢æˆ·ç«¯å¯åŠ¨");
    println!("=====================================");
    
    let url = "ws://127.0.0.1:3000/ws";
    println!("ğŸ”— è¿æ¥åˆ°: {}", url);
    
    let (ws_stream, _) = connect_async(url).await?;
    println!("âœ… WebSocket Echo è¿æ¥æˆåŠŸï¼");
    println!("ğŸ“ æœåŠ¡å™¨å°†å›æ˜¾ä½ å‘é€çš„æ‰€æœ‰æ¶ˆæ¯");
    
    let (mut write, mut read) = ws_stream.split();
    
    // å¯åŠ¨æ¥æ”¶æ¶ˆæ¯çš„ä»»åŠ¡
    let read_handle = tokio::spawn(async move {
        let mut message_count = 0;
        
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    message_count += 1;
                    println!("\nğŸ“© æœåŠ¡å™¨å›æ˜¾ (#{}):", message_count);
                    
                    // å°è¯•æ ¼å¼åŒ– JSON å“åº”
                    if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(&text) {
                        println!("{}", serde_json::to_string_pretty(&json_value).unwrap());
                    } else {
                        println!("{}", text);
                    }
                    print!("\nğŸ‘¤ ä½ : ");
                    io::stdout().flush().unwrap();
                }
                Ok(Message::Binary(data)) => {
                    message_count += 1;
                    println!("\nğŸ“¦ æœåŠ¡å™¨å›æ˜¾äºŒè¿›åˆ¶æ•°æ® (#{}): {} å­—èŠ‚", message_count, data.len());
                    println!("æ•°æ®å†…å®¹: {:?}", data);
                    print!("\nğŸ‘¤ ä½ : ");
                    io::stdout().flush().unwrap();
                }
                Ok(Message::Close(close_frame)) => {
                    println!("\nğŸ‘‹ æœåŠ¡å™¨å…³é—­äº†è¿æ¥: {:?}", close_frame);
                    break;
                }
                Ok(Message::Ping(_)) => {
                    println!("\nğŸ“ æ”¶åˆ°æœåŠ¡å™¨ Ping");
                }
                Ok(Message::Pong(_)) => {
                    println!("\nğŸ“ æ”¶åˆ°æœåŠ¡å™¨ Pong");
                }
                Err(e) => {
                    println!("\nâŒ æ¥æ”¶æ¶ˆæ¯é”™è¯¯: {}", e);
                    break;
                }
            }
        }
    });
    
    // ä¸»çº¿ç¨‹å¤„ç†ç”¨æˆ·è¾“å…¥
    println!("\nğŸ’¡ ä½¿ç”¨è¯´æ˜:");
    println!("- è¾“å…¥ä»»ä½•æ–‡æœ¬ï¼ŒæœåŠ¡å™¨å°†åŸæ ·å›æ˜¾");
    println!("- è¾“å…¥ JSON æ ¼å¼æ•°æ®å°†è·å¾—å¢å¼ºçš„ç»“æ„åŒ–å“åº”");
    println!("- è¾“å…¥ 'quit' æˆ– 'exit' é€€å‡º");
    println!("- è¾“å…¥ 'binary' å‘é€æµ‹è¯•äºŒè¿›åˆ¶æ•°æ®");
    println!("- è¾“å…¥ 'json' å‘é€æµ‹è¯• JSON æ•°æ®");
    println!("\nå¼€å§‹æµ‹è¯•:");
    
    loop {
        print!("ğŸ‘¤ ä½ : ");
        io::stdout().flush().unwrap();
        
        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();
        
        if input == "quit" || input == "exit" {
            break;
        }
        
        if input.is_empty() {
            continue;
        }
        
        // ç‰¹æ®Šå‘½ä»¤å¤„ç†
        match input {
            "binary" => {
                let test_data = vec![1u8, 2, 3, 4, 5, 255, 254, 253, 252];
                println!("ğŸ“¤ å‘é€äºŒè¿›åˆ¶æµ‹è¯•æ•°æ®: {:?}", test_data);
                if write.send(Message::Binary(test_data)).await.is_err() {
                    println!("âŒ å‘é€äºŒè¿›åˆ¶æ•°æ®å¤±è´¥");
                    break;
                }
            }
            "json" => {
                let test_json = serde_json::json!({
                    "type": "test_message",
                    "timestamp": chrono::Utc::now().to_rfc3339(),
                    "client": "rust_cli",
                    "data": {
                        "message": "è¿™æ˜¯ä¸€ä¸ªæµ‹è¯• JSON æ¶ˆæ¯",
                        "number": 42,
                        "array": [1, 2, 3, "hello", true],
                        "nested": {
                            "key": "value"
                        }
                    }
                });
                let json_string = serde_json::to_string(&test_json).unwrap();
                println!("ğŸ“¤ å‘é€ JSON æµ‹è¯•æ•°æ®");
                if write.send(Message::Text(json_string)).await.is_err() {
                    println!("âŒ å‘é€ JSON æ•°æ®å¤±è´¥");
                    break;
                }
            }
            _ => {
                // æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                if write.send(Message::Text(input.to_string())).await.is_err() {
                    println!("âŒ å‘é€æ¶ˆæ¯å¤±è´¥");
                    break;
                }
            }
        }
    }
    
    println!("ğŸ‘‹ æ­£åœ¨å…³é—­ Echo è¿æ¥...");
    let _ = write.send(Message::Close(None)).await;
    read_handle.abort();
    
    Ok(())
}</pre>

        <p><strong>æ›´æ–° Cargo.toml æ·»åŠ å®¢æˆ·ç«¯ä¾èµ–ï¼š</strong></p>
        <pre>[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.20"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
futures-util = "0.3"</pre>

        <p><strong>æ­¥éª¤ 5: é«˜çº§ Echo æœåŠ¡åŠŸèƒ½</strong></p>
        <p><strong>åˆ›å»º src/advanced_echo.rs å±•ç¤ºæ›´å¤šåŠŸèƒ½ï¼š</strong></p>
        <pre>// src/advanced_echo.rs - é«˜çº§ Echo åŠŸèƒ½æ¼”ç¤º
use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade, Query},
    response::Html,
    routing::get,
    Router,
};
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    sync::{atomic::{AtomicUsize, Ordering}, Arc},
    time::{SystemTime, UNIX_EPOCH},
};
use tokio::sync::RwLock;
use uuid::Uuid;

// Echo æœåŠ¡å™¨çŠ¶æ€
#[derive(Debug, Clone)]
pub struct EchoStats {
    total_connections: usize,
    total_messages: usize,
    total_bytes: usize,
    start_time: u64,
}

// è¿æ¥æŸ¥è¯¢å‚æ•°
#[derive(Debug, Deserialize)]
pub struct ConnectParams {
    #[serde(default)]
    echo_format: String,  // "simple", "enhanced", "json"
    #[serde(default)]
    client_name: String,
}

// Echo å“åº”æ ¼å¼
#[derive(Debug, Serialize)]
pub struct EchoResponse {
    echo_id: String,
    client_id: String,
    echo_format: String,
    original_message: serde_json::Value,
    echo_time: String,
    message_stats: MessageStats,
    server_info: ServerInfo,
}

#[derive(Debug, Serialize)]
pub struct MessageStats {
    message_length: usize,
    message_type: String,
    is_json: bool,
    word_count: usize,
}

#[derive(Debug, Serialize)]
pub struct ServerInfo {
    server_uptime: String,
    total_connections: usize,
    current_connections: usize,
}

// å…¨å±€çŠ¶æ€
pub struct EchoServer {
    stats: Arc<RwLock<EchoStats>>,
    active_connections: Arc<AtomicUsize>,
}

impl EchoServer {
    pub fn new() -> Self {
        Self {
            stats: Arc::new(RwLock::new(EchoStats {
                total_connections: 0,
                total_messages: 0,
                total_bytes: 0,
                start_time: SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_secs(),
            })),
            active_connections: Arc::new(AtomicUsize::new(0)),
        }
    }

    // é«˜çº§ Echo å¤„ç†å™¨
    pub async fn handle_advanced_websocket(
        &self,
        ws: WebSocketUpgrade,
        params: Query<ConnectParams>,
    ) -> axum::response::Response {
        let echo_format = if params.echo_format.is_empty() {
            "enhanced".to_string()
        } else {
            params.echo_format.clone()
        };

        let client_name = if params.client_name.is_empty() {
            format!("client_{}", Uuid::new_v4().to_string()[..6].to_string())
        } else {
            params.client_name.clone()
        };

        let stats = self.stats.clone();
        let active_connections = self.active_connections.clone();

        // æ›´æ–°è¿æ¥ç»Ÿè®¡
        {
            let mut stats_guard = stats.write().await;
            stats_guard.total_connections += 1;
        }
        active_connections.fetch_add(1, Ordering::Relaxed);

        ws.on_upgrade(move |socket| {
            Self::handle_echo_connection(
                socket,
                client_name,
                echo_format,
                stats,
                active_connections,
            )
        })
    }

    async fn handle_echo_connection(
        socket: WebSocket,
        client_name: String,
        echo_format: String,
        stats: Arc<RwLock<EchoStats>>,
        active_connections: Arc<AtomicUsize>,
    ) {
        let client_id = Uuid::new_v4().to_string()[..8].to_string();
        tracing::info!("ğŸ”— é«˜çº§ Echo è¿æ¥: {} ({})", client_name, client_id);

        let (mut sender, mut receiver) = socket.split();

        // å‘é€è¿æ¥ç¡®è®¤
        let welcome = serde_json::json!({
            "type": "connection_established",
            "client_id": client_id,
            "client_name": client_name,
            "echo_format": echo_format,
            "server_time": chrono::Utc::now().to_rfc3339(),
            "instructions": format!("Echo æ ¼å¼: {}ã€‚å‘é€æ¶ˆæ¯è¿›è¡Œæµ‹è¯•ã€‚", echo_format)
        });

        if sender
            .send(axum::extract::ws::Message::Text(
                serde_json::to_string(&welcome).unwrap(),
            ))
            .await
            .is_err()
        {
            tracing::error!("å‘é€æ¬¢è¿æ¶ˆæ¯å¤±è´¥: {}", client_id);
            active_connections.fetch_sub(1, Ordering::Relaxed);
            return;
        }

        // æ¶ˆæ¯å¤„ç†å¾ªç¯
        while let Some(msg) = receiver.next().await {
            match msg {
                Ok(axum::extract::ws::Message::Text(text)) => {
                    // æ›´æ–°ç»Ÿè®¡
                    {
                        let mut stats_guard = stats.write().await;
                        stats_guard.total_messages += 1;
                        stats_guard.total_bytes += text.len();
                    }

                    // ç”Ÿæˆ Echo å“åº”
                    let echo_response = Self::create_echo_response(
                        &text,
                        &client_id,
                        &echo_format,
                        &stats,
                        active_connections.load(Ordering::Relaxed),
                    )
                    .await;

                    let response_text = match echo_format.as_str() {
                        "simple" => text, // ç®€å•å›æ˜¾
                        "json" => serde_json::to_string(&echo_response).unwrap(),
                        _ => serde_json::to_string_pretty(&echo_response).unwrap(), // enhanced
                    };

                    if sender
                        .send(axum::extract::ws::Message::Text(response_text))
                        .await
                        .is_err()
                    {
                        tracing::error!("Echo å“åº”å‘é€å¤±è´¥: {}", client_id);
                        break;
                    }
                }
                Ok(axum::extract::ws::Message::Binary(data)) => {
                    // äºŒè¿›åˆ¶æ•°æ® Echo
                    {
                        let mut stats_guard = stats.write().await;
                        stats_guard.total_messages += 1;
                        stats_guard.total_bytes += data.len();
                    }

                    if sender
                        .send(axum::extract::ws::Message::Binary(data))
                        .await
                        .is_err()
                    {
                        tracing::error!("äºŒè¿›åˆ¶ Echo å¤±è´¥: {}", client_id);
                        break;
                    }
                }
                Ok(axum::extract::ws::Message::Close(_)) => {
                    tracing::info!("å®¢æˆ·ç«¯å…³é—­è¿æ¥: {}", client_id);
                    break;
                }
                Err(e) => {
                    tracing::error!("WebSocket é”™è¯¯: {} - {}", client_id, e);
                    break;
                }
                _ => {}
            }
        }

        active_connections.fetch_sub(1, Ordering::Relaxed);
        tracing::info!("Echo è¿æ¥ç»“æŸ: {}", client_id);
    }

    async fn create_echo_response(
        message: &str,
        client_id: &str,
        echo_format: &str,
        stats: &Arc<RwLock<EchoStats>>,
        current_connections: usize,
    ) -> EchoResponse {
        let stats_guard = stats.read().await;

        // æ¶ˆæ¯åˆ†æ
        let is_json = serde_json::from_str::<serde_json::Value>(message).is_ok();
        let original_value = if is_json {
            serde_json::from_str(message).unwrap()
        } else {
            serde_json::Value::String(message.to_string())
        };

        let word_count = message.split_whitespace().count();
        let message_type = if is_json {
            "json"
        } else if message.chars().all(|c| c.is_numeric()) {
            "numeric"
        } else if message.chars().all(|c| c.is_alphabetic() || c.is_whitespace()) {
            "text"
        } else {
            "mixed"
        };

        let uptime = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs()
            - stats_guard.start_time;

        EchoResponse {
            echo_id: Uuid::new_v4().to_string(),
            client_id: client_id.to_string(),
            echo_format: echo_format.to_string(),
            original_message: original_value,
            echo_time: chrono::Utc::now().to_rfc3339(),
            message_stats: MessageStats {
                message_length: message.len(),
                message_type: message_type.to_string(),
                is_json,
                word_count,
            },
            server_info: ServerInfo {
                server_uptime: format!("{}ç§’", uptime),
                total_connections: stats_guard.total_connections,
                current_connections,
            },
        }
    }
}</pre>

        <p><strong>è¿è¡Œå’Œæµ‹è¯•ï¼š</strong></p>
        <pre># è¿è¡ŒæœåŠ¡å™¨
cargo run --bin server

# åœ¨å¦ä¸€ä¸ªç»ˆç«¯è¿è¡Œå®¢æˆ·ç«¯
cargo run --bin client

# æˆ–è€…åœ¨æµè§ˆå™¨ä¸­æµ‹è¯•
# http://localhost:3000</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>å®ç°æ¶ˆæ¯å»¶è¿Ÿå›æ˜¾åŠŸèƒ½ï¼ˆå»¶è¿ŸæŒ‡å®šç§’æ•°åå›æ˜¾ï¼‰</li>
            <li>æ·»åŠ æ¶ˆæ¯è¿‡æ»¤åŠŸèƒ½ï¼ˆè¿‡æ»¤æ•æ„Ÿè¯æ±‡ï¼‰</li>
            <li>å®ç°æ¶ˆæ¯è½¬æ¢åŠŸèƒ½ï¼ˆå¤§å°å†™è½¬æ¢ã€åŠ å¯†ç­‰ï¼‰</li>
            <li>æ·»åŠ è¿æ¥é™æµåŠŸèƒ½ï¼ˆé™åˆ¶å•ä¸ª IP çš„è¿æ¥æ•°ï¼‰</li>
            <li>å®ç°æ¶ˆæ¯æŒä¹…åŒ–ï¼ˆå°†æ¶ˆæ¯ä¿å­˜åˆ°æ–‡ä»¶æˆ–æ•°æ®åº“ï¼‰</li>
            <li>åˆ›å»ºæ€§èƒ½æµ‹è¯•å·¥å…·ï¼Œæµ‹è¯•å¹¶å‘è¿æ¥å’Œæ¶ˆæ¯ååé‡</li>
        </ul>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day16_websocket_echo/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ client.rs
â”‚   â””â”€â”€ advanced_echo.rs
â”œâ”€â”€ templates/
â”‚   â””â”€â”€ echo.html
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-17</strong></p>
        <h2>Day 17 - å¹¿æ’­å¤šä¸ªè¿æ¥ï¼šæ„å»ºèŠå¤©å®¤æ¨¡å‹</h2>
        <p>ä½ å°†ä½¿ç”¨ `tokio::sync::broadcast` æ„å»ºä¸€ä¸ªæœ€å°èŠå¤©å®¤ï¼Œæ”¯æŒå¤šä¸ªå®¢æˆ·ç«¯è¿æ¥å¹¶æ¥æ”¶æ‰€æœ‰å¹¿æ’­æ¶ˆæ¯ã€‚</p>
        <p>ğŸ”— <a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®å¹¶é…ç½®ä¾èµ–</strong></p>
        <pre>cargo new day17_websocket_chat
cd day17_websocket_chat</pre>

        <p><strong>é…ç½® Cargo.tomlï¼š</strong></p>
        <pre>[package]
name = "day17_websocket_chat"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
futures-util = "0.3"
tokio-tungstenite = "0.20"

[[bin]]
name = "server"
path = "src/main.rs"

[[bin]]
name = "client"
path = "src/client.rs"</pre>

        <p><strong>æ­¥éª¤ 2: å®ç°å¹¿æ’­èŠå¤©å®¤æœåŠ¡å™¨</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade, State},
    response::Html,
    routing::get,
    Router,
};
use futures_util::{SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    net::SocketAddr,
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc,
    },
};
use tokio::{
    net::TcpListener,
    sync::{broadcast, RwLock},
};
use tower::ServiceBuilder;
use tower_http::cors::CorsLayer;
use tracing::{debug, error, info, warn};
use uuid::Uuid;

// èŠå¤©æ¶ˆæ¯ç»“æ„
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    pub msg_type: String,
    pub user_id: String,
    pub username: String,
    pub content: String,
    pub timestamp: String,
    pub room: String,
}

// ç”¨æˆ·ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct User {
    pub id: String,
    pub username: String,
    pub join_time: chrono::DateTime<chrono::Utc>,
    pub room: String,
}

// åº”ç”¨çŠ¶æ€
#[derive(Clone)]
pub struct AppState {
    pub users: Arc<RwLock<HashMap<String, User>>>,
    pub tx: broadcast::Sender<ChatMessage>,
    pub active_connections: Arc<AtomicUsize>,
}

impl AppState {
    pub fn new() -> Self {
        let (tx, _rx) = broadcast::channel(1000); // æ”¯æŒ1000æ¡æ¶ˆæ¯ç¼“å†²
        Self {
            users: Arc::new(RwLock::new(HashMap::new())),
            tx,
            active_connections: Arc::new(AtomicUsize::new(0)),
        }
    }
}

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .with_level(true)
        .init();

    // åˆ›å»ºåº”ç”¨çŠ¶æ€
    let state = AppState::new();

    // æ„å»ºåº”ç”¨è·¯ç”±
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .route("/api/users", get(get_users))
        .route("/api/stats", get(get_stats))
        .layer(ServiceBuilder::new().layer(CorsLayer::permissive()))
        .with_state(state);

    // å¯åŠ¨æœåŠ¡å™¨
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!("ğŸš€ WebSocket èŠå¤©å®¤æœåŠ¡å™¨å¯åŠ¨åœ¨ http://{}", addr);
    info!("ğŸ’¬ WebSocket ç«¯ç‚¹: ws://{}/ws", addr);
    info!("ğŸŒ æµ‹è¯•é¡µé¢: http://{}/", addr);

    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// ä¸»é¡µå¤„ç†å™¨
async fn index_handler() -> Html<&'static str> {
    Html(include_str!("../templates/chat.html"))
}

// è·å–åœ¨çº¿ç”¨æˆ·åˆ—è¡¨
async fn get_users(State(state): State<AppState>) -> axum::Json<Vec<User>> {
    let users = state.users.read().await;
    let user_list: Vec<User> = users.values().cloned().collect();
    axum::Json(user_list)
}

// è·å–æœåŠ¡å™¨ç»Ÿè®¡ä¿¡æ¯
async fn get_stats(State(state): State<AppState>) -> axum::Json<serde_json::Value> {
    let users = state.users.read().await;
    let stats = serde_json::json!({
        "active_connections": state.active_connections.load(Ordering::Relaxed),
        "registered_users": users.len(),
        "server_time": chrono::Utc::now().to_rfc3339(),
        "uptime": "è¿è¡Œä¸­"
    });
    axum::Json(stats)
}

// WebSocket å‡çº§å¤„ç†å™¨
async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<AppState>,
) -> axum::response::Response {
    let current_connections = state.active_connections.fetch_add(1, Ordering::Relaxed) + 1;
    info!("ğŸ”— æ–°çš„ WebSocket è¿æ¥ (å½“å‰è¿æ¥æ•°: {})", current_connections);
    ws.on_upgrade(move |socket| handle_websocket(socket, state))
}

// å¤„ç† WebSocket è¿æ¥
async fn handle_websocket(socket: WebSocket, state: AppState) {
    let user_id = Uuid::new_v4().to_string();
    let (mut sender, mut receiver) = socket.split();

    // è®¢é˜…å¹¿æ’­é¢‘é“
    let mut rx = state.tx.subscribe();

    // ç”¨æˆ·ä¿¡æ¯ï¼ˆåˆå§‹çŠ¶æ€ï¼‰
    let mut user_info: Option<User> = None;

    // å¯åŠ¨æ¶ˆæ¯å¹¿æ’­ä»»åŠ¡
    let broadcast_task = {
        let user_id = user_id.clone();
        tokio::spawn(async move {
            while let Ok(msg) = rx.recv().await {
                // ä¸å‘å‘é€è€…å¹¿æ’­è‡ªå·±çš„æ¶ˆæ¯
                if msg.user_id == user_id {
                    continue;
                }

                let message_text = serde_json::to_string(&msg).unwrap_or_else(|_| {
                    serde_json::json!({
                        "msg_type": "error",
                        "content": "æ¶ˆæ¯åºåˆ—åŒ–å¤±è´¥"
                    }).to_string()
                });

                if sender
                    .send(axum::extract::ws::Message::Text(message_text))
                    .await
                    .is_err()
                {
                    debug!("å®¢æˆ·ç«¯ {} è¿æ¥å·²æ–­å¼€", user_id);
                    break;
                }
            }
        })
    };

    // å‘é€æ¬¢è¿æ¶ˆæ¯
    let welcome_msg = ChatMessage {
        msg_type: "system".to_string(),
        user_id: "server".to_string(),
        username: "ç³»ç»Ÿ".to_string(),
        content: "ğŸ‰ æ¬¢è¿åŠ å…¥èŠå¤©å®¤ï¼è¯·å‘é€ç”¨æˆ·åè¿›è¡Œæ³¨å†Œã€‚".to_string(),
        timestamp: chrono::Utc::now().to_rfc3339(),
        room: "general".to_string(),
    };

    if sender
        .send(axum::extract::ws::Message::Text(
            serde_json::to_string(&welcome_msg).unwrap(),
        ))
        .await
        .is_err()
    {
        error!("å‘é€æ¬¢è¿æ¶ˆæ¯å¤±è´¥");
        state.active_connections.fetch_sub(1, Ordering::Relaxed);
        return;
    }

    // æ¶ˆæ¯å¤„ç†å¾ªç¯
    while let Some(msg) = receiver.next().await {
        match msg {
            Ok(axum::extract::ws::Message::Text(text)) => {
                debug!("æ”¶åˆ°æ¶ˆæ¯: {}", text);

                // å°è¯•è§£æä¸º JSON æ¶ˆæ¯
                if let Ok(incoming_msg) = serde_json::from_str::<serde_json::Value>(&text) {
                    if let Err(e) = handle_chat_message(incoming_msg, &state, &user_id, &mut user_info).await {
                        error!("å¤„ç†æ¶ˆæ¯å¤±è´¥: {}", e);
                        let error_msg = ChatMessage {
                            msg_type: "error".to_string(),
                            user_id: "server".to_string(),
                            username: "ç³»ç»Ÿ".to_string(),
                            content: format!("æ¶ˆæ¯å¤„ç†å¤±è´¥: {}", e),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                            room: "general".to_string(),
                        };

                        let _ = sender
                            .send(axum::extract::ws::Message::Text(
                                serde_json::to_string(&error_msg).unwrap(),
                            ))
                            .await;
                    }
                } else {
                    // ç®€å•æ–‡æœ¬æ¶ˆæ¯å¤„ç†ï¼ˆç”¨äºç”¨æˆ·åæ³¨å†Œï¼‰
                    if user_info.is_none() {
                        // ç”¨æˆ·å°šæœªæ³¨å†Œï¼Œå°†æ–‡æœ¬ä½œä¸ºç”¨æˆ·å
                        let username = text.trim().to_string();
                        if !username.is_empty() && username.len() <= 20 {
                            let user = User {
                                id: user_id.clone(),
                                username: username.clone(),
                                join_time: chrono::Utc::now(),
                                room: "general".to_string(),
                            };

                            // æ·»åŠ åˆ°ç”¨æˆ·åˆ—è¡¨
                            state.users.write().await.insert(user_id.clone(), user.clone());
                            user_info = Some(user);

                            // å¹¿æ’­ç”¨æˆ·åŠ å…¥æ¶ˆæ¯
                            let join_msg = ChatMessage {
                                msg_type: "user_joined".to_string(),
                                user_id: user_id.clone(),
                                username: username.clone(),
                                content: format!("ç”¨æˆ· {} åŠ å…¥äº†èŠå¤©å®¤", username),
                                timestamp: chrono::Utc::now().to_rfc3339(),
                                room: "general".to_string(),
                            };

                            let _ = state.tx.send(join_msg.clone());

                            // å‘é€æ³¨å†ŒæˆåŠŸæ¶ˆæ¯
                            let success_msg = ChatMessage {
                                msg_type: "registration_success".to_string(),
                                user_id: "server".to_string(),
                                username: "ç³»ç»Ÿ".to_string(),
                                content: format!("âœ… æ³¨å†ŒæˆåŠŸï¼æ¬¢è¿ {}ï¼Œç°åœ¨å¯ä»¥å¼€å§‹èŠå¤©äº†ã€‚", username),
                                timestamp: chrono::Utc::now().to_rfc3339(),
                                room: "general".to_string(),
                            };

                            let _ = sender
                                .send(axum::extract::ws::Message::Text(
                                    serde_json::to_string(&success_msg).unwrap(),
                                ))
                                .await;

                            info!("ç”¨æˆ·æ³¨å†ŒæˆåŠŸ: {} (ID: {})", username, user_id);
                        } else {
                            let error_msg = ChatMessage {
                                msg_type: "error".to_string(),
                                user_id: "server".to_string(),
                                username: "ç³»ç»Ÿ".to_string(),
                                content: "âŒ ç”¨æˆ·åæ— æ•ˆï¼ˆ1-20ä¸ªå­—ç¬¦ï¼‰".to_string(),
                                timestamp: chrono::Utc::now().to_rfc3339(),
                                room: "general".to_string(),
                            };

                            let _ = sender
                                .send(axum::extract::ws::Message::Text(
                                    serde_json::to_string(&error_msg).unwrap(),
                                ))
                                .await;
                        }
                    } else {
                        // å·²æ³¨å†Œç”¨æˆ·å‘é€çš„ç®€å•æ–‡æœ¬æ¶ˆæ¯
                        if let Some(ref user) = user_info {
                            let chat_msg = ChatMessage {
                                msg_type: "message".to_string(),
                                user_id: user_id.clone(),
                                username: user.username.clone(),
                                content: text,
                                timestamp: chrono::Utc::now().to_rfc3339(),
                                room: user.room.clone(),
                            };

                            // å¹¿æ’­æ¶ˆæ¯
                            if let Err(_) = state.tx.send(chat_msg.clone()) {
                                warn!("å¹¿æ’­æ¶ˆæ¯å¤±è´¥");
                            }
                        }
                    }
                }
            }
            Ok(axum::extract::ws::Message::Close(_)) => {
                info!("ç”¨æˆ· {} ä¸»åŠ¨æ–­å¼€è¿æ¥", user_id);
                break;
            }
            Ok(axum::extract::ws::Message::Ping(data)) => {
                if sender
                    .send(axum::extract::ws::Message::Pong(data))
                    .await
                    .is_err()
                {
                    break;
                }
            }
            Err(e) => {
                error!("WebSocket é”™è¯¯: {}", e);
                break;
            }
            _ => {}
        }
    }

    // æ¸…ç†ç”¨æˆ·ä¿¡æ¯
    if let Some(user) = user_info {
        state.users.write().await.remove(&user_id);

        // å¹¿æ’­ç”¨æˆ·ç¦»å¼€æ¶ˆæ¯
        let leave_msg = ChatMessage {
            msg_type: "user_left".to_string(),
            user_id: user_id.clone(),
            username: user.username.clone(),
            content: format!("ç”¨æˆ· {} ç¦»å¼€äº†èŠå¤©å®¤", user.username),
            timestamp: chrono::Utc::now().to_rfc3339(),
            room: user.room,
        };

        let _ = state.tx.send(leave_msg);
        info!("ç”¨æˆ·ç¦»å¼€: {} (ID: {})", user.username, user_id);
    }

    // ç»ˆæ­¢å¹¿æ’­ä»»åŠ¡
    broadcast_task.abort();

    // æ›´æ–°è¿æ¥è®¡æ•°
    let remaining_connections = state.active_connections.fetch_sub(1, Ordering::Relaxed) - 1;
    info!("WebSocket è¿æ¥å…³é—­ï¼Œå‰©ä½™è¿æ¥æ•°: {}", remaining_connections);
}

// å¤„ç†èŠå¤©æ¶ˆæ¯
async fn handle_chat_message(
    incoming_msg: serde_json::Value,
    state: &AppState,
    user_id: &str,
    user_info: &mut Option<User>,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let msg_type = incoming_msg
        .get("type")
        .and_then(|v| v.as_str())
        .unwrap_or("message");

    match msg_type {
        "register" => {
            // ç”¨æˆ·æ³¨å†Œ
            if let Some(username) = incoming_msg.get("username").and_then(|v| v.as_str()) {
                let username = username.trim().to_string();
                if !username.is_empty() && username.len() <= 20 {
                    let user = User {
                        id: user_id.to_string(),
                        username: username.clone(),
                        join_time: chrono::Utc::now(),
                        room: "general".to_string(),
                    };

                    state.users.write().await.insert(user_id.to_string(), user.clone());
                    *user_info = Some(user);

                    let join_msg = ChatMessage {
                        msg_type: "user_joined".to_string(),
                        user_id: user_id.to_string(),
                        username: username.clone(),
                        content: format!("ç”¨æˆ· {} åŠ å…¥äº†èŠå¤©å®¤", username),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                        room: "general".to_string(),
                    };

                    state.tx.send(join_msg)?;
                    info!("ç”¨æˆ·æ³¨å†ŒæˆåŠŸ: {} (ID: {})", username, user_id);
                }
            }
        }
        "message" => {
            // æ™®é€šèŠå¤©æ¶ˆæ¯
            if let Some(user) = user_info {
                if let Some(content) = incoming_msg.get("content").and_then(|v| v.as_str()) {
                    let chat_msg = ChatMessage {
                        msg_type: "message".to_string(),
                        user_id: user_id.to_string(),
                        username: user.username.clone(),
                        content: content.to_string(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                        room: user.room.clone(),
                    };

                    state.tx.send(chat_msg)?;
                }
            }
        }
        "typing" => {
            // è¾“å…¥æŒ‡ç¤ºå™¨
            if let Some(user) = user_info {
                let typing_msg = ChatMessage {
                    msg_type: "typing".to_string(),
                    user_id: user_id.to_string(),
                    username: user.username.clone(),
                    content: "æ­£åœ¨è¾“å…¥...".to_string(),
                    timestamp: chrono::Utc::now().to_rfc3339(),
                    room: user.room.clone(),
                };

                state.tx.send(typing_msg)?;
            }
        }
        _ => {
            return Err("æœªçŸ¥æ¶ˆæ¯ç±»å‹".into());
        }
    }

    Ok(())
}</pre>

        <p><strong>æ­¥éª¤ 3: åˆ›å»ºèŠå¤©å®¤å‰ç«¯é¡µé¢</strong></p>
        <p><strong>åˆ›å»º templates/chat.htmlï¼š</strong></p>
        <pre>mkdir templates</pre>
        
        <p><strong>templates/chat.html å†…å®¹ï¼š</strong></p>
        <pre>&lt;!DOCTYPE html>
&lt;html lang="zh-CN">
&lt;head>
    &lt;meta charset="UTF-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
    &lt;title>WebSocket èŠå¤©å®¤&lt;/title>
    &lt;style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-container {
            width: 90%;
            max-width: 1200px;
            height: 90vh;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            overflow: hidden;
        }
        
        .sidebar {
            width: 300px;
            background: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-header {
            padding: 20px;
            background: #34495e;
            border-bottom: 1px solid #3d566e;
        }
        
        .sidebar-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .connection-status {
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
        }
        
        .status-connected {
            background: #27ae60;
        }
        
        .status-disconnected {
            background: #e74c3c;
        }
        
        .status-connecting {
            background: #f39c12;
        }
        
        .users-section {
            flex: 1;
            padding: 20px;
        }
        
        .users-title {
            margin-bottom: 15px;
            font-size: 14px;
            color: #bdc3c7;
        }
        
        .user-list {
            list-style: none;
        }
        
        .user-item {
            padding: 8px 12px;
            margin-bottom: 5px;
            background: #34495e;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .stats-section {
            padding: 20px;
            border-top: 1px solid #3d566e;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .main-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .chat-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }
        
        .chat-title {
            font-size: 20px;
            color: #495057;
            margin-bottom: 5px;
        }
        
        .chat-subtitle {
            font-size: 14px;
            color: #6c757d;
        }
        
        .messages-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f1f3f4;
        }
        
        .message {
            margin-bottom: 15px;
            max-width: 70%;
            word-wrap: break-word;
        }
        
        .message-own {
            margin-left: auto;
        }
        
        .message-bubble {
            padding: 12px 16px;
            border-radius: 18px;
            position: relative;
        }
        
        .message-own .message-bubble {
            background: #007bff;
            color: white;
        }
        
        .message-other .message-bubble {
            background: white;
            border: 1px solid #dee2e6;
        }
        
        .message-system .message-bubble {
            background: #ffeaa7;
            border: 1px solid #fdcb6e;
            text-align: center;
            font-style: italic;
            margin: 10px auto;
            max-width: 80%;
        }
        
        .message-header {
            font-size: 12px;
            margin-bottom: 4px;
            opacity: 0.7;
        }
        
        .message-content {
            font-size: 14px;
            line-height: 1.4;
        }
        
        .message-time {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 4px;
        }
        
        .typing-indicator {
            font-style: italic;
            color: #6c757d;
            font-size: 12px;
            margin-left: 20px;
            opacity: 0.8;
        }
        
        .input-section {
            padding: 20px;
            background: white;
            border-top: 1px solid #dee2e6;
        }
        
        .input-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .registration-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .registration-input {
            padding: 15px;
            border: 2px solid #007bff;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
        }
        
        .registration-button {
            padding: 15px 30px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .registration-button:hover {
            background: #0056b3;
        }
        
        .message-input {
            flex: 1;
            padding: 15px 20px;
            border: 1px solid #dee2e6;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            resize: none;
        }
        
        .send-button {
            padding: 15px 25px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .send-button:hover {
            background: #0056b3;
        }
        
        .send-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .quick-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .quick-button {
            padding: 8px 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .quick-button:hover {
            background: #495057;
        }
        
        @media (max-width: 768px) {
            .chat-container {
                width: 100%;
                height: 100vh;
                border-radius: 0;
            }
            
            .sidebar {
                display: none;
            }
        }
    &lt;/style>
&lt;/head>
&lt;body>
    &lt;div class="chat-container">
        &lt;div class="sidebar">
            &lt;div class="sidebar-header">
                &lt;div class="sidebar-title">ğŸ’¬ èŠå¤©å®¤&lt;/div>
                &lt;div id="connectionStatus" class="connection-status status-disconnected">æœªè¿æ¥&lt;/div>
            &lt;/div>
            
            &lt;div class="users-section">
                &lt;div class="users-title">åœ¨çº¿ç”¨æˆ· (&lt;span id="userCount">0&lt;/span>)&lt;/div>
                &lt;ul id="userList" class="user-list">&lt;/ul>
            &lt;/div>
            
            &lt;div class="stats-section">
                &lt;div class="stat-item">
                    &lt;span>è¿æ¥æ•°:&lt;/span>
                    &lt;span id="connectionCount">0&lt;/span>
                &lt;/div>
                &lt;div class="stat-item">
                    &lt;span>æ¶ˆæ¯æ•°:&lt;/span>
                    &lt;span id="messageCount">0&lt;/span>
                &lt;/div>
                &lt;div class="stat-item">
                    &lt;span>åœ¨çº¿æ—¶é—´:&lt;/span>
                    &lt;span id="onlineTime">00:00&lt;/span>
                &lt;/div>
            &lt;/div>
        &lt;/div>
        
        &lt;div class="main-chat">
            &lt;div class="chat-header">
                &lt;div class="chat-title">ğŸŒŸ WebSocket èŠå¤©å®¤&lt;/div>
                &lt;div class="chat-subtitle">å®æ—¶é€šä¿¡æ¼”ç¤º&lt;/div>
            &lt;/div>
            
            &lt;div id="messagesContainer" class="messages-container">
                &lt;div id="typingIndicator" class="typing-indicator" style="display: none;">&lt;/div>
            &lt;/div>
            
            &lt;div class="input-section">
                &lt;div id="registrationForm" class="registration-container">
                    &lt;input type="text" id="usernameInput" class="registration-input" 
                           placeholder="è¯·è¾“å…¥æ‚¨çš„ç”¨æˆ·å..." maxlength="20">
                    &lt;button id="registerButton" class="registration-button">ğŸš€ åŠ å…¥èŠå¤©å®¤&lt;/button>
                &lt;/div>
                
                &lt;div id="chatForm" class="input-container" style="display: none;">
                    &lt;div class="quick-actions">
                        &lt;button class="quick-button" onclick="sendQuickMessage('ğŸ‘‹ å¤§å®¶å¥½ï¼')">ğŸ‘‹ æ‰“æ‹›å‘¼&lt;/button>
                        &lt;button class="quick-button" onclick="sendQuickMessage('ğŸ˜„ å“ˆå“ˆå“ˆ')">ğŸ˜„ å¼€å¿ƒ&lt;/button>
                        &lt;button class="quick-button" onclick="sendQuickMessage('ğŸ‘ èµä¸€ä¸ª')">ğŸ‘ ç‚¹èµ&lt;/button>
                        &lt;button class="quick-button" onclick="sendQuickMessage('ğŸ¤” æœ‰è¶£...')">ğŸ¤” æ€è€ƒ&lt;/button>
                    &lt;/div>
                    &lt;textarea id="messageInput" class="message-input" 
                             placeholder="è¾“å…¥æ¶ˆæ¯..." rows="1">&lt;/textarea>
                    &lt;button id="sendButton" class="send-button" disabled>ğŸ“¤ å‘é€&lt;/button>
                &lt;/div>
            &lt;/div>
        &lt;/div>
    &lt;/div>

    &lt;script>
        class ChatRoom {
            constructor() {
                this.ws = null;
                this.username = '';
                this.isRegistered = false;
                this.messageCount = 0;
                this.startTime = null;
                this.users = new Map();
                
                this.initElements();
                this.bindEvents();
                this.connect();
            }
            
            initElements() {
                this.elements = {
                    connectionStatus: document.getElementById('connectionStatus'),
                    userList: document.getElementById('userList'),
                    userCount: document.getElementById('userCount'),
                    connectionCount: document.getElementById('connectionCount'),
                    messageCount: document.getElementById('messageCount'),
                    onlineTime: document.getElementById('onlineTime'),
                    messagesContainer: document.getElementById('messagesContainer'),
                    typingIndicator: document.getElementById('typingIndicator'),
                    registrationForm: document.getElementById('registrationForm'),
                    chatForm: document.getElementById('chatForm'),
                    usernameInput: document.getElementById('usernameInput'),
                    registerButton: document.getElementById('registerButton'),
                    messageInput: document.getElementById('messageInput'),
                    sendButton: document.getElementById('sendButton')
                };
            }
            
            bindEvents() {
                this.elements.registerButton.addEventListener('click', () => this.register());
                this.elements.usernameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.register();
                });
                
                this.elements.sendButton.addEventListener('click', () => this.sendMessage());
                this.elements.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
                
                this.elements.messageInput.addEventListener('input', () => {
                    this.elements.sendButton.disabled = !this.elements.messageInput.value.trim();
                });
                
                // è‡ªåŠ¨è°ƒæ•´è¾“å…¥æ¡†é«˜åº¦
                this.elements.messageInput.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 100) + 'px';
                });
            }
            
            connect() {
                const wsUrl = `ws://${window.location.host}/ws`;
                this.updateConnectionStatus('connecting', 'è¿æ¥ä¸­...');
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    this.updateConnectionStatus('connected', 'å·²è¿æ¥');
                    this.startTime = Date.now();
                    this.startTimer();
                    this.addSystemMessage('âœ… è¿æ¥æˆåŠŸï¼');
                };
                
                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (e) {
                        console.error('æ¶ˆæ¯è§£æå¤±è´¥:', e);
                    }
                };
                
                this.ws.onclose = (event) => {
                    this.updateConnectionStatus('disconnected', 'æœªè¿æ¥');
                    this.addSystemMessage(`âŒ è¿æ¥å…³é—­ (ä»£ç : ${event.code})`);
                    this.stopTimer();
                };
                
                this.ws.onerror = (error) => {
                    this.updateConnectionStatus('disconnected', 'è¿æ¥é”™è¯¯');
                    this.addSystemMessage('ğŸ’¥ è¿æ¥å‡ºé”™');
                    console.error('WebSocket é”™è¯¯:', error);
                };
            }
            
            register() {
                const username = this.elements.usernameInput.value.trim();
                if (!username) {
                    alert('è¯·è¾“å…¥ç”¨æˆ·å');
                    return;
                }
                
                if (username.length > 20) {
                    alert('ç”¨æˆ·åä¸èƒ½è¶…è¿‡20ä¸ªå­—ç¬¦');
                    return;
                }
                
                this.username = username;
                this.sendWebSocketMessage({
                    type: 'register',
                    username: username
                });
            }
            
            sendMessage() {
                const content = this.elements.messageInput.value.trim();
                if (!content || !this.isRegistered) return;
                
                this.sendWebSocketMessage({
                    type: 'message',
                    content: content
                });
                
                this.elements.messageInput.value = '';
                this.elements.messageInput.style.height = 'auto';
                this.elements.sendButton.disabled = true;
            }
            
            sendQuickMessage(message) {
                if (!this.isRegistered) return;
                
                this.sendWebSocketMessage({
                    type: 'message',
                    content: message
                });
            }
            
            sendWebSocketMessage(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                }
            }
            
            handleMessage(message) {
                switch (message.msg_type) {
                    case 'system':
                        this.addSystemMessage(message.content);
                        break;
                    case 'registration_success':
                        this.isRegistered = true;
                        this.elements.registrationForm.style.display = 'none';
                        this.elements.chatForm.style.display = 'block';
                        this.addSystemMessage(message.content);
                        this.updateUserList();
                        break;
                    case 'message':
                        this.addChatMessage(message);
                        this.messageCount++;
                        this.elements.messageCount.textContent = this.messageCount;
                        break;
                    case 'user_joined':
                    case 'user_left':
                        this.addSystemMessage(message.content);
                        this.updateUserList();
                        break;
                    case 'typing':
                        this.showTypingIndicator(message.username);
                        break;
                    case 'error':
                        this.addSystemMessage(`âŒ ${message.content}`);
                        break;
                }
            }
            
            addSystemMessage(content) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message message-system';
                messageDiv.innerHTML = `
                    &lt;div class="message-bubble">
                        &lt;div class="message-content">${this.escapeHtml(content)}&lt;/div>
                        &lt;div class="message-time">${new Date().toLocaleTimeString()}&lt;/div>
                    &lt;/div>
                `;
                
                this.elements.messagesContainer.appendChild(messageDiv);
                this.scrollToBottom();
            }
            
            addChatMessage(message) {
                const isOwn = message.username === this.username;
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isOwn ? 'message-own' : 'message-other'}`;
                
                messageDiv.innerHTML = `
                    &lt;div class="message-bubble">
                        ${!isOwn ? `&lt;div class="message-header">${this.escapeHtml(message.username)}&lt;/div>` : ''}
                        &lt;div class="message-content">${this.escapeHtml(message.content)}&lt;/div>
                        &lt;div class="message-time">${new Date(message.timestamp).toLocaleTimeString()}&lt;/div>
                    &lt;/div>
                `;
                
                this.elements.messagesContainer.appendChild(messageDiv);
                this.scrollToBottom();
            }
            
            showTypingIndicator(username) {
                if (username === this.username) return;
                
                this.elements.typingIndicator.textContent = `${username} æ­£åœ¨è¾“å…¥...`;
                this.elements.typingIndicator.style.display = 'block';
                
                clearTimeout(this.typingTimeout);
                this.typingTimeout = setTimeout(() => {
                    this.elements.typingIndicator.style.display = 'none';
                }, 3000);
            }
            
            async updateUserList() {
                try {
                    const response = await fetch('/api/users');
                    const users = await response.json();
                    
                    this.elements.userList.innerHTML = '';
                    this.elements.userCount.textContent = users.length;
                    
                    users.forEach(user => {
                        const li = document.createElement('li');
                        li.className = 'user-item';
                        li.textContent = `ğŸ‘¤ ${user.username}`;
                        this.elements.userList.appendChild(li);
                    });
                } catch (e) {
                    console.error('è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥:', e);
                }
            }
            
            updateConnectionStatus(status, text) {
                this.elements.connectionStatus.className = `connection-status status-${status}`;
                this.elements.connectionStatus.textContent = text;
            }
            
            startTimer() {
                this.timer = setInterval(() => {
                    if (this.startTime) {
                        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                        const minutes = Math.floor(elapsed / 60);
                        const seconds = elapsed % 60;
                        this.elements.onlineTime.textContent = 
                            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                }, 1000);
            }
            
            stopTimer() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
            }
            
            scrollToBottom() {
                this.elements.messagesContainer.scrollTop = this.elements.messagesContainer.scrollHeight;
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨èŠå¤©å®¤
        document.addEventListener('DOMContentLoaded', () => {
            window.chatRoom = new ChatRoom();
        });
        
        // å…¨å±€å¿«é€Ÿæ¶ˆæ¯å‡½æ•°
        function sendQuickMessage(message) {
            if (window.chatRoom) {
                window.chatRoom.sendQuickMessage(message);
            }
        }
    &lt;/script>
&lt;/body>
&lt;/html></pre>

        <p><strong>æ­¥éª¤ 4: åˆ›å»ºå‘½ä»¤è¡Œå®¢æˆ·ç«¯</strong></p>
        <p><strong>åˆ›å»º src/client.rsï¼š</strong></p>
        <pre>use futures_util::{SinkExt, StreamExt};
use serde_json;
use std::io::{self, Write};
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ’¬ WebSocket èŠå¤©å®¤å®¢æˆ·ç«¯");
    println!("============================");

    let url = "ws://127.0.0.1:3000/ws";
    println!("ğŸ”— è¿æ¥åˆ°èŠå¤©æœåŠ¡å™¨: {}", url);

    let (ws_stream, _) = connect_async(url).await?;
    println!("âœ… è¿æ¥æˆåŠŸï¼");

    let (mut write, mut read) = ws_stream.split();

    // å¯åŠ¨æ¥æ”¶æ¶ˆæ¯çš„ä»»åŠ¡
    let read_handle = tokio::spawn(async move {
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    if let Ok(chat_msg) = serde_json::from_str::<serde_json::Value>(&text) {
                        print_chat_message(&chat_msg);
                    } else {
                        println!("ğŸ“© {}", text);
                    }
                }
                Ok(Message::Close(_)) => {
                    println!("\nğŸ‘‹ æœåŠ¡å™¨å…³é—­äº†è¿æ¥");
                    break;
                }
                Err(e) => {
                    println!("\nâŒ æ¥æ”¶æ¶ˆæ¯é”™è¯¯: {}", e);
                    break;
                }
                _ => {}
            }
        }
    });

    // ç”¨æˆ·æ³¨å†Œæµç¨‹
    println!("\nè¯·è¾“å…¥æ‚¨çš„ç”¨æˆ·å:");
    print!("ğŸ‘¤ ç”¨æˆ·å: ");
    io::stdout().flush().unwrap();

    let mut username = String::new();
    io::stdin().read_line(&mut username).unwrap();
    let username = username.trim();

    if username.is_empty() {
        println!("âŒ ç”¨æˆ·åä¸èƒ½ä¸ºç©º");
        return Ok(());
    }

    // å‘é€æ³¨å†Œæ¶ˆæ¯
    let register_msg = serde_json::json!({
        "type": "register",
        "username": username
    });

    write
        .send(Message::Text(serde_json::to_string(&register_msg).unwrap()))
        .await?;

    println!("ğŸ“ æ³¨å†Œæ¶ˆæ¯å·²å‘é€ï¼Œç­‰å¾…æœåŠ¡å™¨ç¡®è®¤...");
    println!("ğŸ’¡ è¾“å…¥æ¶ˆæ¯å¹¶æŒ‰å›è½¦å‘é€ï¼Œè¾“å…¥ '/quit' é€€å‡º");
    println!("ğŸ“š ç‰¹æ®Šå‘½ä»¤:");
    println!("  /users  - æ˜¾ç¤ºåœ¨çº¿ç”¨æˆ·");
    println!("  /stats  - æ˜¾ç¤ºæœåŠ¡å™¨ç»Ÿè®¡");
    println!("  /help   - æ˜¾ç¤ºå¸®åŠ©");
    println!("\nå¼€å§‹èŠå¤©:");

    // æ¶ˆæ¯å‘é€å¾ªç¯
    loop {
        print!("ğŸ’¬ {} > ", username);
        io::stdout().flush().unwrap();

        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();

        if input == "/quit" {
            break;
        }

        if input.is_empty() {
            continue;
        }

        // å¤„ç†ç‰¹æ®Šå‘½ä»¤
        match input {
            "/users" => {
                println!("ğŸ“‹ æ­£åœ¨è·å–ç”¨æˆ·åˆ—è¡¨...");
                continue;
            }
            "/stats" => {
                println!("ğŸ“Š æ­£åœ¨è·å–æœåŠ¡å™¨ç»Ÿè®¡...");
                continue;
            }
            "/help" => {
                println!("ğŸ“š å¯ç”¨å‘½ä»¤:");
                println!("  /users  - æ˜¾ç¤ºåœ¨çº¿ç”¨æˆ·");
                println!("  /stats  - æ˜¾ç¤ºæœåŠ¡å™¨ç»Ÿè®¡");
                println!("  /quit   - é€€å‡ºèŠå¤©å®¤");
                println!("  /help   - æ˜¾ç¤ºæ­¤å¸®åŠ©");
                continue;
            }
            _ => {}
        }

        // å‘é€æ™®é€šæ¶ˆæ¯
        let chat_msg = serde_json::json!({
            "type": "message",
            "content": input
        });

        if write
            .send(Message::Text(serde_json::to_string(&chat_msg).unwrap()))
            .await
            .is_err()
        {
            println!("âŒ å‘é€æ¶ˆæ¯å¤±è´¥");
            break;
        }
    }

    println!("ğŸ‘‹ æ­£åœ¨é€€å‡ºèŠå¤©å®¤...");
    let _ = write.send(Message::Close(None)).await;
    read_handle.abort();

    Ok(())
}

fn print_chat_message(msg: &serde_json::Value) {
    let msg_type = msg.get("msg_type").and_then(|v| v.as_str()).unwrap_or("");
    let username = msg.get("username").and_then(|v| v.as_str()).unwrap_or("");
    let content = msg.get("content").and_then(|v| v.as_str()).unwrap_or("");
    let timestamp = msg
        .get("timestamp")
        .and_then(|v| v.as_str())
        .and_then(|s| chrono::DateTime::parse_from_rfc3339(s).ok())
        .map(|dt| dt.format("%H:%M:%S").to_string())
        .unwrap_or_else(|| chrono::Local::now().format("%H:%M:%S").to_string());

    match msg_type {
        "system" => {
            println!("\nğŸ”” [{}] {}", timestamp, content);
        }
        "registration_success" => {
            println!("\nâœ… [{}] {}", timestamp, content);
        }
        "message" => {
            println!("\nğŸ’¬ [{}] {}: {}", timestamp, username, content);
        }
        "user_joined" => {
            println!("\nğŸ“¥ [{}] {}", timestamp, content);
        }
        "user_left" => {
            println!("\nğŸ“¤ [{}] {}", timestamp, content);
        }
        "typing" => {
            print!("\râŒ¨ï¸  {} æ­£åœ¨è¾“å…¥...", username);
            io::stdout().flush().unwrap();
            // ä¸æ¢è¡Œï¼Œè®©ç”¨æˆ·è¾“å…¥æç¤ºç¬¦è¦†ç›–
        }
        "error" => {
            println!("\nâŒ [{}] é”™è¯¯: {}", timestamp, content);
        }
        _ => {
            println!("\nğŸ“© [{}] {}: {}", timestamp, username, content);
        }
    }

    // é‡æ–°æ˜¾ç¤ºè¾“å…¥æç¤ºç¬¦ï¼ˆé™¤äº† typing æ¶ˆæ¯ï¼‰
    if msg_type != "typing" {
        print!("ğŸ’¬ > ");
        io::stdout().flush().unwrap();
    }
}</pre>

        <p><strong>è¿è¡Œå’Œæµ‹è¯•ï¼š</strong></p>
        <pre># è¿è¡ŒæœåŠ¡å™¨
cargo run --bin server

# åœ¨å¤šä¸ªç»ˆç«¯è¿è¡Œå®¢æˆ·ç«¯æµ‹è¯•å¤šç”¨æˆ·èŠå¤©
cargo run --bin client

# æˆ–åœ¨æµè§ˆå™¨ä¸­è®¿é—® http://localhost:3000</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>å®ç°ç§èŠåŠŸèƒ½ï¼ˆç”¨æˆ·ä¹‹é—´ä¸€å¯¹ä¸€æ¶ˆæ¯ï¼‰</li>
            <li>æ·»åŠ å¤šæˆ¿é—´æ”¯æŒï¼ˆç”¨æˆ·å¯ä»¥åŠ å…¥ä¸åŒçš„èŠå¤©æˆ¿é—´ï¼‰</li>
            <li>å®ç°æ¶ˆæ¯å†å²è®°å½•ï¼ˆæ–°ç”¨æˆ·åŠ å…¥æ—¶æ˜¾ç¤ºæœ€è¿‘çš„èŠå¤©è®°å½•ï¼‰</li>
            <li>æ·»åŠ ç”¨æˆ·è§’è‰²ç³»ç»Ÿï¼ˆç®¡ç†å‘˜ã€æ™®é€šç”¨æˆ·ç­‰ï¼‰</li>
            <li>å®ç°æ¶ˆæ¯è¿‡æ»¤å’Œæ•æ„Ÿè¯æ£€æµ‹</li>
            <li>æ·»åŠ æ–‡ä»¶ä¸Šä¼ å’Œå›¾ç‰‡åˆ†äº«åŠŸèƒ½</li>
            <li>å®ç°ç”¨æˆ·åœ¨çº¿çŠ¶æ€æŒ‡ç¤ºå™¨</li>
            <li>æ·»åŠ æ¶ˆæ¯å·²è¯»å›æ‰§åŠŸèƒ½</li>
        </ul>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day17_websocket_chat/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â””â”€â”€ client.rs
â”œâ”€â”€ templates/
â”‚   â””â”€â”€ chat.html
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-18</strong></p>
        <h2>Day 18 - è¿æ¥é‰´æƒæœºåˆ¶</h2>
        <p>ä½ å°†åœ¨è¿æ¥å»ºç«‹æ—¶æå–æŸ¥è¯¢å‚æ•°ï¼ˆå¦‚ `?token=abc123`ï¼‰ï¼Œå¹¶æ£€æŸ¥è¯¥ token æ˜¯å¦åœ¨æˆæƒåˆ—è¡¨ä¸­ï¼Œæ‹’ç»æœªæˆæƒè¿æ¥ã€‚</p>
        <p>ğŸ”— <a href="https://docs.rs/axum/latest/axum/extract/struct.Query.html" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: åˆ›å»ºé¡¹ç›®å¹¶é…ç½®ä¾èµ–</strong></p>
        <pre>cargo new day18_websocket_auth
cd day18_websocket_auth</pre>

        <p><strong>é…ç½® Cargo.tomlï¼š</strong></p>
        <pre>[package]
name = "day18_websocket_auth"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
futures-util = "0.3"
tokio-tungstenite = "0.20"
jsonwebtoken = "9.2"
base64 = "0.21"
sha2 = "0.10"
hex = "0.4"

[[bin]]
name = "server"
path = "src/main.rs"

[[bin]]
name = "client"
path = "src/client.rs"

[[bin]]
name = "token_generator"
path = "src/token_generator.rs"</pre>

        <p><strong>æ­¥éª¤ 2: å®ç°è®¤è¯WebSocketæœåŠ¡å™¨</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade, Query, State},
    http::StatusCode,
    response::{Html, IntoResponse, Response},
    routing::get,
    Router,
};
use futures_util::{SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use std::{
    collections::{HashMap, HashSet},
    net::SocketAddr,
    sync::{atomic::{AtomicUsize, Ordering}, Arc},
    time::{SystemTime, UNIX_EPOCH},
};
use tokio::{net::TcpListener, sync::RwLock};
use tower::ServiceBuilder;
use tower_http::cors::CorsLayer;
use tracing::{debug, error, info, warn};
use uuid::Uuid;

// è®¤è¯æŸ¥è¯¢å‚æ•°
#[derive(Debug, Deserialize)]
pub struct AuthQuery {
    token: Option<String>,
    user_id: Option<String>,
    permissions: Option<String>,
}

// JWT Claims
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,     // ç”¨æˆ·ID
    pub name: String,    // ç”¨æˆ·å
    pub permissions: Vec<String>, // æƒé™åˆ—è¡¨
    pub exp: usize,      // è¿‡æœŸæ—¶é—´
    pub iat: usize,      // ç­¾å‘æ—¶é—´
    pub iss: String,     // ç­¾å‘è€…
}

// ç”¨æˆ·ä¿¡æ¯
#[derive(Debug, Clone, Serialize)]
pub struct AuthenticatedUser {
    pub id: String,
    pub name: String,
    pub permissions: Vec<String>,
    pub token: String,
    pub connected_at: chrono::DateTime<chrono::Utc>,
    pub last_activity: chrono::DateTime<chrono::Utc>,
}

// åº”ç”¨çŠ¶æ€
#[derive(Clone)]
pub struct AppState {
    pub jwt_secret: String,
    pub valid_tokens: Arc<RwLock<HashSet<String>>>,
    pub connected_users: Arc<RwLock<HashMap<String, AuthenticatedUser>>>,
    pub connection_count: Arc<AtomicUsize>,
    pub blocked_ips: Arc<RwLock<HashSet<String>>>,
}

impl AppState {
    pub fn new() -> Self {
        let mut valid_tokens = HashSet::new();
        
        // é¢„è®¾ä¸€äº›æœ‰æ•ˆçš„ç®€å•tokenç”¨äºæµ‹è¯•
        valid_tokens.insert("admin_token_123".to_string());
        valid_tokens.insert("user_token_456".to_string());
        valid_tokens.insert("guest_token_789".to_string());
        valid_tokens.insert("developer_token_000".to_string());
        
        Self {
            jwt_secret: "your_super_secret_jwt_key_here_make_it_long_and_secure".to_string(),
            valid_tokens: Arc::new(RwLock::new(valid_tokens)),
            connected_users: Arc::new(RwLock::new(HashMap::new())),
            connection_count: Arc::new(AtomicUsize::new(0)),
            blocked_ips: Arc::new(RwLock::new(HashSet::new())),
        }
    }
    
    // éªŒè¯ç®€å•token
    pub async fn validate_simple_token(&self, token: &str) -> Option<AuthenticatedUser> {
        let tokens = self.valid_tokens.read().await;
        if tokens.contains(token) {
            let (user_id, name, permissions) = match token {
                "admin_token_123" => ("admin_001", "ç®¡ç†å‘˜", vec!["admin", "read", "write", "delete"]),
                "user_token_456" => ("user_001", "æ™®é€šç”¨æˆ·", vec!["read", "write"]),
                "guest_token_789" => ("guest_001", "è®¿å®¢", vec!["read"]),
                "developer_token_000" => ("dev_001", "å¼€å‘è€…", vec!["admin", "debug", "read", "write"]),
                _ => ("unknown", "æœªçŸ¥ç”¨æˆ·", vec!["read"]),
            };
            
            Some(AuthenticatedUser {
                id: user_id.to_string(),
                name: name.to_string(),
                permissions: permissions.into_iter().map(String::from).collect(),
                token: token.to_string(),
                connected_at: chrono::Utc::now(),
                last_activity: chrono::Utc::now(),
            })
        } else {
            None
        }
    }
    
    // éªŒè¯JWT token
    pub fn validate_jwt_token(&self, token: &str) -> Option<AuthenticatedUser> {
        use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
        
        let validation = Validation::new(Algorithm::HS256);
        match decode::<Claims>(
            token,
            &DecodingKey::from_secret(self.jwt_secret.as_ref()),
            &validation,
        ) {
            Ok(token_data) => {
                let claims = token_data.claims;
                
                // æ£€æŸ¥tokenæ˜¯å¦è¿‡æœŸ
                let now = SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_secs() as usize;
                
                if claims.exp < now {
                    warn!("JWT token å·²è¿‡æœŸ: {}", claims.sub);
                    return None;
                }
                
                Some(AuthenticatedUser {
                    id: claims.sub,
                    name: claims.name,
                    permissions: claims.permissions,
                    token: token.to_string(),
                    connected_at: chrono::Utc::now(),
                    last_activity: chrono::Utc::now(),
                })
            }
            Err(e) => {
                warn!("JWT token éªŒè¯å¤±è´¥: {}", e);
                None
            }
        }
    }
    
    // æ£€æŸ¥IPæ˜¯å¦è¢«å°ç¦
    pub async fn is_ip_blocked(&self, ip: &str) -> bool {
        let blocked_ips = self.blocked_ips.read().await;
        blocked_ips.contains(ip)
    }
    
    // å°ç¦IP
    pub async fn block_ip(&self, ip: String) {
        let mut blocked_ips = self.blocked_ips.write().await;
        blocked_ips.insert(ip);
    }
}

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .with_level(true)
        .init();

    // åˆ›å»ºåº”ç”¨çŠ¶æ€
    let state = AppState::new();

    // æ„å»ºåº”ç”¨è·¯ç”±
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .route("/api/users", get(get_connected_users))
        .route("/api/stats", get(get_auth_stats))
        .route("/api/generate-token", get(generate_simple_token))
        .route("/api/generate-jwt", get(generate_jwt_token))
        .layer(ServiceBuilder::new().layer(CorsLayer::permissive()))
        .with_state(state);

    // å¯åŠ¨æœåŠ¡å™¨
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!("ğŸš€ WebSocket è®¤è¯æœåŠ¡å™¨å¯åŠ¨åœ¨ http://{}", addr);
    info!("ğŸ” WebSocket ç«¯ç‚¹: ws://{}/ws?token=YOUR_TOKEN", addr);
    info!("ğŸŒ æµ‹è¯•é¡µé¢: http://{}/", addr);
    info!("ğŸ”‘ ç”ŸæˆToken: http://{}/api/generate-token", addr);

    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// ä¸»é¡µå¤„ç†å™¨
async fn index_handler() -> Html<&'static str> {
    Html(include_str!("../templates/auth.html"))
}

// è·å–å·²è¿æ¥ç”¨æˆ·åˆ—è¡¨
async fn get_connected_users(State(state): State<AppState>) -> axum::Json<Vec<AuthenticatedUser>> {
    let users = state.connected_users.read().await;
    let user_list: Vec<AuthenticatedUser> = users.values().cloned().collect();
    axum::Json(user_list)
}

// è·å–è®¤è¯ç»Ÿè®¡ä¿¡æ¯
async fn get_auth_stats(State(state): State<AppState>) -> axum::Json<serde_json::Value> {
    let users = state.connected_users.read().await;
    let valid_tokens = state.valid_tokens.read().await;
    let blocked_ips = state.blocked_ips.read().await;
    
    let stats = serde_json::json!({
        "active_connections": state.connection_count.load(Ordering::Relaxed),
        "authenticated_users": users.len(),
        "valid_tokens": valid_tokens.len(),
        "blocked_ips": blocked_ips.len(),
        "server_time": chrono::Utc::now().to_rfc3339(),
        "auth_enabled": true
    });
    axum::Json(stats)
}

// ç”Ÿæˆç®€å•æµ‹è¯•token
async fn generate_simple_token(State(state): State<AppState>) -> impl IntoResponse {
    let new_token = format!("test_token_{}", Uuid::new_v4().to_string()[..8].to_string());
    
    // æ·»åŠ åˆ°æœ‰æ•ˆtokenåˆ—è¡¨
    state.valid_tokens.write().await.insert(new_token.clone());
    info!("ç”Ÿæˆæ–°çš„æµ‹è¯•token: {}", new_token);
    
    axum::Json(serde_json::json!({
        "token": new_token,
        "type": "simple",
        "expires": "never",
        "permissions": ["read"]
    }))
}

// ç”ŸæˆJWT token
async fn generate_jwt_token(Query(params): Query<HashMap<String, String>>, State(state): State<AppState>) -> impl IntoResponse {
    use jsonwebtoken::{encode, EncodingKey, Header};
    
    let user_id = params.get("user_id").unwrap_or(&format!("user_{}", Uuid::new_v4().to_string()[..8].to_string())).clone();
    let name = params.get("name").unwrap_or(&format!("User_{}", &user_id[..8])).clone();
    let permissions_str = params.get("permissions").unwrap_or("read").clone();
    let permissions: Vec<String> = permissions_str.split(',').map(String::from).collect();
    
    let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as usize;
    let exp = now + 3600; // 1å°æ—¶åè¿‡æœŸ
    
    let claims = Claims {
        sub: user_id.clone(),
        name: name.clone(),
        permissions: permissions.clone(),
        exp,
        iat: now,
        iss: "websocket-auth-server".to_string(),
    };
    
    match encode(&Header::default(), &claims, &EncodingKey::from_secret(state.jwt_secret.as_ref())) {
        Ok(token) => {
            info!("ç”Ÿæˆæ–°çš„JWT token for user: {}", user_id);
            axum::Json(serde_json::json!({
                "token": token,
                "type": "jwt",
                "user_id": user_id,
                "name": name,
                "permissions": permissions,
                "expires_at": chrono::Utc::now() + chrono::Duration::seconds(3600),
                "expires_in": 3600
            }))
        }
        Err(e) => {
            error!("JWT token ç”Ÿæˆå¤±è´¥: {}", e);
            axum::Json(serde_json::json!({
                "error": "Failed to generate JWT token",
                "message": e.to_string()
            }))
        }
    }
}

// WebSocket å‡çº§å¤„ç†å™¨ï¼ˆå¸¦è®¤è¯ï¼‰
async fn websocket_handler(
    ws: WebSocketUpgrade,
    Query(auth_query): Query<AuthQuery>,
    State(state): State<AppState>,
) -> Response {
    // æ£€æŸ¥æ˜¯å¦æä¾›äº†token
    let token = match auth_query.token {
        Some(token) if !token.is_empty() => token,
        _ => {
            warn!("WebSocketè¿æ¥è¢«æ‹’ç»: ç¼ºå°‘token");
            return (StatusCode::UNAUTHORIZED, "Missing or empty token").into_response();
        }
    };

    // éªŒè¯tokenï¼ˆå…ˆå°è¯•ç®€å•tokenï¼Œå†å°è¯•JWTï¼‰
    let authenticated_user = if let Some(user) = state.validate_simple_token(&token).await {
        user
    } else if let Some(user) = state.validate_jwt_token(&token) {
        user
    } else {
        warn!("WebSocketè¿æ¥è¢«æ‹’ç»: æ— æ•ˆtoken: {}", token);
        return (StatusCode::UNAUTHORIZED, "Invalid token").into_response();
    };

    // æ£€æŸ¥æƒé™ï¼ˆè‡³å°‘éœ€è¦readæƒé™ï¼‰
    if !authenticated_user.permissions.contains(&"read".to_string()) {
        warn!("WebSocketè¿æ¥è¢«æ‹’ç»: æƒé™ä¸è¶³: {}", authenticated_user.id);
        return (StatusCode::FORBIDDEN, "Insufficient permissions").into_response();
    }

    let current_connections = state.connection_count.fetch_add(1, Ordering::Relaxed) + 1;
    info!("âœ… è®¤è¯æˆåŠŸï¼Œç”¨æˆ· {} ({}) è¿æ¥ WebSocket (å½“å‰è¿æ¥æ•°: {})", 
          authenticated_user.name, authenticated_user.id, current_connections);

    // æ·»åŠ åˆ°å·²è¿æ¥ç”¨æˆ·åˆ—è¡¨
    state.connected_users.write().await.insert(
        authenticated_user.id.clone(), 
        authenticated_user.clone()
    );

    ws.on_upgrade(move |socket| handle_authenticated_websocket(socket, authenticated_user, state))
}

// å¤„ç†å·²è®¤è¯çš„ WebSocket è¿æ¥
async fn handle_authenticated_websocket(
    socket: WebSocket,
    user: AuthenticatedUser,
    state: AppState,
) {
    let (mut sender, mut receiver) = socket.split();
    let user_id = user.id.clone();

    // å‘é€æ¬¢è¿æ¶ˆæ¯
    let welcome_msg = serde_json::json!({
        "type": "auth_success",
        "message": format!("ğŸ‰ æ¬¢è¿ {}ï¼è®¤è¯æˆåŠŸï¼Œè¿æ¥å·²å»ºç«‹ã€‚", user.name),
        "user": {
            "id": user.id,
            "name": user.name,
            "permissions": user.permissions,
            "connected_at": user.connected_at.to_rfc3339()
        },
        "server_time": chrono::Utc::now().to_rfc3339()
    });

    if sender
        .send(axum::extract::ws::Message::Text(
            serde_json::to_string(&welcome_msg).unwrap(),
        ))
        .await
        .is_err()
    {
        error!("å‘é€æ¬¢è¿æ¶ˆæ¯å¤±è´¥: {}", user_id);
        cleanup_user_connection(&state, &user_id).await;
        return;
    }

    // æ¶ˆæ¯å¤„ç†å¾ªç¯
    while let Some(msg) = receiver.next().await {
        match msg {
            Ok(axum::extract::ws::Message::Text(text)) => {
                debug!("ç”¨æˆ· {} å‘é€æ¶ˆæ¯: {}", user_id, text);

                // æ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
                if let Some(mut user_info) = state.connected_users.write().await.get_mut(&user_id) {
                    user_info.last_activity = chrono::Utc::now();
                }

                // è§£ææ¶ˆæ¯
                if let Ok(incoming_msg) = serde_json::from_str::<serde_json::Value>(&text) {
                    if let Err(e) = handle_authenticated_message(incoming_msg, &user, &state, &mut sender).await {
                        error!("å¤„ç†è®¤è¯æ¶ˆæ¯å¤±è´¥: {}", e);
                    }
                } else {
                    // ç®€å•æ–‡æœ¬æ¶ˆæ¯
                    let response = serde_json::json!({
                        "type": "message_received",
                        "user_id": user_id,
                        "user_name": user.name,
                        "content": text,
                        "timestamp": chrono::Utc::now().to_rfc3339(),
                        "permissions": user.permissions
                    });

                    let _ = sender
                        .send(axum::extract::ws::Message::Text(
                            serde_json::to_string(&response).unwrap(),
                        ))
                        .await;
                }
            }
            Ok(axum::extract::ws::Message::Close(_)) => {
                info!("ç”¨æˆ· {} ä¸»åŠ¨æ–­å¼€è¿æ¥", user_id);
                break;
            }
            Ok(axum::extract::ws::Message::Ping(data)) => {
                if sender
                    .send(axum::extract::ws::Message::Pong(data))
                    .await
                    .is_err()
                {
                    break;
                }
            }
            Err(e) => {
                error!("WebSocket é”™è¯¯ï¼Œç”¨æˆ· {}: {}", user_id, e);
                break;
            }
            _ => {}
        }
    }

    // æ¸…ç†è¿æ¥
    cleanup_user_connection(&state, &user_id).await;
    info!("ç”¨æˆ· {} è¿æ¥å·²å…³é—­", user_id);
}

// å¤„ç†å·²è®¤è¯ç”¨æˆ·çš„æ¶ˆæ¯
async fn handle_authenticated_message(
    msg: serde_json::Value,
    user: &AuthenticatedUser,
    state: &AppState,
    sender: &mut futures_util::stream::SplitSink<WebSocket, axum::extract::ws::Message>,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let msg_type = msg.get("type").and_then(|v| v.as_str()).unwrap_or("unknown");

    match msg_type {
        "ping" => {
            let response = serde_json::json!({
                "type": "pong",
                "user_id": user.id,
                "server_time": chrono::Utc::now().to_rfc3339()
            });
            sender
                .send(axum::extract::ws::Message::Text(
                    serde_json::to_string(&response)?,
                ))
                .await?;
        }
        "get_user_info" => {
            let response = serde_json::json!({
                "type": "user_info",
                "user": {
                    "id": user.id,
                    "name": user.name,
                    "permissions": user.permissions,
                    "connected_at": user.connected_at.to_rfc3339(),
                    "last_activity": user.last_activity.to_rfc3339()
                }
            });
            sender
                .send(axum::extract::ws::Message::Text(
                    serde_json::to_string(&response)?,
                ))
                .await?;
        }
        "get_stats" => {
            // éœ€è¦adminæƒé™
            if !user.permissions.contains(&"admin".to_string()) {
                let error_response = serde_json::json!({
                    "type": "error",
                    "message": "æƒé™ä¸è¶³ï¼šéœ€è¦adminæƒé™æ‰èƒ½æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯",
                    "required_permission": "admin"
                });
                sender
                    .send(axum::extract::ws::Message::Text(
                        serde_json::to_string(&error_response)?,
                    ))
                    .await?;
                return Ok(());
            }

            let users = state.connected_users.read().await;
            let response = serde_json::json!({
                "type": "stats",
                "data": {
                    "connected_users": users.len(),
                    "total_connections": state.connection_count.load(Ordering::Relaxed),
                    "users": users.values().collect::<Vec<_>>()
                }
            });
            sender
                .send(axum::extract::ws::Message::Text(
                    serde_json::to_string(&response)?,
                ))
                .await?;
        }
        "admin_action" => {
            // éœ€è¦adminæƒé™
            if !user.permissions.contains(&"admin".to_string()) {
                let error_response = serde_json::json!({
                    "type": "error",
                    "message": "æƒé™ä¸è¶³ï¼šéœ€è¦adminæƒé™",
                    "required_permission": "admin"
                });
                sender
                    .send(axum::extract::ws::Message::Text(
                        serde_json::to_string(&error_response)?,
                    ))
                    .await?;
                return Ok(());
            }

            let action = msg.get("action").and_then(|v| v.as_str()).unwrap_or("");
            match action {
                "list_users" => {
                    let users = state.connected_users.read().await;
                    let response = serde_json::json!({
                        "type": "admin_response",
                        "action": "list_users",
                        "data": users.values().collect::<Vec<_>>()
                    });
                    sender
                        .send(axum::extract::ws::Message::Text(
                            serde_json::to_string(&response)?,
                        ))
                        .await?;
                }
                "server_info" => {
                    let response = serde_json::json!({
                        "type": "admin_response",
                        "action": "server_info",
                        "data": {
                            "server_start_time": chrono::Utc::now().to_rfc3339(),
                            "active_connections": state.connection_count.load(Ordering::Relaxed),
                            "jwt_enabled": true,
                            "auth_required": true
                        }
                    });
                    sender
                        .send(axum::extract::ws::Message::Text(
                            serde_json::to_string(&response)?,
                        ))
                        .await?;
                }
                _ => {
                    let error_response = serde_json::json!({
                        "type": "error",
                        "message": format!("æœªçŸ¥çš„ç®¡ç†å‘˜æ“ä½œ: {}", action)
                    });
                    sender
                        .send(axum::extract::ws::Message::Text(
                            serde_json::to_string(&error_response)?,
                        ))
                        .await?;
                }
            }
        }
        _ => {
            let response = serde_json::json!({
                "type": "echo",
                "original_message": msg,
                "user_id": user.id,
                "user_name": user.name,
                "timestamp": chrono::Utc::now().to_rfc3339()
            });
            sender
                .send(axum::extract::ws::Message::Text(
                    serde_json::to_string(&response)?,
                ))
                .await?;
        }
    }

    Ok(())
}

// æ¸…ç†ç”¨æˆ·è¿æ¥
async fn cleanup_user_connection(state: &AppState, user_id: &str) {
    state.connected_users.write().await.remove(user_id);
    let remaining_connections = state.connection_count.fetch_sub(1, Ordering::Relaxed) - 1;
    info!("æ¸…ç†ç”¨æˆ·è¿æ¥: {}, å‰©ä½™è¿æ¥æ•°: {}", user_id, remaining_connections);
}</pre>

        <p><strong>æ­¥éª¤ 3: åˆ›å»ºè®¤è¯æµ‹è¯•é¡µé¢</strong></p>
        <p><strong>åˆ›å»º templates/auth.htmlï¼š</strong></p>
        <pre>mkdir templates</pre>
        
        <p><strong>templates/auth.html å†…å®¹ï¼š</strong></p>
        <pre>&lt;!DOCTYPE html>
&lt;html lang="zh-CN">
&lt;head>
    &lt;meta charset="UTF-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
    &lt;title>WebSocket è®¤è¯æµ‹è¯•&lt;/title>
    &lt;style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 16px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 600px;
        }
        
        .auth-panel {
            padding: 30px;
            border-right: 1px solid #eee;
        }
        
        .test-panel {
            padding: 30px;
            background: #f8f9fa;
        }
        
        .section-title {
            font-size: 20px;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            margin: 5px;
        }
        
        .btn-primary { background: #3498db; color: white; }
        .btn-success { background: #27ae60; color: white; }
        .btn-warning { background: #f39c12; color: white; }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-secondary { background: #95a5a6; color: white; }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: bold;
            text-align: center;
        }
        
        .status-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .status-error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status-info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        
        .user-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        
        .user-info h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .user-info .info-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .permissions {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        .permission-tag {
            background: #3498db;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        
        .messages-container {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: white;
            font-family: 'Consolas', monospace;
            font-size: 12px;
        }
        
        .message {
            margin: 8px 0;
            padding: 8px;
            border-radius: 4px;
            word-wrap: break-word;
        }
        
        .message-sent { background: #e3f2fd; border-left: 4px solid #2196f3; }
        .message-received { background: #f1f8e9; border-left: 4px solid #4caf50; }
        .message-system { background: #fff3e0; border-left: 4px solid #ff9800; }
        .message-error { background: #ffebee; border-left: 4px solid #f44336; }
        
        .quick-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .token-display {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 11px;
            word-break: break-all;
            margin: 10px 0;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .auth-panel {
                border-right: none;
                border-bottom: 1px solid #eee;
            }
        }
    &lt;/style>
&lt;/head>
&lt;body>
    &lt;div class="container">
        &lt;div class="header">
            &lt;h1>ğŸ” WebSocket è®¤è¯ç³»ç»Ÿæµ‹è¯•&lt;/h1>
            &lt;p>æµ‹è¯•åŸºäºTokenå’ŒJWTçš„WebSocketè¿æ¥è®¤è¯æœºåˆ¶&lt;/p>
        &lt;/div>
        
        &lt;div class="main-content">
            &lt;div class="auth-panel">
                &lt;div class="section-title">ğŸ« è®¤è¯é…ç½®&lt;/div>
                
                &lt;div class="form-group">
                    &lt;label>è®¤è¯æ–¹å¼:&lt;/label>
                    &lt;select id="authType">
                        &lt;option value="simple">ç®€å•Token&lt;/option>
                        &lt;option value="jwt">JWT Token&lt;/option>
                    &lt;/select>
                &lt;/div>
                
                &lt;div class="form-group">
                    &lt;label>Token:&lt;/label>
                    &lt;input type="text" id="tokenInput" placeholder="è¾“å…¥æˆ–ç”Ÿæˆè®¤è¯Token">
                &lt;/div>
                
                &lt;div class="quick-actions">
                    &lt;button class="btn btn-success" onclick="generateToken()">ğŸ”‘ ç”ŸæˆToken&lt;/button>
                    &lt;button class="btn btn-primary" onclick="connectWebSocket()">ğŸ”— è¿æ¥&lt;/button>
                    &lt;button class="btn btn-danger" onclick="disconnect()" disabled id="disconnectBtn">âŒ æ–­å¼€&lt;/button>
                &lt;/div>
                
                &lt;div class="form-group">
                    &lt;label>é¢„è®¾Token (ç‚¹å‡»ä½¿ç”¨):&lt;/label>
                    &lt;div class="quick-actions">
                        &lt;button class="btn btn-secondary" onclick="usePresetToken('admin_token_123')">ğŸ‘‘ ç®¡ç†å‘˜&lt;/button>
                        &lt;button class="btn btn-secondary" onclick="usePresetToken('user_token_456')">ğŸ‘¤ æ™®é€šç”¨æˆ·&lt;/button>
                        &lt;button class="btn btn-secondary" onclick="usePresetToken('guest_token_789')">ğŸ‘¥ è®¿å®¢&lt;/button>
                    &lt;/div>
                &lt;/div>
                
                &lt;div id="connectionStatus" class="status status-warning">æœªè¿æ¥&lt;/div>
                
                &lt;div id="userInfo" class="user-info" style="display: none;">
                    &lt;h4>ğŸ‘¤ ç”¨æˆ·ä¿¡æ¯&lt;/h4>
                    &lt;div class="info-item">
                        &lt;span>ç”¨æˆ·ID:&lt;/span>
                        &lt;span id="userId">-&lt;/span>
                    &lt;/div>
                    &lt;div class="info-item">
                        &lt;span>ç”¨æˆ·å:&lt;/span>
                        &lt;span id="userName">-&lt;/span>
                    &lt;/div>
                    &lt;div class="info-item">
                        &lt;span>è¿æ¥æ—¶é—´:&lt;/span>
                        &lt;span id="connectedAt">-&lt;/span>
                    &lt;/div>
                    &lt;div class="permissions" id="userPermissions">&lt;/div>
                &lt;/div>
            &lt;/div>
            
            &lt;div class="test-panel">
                &lt;div class="section-title">ğŸ§ª åŠŸèƒ½æµ‹è¯•&lt;/div>
                
                &lt;div class="quick-actions">
                    &lt;button class="btn btn-primary" onclick="sendMessage('ping')">ğŸ“ Pingæµ‹è¯•&lt;/button>
                    &lt;button class="btn btn-primary" onclick="sendMessage('get_user_info')">ğŸ‘¤ è·å–ç”¨æˆ·ä¿¡æ¯&lt;/button>
                    &lt;button class="btn btn-warning" onclick="sendMessage('get_stats')">ğŸ“Š è·å–ç»Ÿè®¡(éœ€Admin)&lt;/button>
                    &lt;button class="btn btn-danger" onclick="sendAdminAction('list_users')">ğŸ‘¥ åˆ—å‡ºç”¨æˆ·(éœ€Admin)&lt;/button>
                &lt;/div>
                
                &lt;div class="form-group">
                    &lt;label>è‡ªå®šä¹‰æ¶ˆæ¯:&lt;/label>
                    &lt;div style="display: flex; gap: 10px;">
                        &lt;input type="text" id="customMessage" placeholder="è¾“å…¥JSONæ¶ˆæ¯æˆ–æ–‡æœ¬" style="flex: 1;">
                        &lt;button class="btn btn-primary" onclick="sendCustomMessage()">ğŸ“¤ å‘é€&lt;/button>
                    &lt;/div>
                &lt;/div>
                
                &lt;div class="form-group">
                    &lt;label>æ¶ˆæ¯æ—¥å¿—:&lt;/label>
                    &lt;div class="messages-container" id="messagesContainer">&lt;/div>
                &lt;/div>
                
                &lt;div class="quick-actions">
                    &lt;button class="btn btn-secondary" onclick="clearMessages()">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—&lt;/button>
                    &lt;button class="btn btn-secondary" onclick="exportLogs()">ğŸ’¾ å¯¼å‡ºæ—¥å¿—&lt;/button>
                &lt;/div>
            &lt;/div>
        &lt;/div>
    &lt;/div>

    &lt;script>
        let ws = null;
        let messageCount = 0;

        function addMessage(content, type = 'system') {
            const container = document.getElementById('messagesContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message message-${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            messageDiv.innerHTML = `&lt;strong>[${timestamp}]&lt;/strong> ${content}`;
            
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            messageCount++;
        }

        function updateStatus(text, className) {
            const status = document.getElementById('connectionStatus');
            status.textContent = text;
            status.className = `status status-${className}`;
        }

        function updateUserInfo(user) {
            const userInfo = document.getElementById('userInfo');
            const userId = document.getElementById('userId');
            const userName = document.getElementById('userName');
            const connectedAt = document.getElementById('connectedAt');
            const permissions = document.getElementById('userPermissions');
            
            userId.textContent = user.id;
            userName.textContent = user.name;
            connectedAt.textContent = new Date(user.connected_at).toLocaleString();
            
            permissions.innerHTML = '';
            user.permissions.forEach(perm => {
                const tag = document.createElement('span');
                tag.className = 'permission-tag';
                tag.textContent = perm;
                permissions.appendChild(tag);
            });
            
            userInfo.style.display = 'block';
        }

        async function generateToken() {
            const authType = document.getElementById('authType').value;
            const tokenInput = document.getElementById('tokenInput');
            
            try {
                let url = '/api/generate-token';
                if (authType === 'jwt') {
                    url = '/api/generate-jwt?user_id=test_user&name=æµ‹è¯•ç”¨æˆ·&permissions=read,write';
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.token) {
                    tokenInput.value = data.token;
                    addMessage(`ç”Ÿæˆ${authType.toUpperCase()}TokenæˆåŠŸ: ${data.token.substring(0, 50)}...`, 'system');
                    
                    if (authType === 'jwt') {
                        addMessage(`Tokenä¿¡æ¯: ç”¨æˆ·=${data.name}, æƒé™=${data.permissions.join(',')}, è¿‡æœŸæ—¶é—´=${new Date(data.expires_at).toLocaleString()}`, 'system');
                    }
                } else {
                    addMessage(`ç”ŸæˆTokenå¤±è´¥: ${data.error || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                }
            } catch (error) {
                addMessage(`ç”ŸæˆTokenæ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`, 'error');
            }
        }

        function usePresetToken(token) {
            document.getElementById('tokenInput').value = token;
            document.getElementById('authType').value = 'simple';
            addMessage(`ä½¿ç”¨é¢„è®¾Token: ${token}`, 'system');
        }

        function connectWebSocket() {
            const token = document.getElementById('tokenInput').value.trim();
            
            if (!token) {
                addMessage('è¯·è¾“å…¥Tokenæˆ–ç‚¹å‡»"ç”ŸæˆToken"', 'error');
                return;
            }
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                addMessage('WebSocketå·²ç»è¿æ¥ï¼', 'system');
                return;
            }
            
            const wsUrl = `ws://${window.location.host}/ws?token=${encodeURIComponent(token)}`;
            addMessage(`å°è¯•è¿æ¥: ${wsUrl}`, 'system');
            updateStatus('è¿æ¥ä¸­...', 'warning');
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function(event) {
                updateStatus('å·²è¿æ¥å¹¶è®¤è¯', 'success');
                addMessage('WebSocketè¿æ¥æˆåŠŸï¼Œç­‰å¾…è®¤è¯ç¡®è®¤...', 'system');
                document.getElementById('disconnectBtn').disabled = false;
            };
            
            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    handleMessage(message);
                } catch (e) {
                    addMessage(`æ”¶åˆ°æ¶ˆæ¯: ${event.data}`, 'received');
                }
            };
            
            ws.onclose = function(event) {
                updateStatus(`è¿æ¥å…³é—­ (${event.code})`, 'error');
                addMessage(`WebSocketè¿æ¥å…³é—­: ${event.code} - ${event.reason || 'æ— åŸå› '}`, 'system');
                document.getElementById('disconnectBtn').disabled = true;
                document.getElementById('userInfo').style.display = 'none';
            };
            
            ws.onerror = function(error) {
                updateStatus('è¿æ¥é”™è¯¯', 'error');
                addMessage('WebSocketè¿æ¥å‡ºé”™ï¼Œå¯èƒ½æ˜¯è®¤è¯å¤±è´¥', 'error');
                console.error('WebSocketé”™è¯¯:', error);
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        function handleMessage(message) {
            switch (message.type) {
                case 'auth_success':
                    addMessage(message.message, 'system');
                    updateUserInfo(message.user);
                    break;
                case 'pong':
                    addMessage(`Pongå“åº”: ${message.server_time}`, 'received');
                    break;
                case 'user_info':
                    addMessage('ç”¨æˆ·ä¿¡æ¯æ›´æ–°', 'received');
                    updateUserInfo(message.user);
                    break;
                case 'stats':
                    addMessage(`æœåŠ¡å™¨ç»Ÿè®¡: è¿æ¥ç”¨æˆ·=${message.data.connected_users}å, æ€»è¿æ¥=${message.data.total_connections}æ¬¡`, 'received');
                    break;
                case 'admin_response':
                    if (message.action === 'list_users') {
                        const users = message.data.map(u => `${u.name}(${u.id})`).join(', ');
                        addMessage(`åœ¨çº¿ç”¨æˆ·åˆ—è¡¨: ${users}`, 'received');
                    } else {
                        addMessage(`ç®¡ç†å‘˜æ“ä½œå“åº”: ${JSON.stringify(message.data, null, 2)}`, 'received');
                    }
                    break;
                case 'error':
                    addMessage(`é”™è¯¯: ${message.message}`, 'error');
                    break;
                case 'echo':
                    addMessage(`Echoå“åº”: ${JSON.stringify(message.original_message)}`, 'received');
                    break;
                default:
                    addMessage(`æ”¶åˆ°æ¶ˆæ¯: ${JSON.stringify(message, null, 2)}`, 'received');
            }
        }

        function sendMessage(type) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('WebSocketæœªè¿æ¥', 'error');
                return;
            }
            
            const message = { type: type };
            ws.send(JSON.stringify(message));
            addMessage(`å‘é€: ${JSON.stringify(message)}`, 'sent');
        }

        function sendAdminAction(action) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('WebSocketæœªè¿æ¥', 'error');
                return;
            }
            
            const message = { 
                type: 'admin_action', 
                action: action 
            };
            ws.send(JSON.stringify(message));
            addMessage(`å‘é€ç®¡ç†å‘˜æ“ä½œ: ${JSON.stringify(message)}`, 'sent');
        }

        function sendCustomMessage() {
            const input = document.getElementById('customMessage');
            const content = input.value.trim();
            
            if (!content) return;
            
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('WebSocketæœªè¿æ¥', 'error');
                return;
            }
            
            try {
                // å°è¯•è§£æä¸ºJSON
                const message = JSON.parse(content);
                ws.send(JSON.stringify(message));
                addMessage(`å‘é€JSON: ${content}`, 'sent');
            } catch (e) {
                // ä½œä¸ºçº¯æ–‡æœ¬å‘é€
                ws.send(content);
                addMessage(`å‘é€æ–‡æœ¬: ${content}`, 'sent');
            }
            
            input.value = '';
        }

        function clearMessages() {
            document.getElementById('messagesContainer').innerHTML = '';
            messageCount = 0;
        }

        function exportLogs() {
            const messages = document.getElementById('messagesContainer').innerHTML;
            const blob = new Blob([messages], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `websocket_auth_logs_${new Date().getTime()}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // é¡µé¢åŠ è½½æ—¶çš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            addMessage('WebSocketè®¤è¯æµ‹è¯•é¡µé¢å·²åŠ è½½', 'system');
            addMessage('è¯·é€‰æ‹©è®¤è¯æ–¹å¼ï¼Œè¾“å…¥Tokenæˆ–ç”Ÿæˆæ–°Tokenï¼Œç„¶åç‚¹å‡»è¿æ¥', 'system');
            
            // ç»‘å®šå›è½¦é”®å‘é€
            document.getElementById('customMessage').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendCustomMessage();
                }
            });
        });
    &lt;/script>
&lt;/body>
&lt;/html></pre>

        <p><strong>æ­¥éª¤ 4: åˆ›å»ºTokenç”Ÿæˆå·¥å…·</strong></p>
        <p><strong>åˆ›å»º src/token_generator.rsï¼š</strong></p>
        <pre>use jsonwebtoken::{encode, EncodingKey, Header};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,     // ç”¨æˆ·ID
    name: String,    // ç”¨æˆ·å
    permissions: Vec<String>, // æƒé™åˆ—è¡¨
    exp: usize,      // è¿‡æœŸæ—¶é—´
    iat: usize,      // ç­¾å‘æ—¶é—´
    iss: String,     // ç­¾å‘è€…
}

fn main() {
    println!("ğŸ”‘ WebSocket Token ç”Ÿæˆå·¥å…·");
    println!("============================");

    let secret = "your_super_secret_jwt_key_here_make_it_long_and_secure";

    // ç”Ÿæˆä¸åŒæƒé™çš„æµ‹è¯•ç”¨æˆ·
    let test_users = vec![
        ("admin_001", "ç³»ç»Ÿç®¡ç†å‘˜", vec!["admin", "read", "write", "delete", "debug"]),
        ("user_001", "æ™®é€šç”¨æˆ·", vec!["read", "write"]),
        ("guest_001", "è®¿å®¢ç”¨æˆ·", vec!["read"]),
        ("dev_001", "å¼€å‘è€…", vec!["admin", "debug", "read", "write"]),
        ("moderator_001", "ç‰ˆä¸»", vec!["read", "write", "moderate"]),
    ];

    println!("ç”Ÿæˆçš„JWT Tokens:");
    println!();

    for (user_id, name, permissions) in test_users {
        match generate_jwt_token(user_id, name, permissions, secret, 3600) {
            Ok(token) => {
                println!("ç”¨æˆ·: {} ({})", name, user_id);
                println!("Token: {}", token);
                println!("æƒé™: {:?}", permissions);
                println!("æœ‰æ•ˆæœŸ: 1å°æ—¶");
                println!("æµ‹è¯•URL: ws://localhost:3000/ws?token={}", token);
                println!("{}","-".repeat(80));
            }
            Err(e) => {
                eprintln!("ç”ŸæˆTokenå¤±è´¥ {}: {}", user_id, e);
            }
        }
    }

    // ç”Ÿæˆç®€å•Token
    println!();
    println!("é¢„è®¾ç®€å•Tokens:");
    println!();
    
    let simple_tokens = vec![
        ("admin_token_123", "ç®¡ç†å‘˜Token", vec!["admin", "read", "write", "delete"]),
        ("user_token_456", "ç”¨æˆ·Token", vec!["read", "write"]),
        ("guest_token_789", "è®¿å®¢Token", vec!["read"]),
        ("developer_token_000", "å¼€å‘è€…Token", vec!["admin", "debug", "read", "write"]),
    ];

    for (token, desc, permissions) in simple_tokens {
        println!("Token: {}", token);
        println!("æè¿°: {}", desc);
        println!("æƒé™: {:?}", permissions);
        println!("æµ‹è¯•URL: ws://localhost:3000/ws?token={}", token);
        println!("{}","-".repeat(80));
    }

    // ç”Ÿæˆè‡ªå®šä¹‰Token
    println!();
    println!("ğŸ¯ ç”Ÿæˆè‡ªå®šä¹‰Token:");
    
    print!("è¯·è¾“å…¥ç”¨æˆ·å (é»˜è®¤: custom_user): ");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
    let user_name = input.trim();
    let user_name = if user_name.is_empty() { "custom_user" } else { user_name };

    print!("è¯·è¾“å…¥æƒé™åˆ—è¡¨ï¼Œç”¨é€—å·åˆ†éš” (é»˜è®¤: read,write): ");
    input.clear();
    std::io::stdin().read_line(&mut input).unwrap();
    let permissions_str = input.trim();
    let permissions_str = if permissions_str.is_empty() { "read,write" } else { permissions_str };
    let permissions: Vec<String> = permissions_str.split(',').map(|s| s.trim().to_string()).collect();

    print!("è¯·è¾“å…¥æœ‰æ•ˆæœŸ(ç§’) (é»˜è®¤: 3600): ");
    input.clear();
    std::io::stdin().read_line(&mut input).unwrap();
    let expires_in = input.trim().parse::<usize>().unwrap_or(3600);

    let user_id = format!("custom_{}", Uuid::new_v4().to_string()[..8].to_string());

    match generate_jwt_token(&user_id, user_name, permissions.clone(), secret, expires_in) {
        Ok(token) => {
            println!();
            println!("âœ… è‡ªå®šä¹‰Tokenç”ŸæˆæˆåŠŸ!");
            println!("ç”¨æˆ·ID: {}", user_id);
            println!("ç”¨æˆ·å: {}", user_name);
            println!("æƒé™: {:?}", permissions);
            println!("æœ‰æ•ˆæœŸ: {}ç§’", expires_in);
            println!("Token: {}", token);
            println!("æµ‹è¯•URL: ws://localhost:3000/ws?token={}", token);
        }
        Err(e) => {
            eprintln!("âŒ ç”Ÿæˆè‡ªå®šä¹‰Tokenå¤±è´¥: {}", e);
        }
    }
}

fn generate_jwt_token(
    user_id: &str,
    name: &str,
    permissions: Vec<&str>,
    secret: &str,
    expires_in: usize,
) -> Result<String, jsonwebtoken::errors::Error> {
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() as usize;

    let claims = Claims {
        sub: user_id.to_string(),
        name: name.to_string(),
        permissions: permissions.into_iter().map(String::from).collect(),
        exp: now + expires_in,
        iat: now,
        iss: "websocket-auth-server".to_string(),
    };

    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_ref()))
}</pre>

        <p><strong>æ­¥éª¤ 5: åˆ›å»ºè®¤è¯å®¢æˆ·ç«¯</strong></p>
        <p><strong>åˆ›å»º src/client.rsï¼š</strong></p>
        <pre>use futures_util::{SinkExt, StreamExt};
use serde_json;
use std::io::{self, Write};
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ” WebSocket è®¤è¯å®¢æˆ·ç«¯");
    println!("========================");

    // è·å–è®¤è¯Token
    print!("è¯·è¾“å…¥è®¤è¯Token: ");
    io::stdout().flush().unwrap();
    let mut token = String::new();
    io::stdin().read_line(&mut token).unwrap();
    let token = token.trim();

    if token.is_empty() {
        println!("âŒ Tokenä¸èƒ½ä¸ºç©º");
        println!("ğŸ’¡ æç¤ºï¼šå¯ä»¥ä½¿ç”¨ä»¥ä¸‹é¢„è®¾Token:");
        println!("   - admin_token_123 (ç®¡ç†å‘˜æƒé™)");
        println!("   - user_token_456 (æ™®é€šç”¨æˆ·æƒé™)");
        println!("   - guest_token_789 (è®¿å®¢æƒé™)");
        println!("   - æˆ–è¿è¡Œ cargo run --bin token_generator ç”ŸæˆJWT Token");
        return Ok(());
    }

    let url = format!("ws://127.0.0.1:3000/ws?token={}", urlencoding::encode(token));
    println!("ğŸ”— è¿æ¥åˆ°: {}", url);

    let (ws_stream, response) = connect_async(&url).await?;
    println!("âœ… WebSocketè¿æ¥æˆåŠŸ!");
    println!("ğŸ“‹ æœåŠ¡å™¨å“åº”çŠ¶æ€: {}", response.status());

    let (mut write, mut read) = ws_stream.split();

    // å¯åŠ¨æ¥æ”¶æ¶ˆæ¯çš„ä»»åŠ¡
    let read_handle = tokio::spawn(async move {
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    if let Ok(json_msg) = serde_json::from_str::<serde_json::Value>(&text) {
                        print_json_message(&json_msg);
                    } else {
                        println!("ğŸ“© æ–‡æœ¬æ¶ˆæ¯: {}", text);
                    }
                }
                Ok(Message::Binary(data)) => {
                    println!("ğŸ“¦ äºŒè¿›åˆ¶æ¶ˆæ¯: {} å­—èŠ‚", data.len());
                }
                Ok(Message::Close(close_frame)) => {
                    println!("ğŸ‘‹ æœåŠ¡å™¨å…³é—­è¿æ¥: {:?}", close_frame);
                    break;
                }
                Ok(Message::Ping(_)) => {
                    println!("ğŸ“ æ”¶åˆ°Ping");
                }
                Ok(Message::Pong(_)) => {
                    println!("ğŸ“ æ”¶åˆ°Pong");
                }
                Err(e) => {
                    println!("âŒ æ¥æ”¶æ¶ˆæ¯é”™è¯¯: {}", e);
                    break;
                }
            }
        }
    });

    // æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
    println!();
    println!("ğŸ’¡ å¯ç”¨å‘½ä»¤:");
    println!("   ping                    - å‘é€pingæµ‹è¯•");
    println!("   info                    - è·å–ç”¨æˆ·ä¿¡æ¯");
    println!("   stats                   - è·å–æœåŠ¡å™¨ç»Ÿè®¡ (éœ€è¦adminæƒé™)");
    println!("   admin list_users        - åˆ—å‡ºæ‰€æœ‰åœ¨çº¿ç”¨æˆ· (éœ€è¦adminæƒé™)");
    println!("   admin server_info       - è·å–æœåŠ¡å™¨ä¿¡æ¯ (éœ€è¦adminæƒé™)");
    println!("   json {{\"key\":\"value\"}}   - å‘é€JSONæ¶ˆæ¯");
    println!("   quit                    - é€€å‡ºå®¢æˆ·ç«¯");
    println!();

    // æ¶ˆæ¯å‘é€å¾ªç¯
    loop {
        print!("ğŸ” > ");
        io::stdout().flush().unwrap();

        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();

        if input == "quit" || input == "exit" {
            break;
        }

        if input.is_empty() {
            continue;
        }

        // å¤„ç†å‘½ä»¤
        let message = match input {
            "ping" => {
                serde_json::json!({ "type": "ping" })
            }
            "info" => {
                serde_json::json!({ "type": "get_user_info" })
            }
            "stats" => {
                serde_json::json!({ "type": "get_stats" })
            }
            _ if input.starts_with("admin ") => {
                let action = &input[6..];
                serde_json::json!({
                    "type": "admin_action",
                    "action": action
                })
            }
            _ if input.starts_with("json ") => {
                let json_str = &input[5..];
                match serde_json::from_str::<serde_json::Value>(json_str) {
                    Ok(json_val) => json_val,
                    Err(e) => {
                        println!("âŒ JSONè§£æå¤±è´¥: {}", e);
                        continue;
                    }
                }
            }
            _ => {
                // æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                serde_json::json!({
                    "type": "text_message",
                    "content": input
                })
            }
        };

        if write
            .send(Message::Text(serde_json::to_string(&message).unwrap()))
            .await
            .is_err()
        {
            println!("âŒ å‘é€æ¶ˆæ¯å¤±è´¥");
            break;
        }

        println!("ğŸ“¤ å·²å‘é€: {}", serde_json::to_string(&message).unwrap());
    }

    println!("ğŸ‘‹ æ­£åœ¨å…³é—­è¿æ¥...");
    let _ = write.send(Message::Close(None)).await;
    read_handle.abort();

    Ok(())
}

fn print_json_message(msg: &serde_json::Value) {
    let msg_type = msg.get("type").and_then(|v| v.as_str()).unwrap_or("unknown");
    let timestamp = chrono::Local::now().format("%H:%M:%S").to_string();

    match msg_type {
        "auth_success" => {
            println!("\nâœ… [{}] {}", timestamp, msg.get("message").and_then(|v| v.as_str()).unwrap_or("è®¤è¯æˆåŠŸ"));
            if let Some(user) = msg.get("user") {
                println!("ğŸ‘¤ ç”¨æˆ·ä¿¡æ¯:");
                println!("   ID: {}", user.get("id").and_then(|v| v.as_str()).unwrap_or("N/A"));
                println!("   å§“å: {}", user.get("name").and_then(|v| v.as_str()).unwrap_or("N/A"));
                if let Some(permissions) = user.get("permissions").and_then(|v| v.as_array()) {
                    let perms: Vec<String> = permissions.iter()
                        .filter_map(|p| p.as_str())
                        .map(String::from)
                        .collect();
                    println!("   æƒé™: {:?}", perms);
                }
                println!("   è¿æ¥æ—¶é—´: {}", user.get("connected_at").and_then(|v| v.as_str()).unwrap_or("N/A"));
            }
        }
        "pong" => {
            println!("ğŸ“ [{}] Pongå“åº”", timestamp);
        }
        "user_info" => {
            println!("ğŸ‘¤ [{}] ç”¨æˆ·ä¿¡æ¯æ›´æ–°:", timestamp);
            if let Some(user) = msg.get("user") {
                println!("   {}", serde_json::to_string_pretty(user).unwrap_or_default());
            }
        }
        "stats" => {
            println!("ğŸ“Š [{}] æœåŠ¡å™¨ç»Ÿè®¡:", timestamp);
            if let Some(data) = msg.get("data") {
                println!("   {}", serde_json::to_string_pretty(data).unwrap_or_default());
            }
        }
        "admin_response" => {
            let action = msg.get("action").and_then(|v| v.as_str()).unwrap_or("unknown");
            println!("ğŸ‘‘ [{}] ç®¡ç†å‘˜æ“ä½œå“åº” ({}):", timestamp, action);
            if let Some(data) = msg.get("data") {
                println!("   {}", serde_json::to_string_pretty(data).unwrap_or_default());
            }
        }
        "error" => {
            let error_msg = msg.get("message").and_then(|v| v.as_str()).unwrap_or("æœªçŸ¥é”™è¯¯");
            println!("âŒ [{}] é”™è¯¯: {}", timestamp, error_msg);
            if let Some(required_perm) = msg.get("required_permission") {
                println!("   éœ€è¦æƒé™: {}", required_perm.as_str().unwrap_or("unknown"));
            }
        }
        "echo" => {
            println!("ğŸ”„ [{}] Echoå“åº”:", timestamp);
            println!("   {}", serde_json::to_string_pretty(msg).unwrap_or_default());
        }
        _ => {
            println!("ğŸ“© [{}] æ”¶åˆ°æ¶ˆæ¯ ({}):", timestamp, msg_type);
            println!("   {}", serde_json::to_string_pretty(msg).unwrap_or_default());
        }
    }

    print!("\nğŸ” > ");
    io::stdout().flush().unwrap();
}</pre>

        <p><strong>è¿è¡Œå’Œæµ‹è¯•ï¼š</strong></p>
        <pre># 1. è¿è¡ŒæœåŠ¡å™¨
cargo run --bin server

# 2. ç”Ÿæˆæµ‹è¯•Token (å¯é€‰)
cargo run --bin token_generator

# 3. è¿è¡Œå®¢æˆ·ç«¯æµ‹è¯•
cargo run --bin client

# 4. æˆ–åœ¨æµè§ˆå™¨ä¸­è®¿é—®æµ‹è¯•é¡µé¢
# http://localhost:3000</pre>

        <p><strong>è®¤è¯æµ‹è¯•åœºæ™¯ï¼š</strong></p>
        <pre># æµ‹è¯•åœºæ™¯1: ä½¿ç”¨æœ‰æ•ˆçš„ç®€å•Token
ws://localhost:3000/ws?token=admin_token_123

# æµ‹è¯•åœºæ™¯2: ä½¿ç”¨æ— æ•ˆToken (åº”è¯¥è¢«æ‹’ç»)
ws://localhost:3000/ws?token=invalid_token

# æµ‹è¯•åœºæ™¯3: ä¸æä¾›Token (åº”è¯¥è¢«æ‹’ç»)
ws://localhost:3000/ws

# æµ‹è¯•åœºæ™¯4: ä½¿ç”¨JWT Token
# å…ˆè¿è¡Œ token_generator ç”ŸæˆJWTï¼Œç„¶åä½¿ç”¨ç”Ÿæˆçš„Tokenè¿æ¥

# æµ‹è¯•åœºæ™¯5: æƒé™æµ‹è¯•
# ä½¿ç”¨ guest_token_789 è¿æ¥ï¼Œç„¶åå°è¯•æ‰§è¡Œéœ€è¦adminæƒé™çš„æ“ä½œ</pre>

        <p><strong>å®è·µä»»åŠ¡ï¼š</strong></p>
        <ul>
            <li>å®ç°åŸºäºIPçš„è¿æ¥é™åˆ¶å’Œé»‘åå•åŠŸèƒ½</li>
            <li>æ·»åŠ Tokenåˆ·æ–°æœºåˆ¶ï¼ˆåœ¨Tokenå¿«è¿‡æœŸæ—¶è‡ªåŠ¨åˆ·æ–°ï¼‰</li>
            <li>å®ç°åŸºäºè§’è‰²çš„æƒé™æ§åˆ¶ï¼ˆRBACï¼‰</li>
            <li>æ·»åŠ è¿æ¥å®¡è®¡æ—¥å¿—ï¼ˆè®°å½•æ‰€æœ‰è¿æ¥å°è¯•å’Œæƒé™æ£€æŸ¥ï¼‰</li>
            <li>å®ç°åŠ¨æ€æƒé™ç®¡ç†ï¼ˆè¿è¡Œæ—¶æ·»åŠ /åˆ é™¤ç”¨æˆ·æƒé™ï¼‰</li>
            <li>æ·»åŠ Tokenæ’¤é”€æœºåˆ¶ï¼ˆé»‘åå•å¤±æ•ˆçš„Tokenï¼‰</li>
            <li>å®ç°å¤šå› ç´ è®¤è¯ï¼ˆ2FAï¼‰æ”¯æŒ</li>
            <li>æ·»åŠ è¿æ¥é€Ÿç‡é™åˆ¶å’Œé˜²æš´åŠ›ç ´è§£æœºåˆ¶</li>
        </ul>

        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day18_websocket_auth/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ client.rs
â”‚   â””â”€â”€ token_generator.rs
â”œâ”€â”€ templates/
â”‚   â””â”€â”€ auth.html
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .gitignore</pre>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-19</strong></p>
        <h2>Day 19 - æ„å»ºæ—¥å¿—ç³»ç»Ÿï¼štracing æ—¥å¿—è¾“å‡º</h2>
        <p>ä»Šå¤©ä½ å°†å­¦ä¹ å¹¶å®ç° Rust ä¸­å¼ºå¤§çš„ tracing æ—¥å¿—ç³»ç»Ÿã€‚ä½ å°†é…ç½®ç»“æ„åŒ–æ—¥å¿—è¾“å‡ºï¼Œæ·»åŠ æ—¥å¿—ç­‰çº§æ§åˆ¶ï¼Œå¹¶åœ¨ WebSocket æœåŠ¡ä¸­ä½¿ç”¨ tracing æ¥ç›‘æ§è¿æ¥çŠ¶æ€ã€æ¶ˆæ¯å¤„ç†å’Œé”™è¯¯è¿½è¸ªã€‚</p>
        
        <p><strong>ğŸ¯ ä»Šæ—¥ç›®æ ‡</strong></p>
        <ul>
            <li>ç†è§£ tracing ä¸ä¼ ç»Ÿ log çš„åŒºåˆ«</li>
            <li>é…ç½® tracing_subscriber æ—¥å¿—æ ¼å¼åŒ–</li>
            <li>ä½¿ç”¨ä¸åŒæ—¥å¿—ç­‰çº§è®°å½•ä¿¡æ¯</li>
            <li>æ·»åŠ ç»“æ„åŒ–å­—æ®µå’Œä¸Šä¸‹æ–‡è¿½è¸ª</li>
            <li>å®ç°ç”Ÿäº§ç¯å¢ƒæ—¥å¿—é…ç½®</li>
        </ul>

        <p>ğŸ”— <a href="https://docs.rs/tracing/latest/tracing/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>

        <p><strong>æ­¥éª¤ 1: é¡¹ç›®è®¾ç½®</strong></p>
        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day19_websocket_logging/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ server.rs
â”‚   â””â”€â”€ client.rs
â”œâ”€â”€ static/
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ Cargo.toml
â””â”€â”€ logs/
    â””â”€â”€ app.log</pre>

        <p><strong>Cargo.toml é…ç½®ï¼š</strong></p>
        <pre>[package]
name = "websocket-logging"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.21"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["fs", "cors"] }

# Tracing dependencies
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["json", "env-filter"] }
tracing-appender = "0.2"
anyhow = "1.0"
chrono = { version = "0.4", features = ["serde"] }</pre>

        <p><strong>æ­¥éª¤ 2: åˆ›å»ºä¸»æœåŠ¡å™¨ (src/main.rs)</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocketUpgrade, State},
    http::StatusCode,
    response::{Html, Response},
    routing::get,
    Router,
};
use std::{collections::HashMap, net::SocketAddr, sync::Arc};
use tokio::sync::{broadcast, RwLock};
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{debug, error, info, instrument, warn, Span};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use uuid::Uuid;

mod server;
use server::{handle_websocket, AppState, ConnectedClient};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    init_tracing()?;
    
    info!("ğŸš€ å¯åŠ¨ WebSocket æ—¥å¿—æœåŠ¡å™¨");
    
    // åˆ›å»ºåº”ç”¨çŠ¶æ€
    let (tx, _rx) = broadcast::channel(1000);
    let state = Arc::new(AppState {
        clients: RwLock::new(HashMap::new()),
        tx,
    });
    
    // åˆ›å»ºè·¯ç”±
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .route("/health", get(health_handler))
        .route("/metrics", get(metrics_handler))
        .nest_service("/static", ServeDir::new("static"))
        .with_state(state)
        .layer(CorsLayer::permissive());
    
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!(address = %addr, "æœåŠ¡å™¨å¯åŠ¨å®Œæˆ");
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;
    
    Ok(())
}

/// åˆå§‹åŒ– tracing æ—¥å¿—ç³»ç»Ÿ
fn init_tracing() -> anyhow::Result<()> {
    // åˆ›å»ºæ—¥å¿—ç›®å½•
    std::fs::create_dir_all("logs")?;
    
    // æ–‡ä»¶ appender
    let file_appender = tracing_appender::rolling::daily("logs", "app.log");
    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);
    
    // ç¯å¢ƒè¿‡æ»¤å™¨ï¼Œæ”¯æŒé€šè¿‡ç¯å¢ƒå˜é‡æ§åˆ¶æ—¥å¿—ç­‰çº§
    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| "info,axum=debug,tower_http=debug".into());
    
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_target(true)
                .with_thread_ids(true)
                .with_line_number(true)
                .with_file(true)
                .compact()
        )
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(non_blocking)
                .with_ansi(false)
                .json()
        )
        .with(env_filter)
        .init();
    
    info!("ğŸ“ æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
    Ok(())
}

#[instrument(name = "websocket_upgrade")]
async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<Arc<AppState>>,
) -> Response {
    let client_id = Uuid::new_v4();
    info!(client_id = %client_id, "æ–°çš„ WebSocket è¿æ¥è¯·æ±‚");
    
    ws.on_upgrade(move |socket| {
        let span = tracing::info_span!("websocket_connection", client_id = %client_id);
        async move {
            if let Err(e) = handle_websocket(socket, state, client_id).await {
                error!(client_id = %client_id, error = %e, "WebSocket è¿æ¥å¤„ç†å¤±è´¥");
            }
        }
        .instrument(span)
    })
}

async fn index_handler() -> Html<&'static str> {
    debug!("æä¾›ä¸»é¡µ");
    Html(include_str!("../static/index.html"))
}

#[instrument]
async fn health_handler(State(state): State<Arc<AppState>>) -> Result<String, StatusCode> {
    let clients = state.clients.read().await;
    let client_count = clients.len();
    debug!(client_count, "å¥åº·æ£€æŸ¥");
    
    Ok(format!("{{\"status\":\"healthy\",\"clients\":{}}}", client_count))
}

#[instrument]
async fn metrics_handler(State(state): State<Arc<AppState>>) -> Result<String, StatusCode> {
    let clients = state.clients.read().await;
    let active_connections = clients.len();
    let total_messages: u64 = clients.values().map(|c| c.message_count).sum();
    
    info!(
        active_connections,
        total_messages,
        "æŒ‡æ ‡è¯·æ±‚"
    );
    
    Ok(format!(
        "{{\"active_connections\":{},\"total_messages\":{}}}",
        active_connections, total_messages
    ))
}</pre>

        <p><strong>æ­¥éª¤ 3: WebSocket å¤„ç†å™¨ (src/server.rs)</strong></p>
        <pre>use axum::extract::ws::{Message, WebSocket};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, time::Instant};
use tokio::sync::{broadcast, RwLock};
use tracing::{debug, error, info, instrument, warn};
use uuid::Uuid;

#[derive(Debug, Clone)]
pub struct ConnectedClient {
    pub id: Uuid,
    pub name: String,
    pub connected_at: Instant,
    pub message_count: u64,
}

pub struct AppState {
    pub clients: RwLock<HashMap<Uuid, ConnectedClient>>,
    pub tx: broadcast::Sender<BroadcastMessage>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    pub message_type: String,
    pub content: String,
    pub sender: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub struct BroadcastMessage {
    pub sender_id: Uuid,
    pub message: ChatMessage,
}

#[instrument(skip(socket, state))]
pub async fn handle_websocket(
    mut socket: WebSocket,
    state: std::sync::Arc<AppState>,
    client_id: Uuid,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    info!(client_id = %client_id, "WebSocket è¿æ¥å»ºç«‹");
    
    // å‘é€æ¬¢è¿æ¶ˆæ¯
    let welcome_msg = ChatMessage {
        message_type: "system".to_string(),
        content: format!("æ¬¢è¿è¿æ¥ï¼æ‚¨çš„ ID: {}", client_id),
        sender: Some("ç³»ç»Ÿ".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    if let Err(e) = socket.send(Message::Text(serde_json::to_string(&welcome_msg)?)).await {
        error!(client_id = %client_id, error = %e, "å‘é€æ¬¢è¿æ¶ˆæ¯å¤±è´¥");
        return Err(e.into());
    }
    
    // æ³¨å†Œå®¢æˆ·ç«¯
    let client = ConnectedClient {
        id: client_id,
        name: format!("ç”¨æˆ·-{}", &client_id.to_string()[..8]),
        connected_at: Instant::now(),
        message_count: 0,
    };
    
    {
        let mut clients = state.clients.write().await;
        clients.insert(client_id, client.clone());
        info!(
            client_id = %client_id,
            client_name = %client.name,
            total_clients = clients.len(),
            "å®¢æˆ·ç«¯æ³¨å†ŒæˆåŠŸ"
        );
    }
    
    // å¹¿æ’­æ–°ç”¨æˆ·åŠ å…¥
    let join_msg = ChatMessage {
        message_type: "join".to_string(),
        content: format!("{} åŠ å…¥äº†èŠå¤©å®¤", client.name),
        sender: Some("ç³»ç»Ÿ".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    let broadcast_msg = BroadcastMessage {
        sender_id: client_id,
        message: join_msg,
    };
    
    if let Err(e) = state.tx.send(broadcast_msg) {
        warn!(client_id = %client_id, error = %e, "å¹¿æ’­åŠ å…¥æ¶ˆæ¯å¤±è´¥");
    }
    
    // åˆ›å»ºå¹¿æ’­æ¥æ”¶å™¨
    let mut rx = state.tx.subscribe();
    let state_clone = state.clone();
    
    // å¯åŠ¨æ¶ˆæ¯å¹¿æ’­ä»»åŠ¡
    let broadcast_task = tokio::spawn(async move {
        while let Ok(broadcast_msg) = rx.recv().await {
            // ä¸å‘å‘é€è€…å›æ˜¾æ¶ˆæ¯
            if broadcast_msg.sender_id == client_id {
                continue;
            }
            
            debug!(
                client_id = %client_id,
                sender_id = %broadcast_msg.sender_id,
                message_type = %broadcast_msg.message.message_type,
                "è½¬å‘å¹¿æ’­æ¶ˆæ¯"
            );
            
            let msg_json = match serde_json::to_string(&broadcast_msg.message) {
                Ok(json) => json,
                Err(e) => {
                    error!(error = %e, "åºåˆ—åŒ–å¹¿æ’­æ¶ˆæ¯å¤±è´¥");
                    continue;
                }
            };
            
            if let Err(e) = socket.send(Message::Text(msg_json)).await {
                error!(
                    client_id = %client_id,
                    error = %e,
                    "å‘é€å¹¿æ’­æ¶ˆæ¯å¤±è´¥ï¼Œè¿æ¥å¯èƒ½å·²æ–­å¼€"
                );
                break;
            }
        }
    });
    
    // å¤„ç†å®¢æˆ·ç«¯æ¶ˆæ¯
    let mut message_count = 0u64;
    while let Some(msg) = socket.recv().await {
        match msg {
            Ok(Message::Text(text)) => {
                message_count += 1;
                debug!(
                    client_id = %client_id,
                    message_count,
                    text_length = text.len(),
                    "æ”¶åˆ°æ–‡æœ¬æ¶ˆæ¯"
                );
                
                match serde_json::from_str::<ChatMessage>(&text) {
                    Ok(mut chat_msg) => {
                        chat_msg.sender = Some(client.name.clone());
                        chat_msg.timestamp = chrono::Utc::now();
                        
                        info!(
                            client_id = %client_id,
                            sender = %chat_msg.sender.as_ref().unwrap(),
                            message_type = %chat_msg.message_type,
                            content_length = chat_msg.content.len(),
                            "å¤„ç†èŠå¤©æ¶ˆæ¯"
                        );
                        
                        let broadcast_msg = BroadcastMessage {
                            sender_id: client_id,
                            message: chat_msg,
                        };
                        
                        if let Err(e) = state.tx.send(broadcast_msg) {
                            error!(
                                client_id = %client_id,
                                error = %e,
                                "å¹¿æ’­æ¶ˆæ¯å¤±è´¥"
                            );
                        } else {
                            // æ›´æ–°å®¢æˆ·ç«¯æ¶ˆæ¯è®¡æ•°
                            if let Ok(mut clients) = state.clients.write().await.try_write() {
                                if let Some(client) = clients.get_mut(&client_id) {
                                    client.message_count += 1;
                                }
                            }
                        }
                    }
                    Err(e) => {
                        warn!(
                            client_id = %client_id,
                            error = %e,
                            raw_text = %text,
                            "æ¶ˆæ¯ JSON è§£æå¤±è´¥"
                        );
                        
                        let error_msg = ChatMessage {
                            message_type: "error".to_string(),
                            content: "æ¶ˆæ¯æ ¼å¼é”™è¯¯".to_string(),
                            sender: Some("ç³»ç»Ÿ".to_string()),
                            timestamp: chrono::Utc::now(),
                        };
                        
                        let _ = socket.send(Message::Text(
                            serde_json::to_string(&error_msg)?
                        )).await;
                    }
                }
            }
            Ok(Message::Binary(data)) => {
                debug!(
                    client_id = %client_id,
                    data_length = data.len(),
                    "æ”¶åˆ°äºŒè¿›åˆ¶æ¶ˆæ¯"
                );
                
                let response = format!("æ”¶åˆ° {} å­—èŠ‚äºŒè¿›åˆ¶æ•°æ®", data.len());
                let echo_msg = ChatMessage {
                    message_type: "binary_ack".to_string(),
                    content: response,
                    sender: Some("ç³»ç»Ÿ".to_string()),
                    timestamp: chrono::Utc::now(),
                };
                
                let _ = socket.send(Message::Text(
                    serde_json::to_string(&echo_msg)?
                )).await;
            }
            Ok(Message::Close(frame)) => {
                info!(
                    client_id = %client_id,
                    close_frame = ?frame,
                    "å®¢æˆ·ç«¯ä¸»åŠ¨å…³é—­è¿æ¥"
                );
                break;
            }
            Err(e) => {
                error!(
                    client_id = %client_id,
                    error = %e,
                    "WebSocket æ¶ˆæ¯æ¥æ”¶é”™è¯¯"
                );
                break;
            }
            _ => {
                debug!(client_id = %client_id, "æ”¶åˆ°å…¶ä»–ç±»å‹æ¶ˆæ¯");
            }
        }
    }
    
    // æ¸…ç†å·¥ä½œ
    broadcast_task.abort();
    
    // ä»å®¢æˆ·ç«¯åˆ—è¡¨ä¸­ç§»é™¤
    {
        let mut clients = state.clients.write().await;
        if let Some(removed_client) = clients.remove(&client_id) {
            info!(
                client_id = %client_id,
                client_name = %removed_client.name,
                session_duration = ?removed_client.connected_at.elapsed(),
                total_messages = removed_client.message_count,
                remaining_clients = clients.len(),
                "å®¢æˆ·ç«¯æ–­å¼€è¿æ¥ï¼Œæ¸…ç†å®Œæˆ"
            );
        }
    }
    
    // å¹¿æ’­ç”¨æˆ·ç¦»å¼€æ¶ˆæ¯
    let leave_msg = ChatMessage {
        message_type: "leave".to_string(),
        content: format!("{} ç¦»å¼€äº†èŠå¤©å®¤", client.name),
        sender: Some("ç³»ç»Ÿ".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    let broadcast_msg = BroadcastMessage {
        sender_id: client_id,
        message: leave_msg,
    };
    
    let _ = state.tx.send(broadcast_msg);
    
    Ok(())
}</pre>

        <p><strong>æ­¥éª¤ 4: å‘½ä»¤è¡Œæµ‹è¯•å®¢æˆ·ç«¯ (src/client.rs)</strong></p>
        <pre>use serde_json::json;
use std::io::{self, Write};
use tokio_tungstenite::{connect_async, tungstenite::Message};
use tracing::{error, info};
use url::Url;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // ç®€å•çš„æ§åˆ¶å°æ—¥å¿—
    tracing_subscriber::fmt()
        .with_env_filter("info")
        .init();
    
    let url = Url::parse("ws://127.0.0.1:3000/ws")?;
    info!("è¿æ¥åˆ° WebSocket æœåŠ¡å™¨: {}", url);
    
    let (ws_stream, _) = connect_async(url).await?;
    info!("WebSocket è¿æ¥å»ºç«‹æˆåŠŸï¼");
    
    let (mut write, mut read) = ws_stream.split();
    
    // å¯åŠ¨æ¶ˆæ¯æ¥æ”¶ä»»åŠ¡
    let read_task = tokio::spawn(async move {
        use futures_util::StreamExt;
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&text) {
                        if let Some(content) = parsed.get("content") {
                            if let Some(sender) = parsed.get("sender") {
                                println!("[{}] {}", sender, content);
                            } else {
                                println!("{}", content);
                            }
                        } else {
                            println!("æ”¶åˆ°æ¶ˆæ¯: {}", text);
                        }
                    } else {
                        println!("æ”¶åˆ°æ¶ˆæ¯: {}", text);
                    }
                }
                Ok(Message::Close(_)) => {
                    info!("æœåŠ¡å™¨å…³é—­è¿æ¥");
                    break;
                }
                Err(e) => {
                    error!("æ¥æ”¶æ¶ˆæ¯é”™è¯¯: {}", e);
                    break;
                }
                _ => {}
            }
        }
    });
    
    // ä¸»è¾“å…¥å¾ªç¯
    println!("WebSocket èŠå¤©å®¢æˆ·ç«¯");
    println!("è¾“å…¥æ¶ˆæ¯å¹¶æŒ‰å›è½¦å‘é€ï¼Œè¾“å…¥ 'quit' é€€å‡º");
    println!("---");
    
    loop {
        print!("> ");
        io::stdout().flush()?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let input = input.trim();
        
        if input == "quit" {
            info!("ç”¨æˆ·è¯·æ±‚é€€å‡º");
            break;
        }
        
        if input.is_empty() {
            continue;
        }
        
        let message = json!({
            "message_type": "chat",
            "content": input,
            "sender": null,
            "timestamp": chrono::Utc::now()
        });
        
        use futures_util::SinkExt;
        if let Err(e) = write.send(Message::Text(message.to_string())).await {
            error!("å‘é€æ¶ˆæ¯å¤±è´¥: {}", e);
            break;
        }
    }
    
    read_task.abort();
    info!("å®¢æˆ·ç«¯é€€å‡º");
    Ok(())
}</pre>

        <p><strong>æ­¥éª¤ 5: å‰ç«¯æµ‹è¯•é¡µé¢ (static/index.html)</strong></p>
        <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;WebSocket æ—¥å¿—ç›‘æ§èŠå¤©å®¤&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .main-content {
            display: flex;
            height: 600px;
        }
        
        .chat-area {
            flex: 2;
            display: flex;
            flex-direction: column;
            border-right: 2px solid #ecf0f1;
        }
        
        .log-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #2c3e50;
            color: #ecf0f1;
        }
        
        #messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
            border-bottom: 2px solid #ecf0f1;
        }
        
        #logs {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #34495e;
        }
        
        .input-area {
            padding: 15px;
            background: white;
            border-top: 1px solid #ecf0f1;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
        }
        
        #messageInput {
            flex: 1;
            padding: 12px;
            border: 2px solid #ecf0f1;
            border-radius: 5px;
            font-size: 14px;
        }
        
        #messageInput:focus {
            outline: none;
            border-color: #3498db;
        }
        
        button {
            padding: 12px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover:not(:disabled) {
            background: #2980b9;
        }
        
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        
        .status {
            padding: 10px 20px;
            background: #ecf0f1;
            border-bottom: 1px solid #bdc3c7;
            font-size: 14px;
        }
        
        .status.connected {
            background: #d5f4e6;
            color: #27ae60;
        }
        
        .status.disconnected {
            background: #fadbd8;
            color: #e74c3c;
        }
        
        .message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            line-height: 1.4;
        }
        
        .message.system {
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            font-style: italic;
        }
        
        .message.user {
            background: #e8f5e8;
            border-left: 4px solid #27ae60;
        }
        
        .message.error {
            background: #fdf2f2;
            border-left: 4px solid #e74c3c;
        }
        
        .message.join {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        
        .message.leave {
            background: #f4f4f4;
            border-left: 4px solid #6c757d;
        }
        
        .message-meta {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px solid #2c3e50;
        }
        
        .log-entry.info { color: #3498db; }
        .log-entry.warn { color: #f39c12; }
        .log-entry.error { color: #e74c3c; }
        .log-entry.debug { color: #95a5a6; }
        
        .controls {
            padding: 15px 20px;
            background: #34495e;
            border-bottom: 1px solid #2c3e50;
        }
        
        .controls button {
            margin-right: 10px;
            font-size: 12px;
            padding: 8px 12px;
        }
        
        .controls .clear {
            background: #e74c3c;
        }
        
        .controls .clear:hover {
            background: #c0392b;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;ğŸ“Š WebSocket æ—¥å¿—ç›‘æ§èŠå¤©å®¤&lt;/h1&gt;
            &lt;p&gt;å®æ—¶æ¶ˆæ¯ + ç»“æ„åŒ–æ—¥å¿—ç›‘æ§&lt;/p&gt;
        &lt;/div&gt;
        
        &lt;div class="status" id="status"&gt;
            ğŸ”´ æœªè¿æ¥
        &lt;/div&gt;
        
        &lt;div class="main-content"&gt;
            &lt;div class="chat-area"&gt;
                &lt;div id="messages"&gt;&lt;/div&gt;
                &lt;div class="input-area"&gt;
                    &lt;div class="input-group"&gt;
                        &lt;input 
                            type="text" 
                            id="messageInput" 
                            placeholder="è¾“å…¥æ¶ˆæ¯..." 
                            disabled
                        &gt;
                        &lt;button id="sendButton" disabled&gt;å‘é€&lt;/button&gt;
                        &lt;button id="connectButton"&gt;è¿æ¥&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class="log-area"&gt;
                &lt;div class="controls"&gt;
                    &lt;button onclick="clearLogs()" class="clear"&gt;æ¸…ç©ºæ—¥å¿—&lt;/button&gt;
                    &lt;button onclick="toggleLogLevel()"&gt;åˆ‡æ¢ç­‰çº§&lt;/button&gt;
                    &lt;button onclick="exportLogs()"&gt;å¯¼å‡ºæ—¥å¿—&lt;/button&gt;
                &lt;/div&gt;
                &lt;div id="logs"&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        let ws = null;
        let isConnected = false;
        let logLevel = 'info';
        let logEntries = [];
        
        const statusEl = document.getElementById('status');
        const messagesEl = document.getElementById('messages');
        const logsEl = document.getElementById('logs');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const connectButton = document.getElementById('connectButton');
        
        function log(level, message, data = null) {
            const timestamp = new Date().toISOString();
            const entry = {
                timestamp,
                level,
                message,
                data: data ? JSON.stringify(data, null, 2) : null
            };
            
            logEntries.push(entry);
            
            const logEl = document.createElement('div');
            logEl.className = `log-entry ${level}`;
            logEl.innerHTML = `
                &lt;strong&gt;[${timestamp.substring(11, 23)}]&lt;/strong&gt; 
                &lt;span class="level"&gt;${level.toUpperCase()}&lt;/span&gt; 
                ${message}
                ${data ? `&lt;br&gt;&lt;pre style="margin: 5px 0; font-size: 10px;"&gt;${JSON.stringify(data, null, 2)}&lt;/pre&gt;` : ''}
            `;
            
            logsEl.appendChild(logEl);
            logsEl.scrollTop = logsEl.scrollHeight;
            
            // é™åˆ¶æ—¥å¿—æ¡æ•°
            while (logsEl.children.length > 1000) {
                logsEl.removeChild(logsEl.firstChild);
            }
        }
        
        function updateStatus(status, connected) {
            isConnected = connected;
            statusEl.textContent = status;
            statusEl.className = `status ${connected ? 'connected' : 'disconnected'}`;
            
            messageInput.disabled = !connected;
            sendButton.disabled = !connected;
            connectButton.textContent = connected ? 'æ–­å¼€' : 'è¿æ¥';
        }
        
        function addMessage(type, content, sender = null, timestamp = null) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            
            const time = timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
            
            messageEl.innerHTML = `
                &lt;div&gt;${content}&lt;/div&gt;
                &lt;div class="message-meta"&gt;
                    ${sender ? `ğŸ‘¤ ${sender} â€¢ ` : ''}â° ${time}
                &lt;/div&gt;
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function connect() {
            if (isConnected) {
                disconnect();
                return;
            }
            
            log('info', 'å°è¯•è¿æ¥ WebSocket æœåŠ¡å™¨...');
            
            try {
                ws = new WebSocket('ws://localhost:3000/ws');
                
                ws.onopen = function(event) {
                    log('info', 'WebSocket è¿æ¥å»ºç«‹æˆåŠŸ', { 
                        url: ws.url,
                        readyState: ws.readyState 
                    });
                    updateStatus('ğŸŸ¢ å·²è¿æ¥', true);
                    addMessage('system', 'è¿æ¥æˆåŠŸï¼æ¬¢è¿ä½¿ç”¨èŠå¤©å®¤');
                };
                
                ws.onmessage = function(event) {
                    log('debug', 'æ”¶åˆ°æœåŠ¡å™¨æ¶ˆæ¯', { 
                        data: event.data,
                        size: event.data.length 
                    });
                    
                    try {
                        const message = JSON.parse(event.data);
                        
                        addMessage(
                            message.message_type || 'user',
                            message.content,
                            message.sender,
                            message.timestamp
                        );
                        
                        log('info', `å¤„ç†æ¶ˆæ¯: ${message.message_type}`, {
                            sender: message.sender,
                            content_length: message.content.length
                        });
                        
                    } catch (e) {
                        log('error', 'è§£ææ¶ˆæ¯ JSON å¤±è´¥', { 
                            raw: event.data,
                            error: e.message 
                        });
                        addMessage('error', `æ¶ˆæ¯è§£æé”™è¯¯: ${event.data}`);
                    }
                };
                
                ws.onclose = function(event) {
                    log('warn', 'WebSocket è¿æ¥å…³é—­', {
                        code: event.code,
                        reason: event.reason,
                        wasClean: event.wasClean
                    });
                    updateStatus('ğŸ”´ è¿æ¥æ–­å¼€', false);
                    addMessage('system', `è¿æ¥æ–­å¼€ (ä»£ç : ${event.code})`);
                };
                
                ws.onerror = function(error) {
                    log('error', 'WebSocket è¿æ¥é”™è¯¯', { error: error.toString() });
                    updateStatus('ğŸ”´ è¿æ¥é”™è¯¯', false);
                    addMessage('error', 'è¿æ¥å‘ç”Ÿé”™è¯¯');
                };
                
            } catch (e) {
                log('error', 'WebSocket åˆå§‹åŒ–å¤±è´¥', { error: e.message });
                updateStatus('ğŸ”´ è¿æ¥å¤±è´¥', false);
            }
        }
        
        function disconnect() {
            if (ws) {
                log('info', 'ä¸»åŠ¨æ–­å¼€ WebSocket è¿æ¥');
                ws.close();
                ws = null;
            }
            updateStatus('ğŸ”´ æœªè¿æ¥', false);
        }
        
        function sendMessage() {
            if (!isConnected || !ws) {
                log('warn', 'å°è¯•å‘é€æ¶ˆæ¯ä½†è¿æ¥æœªå»ºç«‹');
                return;
            }
            
            const content = messageInput.value.trim();
            if (!content) return;
            
            const message = {
                message_type: 'chat',
                content: content,
                sender: null,
                timestamp: new Date().toISOString()
            };
            
            try {
                ws.send(JSON.stringify(message));
                log('info', 'å‘é€æ¶ˆæ¯', { 
                    content_length: content.length,
                    message_type: 'chat' 
                });
                
                messageInput.value = '';
            } catch (e) {
                log('error', 'å‘é€æ¶ˆæ¯å¤±è´¥', { error: e.message });
                addMessage('error', 'æ¶ˆæ¯å‘é€å¤±è´¥');
            }
        }
        
        function clearLogs() {
            logsEl.innerHTML = '';
            logEntries = [];
            log('info', 'æ—¥å¿—å·²æ¸…ç©º');
        }
        
        function toggleLogLevel() {
            const levels = ['debug', 'info', 'warn', 'error'];
            const currentIndex = levels.indexOf(logLevel);
            logLevel = levels[(currentIndex + 1) % levels.length];
            log('info', `æ—¥å¿—ç­‰çº§åˆ‡æ¢ä¸º: ${logLevel.toUpperCase()}`);
        }
        
        function exportLogs() {
            const logsJson = JSON.stringify(logEntries, null, 2);
            const blob = new Blob([logsJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `websocket_logs_${new Date().toISOString().slice(0, 19)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('info', 'æ—¥å¿—å·²å¯¼å‡º', { entries: logEntries.length });
        }
        
        // äº‹ä»¶ç›‘å¬
        connectButton.addEventListener('click', connect);
        sendButton.addEventListener('click', sendMessage);
        
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        // é¡µé¢åŠ è½½å®Œæˆ
        log('info', 'é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡å°±ç»ª');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

        <p><strong>æ­¥éª¤ 6: è¿è¡Œå’Œæµ‹è¯•</strong></p>
        <pre># å¯åŠ¨æœåŠ¡å™¨ï¼ˆæ”¯æŒç¯å¢ƒå˜é‡æ§åˆ¶æ—¥å¿—ç­‰çº§ï¼‰
RUST_LOG=debug cargo run --bin websocket-logging

# åœ¨å¦ä¸€ä¸ªç»ˆç«¯å¯åŠ¨å‘½ä»¤è¡Œå®¢æˆ·ç«¯
cargo run --bin client

# æˆ–åœ¨æµè§ˆå™¨è®¿é—®
open http://localhost:3000</pre>

        <p><strong>æ­¥éª¤ 7: æ—¥å¿—ç­‰çº§æµ‹è¯•</strong></p>
        <pre># ä¸åŒç­‰çº§çš„æ—¥å¿—è¾“å‡ºæµ‹è¯•
RUST_LOG=error cargo run    # åªæ˜¾ç¤ºé”™è¯¯
RUST_LOG=warn cargo run     # æ˜¾ç¤ºè­¦å‘Šå’Œé”™è¯¯
RUST_LOG=info cargo run     # æ˜¾ç¤ºä¿¡æ¯ã€è­¦å‘Šå’Œé”™è¯¯ï¼ˆé»˜è®¤ï¼‰
RUST_LOG=debug cargo run    # æ˜¾ç¤ºæ‰€æœ‰æ—¥å¿—
RUST_LOG=trace cargo run    # æ˜¾ç¤ºæœ€è¯¦ç»†çš„æ—¥å¿—

# æ¨¡å—çº§åˆ«æ§åˆ¶
RUST_LOG=websocket_logging=debug,axum=info cargo run</pre>

        <p><strong>ğŸ¯ ä»Šæ—¥æ”¶è·</strong></p>
        <ul>
            <li>âœ… å­¦ä¼šä½¿ç”¨ tracing è¿›è¡Œç»“æ„åŒ–æ—¥å¿—è®°å½•</li>
            <li>âœ… é…ç½®æ–‡ä»¶å’Œæ§åˆ¶å°åŒé‡æ—¥å¿—è¾“å‡º</li>
            <li>âœ… ä½¿ç”¨ç¯å¢ƒå˜é‡æ§åˆ¶æ—¥å¿—ç­‰çº§</li>
            <li>âœ… åœ¨ WebSocket åº”ç”¨ä¸­æ·»åŠ ä¸Šä¸‹æ–‡è¿½è¸ª</li>
            <li>âœ… å®ç°ç”Ÿäº§ç¯å¢ƒæ—¥å¿—è½®è½¬å’Œå½’æ¡£</li>
            <li>âœ… é€šè¿‡ instrument å®ç®€åŒ–æ—¥å¿—æ ‡è®°</li>
            <li>âœ… ç†è§£æ—¥å¿—ä¸ç›‘æ§çš„é‡è¦æ€§</li>
        </ul>

        <p><strong>ğŸ’¡ æ‰©å±•ç»ƒä¹ </strong></p>
        <ul>
            <li>æ·»åŠ  Prometheus æŒ‡æ ‡å¯¼å‡º</li>
            <li>é›†æˆ OpenTelemetry åˆ†å¸ƒå¼è¿½è¸ª</li>
            <li>å®ç°æ—¥å¿—èšåˆå’Œæ£€ç´¢åŠŸèƒ½</li>
            <li>æ·»åŠ æ€§èƒ½ç›‘æ§å’ŒæŠ¥è­¦æœºåˆ¶</li>
        </ul>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-20</strong></p>
        <h2>Day 20 - æ„å»º release ç‰ˆæœ¬å¹¶åˆ›å»º Dockerfile</h2>
        <p>ä»Šå¤©ä½ å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ Docker å®¹å™¨åŒ– Rust WebSocket åº”ç”¨ã€‚ä½ å°†åˆ›å»ºå¤šé˜¶æ®µ Dockerfile æ¥ä¼˜åŒ–é•œåƒå¤§å°ï¼Œé…ç½®ç”Ÿäº§ç¯å¢ƒå‚æ•°ï¼Œå¹¶æŒæ¡ Docker æ„å»ºå’Œéƒ¨ç½²çš„æœ€ä½³å®è·µã€‚</p>
        
        <p><strong>ğŸ¯ ä»Šæ—¥ç›®æ ‡</strong></p>
        <ul>
            <li>åˆ›å»ºå¤šé˜¶æ®µ Dockerfile ä¼˜åŒ–é•œåƒå¤§å°</li>
            <li>é…ç½®ç”Ÿäº§ç¯å¢ƒçš„ Rust æ„å»º</li>
            <li>è®¾ç½®å®¹å™¨è¿è¡Œæ—¶ç¯å¢ƒå˜é‡</li>
            <li>å®ç°å¥åº·æ£€æŸ¥å’Œç›‘æ§ç«¯ç‚¹</li>
            <li>æŒæ¡ Docker å®‰å…¨æœ€ä½³å®è·µ</li>
        </ul>

        <p>ğŸ”— <a href="https://docs.docker.com/build/building/multi-stage/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>

        <p><strong>æ­¥éª¤ 1: é¡¹ç›®è®¾ç½®</strong></p>
        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day20_docker_websocket/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ server.rs
â”‚   â””â”€â”€ config.rs
â”œâ”€â”€ static/
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ docker-compose.yml
â”‚   â””â”€â”€ .dockerignore
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ build.sh
â”‚   â””â”€â”€ run.sh
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ .env.example
â””â”€â”€ README.md</pre>

        <p><strong>æ­¥éª¤ 2: ä¼˜åŒ–çš„ Cargo.toml</strong></p>
        <pre>[package]
name = "websocket-docker"
version = "0.1.0"
edition = "2021"
authors = ["Your Name &lt;your.email@example.com&gt;"]
description = "Production-ready WebSocket server with Docker deployment"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["fs", "cors"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["json", "env-filter"] }
anyhow = "1.0"
chrono = { version = "0.4", features = ["serde"] }
clap = { version = "4.0", features = ["derive", "env"] }
dotenvy = "0.15"

# ä¼˜åŒ– release æ„å»º
[profile.release]
lto = true              # Link Time Optimization
codegen-units = 1       # å•çº¿ç¨‹ç¼–è¯‘ä¼˜åŒ–
panic = "abort"         # å‡å°‘äºŒè¿›åˆ¶å¤§å°
strip = true            # ç§»é™¤è°ƒè¯•ç¬¦å·</pre>

        <p><strong>æ­¥éª¤ 3: é…ç½®ç®¡ç† (src/config.rs)</strong></p>
        <pre>use clap::Parser;
use std::net::SocketAddr;

#[derive(Parser, Debug, Clone)]
#[command(name = "websocket-server")]
#[command(about = "Production WebSocket server with Docker support")]
pub struct Config {
    /// Server bind address
    #[arg(long, env = "BIND_ADDR", default_value = "0.0.0.0:3000")]
    pub bind_addr: SocketAddr,
    
    /// Log level
    #[arg(long, env = "LOG_LEVEL", default_value = "info")]
    pub log_level: String,
    
    /// Maximum number of concurrent connections
    #[arg(long, env = "MAX_CONNECTIONS", default_value = "1000")]
    pub max_connections: usize,
    
    /// Broadcast channel capacity
    #[arg(long, env = "CHANNEL_CAPACITY", default_value = "1000")]
    pub channel_capacity: usize,
    
    /// Enable metrics endpoint
    #[arg(long, env = "ENABLE_METRICS", default_value = "true")]
    pub enable_metrics: bool,
    
    /// Static files directory
    #[arg(long, env = "STATIC_DIR", default_value = "static")]
    pub static_dir: String,
    
    /// Application environment
    #[arg(long, env = "APP_ENV", default_value = "production")]
    pub environment: String,
}

impl Config {
    pub fn from_env() -> anyhow::Result<Self> {
        // åŠ è½½ .env æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        let _ = dotenvy::dotenv();
        
        let config = Self::parse();
        
        tracing::info!(
            bind_addr = %config.bind_addr,
            log_level = %config.log_level,
            max_connections = config.max_connections,
            environment = %config.environment,
            "é…ç½®åŠ è½½å®Œæˆ"
        );
        
        Ok(config)
    }
    
    pub fn is_production(&self) -> bool {
        self.environment == "production"
    }
}</pre>

        <p><strong>æ­¥éª¤ 4: ç”Ÿäº§ç¯å¢ƒä¸»ç¨‹åº (src/main.rs)</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocketUpgrade, State},
    http::StatusCode,
    response::{Html, Json, Response},
    routing::get,
    Router,
};
use std::{collections::HashMap, sync::Arc, time::Duration};
use tokio::{signal, sync::{broadcast, RwLock}};
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{error, info, warn};
use uuid::Uuid;

mod config;
mod server;

use config::Config;
use server::{handle_websocket, AppState, ConnectedClient};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // åŠ è½½é…ç½®
    let config = Config::from_env()?;
    
    // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    init_tracing(&config)?;
    
    info!("ğŸš€ å¯åŠ¨ç”Ÿäº§ç¯å¢ƒ WebSocket æœåŠ¡å™¨");
    info!("ç‰ˆæœ¬: {}", env!("CARGO_PKG_VERSION"));
    info!("æ„å»ºæ—¶é—´: {}", env!("BUILD_TIMESTAMP"));
    
    // åˆ›å»ºåº”ç”¨çŠ¶æ€
    let (tx, _rx) = broadcast::channel(config.channel_capacity);
    let state = Arc::new(AppState {
        clients: RwLock::new(HashMap::new()),
        tx,
        config: config.clone(),
        start_time: std::time::Instant::now(),
    });
    
    // åˆ›å»ºè·¯ç”±
    let mut app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .route("/health", get(health_handler))
        .route("/ready", get(readiness_handler));
    
    // å¯é€‰çš„æŒ‡æ ‡ç«¯ç‚¹
    if config.enable_metrics {
        app = app.route("/metrics", get(metrics_handler));
    }
    
    // é™æ€æ–‡ä»¶æœåŠ¡
    if tokio::fs::metadata(&config.static_dir).await.is_ok() {
        app = app.nest_service("/static", ServeDir::new(&config.static_dir));
        info!("å¯ç”¨é™æ€æ–‡ä»¶æœåŠ¡: {}", config.static_dir);
    }
    
    app = app
        .with_state(state.clone())
        .layer(CorsLayer::permissive());
    
    // å¯åŠ¨æœåŠ¡å™¨
    info!(address = %config.bind_addr, "æœåŠ¡å™¨å¯åŠ¨å®Œæˆ");
    
    let listener = tokio::net::TcpListener::bind(config.bind_addr).await?;
    
    // ä¼˜é›…å…³é—­å¤„ç†
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await?;
    
    info!("æœåŠ¡å™¨ä¼˜é›…å…³é—­å®Œæˆ");
    Ok(())
}

/// åˆå§‹åŒ–ç”Ÿäº§ç¯å¢ƒæ—¥å¿—ç³»ç»Ÿ
fn init_tracing(config: &Config) -> anyhow::Result<()> {
    use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
    
    let env_filter = EnvFilter::try_from_default_env()
        .or_else(|_| EnvFilter::try_new(&config.log_level))?;
    
    if config.is_production() {
        // ç”Ÿäº§ç¯å¢ƒï¼šJSON æ ¼å¼æ—¥å¿—
        tracing_subscriber::registry()
            .with(
                tracing_subscriber::fmt::layer()
                    .json()
                    .with_target(true)
                    .with_current_span(false)
                    .with_span_list(false)
                    .with_ansi(false)
            )
            .with(env_filter)
            .init();
    } else {
        // å¼€å‘ç¯å¢ƒï¼šå¯è¯»æ€§æ›´å¥½çš„æ ¼å¼
        tracing_subscriber::registry()
            .with(
                tracing_subscriber::fmt::layer()
                    .compact()
                    .with_target(true)
                    .with_line_number(true)
            )
            .with(env_filter)
            .init();
    }
    
    info!("ğŸ“ æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
    Ok(())
}

async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<Arc<AppState>>,
) -> Response {
    let client_id = Uuid::new_v4();
    
    // æ£€æŸ¥è¿æ¥æ•°é™åˆ¶
    {
        let clients = state.clients.read().await;
        if clients.len() >= state.config.max_connections {
            warn!(
                client_id = %client_id,
                current_connections = clients.len(),
                max_connections = state.config.max_connections,
                "æ‹’ç»è¿æ¥ï¼šè¾¾åˆ°æœ€å¤§è¿æ¥æ•°é™åˆ¶"
            );
            return (StatusCode::SERVICE_UNAVAILABLE, "æœåŠ¡å™¨ç¹å¿™").into_response();
        }
    }
    
    info!(client_id = %client_id, "æ–°çš„ WebSocket è¿æ¥è¯·æ±‚");
    
    ws.on_upgrade(move |socket| async move {
        if let Err(e) = handle_websocket(socket, state, client_id).await {
            error!(client_id = %client_id, error = %e, "WebSocket è¿æ¥å¤„ç†å¤±è´¥");
        }
    })
}

async fn index_handler() -> Html<&'static str> {
    Html(include_str!("../static/index.html"))
}

/// å¥åº·æ£€æŸ¥ç«¯ç‚¹
async fn health_handler(State(state): State<Arc<AppState>>) -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now(),
        "uptime_seconds": state.start_time.elapsed().as_secs(),
        "version": env!("CARGO_PKG_VERSION")
    }))
}

/// å°±ç»ªæ£€æŸ¥ç«¯ç‚¹ï¼ˆKubernetes readiness probeï¼‰
async fn readiness_handler(State(state): State<Arc<AppState>>) -> Result<Json<serde_json::Value>, StatusCode> {
    let clients = state.clients.read().await;
    let connection_count = clients.len();
    
    // æ£€æŸ¥æœåŠ¡æ˜¯å¦å°±ç»ª
    if connection_count < state.config.max_connections {
        Ok(Json(serde_json::json!({
            "status": "ready",
            "connections": connection_count,
            "max_connections": state.config.max_connections,
            "timestamp": chrono::Utc::now()
        })))
    } else {
        Err(StatusCode::SERVICE_UNAVAILABLE)
    }
}

/// æŒ‡æ ‡ç«¯ç‚¹
async fn metrics_handler(State(state): State<Arc<AppState>>) -> Json<serde_json::Value> {
    let clients = state.clients.read().await;
    let active_connections = clients.len();
    let total_messages: u64 = clients.values().map(|c| c.message_count).sum();
    let uptime = state.start_time.elapsed().as_secs();
    
    Json(serde_json::json!({
        "active_connections": active_connections,
        "total_messages": total_messages,
        "uptime_seconds": uptime,
        "max_connections": state.config.max_connections,
        "memory_usage_mb": get_memory_usage(),
        "timestamp": chrono::Utc::now()
    }))
}

/// è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
fn get_memory_usage() -> u64 {
    // ç®€å•çš„å†…å­˜ä½¿ç”¨ä¼°ç®—
    #[cfg(target_os = "linux")]
    {
        if let Ok(status) = std::fs::read_to_string("/proc/self/status") {
            for line in status.lines() {
                if line.starts_with("VmRSS:") {
                    if let Some(kb_str) = line.split_whitespace().nth(1) {
                        if let Ok(kb) = kb_str.parse::<u64>() {
                            return kb / 1024; // è½¬æ¢ä¸º MB
                        }
                    }
                }
            }
        }
    }
    0
}

/// ä¼˜é›…å…³é—­ä¿¡å·å¤„ç†
async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            info!("æ”¶åˆ° SIGINT ä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­");
        },
        _ = terminate => {
            info!("æ”¶åˆ° SIGTERM ä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­");
        },
    }
    
    // ç»™äºˆä¸€äº›æ—¶é—´å®Œæˆå½“å‰è¯·æ±‚
    tokio::time::sleep(Duration::from_secs(1)).await;
}</pre>

        <p><strong>æ­¥éª¤ 5: æ›´æ–°çš„æœåŠ¡å™¨é€»è¾‘ (src/server.rs)</strong></p>
        <pre>use axum::extract::ws::{Message, WebSocket};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, time::Instant};
use tokio::sync::{broadcast, RwLock};
use tracing::{debug, error, info, warn};
use uuid::Uuid;

use crate::config::Config;

#[derive(Debug, Clone)]
pub struct ConnectedClient {
    pub id: Uuid,
    pub name: String,
    pub connected_at: Instant,
    pub message_count: u64,
    pub last_activity: Instant,
}

pub struct AppState {
    pub clients: RwLock<HashMap<Uuid, ConnectedClient>>,
    pub tx: broadcast::Sender<BroadcastMessage>,
    pub config: Config,
    pub start_time: Instant,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    pub message_type: String,
    pub content: String,
    pub sender: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub struct BroadcastMessage {
    pub sender_id: Uuid,
    pub message: ChatMessage,
}

pub async fn handle_websocket(
    mut socket: WebSocket,
    state: std::sync::Arc<AppState>,
    client_id: Uuid,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    info!(
        client_id = %client_id,
        environment = %state.config.environment,
        "WebSocket è¿æ¥å»ºç«‹"
    );
    
    // å‘é€æ¬¢è¿æ¶ˆæ¯
    let welcome_msg = ChatMessage {
        message_type: "system".to_string(),
        content: format!(
            "æ¬¢è¿è¿æ¥åˆ° {} ç¯å¢ƒï¼æ‚¨çš„ ID: {}",
            state.config.environment,
            client_id
        ),
        sender: Some("ç³»ç»Ÿ".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    if let Err(e) = socket.send(Message::Text(serde_json::to_string(&welcome_msg)?)).await {
        error!(client_id = %client_id, error = %e, "å‘é€æ¬¢è¿æ¶ˆæ¯å¤±è´¥");
        return Err(e.into());
    }
    
    // æ³¨å†Œå®¢æˆ·ç«¯
    let client = ConnectedClient {
        id: client_id,
        name: format!("ç”¨æˆ·-{}", &client_id.to_string()[..8]),
        connected_at: Instant::now(),
        message_count: 0,
        last_activity: Instant::now(),
    };
    
    {
        let mut clients = state.clients.write().await;
        clients.insert(client_id, client.clone());
        info!(
            client_id = %client_id,
            client_name = %client.name,
            total_clients = clients.len(),
            max_connections = state.config.max_connections,
            "å®¢æˆ·ç«¯æ³¨å†ŒæˆåŠŸ"
        );
    }
    
    // å¹¿æ’­æ–°ç”¨æˆ·åŠ å…¥
    let join_msg = ChatMessage {
        message_type: "join".to_string(),
        content: format!("{} åŠ å…¥äº†èŠå¤©å®¤", client.name),
        sender: Some("ç³»ç»Ÿ".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    let _ = state.tx.send(BroadcastMessage {
        sender_id: client_id,
        message: join_msg,
    });
    
    // åˆ›å»ºå¹¿æ’­æ¥æ”¶å™¨
    let mut rx = state.tx.subscribe();
    let state_clone = state.clone();
    
    // å¯åŠ¨æ¶ˆæ¯å¹¿æ’­ä»»åŠ¡
    let broadcast_task = tokio::spawn(async move {
        while let Ok(broadcast_msg) = rx.recv().await {
            if broadcast_msg.sender_id == client_id {
                continue;
            }
            
            let msg_json = match serde_json::to_string(&broadcast_msg.message) {
                Ok(json) => json,
                Err(e) => {
                    error!(error = %e, "åºåˆ—åŒ–å¹¿æ’­æ¶ˆæ¯å¤±è´¥");
                    continue;
                }
            };
            
            if let Err(e) = socket.send(Message::Text(msg_json)).await {
                debug!(
                    client_id = %client_id,
                    error = %e,
                    "å‘é€å¹¿æ’­æ¶ˆæ¯å¤±è´¥ï¼Œè¿æ¥å¯èƒ½å·²æ–­å¼€"
                );
                break;
            }
        }
    });
    
    // å¤„ç†å®¢æˆ·ç«¯æ¶ˆæ¯
    let mut message_count = 0u64;
    while let Some(msg) = socket.recv().await {
        match msg {
            Ok(Message::Text(text)) => {
                message_count += 1;
                
                // æ›´æ–°æ´»åŠ¨æ—¶é—´
                {
                    let mut clients = state.clients.write().await;
                    if let Some(client) = clients.get_mut(&client_id) {
                        client.last_activity = Instant::now();
                        client.message_count += 1;
                    }
                }
                
                match serde_json::from_str::<ChatMessage>(&text) {
                    Ok(mut chat_msg) => {
                        chat_msg.sender = Some(client.name.clone());
                        chat_msg.timestamp = chrono::Utc::now();
                        
                        debug!(
                            client_id = %client_id,
                            sender = %chat_msg.sender.as_ref().unwrap(),
                            message_type = %chat_msg.message_type,
                            content_length = chat_msg.content.len(),
                            environment = %state.config.environment,
                            "å¤„ç†èŠå¤©æ¶ˆæ¯"
                        );
                        
                        let _ = state.tx.send(BroadcastMessage {
                            sender_id: client_id,
                            message: chat_msg,
                        });
                    }
                    Err(e) => {
                        warn!(
                            client_id = %client_id,
                            error = %e,
                            "æ¶ˆæ¯ JSON è§£æå¤±è´¥"
                        );
                        
                        let error_msg = ChatMessage {
                            message_type: "error".to_string(),
                            content: "æ¶ˆæ¯æ ¼å¼é”™è¯¯".to_string(),
                            sender: Some("ç³»ç»Ÿ".to_string()),
                            timestamp: chrono::Utc::now(),
                        };
                        
                        let _ = socket.send(Message::Text(
                            serde_json::to_string(&error_msg)?
                        )).await;
                    }
                }
            }
            Ok(Message::Close(frame)) => {
                info!(
                    client_id = %client_id,
                    close_frame = ?frame,
                    "å®¢æˆ·ç«¯ä¸»åŠ¨å…³é—­è¿æ¥"
                );
                break;
            }
            Err(e) => {
                error!(
                    client_id = %client_id,
                    error = %e,
                    "WebSocket æ¶ˆæ¯æ¥æ”¶é”™è¯¯"
                );
                break;
            }
            _ => {}
        }
    }
    
    // æ¸…ç†å·¥ä½œ
    broadcast_task.abort();
    
    // ä»å®¢æˆ·ç«¯åˆ—è¡¨ä¸­ç§»é™¤
    {
        let mut clients = state.clients.write().await;
        if let Some(removed_client) = clients.remove(&client_id) {
            info!(
                client_id = %client_id,
                client_name = %removed_client.name,
                session_duration = ?removed_client.connected_at.elapsed(),
                total_messages = removed_client.message_count,
                remaining_clients = clients.len(),
                "å®¢æˆ·ç«¯æ–­å¼€è¿æ¥ï¼Œæ¸…ç†å®Œæˆ"
            );
        }
    }
    
    // å¹¿æ’­ç”¨æˆ·ç¦»å¼€æ¶ˆæ¯
    let leave_msg = ChatMessage {
        message_type: "leave".to_string(),
        content: format!("{} ç¦»å¼€äº†èŠå¤©å®¤", client.name),
        sender: Some("ç³»ç»Ÿ".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    let _ = state.tx.send(BroadcastMessage {
        sender_id: client_id,
        message: leave_msg,
    });
    
    Ok(())
}</pre>

        <p><strong>æ­¥éª¤ 6: å¤šé˜¶æ®µ Dockerfile (docker/Dockerfile)</strong></p>
        <pre># ç¬¬ä¸€é˜¶æ®µï¼šæ„å»ºç¯å¢ƒ
FROM rust:1.75-slim as builder

# å®‰è£…æ„å»ºä¾èµ–
RUN apt-get update && apt-get install -y \
    pkg-config \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# åˆ›å»ºæ–°ç”¨æˆ·é¿å…ä»¥ root èº«ä»½è¿è¡Œ
RUN useradd -m -u 1001 appuser

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /usr/src/app

# å¤åˆ¶ Cargo æ–‡ä»¶å…ˆå®‰è£…ä¾èµ–ï¼ˆåˆ©ç”¨ Docker ç¼“å­˜ï¼‰
COPY Cargo.toml Cargo.lock ./

# åˆ›å»ºè™šæ‹Ÿä¸»æ–‡ä»¶ä»¥æ„å»ºä¾èµ–
RUN mkdir src && echo "fn main() {}" > src/main.rs
RUN cargo build --release
RUN rm -f target/release/deps/websocket_docker*

# å¤åˆ¶æºä»£ç 
COPY src ./src
COPY static ./static

# æ·»åŠ æ„å»ºæ—¶é—´æˆ³
ARG BUILD_TIMESTAMP
ENV BUILD_TIMESTAMP=$BUILD_TIMESTAMP

# æ„å»ºåº”ç”¨
RUN cargo build --release

# ç¬¬äºŒé˜¶æ®µï¼šè¿è¡Œæ—¶ç¯å¢ƒ
FROM debian:bookworm-slim as runtime

# å®‰è£…è¿è¡Œæ—¶ä¾èµ–
RUN apt-get update && apt-get install -y \
    ca-certificates \
    curl \
    && rm -rf /var/lib/apt/lists/*

# åˆ›å»ºåº”ç”¨ç”¨æˆ·
RUN useradd -m -u 1001 appuser

# åˆ›å»ºåº”ç”¨ç›®å½•
WORKDIR /app

# ä»æ„å»ºé˜¶æ®µå¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /usr/src/app/target/release/websocket-docker /app/websocket-docker
COPY --from=builder /usr/src/app/static /app/static

# è®¾ç½®æ–‡ä»¶æƒé™
RUN chown -R appuser:appuser /app
RUN chmod +x /app/websocket-docker

# åˆ‡æ¢åˆ°éç‰¹æƒç”¨æˆ·
USER appuser

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# è®¾ç½®ç¯å¢ƒå˜é‡
ENV RUST_LOG=info
ENV BIND_ADDR=0.0.0.0:3000
ENV APP_ENV=production

# å¯åŠ¨åº”ç”¨
CMD ["./websocket-docker"]</pre>

        <p><strong>æ­¥éª¤ 7: Docker Compose é…ç½® (docker/docker-compose.yml)</strong></p>
        <pre>version: '3.8'

services:
  websocket-server:
    build:
      context: ..
      dockerfile: docker/Dockerfile
      args:
        BUILD_TIMESTAMP: ${BUILD_TIMESTAMP:-"unknown"}
    ports:
      - "3000:3000"
    environment:
      - RUST_LOG=info
      - LOG_LEVEL=info
      - MAX_CONNECTIONS=1000
      - CHANNEL_CAPACITY=1000
      - ENABLE_METRICS=true
      - APP_ENV=production
    volumes:
      - ../logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.5'
        reservations:
          memory: 128M
          cpus: '0.1'

  # å¯é€‰ï¼šæ·»åŠ åå‘ä»£ç†
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - websocket-server
    restart: unless-stopped</pre>

        <p><strong>æ­¥éª¤ 8: æ„å»ºè„šæœ¬ (scripts/build.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}ğŸ³ æ„å»º WebSocket Docker é•œåƒ${NC}"

# è®¾ç½®æ„å»ºæ—¶é—´æˆ³
export BUILD_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# è·å–é¡¹ç›®ä¿¡æ¯
PROJECT_NAME="websocket-docker"
VERSION=$(grep '^version' Cargo.toml | cut -d'"' -f2)
IMAGE_NAME="${PROJECT_NAME}:${VERSION}"
LATEST_IMAGE="${PROJECT_NAME}:latest"

echo -e "${YELLOW}é¡¹ç›®: ${PROJECT_NAME}${NC}"
echo -e "${YELLOW}ç‰ˆæœ¬: ${VERSION}${NC}"
echo -e "${YELLOW}æ„å»ºæ—¶é—´: ${BUILD_TIMESTAMP}${NC}"

# æ„å»ºé•œåƒ
echo -e "${GREEN}ğŸ“¦ å¼€å§‹æ„å»ºé•œåƒ...${NC}"
cd docker
docker build \
    --build-arg BUILD_TIMESTAMP="${BUILD_TIMESTAMP}" \
    -t "${IMAGE_NAME}" \
    -t "${LATEST_IMAGE}" \
    -f Dockerfile \
    ..

echo -e "${GREEN}âœ… é•œåƒæ„å»ºå®Œæˆ${NC}"

# æ˜¾ç¤ºé•œåƒä¿¡æ¯
echo -e "${GREEN}ğŸ“Š é•œåƒä¿¡æ¯:${NC}"
docker images | head -1
docker images | grep "${PROJECT_NAME}"

# æ˜¾ç¤ºé•œåƒå¤§å°
echo -e "${GREEN}ğŸ’¾ é•œåƒå¤§å°æ¯”è¾ƒ:${NC}"
RUST_BASE_SIZE=$(docker images rust:1.75-slim --format "table {{.Size}}" | tail -1)
IMAGE_SIZE=$(docker images "${LATEST_IMAGE}" --format "table {{.Size}}" | tail -1)
echo "Rust åŸºç¡€é•œåƒ: ${RUST_BASE_SIZE}"
echo "åº”ç”¨é•œåƒ: ${IMAGE_SIZE}"

echo -e "${GREEN}ğŸ‰ æ„å»ºå®Œæˆï¼${NC}"
echo -e "${YELLOW}è¿è¡Œå‘½ä»¤: docker run -p 3000:3000 ${LATEST_IMAGE}${NC}"</pre>

        <p><strong>æ­¥éª¤ 9: è¿è¡Œè„šæœ¬ (scripts/run.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# é¢œè‰²è¾“å‡º
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

PROJECT_NAME="websocket-docker"
IMAGE_NAME="${PROJECT_NAME}:latest"
CONTAINER_NAME="${PROJECT_NAME}-container"

echo -e "${GREEN}ğŸš€ å¯åŠ¨ WebSocket å®¹å™¨${NC}"

# åœæ­¢å¹¶åˆ é™¤ç°æœ‰å®¹å™¨
if docker ps -a | grep -q "${CONTAINER_NAME}"; then
    echo -e "${YELLOW}åœæ­¢ç°æœ‰å®¹å™¨...${NC}"
    docker stop "${CONTAINER_NAME}" || true
    docker rm "${CONTAINER_NAME}" || true
fi

# åˆ›å»ºæ—¥å¿—ç›®å½•
mkdir -p ../logs

# å¯åŠ¨æ–°å®¹å™¨
echo -e "${GREEN}å¯åŠ¨æ–°å®¹å™¨...${NC}"
docker run -d \
    --name "${CONTAINER_NAME}" \
    -p 3000:3000 \
    -v "$(pwd)/../logs:/app/logs" \
    -e RUST_LOG=info \
    -e LOG_LEVEL=info \
    -e MAX_CONNECTIONS=1000 \
    -e APP_ENV=production \
    --restart unless-stopped \
    "${IMAGE_NAME}"

echo -e "${GREEN}âœ… å®¹å™¨å¯åŠ¨æˆåŠŸ${NC}"

# æ˜¾ç¤ºå®¹å™¨çŠ¶æ€
echo -e "${GREEN}ğŸ“Š å®¹å™¨çŠ¶æ€:${NC}"
docker ps | head -1
docker ps | grep "${CONTAINER_NAME}"

# ç­‰å¾…æœåŠ¡å¯åŠ¨
echo -e "${YELLOW}ç­‰å¾…æœåŠ¡å¯åŠ¨...${NC}"
sleep 3

# æµ‹è¯•å¥åº·æ£€æŸ¥
echo -e "${GREEN}ğŸ” å¥åº·æ£€æŸ¥:${NC}"
if curl -f http://localhost:3000/health; then
    echo -e "${GREEN}âœ… æœåŠ¡å¥åº·${NC}"
else
    echo -e "${RED}âŒ æœåŠ¡ä¸å¥åº·${NC}"
fi

echo -e "${GREEN}ğŸ‰ éƒ¨ç½²å®Œæˆï¼${NC}"
echo -e "${YELLOW}è®¿é—®åœ°å€: http://localhost:3000${NC}"
echo -e "${YELLOW}æŸ¥çœ‹æ—¥å¿—: docker logs -f ${CONTAINER_NAME}${NC}"</pre>

        <p><strong>æ­¥éª¤ 10: Docker å¿½ç•¥æ–‡ä»¶ (docker/.dockerignore)</strong></p>
        <pre>target/
Dockerfile
docker-compose.yml
.dockerignore
.git/
.gitignore
*.md
logs/
scripts/
.env*
docker/</pre>

        <p><strong>æ­¥éª¤ 11: ç¯å¢ƒå˜é‡ç¤ºä¾‹ (.env.example)</strong></p>
        <pre># WebSocket æœåŠ¡å™¨é…ç½®
BIND_ADDR=0.0.0.0:3000
LOG_LEVEL=info
MAX_CONNECTIONS=1000
CHANNEL_CAPACITY=1000
ENABLE_METRICS=true
STATIC_DIR=static
APP_ENV=production

# Docker æ„å»ºé…ç½®
BUILD_TIMESTAMP=2025-08-20T10:00:00Z

# æ•°æ®åº“é…ç½®ï¼ˆå¯é€‰ï¼‰
# DATABASE_URL=postgresql://user:pass@localhost/websocket_db

# Redis é…ç½®ï¼ˆå¯é€‰ï¼‰
# REDIS_URL=redis://localhost:6379</pre>

        <p><strong>æ­¥éª¤ 12: æ„å»ºå’Œè¿è¡Œ</strong></p>
        <pre># 1. è®¾ç½®æ‰§è¡Œæƒé™
chmod +x scripts/build.sh scripts/run.sh

# 2. æ„å»º Docker é•œåƒ
./scripts/build.sh

# 3. è¿è¡Œå®¹å™¨
./scripts/run.sh

# 4. æˆ–ä½¿ç”¨ Docker Compose
cd docker
docker-compose up -d

# 5. æŸ¥çœ‹æ—¥å¿—
docker logs -f websocket-docker-container

# 6. æµ‹è¯•æœåŠ¡
curl http://localhost:3000/health
curl http://localhost:3000/metrics

# 7. æ‰“å¼€æµè§ˆå™¨æµ‹è¯•
open http://localhost:3000</pre>

        <p><strong>æ­¥éª¤ 13: ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–</strong></p>
        <pre># æŸ¥çœ‹é•œåƒå¤§å°
docker images websocket-docker

# é•œåƒå®‰å…¨æ‰«æ
docker scout cves websocket-docker:latest

# æ€§èƒ½æµ‹è¯•
wrk -t12 -c400 -d30s http://localhost:3000/health

# å†…å­˜ä½¿ç”¨ç›‘æ§
docker stats websocket-docker-container

# å®¹å™¨èµ„æºé™åˆ¶
docker run -d \
    --name websocket-production \
    -p 3000:3000 \
    --memory=256m \
    --cpus=0.5 \
    --restart=always \
    websocket-docker:latest</pre>

        <p><strong>ğŸ¯ ä»Šæ—¥æ”¶è·</strong></p>
        <ul>
            <li>âœ… åˆ›å»ºäº†ä¼˜åŒ–çš„å¤šé˜¶æ®µ Dockerfile</li>
            <li>âœ… å®ç°äº†ç”Ÿäº§ç¯å¢ƒé…ç½®ç®¡ç†</li>
            <li>âœ… æ·»åŠ äº†å¥åº·æ£€æŸ¥å’Œç›‘æ§ç«¯ç‚¹</li>
            <li>âœ… é…ç½®äº†ä¼˜é›…å…³é—­æœºåˆ¶</li>
            <li>âœ… å®ç°äº† Docker Compose éƒ¨ç½²</li>
            <li>âœ… æŒæ¡äº†å®¹å™¨å®‰å…¨æœ€ä½³å®è·µ</li>
            <li>âœ… ä¼˜åŒ–äº†é•œåƒå¤§å°å’Œæ„å»ºæ•ˆç‡</li>
        </ul>

        <p><strong>ğŸ’¡ æ‰©å±•ç»ƒä¹ </strong></p>
        <ul>
            <li>æ·»åŠ  Nginx åå‘ä»£ç†é…ç½®</li>
            <li>å®ç°å¤šå®¹å™¨è´Ÿè½½å‡è¡¡</li>
            <li>é›†æˆ Prometheus ç›‘æ§</li>
            <li>æ·»åŠ æ—¥å¿—èšåˆå’Œåˆ†æ</li>
        </ul>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-21</strong></p>
        <h2>Day 21 - Docker å®¹å™¨æµ‹è¯•ä¸éƒ¨ç½²éªŒè¯</h2>
        <p>ä»Šå¤©ä½ å°†å…¨é¢æµ‹è¯• Docker åŒ–çš„ WebSocket åº”ç”¨ï¼ŒåŒ…æ‹¬å®¹å™¨è¿è¡Œæµ‹è¯•ã€æ€§èƒ½åŸºå‡†æµ‹è¯•ã€è´Ÿè½½æµ‹è¯•ã€ç›‘æ§é›†æˆä»¥åŠç”Ÿäº§ç¯å¢ƒéƒ¨ç½²éªŒè¯ã€‚ä½ å°†æŒæ¡å®¹å™¨åŒ–åº”ç”¨çš„å®Œæ•´æµ‹è¯•å’Œéƒ¨ç½²æµç¨‹ã€‚</p>
        
        <p><strong>ğŸ¯ ä»Šæ—¥ç›®æ ‡</strong></p>
        <ul>
            <li>å…¨é¢æµ‹è¯• Docker å®¹å™¨åŠŸèƒ½</li>
            <li>è¿›è¡Œæ€§èƒ½å’Œè´Ÿè½½æµ‹è¯•</li>
            <li>é…ç½®ç›‘æ§å’Œæ—¥å¿—æ”¶é›†</li>
            <li>å®ç°è‡ªåŠ¨åŒ–éƒ¨ç½²è„šæœ¬</li>
            <li>éªŒè¯ç”Ÿäº§ç¯å¢ƒå°±ç»ªæ€§</li>
        </ul>

        <p>ğŸ”— <a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>

        <p><strong>æ­¥éª¤ 1: æµ‹è¯•é¡¹ç›®ç»“æ„</strong></p>
        <pre>ğŸ“ å®Œæ•´æµ‹è¯•é¡¹ç›®ç»“æ„ï¼š
day21_docker_testing/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ server.rs
â”‚   â””â”€â”€ config.rs
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ integration_test.rs
â”‚   â”œâ”€â”€ load_test.rs
â”‚   â””â”€â”€ docker_test.rs
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ test_all.sh
â”‚   â”œâ”€â”€ benchmark.sh
â”‚   â”œâ”€â”€ deploy.sh
â”‚   â””â”€â”€ monitor.sh
â”œâ”€â”€ monitoring/
â”‚   â”œâ”€â”€ prometheus.yml
â”‚   â”œâ”€â”€ grafana/
â”‚   â”‚   â””â”€â”€ dashboard.json
â”‚   â””â”€â”€ docker-compose.monitoring.yml
â”œâ”€â”€ nginx/
â”‚   â”œâ”€â”€ nginx.conf
â”‚   â””â”€â”€ ssl/
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ docker-compose.yml
â”‚   â”œâ”€â”€ docker-compose.prod.yml
â”‚   â””â”€â”€ .dockerignore
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”œâ”€â”€ service.yaml
â”‚   â””â”€â”€ ingress.yaml
â””â”€â”€ README.md</pre>

        <p><strong>æ­¥éª¤ 2: é›†æˆæµ‹è¯•å¥—ä»¶ (tests/integration_test.rs)</strong></p>
        <pre>use std::time::Duration;
use tokio::time::timeout;
use tokio_tungstenite::{connect_async, tungstenite::Message};
use serde_json::json;
use url::Url;

#[tokio::test]
async fn test_websocket_connection() {
    let url = Url::parse("ws://127.0.0.1:3000/ws").expect("Invalid URL");
    
    let result = timeout(Duration::from_secs(5), connect_async(url)).await;
    assert!(result.is_ok(), "WebSocket è¿æ¥è¶…æ—¶");
    
    let (ws_stream, _) = result.unwrap().expect("è¿æ¥å¤±è´¥");
    println!("âœ… WebSocket è¿æ¥æµ‹è¯•é€šè¿‡");
}

#[tokio::test]
async fn test_health_endpoint() {
    let client = reqwest::Client::new();
    
    let response = client
        .get("http://127.0.0.1:3000/health")
        .timeout(Duration::from_secs(5))
        .send()
        .await
        .expect("å¥åº·æ£€æŸ¥è¯·æ±‚å¤±è´¥");
    
    assert!(response.status().is_success());
    
    let health_data: serde_json::Value = response
        .json()
        .await
        .expect("è§£æå¥åº·æ£€æŸ¥å“åº”å¤±è´¥");
    
    assert_eq!(health_data["status"], "healthy");
    println!("âœ… å¥åº·æ£€æŸ¥æµ‹è¯•é€šè¿‡");
}

#[tokio::test]
async fn test_metrics_endpoint() {
    let client = reqwest::Client::new();
    
    let response = client
        .get("http://127.0.0.1:3000/metrics")
        .timeout(Duration::from_secs(5))
        .send()
        .await
        .expect("æŒ‡æ ‡è¯·æ±‚å¤±è´¥");
    
    assert!(response.status().is_success());
    
    let metrics: serde_json::Value = response
        .json()
        .await
        .expect("è§£ææŒ‡æ ‡å“åº”å¤±è´¥");
    
    assert!(metrics.get("active_connections").is_some());
    assert!(metrics.get("uptime_seconds").is_some());
    println!("âœ… æŒ‡æ ‡ç«¯ç‚¹æµ‹è¯•é€šè¿‡");
}

#[tokio::test]
async fn test_message_broadcast() {
    use futures_util::{SinkExt, StreamExt};
    
    let url = Url::parse("ws://127.0.0.1:3000/ws").expect("Invalid URL");
    
    // åˆ›å»ºä¸¤ä¸ªå®¢æˆ·ç«¯è¿æ¥
    let (ws1, _) = connect_async(url.clone()).await.expect("å®¢æˆ·ç«¯1è¿æ¥å¤±è´¥");
    let (ws2, _) = connect_async(url).await.expect("å®¢æˆ·ç«¯2è¿æ¥å¤±è´¥");
    
    let (mut write1, mut read1) = ws1.split();
    let (mut write2, mut read2) = ws2.split();
    
    // å‘é€æµ‹è¯•æ¶ˆæ¯
    let test_message = json!({
        "message_type": "chat",
        "content": "Hello from test!",
        "timestamp": chrono::Utc::now()
    });
    
    write1.send(Message::Text(test_message.to_string()))
        .await
        .expect("å‘é€æ¶ˆæ¯å¤±è´¥");
    
    // éªŒè¯å®¢æˆ·ç«¯2æ”¶åˆ°å¹¿æ’­æ¶ˆæ¯
    let received = timeout(Duration::from_secs(3), read2.next()).await;
    assert!(received.is_ok(), "æœªåœ¨é¢„æœŸæ—¶é—´å†…æ”¶åˆ°æ¶ˆæ¯");
    
    println!("âœ… æ¶ˆæ¯å¹¿æ’­æµ‹è¯•é€šè¿‡");
}</pre>

        <p><strong>æ­¥éª¤ 3: è´Ÿè½½æµ‹è¯• (tests/load_test.rs)</strong></p>
        <pre>#[cfg(test)]
mod load_tests {
    use super::*;
    use std::sync::Arc;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use tokio::time::{sleep, Duration};
    use futures_util::future::join_all;

    #[tokio::test]
    #[ignore] // ä½¿ç”¨ cargo test -- --ignored è¿è¡Œ
    async fn load_test_concurrent_connections() {
        const CONCURRENT_CONNECTIONS: usize = 100;
        const MESSAGE_COUNT: usize = 10;
        
        let success_count = Arc::new(AtomicUsize::new(0));
        let error_count = Arc::new(AtomicUsize::new(0));
        
        println!("ğŸš€ å¼€å§‹è´Ÿè½½æµ‹è¯•ï¼š{} å¹¶å‘è¿æ¥", CONCURRENT_CONNECTIONS);
        
        let tasks: Vec<_> = (0..CONCURRENT_CONNECTIONS)
            .map(|i| {
                let success_count = Arc::clone(&success_count);
                let error_count = Arc::clone(&error_count);
                
                tokio::spawn(async move {
                    match simulate_client(i, MESSAGE_COUNT).await {
                        Ok(_) => {
                            success_count.fetch_add(1, Ordering::Relaxed);
                            println!("âœ… å®¢æˆ·ç«¯ {} å®Œæˆ", i);
                        }
                        Err(e) => {
                            error_count.fetch_add(1, Ordering::Relaxed);
                            println!("âŒ å®¢æˆ·ç«¯ {} å¤±è´¥: {}", i, e);
                        }
                    }
                })
            })
            .collect();
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        join_all(tasks).await;
        
        let successes = success_count.load(Ordering::Relaxed);
        let errors = error_count.load(Ordering::Relaxed);
        
        println!("ğŸ“Š è´Ÿè½½æµ‹è¯•ç»“æœ:");
        println!("   æˆåŠŸ: {}", successes);
        println!("   å¤±è´¥: {}", errors);
        println!("   æˆåŠŸç‡: {:.2}%", (successes as f64 / CONCURRENT_CONNECTIONS as f64) * 100.0);
        
        // è‡³å°‘ 95% æˆåŠŸç‡
        assert!(successes >= (CONCURRENT_CONNECTIONS as f64 * 0.95) as usize);
    }
    
    async fn simulate_client(client_id: usize, message_count: usize) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        use tokio_tungstenite::{connect_async, tungstenite::Message};
        use futures_util::{SinkExt, StreamExt};
        use serde_json::json;
        use url::Url;
        
        let url = Url::parse("ws://127.0.0.1:3000/ws")?;
        let (ws_stream, _) = connect_async(url).await?;
        let (mut write, mut read) = ws_stream.split();
        
        // å¯åŠ¨è¯»å–ä»»åŠ¡
        let read_task = tokio::spawn(async move {
            let mut received_count = 0;
            while let Some(msg) = read.next().await {
                match msg {
                    Ok(Message::Text(_)) => {
                        received_count += 1;
                        if received_count >= message_count * 2 { // æœŸæœ›æ”¶åˆ°è‡ªå·±çš„æ¶ˆæ¯ + å…¶ä»–æ¶ˆæ¯
                            break;
                        }
                    }
                    Ok(Message::Close(_)) => break,
                    Err(_) => break,
                    _ => {}
                }
            }
            received_count
        });
        
        // å‘é€æ¶ˆæ¯
        for i in 0..message_count {
            let message = json!({
                "message_type": "chat",
                "content": format!("Load test message {} from client {}", i, client_id),
                "timestamp": chrono::Utc::now()
            });
            
            write.send(Message::Text(message.to_string())).await?;
            sleep(Duration::from_millis(100)).await; // æ§åˆ¶å‘é€é¢‘ç‡
        }
        
        // ç­‰å¾…æ¥æ”¶ä»»åŠ¡å®Œæˆ
        let _ = tokio::time::timeout(Duration::from_secs(10), read_task).await;
        
        Ok(())
    }
    
    #[tokio::test]
    #[ignore]
    async fn stress_test_memory_usage() {
        const CONNECTION_COUNT: usize = 500;
        const TEST_DURATION: Duration = Duration::from_secs(60);
        
        println!("ğŸ§  å¼€å§‹å†…å­˜å‹åŠ›æµ‹è¯•ï¼š{} è¿æ¥ï¼ŒæŒç»­ {} ç§’", 
                CONNECTION_COUNT, TEST_DURATION.as_secs());
        
        let client = reqwest::Client::new();
        let start_time = std::time::Instant::now();
        
        // è®°å½•åˆå§‹å†…å­˜ä½¿ç”¨
        let initial_metrics = get_server_metrics(&client).await;
        println!("ğŸ“Š åˆå§‹å†…å­˜ä½¿ç”¨: {} MB", initial_metrics["memory_usage_mb"]);
        
        // å»ºç«‹è¿æ¥å¹¶æŒç»­æµ‹è¯•
        let mut tasks = Vec::new();
        
        for i in 0..CONNECTION_COUNT {
            let task = tokio::spawn(async move {
                if let Ok(url) = url::Url::parse("ws://127.0.0.1:3000/ws") {
                    if let Ok((ws_stream, _)) = tokio_tungstenite::connect_async(url).await {
                        let (_write, mut read) = futures_util::StreamExt::split(ws_stream);
                        
                        // ä¿æŒè¿æ¥æ´»è·ƒ
                        let mut message_count = 0;
                        while message_count < 100 {
                            if let Some(Ok(_)) = read.next().await {
                                message_count += 1;
                            }
                            tokio::time::sleep(Duration::from_millis(500)).await;
                        }
                    }
                }
            });
            tasks.push(task);
            
            if i % 50 == 0 {
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
        }
        
        // ç›‘æ§å†…å­˜ä½¿ç”¨
        let monitor_task = tokio::spawn(async move {
            let mut max_memory = 0u64;
            while start_time.elapsed() < TEST_DURATION {
                if let Ok(metrics) = get_server_metrics(&client).await {
                    let current_memory = metrics["memory_usage_mb"].as_u64().unwrap_or(0);
                    max_memory = max_memory.max(current_memory);
                    println!("ğŸ’¾ å½“å‰å†…å­˜ä½¿ç”¨: {} MB", current_memory);
                }
                tokio::time::sleep(Duration::from_secs(5)).await;
            }
            max_memory
        });
        
        let max_memory = monitor_task.await.unwrap();
        
        // æ¸…ç†ä»»åŠ¡
        for task in tasks {
            task.abort();
        }
        
        println!("ğŸ“Š å‹åŠ›æµ‹è¯•ç»“æœ:");
        println!("   æœ€å¤§å†…å­˜ä½¿ç”¨: {} MB", max_memory);
        println!("   å†…å­˜å¢é•¿: {} MB", max_memory - initial_metrics["memory_usage_mb"].as_u64().unwrap_or(0));
        
        // ç¡®ä¿å†…å­˜ä½¿ç”¨åœ¨åˆç†èŒƒå›´å†…ï¼ˆå°äº512MBï¼‰
        assert!(max_memory < 512, "å†…å­˜ä½¿ç”¨è¶…å‡ºé¢„æœŸèŒƒå›´");
    }
    
    async fn get_server_metrics(client: &reqwest::Client) -> serde_json::Value {
        client
            .get("http://127.0.0.1:3000/metrics")
            .send()
            .await
            .unwrap()
            .json()
            .await
            .unwrap()
    }
}</pre>

        <p><strong>æ­¥éª¤ 4: Docker æµ‹è¯•è„šæœ¬ (tests/docker_test.rs)</strong></p>
        <pre>use std::process::Command;
use std::time::Duration;
use tokio::time::sleep;

#[tokio::test]
async fn test_docker_container_lifecycle() {
    let container_name = "websocket-test-container";
    let image_name = "websocket-docker:latest";
    
    // æ¸…ç†å¯èƒ½å­˜åœ¨çš„å®¹å™¨
    cleanup_container(container_name);
    
    // å¯åŠ¨å®¹å™¨
    println!("ğŸ³ å¯åŠ¨ Docker å®¹å™¨...");
    let output = Command::new("docker")
        .args(&[
            "run", "-d",
            "--name", container_name,
            "-p", "3001:3000", // ä½¿ç”¨ä¸åŒç«¯å£é¿å…å†²çª
            "-e", "RUST_LOG=info",
            image_name
        ])
        .output()
        .expect("å¯åŠ¨å®¹å™¨å¤±è´¥");
    
    assert!(output.status.success(), "å®¹å™¨å¯åŠ¨å¤±è´¥: {}", 
            String::from_utf8_lossy(&output.stderr));
    
    // ç­‰å¾…å®¹å™¨å¯åŠ¨
    println!("â³ ç­‰å¾…å®¹å™¨å¯åŠ¨...");
    sleep(Duration::from_secs(5)).await;
    
    // éªŒè¯å®¹å™¨è¿è¡ŒçŠ¶æ€
    let status_output = Command::new("docker")
        .args(&["ps", "--filter", &format!("name={}", container_name), "--format", "{{.Status}}"])
        .output()
        .expect("è·å–å®¹å™¨çŠ¶æ€å¤±è´¥");
    
    let status = String::from_utf8_lossy(&status_output.stdout);
    assert!(status.contains("Up"), "å®¹å™¨æœªæ­£å¸¸è¿è¡Œ: {}", status);
    println!("âœ… å®¹å™¨è¿è¡ŒçŠ¶æ€æ­£å¸¸");
    
    // æµ‹è¯•å¥åº·æ£€æŸ¥
    let health_check = reqwest::get("http://127.0.0.1:3001/health").await;
    assert!(health_check.is_ok(), "å¥åº·æ£€æŸ¥å¤±è´¥");
    println!("âœ… å®¹å™¨å¥åº·æ£€æŸ¥é€šè¿‡");
    
    // æµ‹è¯•æ—¥å¿—è¾“å‡º
    let logs_output = Command::new("docker")
        .args(&["logs", "--tail", "10", container_name])
        .output()
        .expect("è·å–å®¹å™¨æ—¥å¿—å¤±è´¥");
    
    let logs = String::from_utf8_lossy(&logs_output.stdout);
    assert!(logs.contains("WebSocket"), "å®¹å™¨æ—¥å¿—å¼‚å¸¸");
    println!("âœ… å®¹å™¨æ—¥å¿—æ­£å¸¸");
    
    // æ¸…ç†
    cleanup_container(container_name);
    println!("ğŸ§¹ å®¹å™¨æµ‹è¯•å®Œæˆï¼Œå·²æ¸…ç†");
}

#[tokio::test]
async fn test_docker_resource_limits() {
    let container_name = "websocket-resource-test";
    let image_name = "websocket-docker:latest";
    
    cleanup_container(container_name);
    
    // å¯åŠ¨å¸¦èµ„æºé™åˆ¶çš„å®¹å™¨
    println!("ğŸ³ å¯åŠ¨èµ„æºé™åˆ¶å®¹å™¨...");
    let output = Command::new("docker")
        .args(&[
            "run", "-d",
            "--name", container_name,
            "-p", "3002:3000",
            "--memory", "128m",
            "--cpus", "0.5",
            image_name
        ])
        .output()
        .expect("å¯åŠ¨å®¹å™¨å¤±è´¥");
    
    assert!(output.status.success());
    
    sleep(Duration::from_secs(3)).await;
    
    // æ£€æŸ¥èµ„æºä½¿ç”¨
    let stats_output = Command::new("docker")
        .args(&["stats", "--no-stream", "--format", 
               "table {{.MemUsage}}\t{{.CPUPerc}}", container_name])
        .output()
        .expect("è·å–èµ„æºç»Ÿè®¡å¤±è´¥");
    
    let stats = String::from_utf8_lossy(&stats_output.stdout);
    println!("ğŸ“Š èµ„æºä½¿ç”¨æƒ…å†µ:\n{}", stats);
    
    // éªŒè¯æœåŠ¡ä»ç„¶å¯ç”¨
    let response = reqwest::get("http://127.0.0.1:3002/health").await;
    assert!(response.is_ok(), "èµ„æºé™åˆ¶ä¸‹æœåŠ¡ä¸å¯ç”¨");
    println!("âœ… èµ„æºé™åˆ¶æµ‹è¯•é€šè¿‡");
    
    cleanup_container(container_name);
}

fn cleanup_container(container_name: &str) {
    // åœæ­¢å®¹å™¨
    Command::new("docker")
        .args(&["stop", container_name])
        .output()
        .ok();
    
    // åˆ é™¤å®¹å™¨
    Command::new("docker")
        .args(&["rm", container_name])
        .output()
        .ok();
}</pre>

        <p><strong>æ­¥éª¤ 5: ç»¼åˆæµ‹è¯•è„šæœ¬ (scripts/test_all.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}ğŸ§ª å¼€å§‹å®Œæ•´çš„ Docker WebSocket æµ‹è¯•å¥—ä»¶${NC}"

PROJECT_NAME="websocket-docker"
IMAGE_NAME="${PROJECT_NAME}:latest"
TEST_CONTAINER="${PROJECT_NAME}-test"

# æ¸…ç†å‡½æ•°
cleanup() {
    echo -e "${YELLOW}ğŸ§¹ æ¸…ç†æµ‹è¯•ç¯å¢ƒ...${NC}"
    docker stop "${TEST_CONTAINER}" 2>/dev/null || true
    docker rm "${TEST_CONTAINER}" 2>/dev/null || true
}

# è®¾ç½®æ¸…ç†é’©å­
trap cleanup EXIT

# 1. æ„å»ºæµ‹è¯•
echo -e "${GREEN}ğŸ“¦ æ­¥éª¤ 1: æ„å»ºé•œåƒæµ‹è¯•${NC}"
if docker build -t "${IMAGE_NAME}" -f docker/Dockerfile . > /dev/null 2>&1; then
    echo "âœ… é•œåƒæ„å»ºæˆåŠŸ"
else
    echo -e "${RED}âŒ é•œåƒæ„å»ºå¤±è´¥${NC}"
    exit 1
fi

# 2. å®¹å™¨å¯åŠ¨æµ‹è¯•
echo -e "${GREEN}ğŸš€ æ­¥éª¤ 2: å®¹å™¨å¯åŠ¨æµ‹è¯•${NC}"
docker run -d \
    --name "${TEST_CONTAINER}" \
    -p 3000:3000 \
    -e RUST_LOG=info \
    -e MAX_CONNECTIONS=100 \
    "${IMAGE_NAME}"

# ç­‰å¾…æœåŠ¡å¯åŠ¨
echo "â³ ç­‰å¾…æœåŠ¡å¯åŠ¨..."
sleep 5

# éªŒè¯å®¹å™¨çŠ¶æ€
if docker ps | grep -q "${TEST_CONTAINER}"; then
    echo "âœ… å®¹å™¨å¯åŠ¨æˆåŠŸ"
else
    echo -e "${RED}âŒ å®¹å™¨å¯åŠ¨å¤±è´¥${NC}"
    docker logs "${TEST_CONTAINER}"
    exit 1
fi

# 3. å¥åº·æ£€æŸ¥æµ‹è¯•
echo -e "${GREEN}ğŸ” æ­¥éª¤ 3: å¥åº·æ£€æŸ¥æµ‹è¯•${NC}"
max_attempts=10
attempt=1

while [ $attempt -le $max_attempts ]; do
    if curl -f -s http://localhost:3000/health > /dev/null; then
        echo "âœ… å¥åº·æ£€æŸ¥é€šè¿‡"
        break
    elif [ $attempt -eq $max_attempts ]; then
        echo -e "${RED}âŒ å¥åº·æ£€æŸ¥å¤±è´¥${NC}"
        docker logs "${TEST_CONTAINER}"
        exit 1
    else
        echo "â³ å¥åº·æ£€æŸ¥å°è¯• $attempt/$max_attempts..."
        sleep 2
        ((attempt++))
    fi
done

# 4. API ç«¯ç‚¹æµ‹è¯•
echo -e "${GREEN}ğŸŒ æ­¥éª¤ 4: API ç«¯ç‚¹æµ‹è¯•${NC}"

# å¥åº·æ£€æŸ¥ç«¯ç‚¹
health_response=$(curl -s http://localhost:3000/health)
if echo "$health_response" | grep -q "healthy"; then
    echo "âœ… å¥åº·æ£€æŸ¥ç«¯ç‚¹æ­£å¸¸"
else
    echo -e "${RED}âŒ å¥åº·æ£€æŸ¥ç«¯ç‚¹å¼‚å¸¸${NC}"
    echo "å“åº”: $health_response"
    exit 1
fi

# æŒ‡æ ‡ç«¯ç‚¹
metrics_response=$(curl -s http://localhost:3000/metrics)
if echo "$metrics_response" | grep -q "active_connections"; then
    echo "âœ… æŒ‡æ ‡ç«¯ç‚¹æ­£å¸¸"
else
    echo -e "${RED}âŒ æŒ‡æ ‡ç«¯ç‚¹å¼‚å¸¸${NC}"
    echo "å“åº”: $metrics_response"
    exit 1
fi

# å°±ç»ªæ£€æŸ¥ç«¯ç‚¹
ready_response=$(curl -s http://localhost:3000/ready)
if echo "$ready_response" | grep -q "ready"; then
    echo "âœ… å°±ç»ªæ£€æŸ¥ç«¯ç‚¹æ­£å¸¸"
else
    echo -e "${RED}âŒ å°±ç»ªæ£€æŸ¥ç«¯ç‚¹å¼‚å¸¸${NC}"
    echo "å“åº”: $ready_response"
    exit 1
fi

# 5. WebSocket è¿æ¥æµ‹è¯•
echo -e "${GREEN}ğŸ”Œ æ­¥éª¤ 5: WebSocket è¿æ¥æµ‹è¯•${NC}"
# ä½¿ç”¨ wscat æˆ– websocat è¿›è¡Œæµ‹è¯•ï¼ˆå¦‚æœå¯ç”¨ï¼‰
if command -v websocat > /dev/null 2>&1; then
    timeout 5s bash -c '
        echo "{\"message_type\":\"chat\",\"content\":\"test message\"}" | \
        websocat ws://localhost:3000/ws 2>/dev/null | \
        head -n 1 > /tmp/ws_test_output
    ' || true
    
    if [ -s /tmp/ws_test_output ]; then
        echo "âœ… WebSocket è¿æ¥æµ‹è¯•é€šè¿‡"
        rm -f /tmp/ws_test_output
    else
        echo -e "${YELLOW}âš ï¸  WebSocket æµ‹è¯•è·³è¿‡ï¼ˆéœ€è¦ websocat å·¥å…·ï¼‰${NC}"
    fi
else
    echo -e "${YELLOW}âš ï¸  WebSocket æµ‹è¯•è·³è¿‡ï¼ˆéœ€è¦ websocat å·¥å…·ï¼‰${NC}"
fi

# 6. èµ„æºä½¿ç”¨æµ‹è¯•
echo -e "${GREEN}ğŸ“Š æ­¥éª¤ 6: èµ„æºä½¿ç”¨æµ‹è¯•${NC}"
docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" "${TEST_CONTAINER}"

# è·å–å†…å­˜ä½¿ç”¨ï¼ˆMBï¼‰
memory_usage=$(docker stats --no-stream --format "{{.MemUsage}}" "${TEST_CONTAINER}" | cut -d'/' -f1 | sed 's/MiB//' | sed 's/ //')
if (( $(echo "$memory_usage < 200" | bc -l) )); then
    echo "âœ… å†…å­˜ä½¿ç”¨æ­£å¸¸: ${memory_usage}MB"
else
    echo -e "${YELLOW}âš ï¸  å†…å­˜ä½¿ç”¨è¾ƒé«˜: ${memory_usage}MB${NC}"
fi

# 7. æ—¥å¿—æ£€æŸ¥
echo -e "${GREEN}ğŸ“ æ­¥éª¤ 7: æ—¥å¿—æ£€æŸ¥${NC}"
log_output=$(docker logs "${TEST_CONTAINER}" 2>&1)

if echo "$log_output" | grep -q "WebSocket æœåŠ¡å™¨"; then
    echo "âœ… å¯åŠ¨æ—¥å¿—æ­£å¸¸"
else
    echo -e "${RED}âŒ å¯åŠ¨æ—¥å¿—å¼‚å¸¸${NC}"
    echo "$log_output"
    exit 1
fi

if echo "$log_output" | grep -q "ERROR\|PANIC"; then
    echo -e "${YELLOW}âš ï¸  å‘ç°é”™è¯¯æ—¥å¿—:${NC}"
    echo "$log_output" | grep -E "ERROR|PANIC"
else
    echo "âœ… æ— é”™è¯¯æ—¥å¿—"
fi

# 8. è´Ÿè½½æµ‹è¯•ï¼ˆå¯é€‰ï¼‰
if [ "${1:-}" = "--load-test" ]; then
    echo -e "${GREEN}ğŸš› æ­¥éª¤ 8: è´Ÿè½½æµ‹è¯•${NC}"
    
    # ä½¿ç”¨ ab (Apache Bench) è¿›è¡Œç®€å•è´Ÿè½½æµ‹è¯•
    if command -v ab > /dev/null 2>&1; then
        echo "æ‰§è¡Œ 100 ä¸ªå¹¶å‘è¯·æ±‚åˆ°å¥åº·æ£€æŸ¥ç«¯ç‚¹..."
        ab -n 1000 -c 10 -q http://localhost:3000/health | grep -E "Requests per second|Time per request|Transfer rate"
        echo "âœ… è´Ÿè½½æµ‹è¯•å®Œæˆ"
    else
        echo -e "${YELLOW}âš ï¸  è´Ÿè½½æµ‹è¯•è·³è¿‡ï¼ˆéœ€è¦ apache2-utilsï¼‰${NC}"
    fi
fi

# 9. å®‰å…¨æ£€æŸ¥
echo -e "${GREEN}ğŸ”’ æ­¥éª¤ 9: å®‰å…¨æ£€æŸ¥${NC}"

# æ£€æŸ¥å®¹å™¨æ˜¯å¦ä»¥é root ç”¨æˆ·è¿è¡Œ
user_info=$(docker exec "${TEST_CONTAINER}" whoami 2>/dev/null || echo "unknown")
if [ "$user_info" != "root" ]; then
    echo "âœ… å®¹å™¨ä½¿ç”¨é root ç”¨æˆ·è¿è¡Œ: $user_info"
else
    echo -e "${YELLOW}âš ï¸  å®¹å™¨ä»¥ root ç”¨æˆ·è¿è¡Œ${NC}"
fi

# æ£€æŸ¥ç«¯å£æš´éœ²
exposed_ports=$(docker port "${TEST_CONTAINER}")
echo "ğŸ“¡ æš´éœ²çš„ç«¯å£: $exposed_ports"

# 10. é•œåƒåˆ†æ
echo -e "${GREEN}ğŸ” æ­¥éª¤ 10: é•œåƒåˆ†æ${NC}"
image_size=$(docker images "${IMAGE_NAME}" --format "{{.Size}}")
echo "ğŸ’¾ é•œåƒå¤§å°: $image_size"

# æ˜¾ç¤ºé•œåƒå±‚ä¿¡æ¯
echo "ğŸ“‹ é•œåƒå±‚ä¿¡æ¯:"
docker history "${IMAGE_NAME}" --format "table {{.CreatedBy}}\t{{.Size}}" | head -10

# å®Œæˆ
echo -e "${GREEN}ğŸ‰ æ‰€æœ‰æµ‹è¯•å®Œæˆï¼${NC}"
echo -e "${BLUE}æµ‹è¯•æ€»ç»“:${NC}"
echo "   - é•œåƒæ„å»º: âœ… é€šè¿‡"
echo "   - å®¹å™¨å¯åŠ¨: âœ… é€šè¿‡"
echo "   - å¥åº·æ£€æŸ¥: âœ… é€šè¿‡"
echo "   - API ç«¯ç‚¹: âœ… é€šè¿‡"
echo "   - èµ„æºä½¿ç”¨: âœ… æ­£å¸¸"
echo "   - æ—¥å¿—æ£€æŸ¥: âœ… é€šè¿‡"
echo "   - å®‰å…¨æ£€æŸ¥: âœ… é€šè¿‡"
echo ""
echo -e "${GREEN}Docker WebSocket åº”ç”¨å·²å‡†å¤‡å¥½éƒ¨ç½²ï¼${NC}"</pre>

        <p><strong>æ­¥éª¤ 6: æ€§èƒ½åŸºå‡†æµ‹è¯• (scripts/benchmark.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# é¢œè‰²è¾“å‡º
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}ğŸ“Š WebSocket æœåŠ¡æ€§èƒ½åŸºå‡†æµ‹è¯•${NC}"

# é…ç½®å‚æ•°
CONTAINER_NAME="websocket-benchmark"
IMAGE_NAME="websocket-docker:latest"
TEST_PORT="3000"
RESULTS_DIR="benchmark_results"

# åˆ›å»ºç»“æœç›®å½•
mkdir -p "${RESULTS_DIR}"
timestamp=$(date +"%Y%m%d_%H%M%S")

cleanup() {
    echo -e "${YELLOW}ğŸ§¹ æ¸…ç†æµ‹è¯•ç¯å¢ƒ...${NC}"
    docker stop "${CONTAINER_NAME}" 2>/dev/null || true
    docker rm "${CONTAINER_NAME}" 2>/dev/null || true
}

trap cleanup EXIT

# å¯åŠ¨æµ‹è¯•å®¹å™¨
echo -e "${GREEN}ğŸš€ å¯åŠ¨æµ‹è¯•å®¹å™¨...${NC}"
docker run -d \
    --name "${CONTAINER_NAME}" \
    -p "${TEST_PORT}:3000" \
    -e RUST_LOG=warn \
    -e MAX_CONNECTIONS=2000 \
    "${IMAGE_NAME}"

echo "â³ ç­‰å¾…æœåŠ¡å¯åŠ¨..."
sleep 3

# éªŒè¯æœåŠ¡å¯ç”¨
if ! curl -f -s "http://localhost:${TEST_PORT}/health" > /dev/null; then
    echo "âŒ æœåŠ¡å¯åŠ¨å¤±è´¥"
    exit 1
fi

echo "âœ… æœåŠ¡å¯åŠ¨æˆåŠŸ"

# 1. HTTP ç«¯ç‚¹æ€§èƒ½æµ‹è¯•
echo -e "${GREEN}ğŸŒ HTTP ç«¯ç‚¹æ€§èƒ½æµ‹è¯•${NC}"

if command -v ab > /dev/null 2>&1; then
    echo "æµ‹è¯•å¥åº·æ£€æŸ¥ç«¯ç‚¹..."
    ab -n 10000 -c 100 -q "http://localhost:${TEST_PORT}/health" > "${RESULTS_DIR}/health_benchmark_${timestamp}.txt"
    
    echo "æµ‹è¯•æŒ‡æ ‡ç«¯ç‚¹..."
    ab -n 5000 -c 50 -q "http://localhost:${TEST_PORT}/metrics" > "${RESULTS_DIR}/metrics_benchmark_${timestamp}.txt"
    
    # æ˜¾ç¤ºå…³é”®æŒ‡æ ‡
    echo "ğŸ“Š å¥åº·æ£€æŸ¥ç«¯ç‚¹ç»“æœ:"
    grep -E "Requests per second|Time per request|Transfer rate" "${RESULTS_DIR}/health_benchmark_${timestamp}.txt"
    
    echo "ğŸ“Š æŒ‡æ ‡ç«¯ç‚¹ç»“æœ:"
    grep -E "Requests per second|Time per request|Transfer rate" "${RESULTS_DIR}/metrics_benchmark_${timestamp}.txt"
else
    echo -e "${YELLOW}âš ï¸  è·³è¿‡ HTTP æ€§èƒ½æµ‹è¯•ï¼ˆéœ€è¦ apache2-utilsï¼‰${NC}"
fi

# 2. WebSocket è¿æ¥æ€§èƒ½æµ‹è¯•
echo -e "${GREEN}ğŸ”Œ WebSocket è¿æ¥æ€§èƒ½æµ‹è¯•${NC}"

# åˆ›å»º Node.js WebSocket å‹åŠ›æµ‹è¯•è„šæœ¬
cat > "${RESULTS_DIR}/ws_stress_test.js" << 'EOF'
const WebSocket = require('ws');
const { performance } = require('perf_hooks');

const WS_URL = 'ws://localhost:3000/ws';
const CONCURRENT_CONNECTIONS = 500;
const MESSAGES_PER_CONNECTION = 10;
const CONNECTION_DELAY = 2; // ms between connections

let totalConnections = 0;
let successfulConnections = 0;
let totalMessages = 0;
let connectionTimes = [];
let messageTimes = [];

async function createConnection(id) {
    return new Promise((resolve) => {
        const startTime = performance.now();
        const ws = new WebSocket(WS_URL);
        let messagesSent = 0;
        let messagesReceived = 0;
        
        ws.on('open', () => {
            const connectionTime = performance.now() - startTime;
            connectionTimes.push(connectionTime);
            successfulConnections++;
            
            // å‘é€æµ‹è¯•æ¶ˆæ¯
            const sendMessage = () => {
                if (messagesSent < MESSAGES_PER_CONNECTION) {
                    const msgStartTime = performance.now();
                    const message = JSON.stringify({
                        message_type: 'chat',
                        content: `Test message ${messagesSent} from client ${id}`,
                        timestamp: new Date().toISOString()
                    });
                    
                    ws.send(message);
                    messagesSent++;
                    
                    setTimeout(sendMessage, 10);
                } else {
                    setTimeout(() => ws.close(), 100);
                }
            };
            
            sendMessage();
        });
        
        ws.on('message', (data) => {
            const msgTime = performance.now();
            messagesReceived++;
            totalMessages++;
        });
        
        ws.on('close', () => {
            resolve({
                id,
                messagesSent,
                messagesReceived,
                connectionTime: connectionTimes[connectionTimes.length - 1]
            });
        });
        
        ws.on('error', (error) => {
            console.error(`Client ${id} error:`, error.message);
            resolve({ id, error: error.message });
        });
    });
}

async function runTest() {
    console.log(`ğŸš€ å¯åŠ¨ ${CONCURRENT_CONNECTIONS} ä¸ªå¹¶å‘ WebSocket è¿æ¥`);
    console.log(`ğŸ“ æ¯ä¸ªè¿æ¥å‘é€ ${MESSAGES_PER_CONNECTION} æ¡æ¶ˆæ¯`);
    
    const startTime = performance.now();
    const promises = [];
    
    for (let i = 0; i < CONCURRENT_CONNECTIONS; i++) {
        promises.push(createConnection(i));
        totalConnections++;
        
        if (i % 50 === 0) {
            await new Promise(resolve => setTimeout(resolve, CONNECTION_DELAY));
        }
    }
    
    const results = await Promise.all(promises);
    const endTime = performance.now();
    const totalTime = endTime - startTime;
    
    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    const avgConnectionTime = connectionTimes.reduce((a, b) => a + b, 0) / connectionTimes.length;
    const minConnectionTime = Math.min(...connectionTimes);
    const maxConnectionTime = Math.max(...connectionTimes);
    
    console.log('\nğŸ“Š æµ‹è¯•ç»“æœ:');
    console.log(`   æ€»è¿æ¥æ•°: ${totalConnections}`);
    console.log(`   æˆåŠŸè¿æ¥: ${successfulConnections}`);
    console.log(`   è¿æ¥æˆåŠŸç‡: ${(successfulConnections / totalConnections * 100).toFixed(2)}%`);
    console.log(`   æ€»æ¶ˆæ¯æ•°: ${totalMessages}`);
    console.log(`   æµ‹è¯•æ—¶é•¿: ${(totalTime / 1000).toFixed(2)} ç§’`);
    console.log(`   è¿æ¥/ç§’: ${(successfulConnections / (totalTime / 1000)).toFixed(2)}`);
    console.log(`   æ¶ˆæ¯/ç§’: ${(totalMessages / (totalTime / 1000)).toFixed(2)}`);
    console.log(`   å¹³å‡è¿æ¥æ—¶é—´: ${avgConnectionTime.toFixed(2)} ms`);
    console.log(`   æœ€å°è¿æ¥æ—¶é—´: ${minConnectionTime.toFixed(2)} ms`);
    console.log(`   æœ€å¤§è¿æ¥æ—¶é—´: ${maxConnectionTime.toFixed(2)} ms`);
    
    // ä¿å­˜ç»“æœåˆ°æ–‡ä»¶
    const report = {
        timestamp: new Date().toISOString(),
        config: {
            concurrent_connections: CONCURRENT_CONNECTIONS,
            messages_per_connection: MESSAGES_PER_CONNECTION
        },
        results: {
            total_connections: totalConnections,
            successful_connections: successfulConnections,
            success_rate: successfulConnections / totalConnections * 100,
            total_messages: totalMessages,
            test_duration_ms: totalTime,
            connections_per_second: successfulConnections / (totalTime / 1000),
            messages_per_second: totalMessages / (totalTime / 1000),
            avg_connection_time_ms: avgConnectionTime,
            min_connection_time_ms: minConnectionTime,
            max_connection_time_ms: maxConnectionTime
        }
    };
    
    console.log('\nğŸ’¾ ä¿å­˜ç»“æœåˆ° ws_benchmark_results.json');
    require('fs').writeFileSync('ws_benchmark_results.json', JSON.stringify(report, null, 2));
}

runTest().catch(console.error);
EOF

# è¿è¡Œ WebSocket å‹åŠ›æµ‹è¯•ï¼ˆå¦‚æœ Node.js å¯ç”¨ï¼‰
if command -v node > /dev/null 2>&1; then
    if npm list ws > /dev/null 2>&1 || npm install ws > /dev/null 2>&1; then
        echo "æ‰§è¡Œ WebSocket å‹åŠ›æµ‹è¯•..."
        cd "${RESULTS_DIR}"
        node ws_stress_test.js
        cd ..
        echo "âœ… WebSocket å‹åŠ›æµ‹è¯•å®Œæˆ"
    else
        echo -e "${YELLOW}âš ï¸  è·³è¿‡ WebSocket å‹åŠ›æµ‹è¯•ï¼ˆéœ€è¦ ws npm åŒ…ï¼‰${NC}"
    fi
else
    echo -e "${YELLOW}âš ï¸  è·³è¿‡ WebSocket å‹åŠ›æµ‹è¯•ï¼ˆéœ€è¦ Node.jsï¼‰${NC}"
fi

# 3. èµ„æºç›‘æ§
echo -e "${GREEN}ğŸ“Š èµ„æºä½¿ç”¨ç›‘æ§${NC}"

# ç›‘æ§ 30 ç§’çš„èµ„æºä½¿ç”¨
echo "ç›‘æ§å®¹å™¨èµ„æºä½¿ç”¨ 30 ç§’..."
for i in {1..6}; do
    docker stats --no-stream --format "{{.CPUPerc}},{{.MemUsage}}" "${CONTAINER_NAME}" >> "${RESULTS_DIR}/resource_usage_${timestamp}.csv"
    sleep 5
done

echo "ğŸ“Š èµ„æºä½¿ç”¨ç»Ÿè®¡:"
echo "CPU ä½¿ç”¨ç‡:"
awk -F',' '{sum+=$1; count++} END {print "   å¹³å‡: " sum/count "%"}' "${RESULTS_DIR}/resource_usage_${timestamp}.csv"

echo "å†…å­˜ä½¿ç”¨:"
tail -1 "${RESULTS_DIR}/resource_usage_${timestamp}.csv" | awk -F',' '{print "   å½“å‰: " $2}'

# 4. ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
echo -e "${GREEN}ğŸ“‹ ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š${NC}"

cat > "${RESULTS_DIR}/benchmark_report_${timestamp}.md" << EOF
# WebSocket æœåŠ¡æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š

**æµ‹è¯•æ—¶é—´**: $(date)
**æµ‹è¯•ç‰ˆæœ¬**: ${IMAGE_NAME}
**æµ‹è¯•é…ç½®**: Docker å®¹å™¨è¿è¡Œ

## æµ‹è¯•ç¯å¢ƒ
- å®¹å™¨åç§°: ${CONTAINER_NAME}
- æµ‹è¯•ç«¯å£: ${TEST_PORT}
- ç³»ç»Ÿä¿¡æ¯: $(uname -a)

## HTTP ç«¯ç‚¹æ€§èƒ½
$([ -f "${RESULTS_DIR}/health_benchmark_${timestamp}.txt" ] && echo "### å¥åº·æ£€æŸ¥ç«¯ç‚¹" && grep -E "Requests per second|Time per request|Transfer rate" "${RESULTS_DIR}/health_benchmark_${timestamp}.txt" || echo "HTTP æ€§èƒ½æµ‹è¯•æœªæ‰§è¡Œ")

## WebSocket æ€§èƒ½
$([ -f "${RESULTS_DIR}/ws_benchmark_results.json" ] && echo "### WebSocket è¿æ¥æµ‹è¯•" && cat "${RESULTS_DIR}/ws_benchmark_results.json" | jq -r '.results | to_entries[] | "- \(.key): \(.value)"' || echo "WebSocket æ€§èƒ½æµ‹è¯•æœªæ‰§è¡Œ")

## èµ„æºä½¿ç”¨
- æµ‹è¯•æœŸé—´å¹³å‡ CPU ä½¿ç”¨ç‡: $(awk -F',' '{sum+=$1; count++} END {print sum/count "%"}' "${RESULTS_DIR}/resource_usage_${timestamp}.csv")
- æµ‹è¯•ç»“æŸæ—¶å†…å­˜ä½¿ç”¨: $(tail -1 "${RESULTS_DIR}/resource_usage_${timestamp}.csv" | awk -F',' '{print $2}')

## ç»“è®º
$(if [ -f "${RESULTS_DIR}/ws_benchmark_results.json" ]; then
    success_rate=$(cat "${RESULTS_DIR}/ws_benchmark_results.json" | jq -r '.results.success_rate')
    if (( $(echo "$success_rate > 95" | bc -l) )); then
        echo "âœ… æ€§èƒ½æµ‹è¯•é€šè¿‡ - è¿æ¥æˆåŠŸç‡: ${success_rate}%"
    else
        echo "âš ï¸ æ€§èƒ½éœ€è¦ä¼˜åŒ– - è¿æ¥æˆåŠŸç‡: ${success_rate}%"
    fi
else
    echo "åŸºç¡€åŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼ŒWebSocket æ€§èƒ½æµ‹è¯•æœªæ‰§è¡Œ"
fi)
EOF

echo "âœ… æµ‹è¯•æŠ¥å‘Šå·²ä¿å­˜åˆ°: ${RESULTS_DIR}/benchmark_report_${timestamp}.md"

echo -e "${GREEN}ğŸ‰ æ€§èƒ½åŸºå‡†æµ‹è¯•å®Œæˆï¼${NC}"
echo "ğŸ“ æ‰€æœ‰ç»“æœæ–‡ä»¶ä¿å­˜åœ¨: ${RESULTS_DIR}/"
ls -la "${RESULTS_DIR}/"</pre>

        <p><strong>æ­¥éª¤ 7: ç”Ÿäº§éƒ¨ç½²è„šæœ¬ (scripts/deploy.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}ğŸš€ WebSocket æœåŠ¡ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²${NC}"

# é…ç½®å‚æ•°
PROJECT_NAME="websocket-docker"
IMAGE_NAME="${PROJECT_NAME}:latest"
PROD_CONTAINER="${PROJECT_NAME}-prod"
BACKUP_CONTAINER="${PROJECT_NAME}-backup"

# ç¯å¢ƒæ£€æŸ¥
check_requirements() {
    echo -e "${GREEN}ğŸ” æ£€æŸ¥éƒ¨ç½²è¦æ±‚...${NC}"
    
    # æ£€æŸ¥ Docker
    if ! command -v docker > /dev/null 2>&1; then
        echo -e "${RED}âŒ Docker æœªå®‰è£…${NC}"
        exit 1
    fi
    
    # æ£€æŸ¥é•œåƒå­˜åœ¨
    if ! docker images | grep -q "${PROJECT_NAME}"; then
        echo -e "${RED}âŒ é•œåƒ ${IMAGE_NAME} ä¸å­˜åœ¨${NC}"
        echo "è¯·å…ˆè¿è¡Œ: ./scripts/build.sh"
        exit 1
    fi
    
    # æ£€æŸ¥ç«¯å£å ç”¨
    if netstat -tuln 2>/dev/null | grep -q ":3000 "; then
        echo -e "${YELLOW}âš ï¸  ç«¯å£ 3000 å·²è¢«å ç”¨${NC}"
        echo "æ­£åœ¨æ£€æŸ¥æ˜¯å¦ä¸ºå½“å‰æœåŠ¡..."
        
        if docker ps | grep -q "${PROD_CONTAINER}"; then
            echo "å‘ç°ç°æœ‰ç”Ÿäº§å®¹å™¨ï¼Œå°†è¿›è¡Œæ»šåŠ¨æ›´æ–°"
        else
            echo -e "${RED}âŒ ç«¯å£è¢«å…¶ä»–æœåŠ¡å ç”¨${NC}"
            exit 1
        fi
    fi
    
    echo "âœ… ç¯å¢ƒæ£€æŸ¥é€šè¿‡"
}

# å¥åº·æ£€æŸ¥å‡½æ•°
wait_for_health() {
    local container_name=$1
    local max_attempts=30
    local attempt=1
    
    echo "â³ ç­‰å¾…æœåŠ¡å¥åº·æ£€æŸ¥..."
    
    while [ $attempt -le $max_attempts ]; do
        if curl -f -s http://localhost:3000/health > /dev/null 2>&1; then
            echo "âœ… æœåŠ¡å¥åº·æ£€æŸ¥é€šè¿‡"
            return 0
        fi
        
        if [ $attempt -eq $max_attempts ]; then
            echo -e "${RED}âŒ æœåŠ¡å¥åº·æ£€æŸ¥å¤±è´¥${NC}"
            echo "å®¹å™¨æ—¥å¿—:"
            docker logs --tail 20 "$container_name"
            return 1
        fi
        
        echo "å°è¯• $attempt/$max_attempts - ç­‰å¾…æœåŠ¡å¯åŠ¨..."
        sleep 2
        ((attempt++))
    done
}

# å¤‡ä»½å½“å‰å®¹å™¨
backup_current_container() {
    if docker ps | grep -q "${PROD_CONTAINER}"; then
        echo -e "${YELLOW}ğŸ“¦ å¤‡ä»½å½“å‰ç”Ÿäº§å®¹å™¨...${NC}"
        
        # åœæ­¢å¤‡ä»½å®¹å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        docker stop "${BACKUP_CONTAINER}" 2>/dev/null || true
        docker rm "${BACKUP_CONTAINER}" 2>/dev/null || true
        
        # åˆ›å»ºå½“å‰å®¹å™¨çš„å¤‡ä»½
        docker commit "${PROD_CONTAINER}" "${PROJECT_NAME}:backup"
        echo "âœ… å®¹å™¨å¤‡ä»½å®Œæˆ"
    fi
}

# æ»šåŠ¨æ›´æ–°éƒ¨ç½²
rolling_update() {
    echo -e "${GREEN}ğŸ”„ æ‰§è¡Œæ»šåŠ¨æ›´æ–°éƒ¨ç½²...${NC}"
    
    # å¯åŠ¨æ–°å®¹å™¨
    echo "å¯åŠ¨æ–°ç‰ˆæœ¬å®¹å™¨..."
    docker run -d \
        --name "${PROD_CONTAINER}-new" \
        -p 3001:3000 \
        -e RUST_LOG=info \
        -e LOG_LEVEL=info \
        -e MAX_CONNECTIONS=2000 \
        -e CHANNEL_CAPACITY=2000 \
        -e ENABLE_METRICS=true \
        -e APP_ENV=production \
        -v "${PWD}/logs:/app/logs" \
        --restart unless-stopped \
        "${IMAGE_NAME}"
    
    # ç­‰å¾…æ–°å®¹å™¨å¥åº·
    if ! wait_for_health "${PROD_CONTAINER}-new"; then
        echo -e "${RED}âŒ æ–°å®¹å™¨å¯åŠ¨å¤±è´¥ï¼Œå›æ»š${NC}"
        docker stop "${PROD_CONTAINER}-new" 2>/dev/null || true
        docker rm "${PROD_CONTAINER}-new" 2>/dev/null || true
        exit 1
    fi
    
    # åˆ‡æ¢æµé‡
    echo "åˆ‡æ¢æµé‡åˆ°æ–°å®¹å™¨..."
    if docker ps | grep -q "${PROD_CONTAINER}"; then
        docker stop "${PROD_CONTAINER}"
        docker rm "${PROD_CONTAINER}"
    fi
    
    # æ›´æ–°ç«¯å£æ˜ å°„
    docker stop "${PROD_CONTAINER}-new"
    docker commit "${PROD_CONTAINER}-new" "${PROJECT_NAME}:current"
    docker rm "${PROD_CONTAINER}-new"
    
    # å¯åŠ¨æœ€ç»ˆç”Ÿäº§å®¹å™¨
    docker run -d \
        --name "${PROD_CONTAINER}" \
        -p 3000:3000 \
        -e RUST_LOG=info \
        -e LOG_LEVEL=info \
        -e MAX_CONNECTIONS=2000 \
        -e CHANNEL_CAPACITY=2000 \
        -e ENABLE_METRICS=true \
        -e APP_ENV=production \
        -v "${PWD}/logs:/app/logs" \
        --restart unless-stopped \
        "${PROJECT_NAME}:current"
    
    # æœ€ç»ˆå¥åº·æ£€æŸ¥
    if ! wait_for_health "${PROD_CONTAINER}"; then
        echo -e "${RED}âŒ æœ€ç»ˆéƒ¨ç½²å¤±è´¥${NC}"
        exit 1
    fi
    
    echo "âœ… æ»šåŠ¨æ›´æ–°å®Œæˆ"
}

# å…¨æ–°éƒ¨ç½²
fresh_deploy() {
    echo -e "${GREEN}ğŸ†• æ‰§è¡Œå…¨æ–°éƒ¨ç½²...${NC}"
    
    # åˆ›å»ºæ—¥å¿—ç›®å½•
    mkdir -p logs
    
    # å¯åŠ¨ç”Ÿäº§å®¹å™¨
    docker run -d \
        --name "${PROD_CONTAINER}" \
        -p 3000:3000 \
        -e RUST_LOG=info \
        -e LOG_LEVEL=info \
        -e MAX_CONNECTIONS=2000 \
        -e CHANNEL_CAPACITY=2000 \
        -e ENABLE_METRICS=true \
        -e APP_ENV=production \
        -v "${PWD}/logs:/app/logs" \
        --restart unless-stopped \
        "${IMAGE_NAME}"
    
    if ! wait_for_health "${PROD_CONTAINER}"; then
        echo -e "${RED}âŒ éƒ¨ç½²å¤±è´¥${NC}"
        exit 1
    fi
    
    echo "âœ… å…¨æ–°éƒ¨ç½²å®Œæˆ"
}

# éƒ¨ç½²åéªŒè¯
post_deploy_verification() {
    echo -e "${GREEN}ğŸ” éƒ¨ç½²åéªŒè¯...${NC}"
    
    # API ç«¯ç‚¹æµ‹è¯•
    echo "æµ‹è¯• API ç«¯ç‚¹..."
    
    # å¥åº·æ£€æŸ¥
    if curl -f -s http://localhost:3000/health | grep -q "healthy"; then
        echo "âœ… å¥åº·æ£€æŸ¥ç«¯ç‚¹æ­£å¸¸"
    else
        echo -e "${RED}âŒ å¥åº·æ£€æŸ¥ç«¯ç‚¹å¼‚å¸¸${NC}"
        exit 1
    fi
    
    # æŒ‡æ ‡ç«¯ç‚¹
    if curl -f -s http://localhost:3000/metrics | grep -q "active_connections"; then
        echo "âœ… æŒ‡æ ‡ç«¯ç‚¹æ­£å¸¸"
    else
        echo -e "${RED}âŒ æŒ‡æ ‡ç«¯ç‚¹å¼‚å¸¸${NC}"
        exit 1
    fi
    
    # WebSocket æµ‹è¯•ï¼ˆå¦‚æœå·¥å…·å¯ç”¨ï¼‰
    if command -v websocat > /dev/null 2>&1; then
        echo "æµ‹è¯• WebSocket è¿æ¥..."
        timeout 3s bash -c '
            echo "{\"message_type\":\"chat\",\"content\":\"deployment test\"}" | \
            websocat ws://localhost:3000/ws 2>/dev/null | \
            head -n 1 > /tmp/deploy_ws_test
        ' || true
        
        if [ -s /tmp/deploy_ws_test ]; then
            echo "âœ… WebSocket è¿æ¥æ­£å¸¸"
            rm -f /tmp/deploy_ws_test
        else
            echo -e "${YELLOW}âš ï¸  WebSocket æµ‹è¯•æœªé€šè¿‡${NC}"
        fi
    fi
    
    # èµ„æºæ£€æŸ¥
    echo "æ£€æŸ¥èµ„æºä½¿ç”¨..."
    docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" "${PROD_CONTAINER}"
    
    # å®¹å™¨ä¿¡æ¯
    echo "å®¹å™¨ä¿¡æ¯:"
    docker ps --filter "name=${PROD_CONTAINER}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
    
    echo "âœ… éƒ¨ç½²éªŒè¯å®Œæˆ"
}

# ç”Ÿæˆéƒ¨ç½²æŠ¥å‘Š
generate_deploy_report() {
    local deploy_time=$(date)
    local container_id=$(docker ps --filter "name=${PROD_CONTAINER}" --format "{{.ID}}")
    local image_id=$(docker inspect "${PROD_CONTAINER}" --format "{{.Image}}")
    
    cat > "deploy_report_$(date +%Y%m%d_%H%M%S).md" << EOF
# WebSocket æœåŠ¡éƒ¨ç½²æŠ¥å‘Š

**éƒ¨ç½²æ—¶é—´**: ${deploy_time}
**å®¹å™¨ ID**: ${container_id}
**é•œåƒ ID**: ${image_id}

## éƒ¨ç½²é…ç½®
- å®¹å™¨åç§°: ${PROD_CONTAINER}
- ç«¯å£æ˜ å°„: 3000:3000
- ç¯å¢ƒå˜é‡:
  - RUST_LOG=info
  - MAX_CONNECTIONS=2000
  - APP_ENV=production

## éªŒè¯ç»“æœ
- å¥åº·æ£€æŸ¥: âœ… é€šè¿‡
- æŒ‡æ ‡ç«¯ç‚¹: âœ… é€šè¿‡
- å®¹å™¨çŠ¶æ€: âœ… è¿è¡Œä¸­

## è®¿é—®ä¿¡æ¯
- æœåŠ¡åœ°å€: http://localhost:3000
- WebSocket: ws://localhost:3000/ws
- å¥åº·æ£€æŸ¥: http://localhost:3000/health
- æœåŠ¡æŒ‡æ ‡: http://localhost:3000/metrics

## è¿ç»´å‘½ä»¤
\`\`\`bash
# æŸ¥çœ‹æ—¥å¿—
docker logs -f ${PROD_CONTAINER}

# æŸ¥çœ‹èµ„æºä½¿ç”¨
docker stats ${PROD_CONTAINER}

# é‡å¯æœåŠ¡
docker restart ${PROD_CONTAINER}

# åœæ­¢æœåŠ¡
docker stop ${PROD_CONTAINER}
\`\`\`
EOF

    echo "ğŸ“‹ éƒ¨ç½²æŠ¥å‘Šå·²ä¿å­˜"
}

# ä¸»éƒ¨ç½²æµç¨‹
main() {
    echo -e "${BLUE}å¼€å§‹ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æµç¨‹${NC}"
    
    # 1. ç¯å¢ƒæ£€æŸ¥
    check_requirements
    
    # 2. å¤‡ä»½ç°æœ‰å®¹å™¨
    backup_current_container
    
    # 3. é€‰æ‹©éƒ¨ç½²æ–¹å¼
    if docker ps | grep -q "${PROD_CONTAINER}"; then
        rolling_update
    else
        fresh_deploy
    fi
    
    # 4. éƒ¨ç½²åéªŒè¯
    post_deploy_verification
    
    # 5. ç”ŸæˆæŠ¥å‘Š
    generate_deploy_report
    
    echo -e "${GREEN}ğŸ‰ ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å®Œæˆï¼${NC}"
    echo -e "${BLUE}æœåŠ¡è®¿é—®åœ°å€: http://localhost:3000${NC}"
    echo -e "${BLUE}WebSocket åœ°å€: ws://localhost:3000/ws${NC}"
    echo -e "${YELLOW}æŸ¥çœ‹æ—¥å¿—: docker logs -f ${PROD_CONTAINER}${NC}"
}

# æ¸…ç†å‡½æ•°
cleanup_failed_deploy() {
    echo -e "${YELLOW}ğŸ§¹ æ¸…ç†å¤±è´¥çš„éƒ¨ç½²...${NC}"
    docker stop "${PROD_CONTAINER}-new" 2>/dev/null || true
    docker rm "${PROD_CONTAINER}-new" 2>/dev/null || true
}

# è®¾ç½®é”™è¯¯å¤„ç†
trap cleanup_failed_deploy ERR

# æ‰§è¡Œä¸»æµç¨‹
main "$@"</pre>

        <p><strong>æ­¥éª¤ 8: ç›‘æ§é…ç½® (monitoring/prometheus.yml)</strong></p>
        <pre>global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

scrape_configs:
  - job_name: 'websocket-server'
    static_configs:
      - targets: ['host.docker.internal:3000']
    metrics_path: '/metrics'
    scrape_interval: 10s
    scrape_timeout: 5s

  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']</pre>

        <p><strong>æ­¥éª¤ 9: Docker Compose ç›‘æ§ (monitoring/docker-compose.monitoring.yml)</strong></p>
        <pre>version: '3.8'

services:
  websocket-server:
    image: websocket-docker:latest
    container_name: websocket-prod
    ports:
      - "3000:3000"
    environment:
      - RUST_LOG=info
      - MAX_CONNECTIONS=2000
      - ENABLE_METRICS=true
      - APP_ENV=production
    volumes:
      - ../logs:/app/logs
    restart: unless-stopped
    networks:
      - monitoring

  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    restart: unless-stopped
    networks:
      - monitoring

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin123
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana:/etc/grafana/provisioning
    restart: unless-stopped
    networks:
      - monitoring

  nginx:
    image: nginx:alpine
    container_name: websocket-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ../nginx/nginx.conf:/etc/nginx/nginx.conf
      - ../nginx/ssl:/etc/nginx/ssl
    depends_on:
      - websocket-server
    restart: unless-stopped
    networks:
      - monitoring

volumes:
  prometheus_data:
  grafana_data:

networks:
  monitoring:
    driver: bridge</pre>

        <p><strong>æ­¥éª¤ 10: è¿è¡Œå®Œæ•´æµ‹è¯•</strong></p>
        <pre># 1. èµ‹äºˆè„šæœ¬æ‰§è¡Œæƒé™
chmod +x scripts/*.sh

# 2. æ„å»ºé•œåƒ
./scripts/build.sh

# 3. è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
./scripts/test_all.sh

# 4. è¿è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
./scripts/benchmark.sh

# 5. éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ
./scripts/deploy.sh

# 6. å¯åŠ¨ç›‘æ§æ ˆ
cd monitoring
docker-compose -f docker-compose.monitoring.yml up -d

# 7. éªŒè¯éƒ¨ç½²
curl http://localhost:3000/health
curl http://localhost:3000/metrics
curl http://localhost:9090  # Prometheus
curl http://localhost:3001  # Grafana

# 8. æŸ¥çœ‹æœåŠ¡çŠ¶æ€
docker ps
docker logs websocket-prod

# 9. è¿è¡Œ Rust é›†æˆæµ‹è¯•
cargo test --test integration_test
cargo test --test docker_test

# 10. è¿è¡Œè´Ÿè½½æµ‹è¯•ï¼ˆéœ€è¦å®‰è£… apache2-utilsï¼‰
sudo apt-get install apache2-utils  # Ubuntu/Debian
# æˆ–
brew install apache2-utils  # macOS

./scripts/test_all.sh --load-test</pre>

        <p><strong>ğŸ¯ ä»Šæ—¥æ”¶è·</strong></p>
        <ul>
            <li>âœ… å®Œæˆäº†å…¨é¢çš„ Docker å®¹å™¨æµ‹è¯•</li>
            <li>âœ… å®ç°äº†è‡ªåŠ¨åŒ–çš„é›†æˆæµ‹è¯•å¥—ä»¶</li>
            <li>âœ… é…ç½®äº†æ€§èƒ½åŸºå‡†æµ‹è¯•å’Œè´Ÿè½½æµ‹è¯•</li>
            <li>âœ… å»ºç«‹äº†ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æµç¨‹</li>
            <li>âœ… é›†æˆäº†ç›‘æ§å’Œæ—¥å¿—æ”¶é›†ç³»ç»Ÿ</li>
            <li>âœ… éªŒè¯äº†å®¹å™¨çš„ç”Ÿäº§å°±ç»ªæ€§</li>
            <li>âœ… æŒæ¡äº† Docker åŒ–åº”ç”¨çš„å®Œæ•´æµ‹è¯•æ–¹æ³•</li>
        </ul>

        <p><strong>ğŸ’¡ æ‰©å±•ç»ƒä¹ </strong></p>
        <ul>
            <li>é›†æˆ Kubernetes éƒ¨ç½²å’Œæµ‹è¯•</li>
            <li>æ·»åŠ åˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿ</li>
            <li>å®ç°è‡ªåŠ¨åŒ– CI/CD æµæ°´çº¿</li>
            <li>é…ç½®é«˜å¯ç”¨è´Ÿè½½å‡è¡¡</li>
        </ul>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-22</strong></p>
        <h2>Day 22 - Kubernetes éƒ¨ç½²ä¸æœåŠ¡é…ç½®</h2>
        <p>ä»Šå¤©ä½ å°†å­¦ä¹ å¦‚ä½•å°† Docker åŒ–çš„ WebSocket åº”ç”¨éƒ¨ç½²åˆ° Kubernetes é›†ç¾¤ã€‚ä½ å°†ç¼–å†™å®Œæ•´çš„ Kubernetes æ¸…å•æ–‡ä»¶ï¼ŒåŒ…æ‹¬ Deploymentã€Serviceã€Ingress ç­‰èµ„æºï¼Œå¹¶æŒæ¡ K8s çš„æ ¸å¿ƒæ¦‚å¿µå’Œæœ€ä½³å®è·µã€‚</p>
        
        <p><strong>ğŸ¯ ä»Šæ—¥ç›®æ ‡</strong></p>
        <ul>
            <li>ç¼–å†™ Kubernetes Deployment æ¸…å•</li>
            <li>é…ç½® Service å’Œ Ingress èµ„æº</li>
            <li>å®ç°å¥åº·æ£€æŸ¥å’Œèµ„æºé™åˆ¶</li>
            <li>è®¾ç½®ç¯å¢ƒå˜é‡å’Œé…ç½®ç®¡ç†</li>
            <li>æŒæ¡ K8s éƒ¨ç½²å’Œç®¡ç†å‘½ä»¤</li>
        </ul>

        <p>ğŸ”— <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>

        <p><strong>æ­¥éª¤ 1: Kubernetes é¡¹ç›®ç»“æ„</strong></p>
        <pre>ğŸ“ å®Œæ•´ K8s é¡¹ç›®ç»“æ„ï¼š
day22_kubernetes_websocket/
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ namespace.yaml
â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”œâ”€â”€ service.yaml
â”‚   â”œâ”€â”€ ingress.yaml
â”‚   â”œâ”€â”€ configmap.yaml
â”‚   â”œâ”€â”€ secret.yaml
â”‚   â”œâ”€â”€ hpa.yaml
â”‚   â”œâ”€â”€ networkpolicy.yaml
â”‚   â””â”€â”€ rbac.yaml
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ deploy.sh
â”‚   â”œâ”€â”€ undeploy.sh
â”‚   â”œâ”€â”€ update.sh
â”‚   â””â”€â”€ monitor.sh
â”œâ”€â”€ monitoring/
â”‚   â”œâ”€â”€ servicemonitor.yaml
â”‚   â””â”€â”€ grafana-dashboard.json
â”œâ”€â”€ docker/
â”‚   â””â”€â”€ Dockerfile
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ server.rs
â”‚   â””â”€â”€ config.rs
â””â”€â”€ README.md</pre>

        <p><strong>æ­¥éª¤ 2: å‘½åç©ºé—´é…ç½® (k8s/namespace.yaml)</strong></p>
        <pre>apiVersion: v1
kind: Namespace
metadata:
  name: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/component: namespace
    environment: production
  annotations:
    description: "WebSocket æœåŠ¡åº”ç”¨å‘½åç©ºé—´"
    contact: "your-team@example.com"
---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: websocket-quota
  namespace: websocket-app
spec:
  hard:
    requests.cpu: "2"
    requests.memory: 4Gi
    limits.cpu: "4"
    limits.memory: 8Gi
    pods: "10"
    services: "5"
    persistentvolumeclaims: "2"
---
apiVersion: v1
kind: LimitRange
metadata:
  name: websocket-limits
  namespace: websocket-app
spec:
  limits:
  - default:
      cpu: "500m"
      memory: "512Mi"
    defaultRequest:
      cpu: "100m"
      memory: "128Mi"
    type: Container</pre>

        <p><strong>æ­¥éª¤ 3: ConfigMap é…ç½® (k8s/configmap.yaml)</strong></p>
        <pre>apiVersion: v1
kind: ConfigMap
metadata:
  name: websocket-config
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: config
data:
  # åº”ç”¨é…ç½®
  RUST_LOG: "info"
  LOG_LEVEL: "info"
  MAX_CONNECTIONS: "2000"
  CHANNEL_CAPACITY: "2000"
  ENABLE_METRICS: "true"
  APP_ENV: "production"
  BIND_ADDR: "0.0.0.0:3000"
  
  # æœåŠ¡å™¨é…ç½®
  server.toml: |
    [server]
    bind_addr = "0.0.0.0:3000"
    max_connections = 2000
    channel_capacity = 2000
    
    [logging]
    level = "info"
    format = "json"
    enable_file_logging = true
    
    [metrics]
    enabled = true
    port = 9090
    
    [health]
    endpoint = "/health"
    check_interval = "30s"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: nginx
    app.kubernetes.io/component: config
data:
  nginx.conf: |
    events {
        worker_connections 1024;
    }
    
    http {
        upstream websocket_backend {
            server websocket-service:3000;
        }
        
        map $http_upgrade $connection_upgrade {
            default upgrade;
            '' close;
        }
        
        server {
            listen 80;
            server_name _;
            
            # WebSocket ä»£ç†
            location /ws {
                proxy_pass http://websocket_backend;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection $connection_upgrade;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                
                proxy_connect_timeout 60s;
                proxy_send_timeout 60s;
                proxy_read_timeout 60s;
            }
            
            # HTTP ä»£ç†
            location / {
                proxy_pass http://websocket_backend;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
            
            # å¥åº·æ£€æŸ¥
            location /nginx-health {
                access_log off;
                return 200 "healthy\n";
                add_header Content-Type text/plain;
            }
        }
    }</pre>

        <p><strong>æ­¥éª¤ 4: Secret é…ç½® (k8s/secret.yaml)</strong></p>
        <pre>apiVersion: v1
kind: Secret
metadata:
  name: websocket-secrets
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: secret
type: Opaque
data:
  # Base64 ç¼–ç çš„å¯†é’¥ (echo -n 'your-secret-key' | base64)
  JWT_SECRET: eW91ci1zZWNyZXQta2V5
  DATABASE_URL: cG9zdGdyZXNxbDovL3VzZXI6cGFzc0Bsb2NhbGhvc3QvZGI=
  REDIS_URL: cmVkaXM6Ly9sb2NhbGhvc3Q6NjM3OS8w
---
apiVersion: v1
kind: Secret
metadata:
  name: tls-secret
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: tls
type: kubernetes.io/tls
data:
  # ä½¿ç”¨ openssl ç”Ÿæˆçš„è¯ä¹¦ (base64 ç¼–ç )
  tls.crt: LS0tLS1CRUdJTi...
  tls.key: LS0tLS1CRUdJTi...</pre>

        <p><strong>æ­¥éª¤ 5: Deployment é…ç½® (k8s/deployment.yaml)</strong></p>
        <pre>apiVersion: apps/v1
kind: Deployment
metadata:
  name: websocket-server
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/component: server
    app.kubernetes.io/part-of: websocket-app
    environment: production
  annotations:
    deployment.kubernetes.io/revision: "1"
    description: "WebSocket æœåŠ¡å™¨éƒ¨ç½²"
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app.kubernetes.io/name: websocket-server
      app.kubernetes.io/component: server
  template:
    metadata:
      labels:
        app.kubernetes.io/name: websocket-server
        app.kubernetes.io/version: "1.0.0"
        app.kubernetes.io/component: server
        app.kubernetes.io/part-of: websocket-app
        environment: production
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "3000"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: websocket-service-account
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        runAsGroup: 1001
        fsGroup: 1001
      containers:
      - name: websocket-server
        image: websocket-docker:latest
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 3000
          protocol: TCP
        env:
        # ConfigMap ç¯å¢ƒå˜é‡
        - name: RUST_LOG
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: RUST_LOG
        - name: LOG_LEVEL
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: LOG_LEVEL
        - name: MAX_CONNECTIONS
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: MAX_CONNECTIONS
        - name: CHANNEL_CAPACITY
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: CHANNEL_CAPACITY
        - name: ENABLE_METRICS
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: ENABLE_METRICS
        - name: APP_ENV
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: APP_ENV
        - name: BIND_ADDR
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: BIND_ADDR
        # Secret ç¯å¢ƒå˜é‡
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: websocket-secrets
              key: JWT_SECRET
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: websocket-secrets
              key: DATABASE_URL
              optional: true
        # Pod ä¿¡æ¯
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: http
            scheme: HTTP
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: http
            scheme: HTTP
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          successThreshold: 1
          failureThreshold: 2
        startupProbe:
          httpGet:
            path: /health
            port: http
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 30
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
          readOnly: true
        - name: logs-volume
          mountPath: /app/logs
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: false
          capabilities:
            drop:
            - ALL
      - name: nginx-sidecar
        image: nginx:alpine
        ports:
        - name: nginx-http
          containerPort: 80
          protocol: TCP
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi
        livenessProbe:
          httpGet:
            path: /nginx-health
            port: nginx-http
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /nginx-health
            port: nginx-http
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
          readOnly: true
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
            add:
            - CHOWN
            - SETUID
            - SETGID
      volumes:
      - name: config-volume
        configMap:
          name: websocket-config
          items:
          - key: server.toml
            path: server.toml
      - name: nginx-config
        configMap:
          name: nginx-config
      - name: logs-volume
        emptyDir: {}
      terminationGracePeriodSeconds: 30
      restartPolicy: Always
      dnsPolicy: ClusterFirst</pre>

        <p><strong>æ­¥éª¤ 6: Service é…ç½® (k8s/service.yaml)</strong></p>
        <pre>apiVersion: v1
kind: Service
metadata:
  name: websocket-service
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: nlb
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp
spec:
  type: ClusterIP
  selector:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: server
  ports:
  - name: http
    port: 3000
    targetPort: http
    protocol: TCP
  - name: nginx
    port: 80
    targetPort: nginx-http
    protocol: TCP
  sessionAffinity: None
---
apiVersion: v1
kind: Service
metadata:
  name: websocket-headless
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: headless-service
spec:
  type: ClusterIP
  clusterIP: None
  selector:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: server
  ports:
  - name: http
    port: 3000
    targetPort: http
    protocol: TCP
---
apiVersion: v1
kind: Service
metadata:
  name: websocket-nodeport
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: nodeport-service
spec:
  type: NodePort
  selector:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: server
  ports:
  - name: http
    port: 3000
    targetPort: http
    protocol: TCP
    nodePort: 30000
  - name: nginx
    port: 80
    targetPort: nginx-http
    protocol: TCP
    nodePort: 30080</pre>

        <p><strong>æ­¥éª¤ 7: Ingress é…ç½® (k8s/ingress.yaml)</strong></p>
        <pre>apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: websocket-ingress
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    
    # WebSocket æ”¯æŒ
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/websocket-services: websocket-service
    
    # ä¼šè¯äº²å’Œæ€§
    nginx.ingress.kubernetes.io/affinity: cookie
    nginx.ingress.kubernetes.io/affinity-mode: persistent
    nginx.ingress.kubernetes.io/session-cookie-name: "websocket-server"
    nginx.ingress.kubernetes.io/session-cookie-expires: "86400"
    nginx.ingress.kubernetes.io/session-cookie-max-age: "86400"
    
    # é€Ÿç‡é™åˆ¶
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    
    # CORS
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-origin: "*"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization"
spec:
  tls:
  - hosts:
    - websocket.example.com
    - api.websocket.example.com
    secretName: tls-secret
  rules:
  - host: websocket.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: websocket-service
            port:
              number: 80
      - path: /ws
        pathType: Prefix
        backend:
          service:
            name: websocket-service
            port:
              number: 3000
  - host: api.websocket.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: websocket-service
            port:
              number: 3000
---
# å¤‡ç”¨ Ingressï¼ˆç”¨äºå†…éƒ¨è®¿é—®ï¼‰
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: websocket-internal-ingress
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: internal-ingress
  annotations:
    kubernetes.io/ingress.class: nginx-internal
    nginx.ingress.kubernetes.io/whitelist-source-range: "10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
spec:
  rules:
  - host: websocket-internal.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: websocket-service
            port:
              number: 3000</pre>

        <p><strong>æ­¥éª¤ 8: HPA è‡ªåŠ¨ä¼¸ç¼© (k8s/hpa.yaml)</strong></p>
        <pre>apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: websocket-hpa
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: websocket-server
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: websocket_active_connections
      target:
        type: AverageValue
        averageValue: "500"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
      - type: Pods
        value: 2
        periodSeconds: 60
      selectPolicy: Max</pre>

        <p><strong>æ­¥éª¤ 9: RBAC æƒé™é…ç½® (k8s/rbac.yaml)</strong></p>
        <pre>apiVersion: v1
kind: ServiceAccount
metadata:
  name: websocket-service-account
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: serviceaccount
automountServiceAccountToken: true
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: websocket-role
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: role
rules:
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: websocket-rolebinding
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: rolebinding
subjects:
- kind: ServiceAccount
  name: websocket-service-account
  namespace: websocket-app
roleRef:
  kind: Role
  name: websocket-role
  apiGroup: rbac.authorization.k8s.io</pre>

        <p><strong>æ­¥éª¤ 10: ç½‘ç»œç­–ç•¥ (k8s/networkpolicy.yaml)</strong></p>
        <pre>apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: websocket-network-policy
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: networkpolicy
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/name: websocket-server
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # å…è®¸æ¥è‡ª Ingress Controller çš„æµé‡
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 3000
    - protocol: TCP
      port: 80
  # å…è®¸æ¥è‡ªåŒå‘½åç©ºé—´çš„æµé‡
  - from:
    - namespaceSelector:
        matchLabels:
          name: websocket-app
    ports:
    - protocol: TCP
      port: 3000
  # å…è®¸æ¥è‡ªç›‘æ§ç³»ç»Ÿçš„æµé‡
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    ports:
    - protocol: TCP
      port: 3000
  egress:
  # å…è®¸ DNS æŸ¥è¯¢
  - to: []
    ports:
    - protocol: UDP
      port: 53
  # å…è®¸è®¿é—®å¤–éƒ¨æ•°æ®åº“ï¼ˆå¦‚æœéœ€è¦ï¼‰
  - to: []
    ports:
    - protocol: TCP
      port: 5432  # PostgreSQL
    - protocol: TCP
      port: 6379  # Redis
  # å…è®¸ HTTPS å‡ºç«™æµé‡
  - to: []
    ports:
    - protocol: TCP
      port: 443</pre>

        <p><strong>æ­¥éª¤ 11: éƒ¨ç½²è„šæœ¬ (scripts/deploy.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}ğŸš€ Kubernetes WebSocket åº”ç”¨éƒ¨ç½²${NC}"

# é…ç½®å‚æ•°
NAMESPACE="websocket-app"
APP_NAME="websocket-server"
IMAGE_TAG="${1:-latest}"
KUBECTL_TIMEOUT="300s"

# æ£€æŸ¥å·¥å…·
check_prerequisites() {
    echo -e "${GREEN}ğŸ” æ£€æŸ¥éƒ¨ç½²å‰ææ¡ä»¶...${NC}"
    
    # æ£€æŸ¥ kubectl
    if ! command -v kubectl > /dev/null 2>&1; then
        echo -e "${RED}âŒ kubectl æœªå®‰è£…${NC}"
        exit 1
    fi
    
    # æ£€æŸ¥é›†ç¾¤è¿æ¥
    if ! kubectl cluster-info > /dev/null 2>&1; then
        echo -e "${RED}âŒ æ— æ³•è¿æ¥åˆ° Kubernetes é›†ç¾¤${NC}"
        exit 1
    fi
    
    # æ£€æŸ¥ Docker é•œåƒ
    if [[ "${Image_TAG}" != "latest" ]] && ! docker images | grep -q "websocket-docker:${IMAGE_TAG}"; then
        echo -e "${YELLOW}âš ï¸  é•œåƒ websocket-docker:${IMAGE_TAG} ä¸å­˜åœ¨æœ¬åœ°${NC}"
        echo "å°†ä½¿ç”¨è¿œç¨‹é•œåƒæˆ–æ„å»ºæ–°é•œåƒ"
    fi
    
    echo "âœ… å‰ææ¡ä»¶æ£€æŸ¥é€šè¿‡"
}

# åˆ›å»ºå‘½åç©ºé—´
create_namespace() {
    echo -e "${GREEN}ğŸ“¦ åˆ›å»ºå‘½åç©ºé—´...${NC}"
    
    if kubectl get namespace "${NAMESPACE}" > /dev/null 2>&1; then
        echo "å‘½åç©ºé—´ ${NAMESPACE} å·²å­˜åœ¨"
    else
        kubectl apply -f k8s/namespace.yaml
        echo "âœ… å‘½åç©ºé—´åˆ›å»ºå®Œæˆ"
    fi
}

# åº”ç”¨ ConfigMap å’Œ Secret
apply_configs() {
    echo -e "${GREEN}âš™ï¸  åº”ç”¨é…ç½®...${NC}"
    
    kubectl apply -f k8s/configmap.yaml
    kubectl apply -f k8s/secret.yaml
    
    echo "âœ… é…ç½®åº”ç”¨å®Œæˆ"
}

# åº”ç”¨ RBAC
apply_rbac() {
    echo -e "${GREEN}ğŸ” åº”ç”¨ RBAC é…ç½®...${NC}"
    
    kubectl apply -f k8s/rbac.yaml
    
    echo "âœ… RBAC é…ç½®å®Œæˆ"
}

# éƒ¨ç½²åº”ç”¨
deploy_application() {
    echo -e "${GREEN}ğŸš€ éƒ¨ç½²åº”ç”¨...${NC}"
    
    # æ›´æ–°é•œåƒæ ‡ç­¾ï¼ˆå¦‚æœæŒ‡å®šäº†ï¼‰
    if [[ "${IMAGE_TAG}" != "latest" ]]; then
        sed -i.bak "s|websocket-docker:latest|websocket-docker:${IMAGE_TAG}|g" k8s/deployment.yaml
    fi
    
    kubectl apply -f k8s/deployment.yaml
    kubectl apply -f k8s/service.yaml
    
    # ç­‰å¾…éƒ¨ç½²å®Œæˆ
    echo "â³ ç­‰å¾…éƒ¨ç½²å®Œæˆ..."
    kubectl wait --for=condition=available --timeout="${KUBECTL_TIMEOUT}" \
        deployment/"${APP_NAME}" -n "${NAMESPACE}"
    
    echo "âœ… åº”ç”¨éƒ¨ç½²å®Œæˆ"
    
    # æ¢å¤åŸå§‹æ–‡ä»¶ï¼ˆå¦‚æœä¿®æ”¹äº†ï¼‰
    if [[ -f k8s/deployment.yaml.bak ]]; then
        mv k8s/deployment.yaml.bak k8s/deployment.yaml
    fi
}

# åº”ç”¨ Ingress
apply_ingress() {
    echo -e "${GREEN}ğŸŒ é…ç½® Ingress...${NC}"
    
    # æ£€æŸ¥ Ingress Controller æ˜¯å¦å­˜åœ¨
    if kubectl get ingressclass nginx > /dev/null 2>&1; then
        kubectl apply -f k8s/ingress.yaml
        echo "âœ… Ingress é…ç½®å®Œæˆ"
    else
        echo -e "${YELLOW}âš ï¸  Nginx Ingress Controller æœªå®‰è£…ï¼Œè·³è¿‡ Ingress é…ç½®${NC}"
        echo "å¯ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å®‰è£…:"
        echo "kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml"
    fi
}

# åº”ç”¨ç½‘ç»œç­–ç•¥
apply_network_policy() {
    echo -e "${GREEN}ğŸ”’ åº”ç”¨ç½‘ç»œç­–ç•¥...${NC}"
    
    # æ£€æŸ¥é›†ç¾¤æ˜¯å¦æ”¯æŒç½‘ç»œç­–ç•¥
    if kubectl get crd networkpolicies.networking.k8s.io > /dev/null 2>&1; then
        kubectl apply -f k8s/networkpolicy.yaml
        echo "âœ… ç½‘ç»œç­–ç•¥é…ç½®å®Œæˆ"
    else
        echo -e "${YELLOW}âš ï¸  é›†ç¾¤ä¸æ”¯æŒç½‘ç»œç­–ç•¥ï¼Œè·³è¿‡é…ç½®${NC}"
    fi
}

# åº”ç”¨ HPA
apply_hpa() {
    echo -e "${GREEN}ğŸ“ˆ é…ç½®è‡ªåŠ¨ä¼¸ç¼©...${NC}"
    
    # æ£€æŸ¥ Metrics Server
    if kubectl get deployment metrics-server -n kube-system > /dev/null 2>&1; then
        kubectl apply -f k8s/hpa.yaml
        echo "âœ… HPA é…ç½®å®Œæˆ"
    else
        echo -e "${YELLOW}âš ï¸  Metrics Server æœªå®‰è£…ï¼Œè·³è¿‡ HPA é…ç½®${NC}"
        echo "å¯ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å®‰è£…:"
        echo "kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml"
    fi
}

# éªŒè¯éƒ¨ç½²
verify_deployment() {
    echo -e "${GREEN}ğŸ” éªŒè¯éƒ¨ç½²çŠ¶æ€...${NC}"
    
    # æ£€æŸ¥ Pod çŠ¶æ€
    echo "Pod çŠ¶æ€:"
    kubectl get pods -n "${NAMESPACE}" -l app.kubernetes.io/name="${APP_NAME}"
    
    # æ£€æŸ¥ Service çŠ¶æ€
    echo -e "\nService çŠ¶æ€:"
    kubectl get services -n "${NAMESPACE}"
    
    # æ£€æŸ¥ Ingress çŠ¶æ€
    echo -e "\nIngress çŠ¶æ€:"
    kubectl get ingress -n "${NAMESPACE}" 2>/dev/null || echo "æ—  Ingress é…ç½®"
    
    # æ£€æŸ¥ HPA çŠ¶æ€
    echo -e "\nHPA çŠ¶æ€:"
    kubectl get hpa -n "${NAMESPACE}" 2>/dev/null || echo "æ—  HPA é…ç½®"
    
    # è·å–è®¿é—®ä¿¡æ¯
    echo -e "\n${BLUE}ğŸŒ è®¿é—®ä¿¡æ¯:${NC}"
    
    # NodePort è®¿é—®
    NODEPORT=$(kubectl get service websocket-nodeport -n "${NAMESPACE}" -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "N/A")
    if [[ "${NODEPORT}" != "N/A" ]]; then
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null || \
                 kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
        echo "NodePort è®¿é—®: http://${NODE_IP}:${NODEPORT}"
    fi
    
    # Ingress è®¿é—®
    INGRESS_IP=$(kubectl get ingress websocket-ingress -n "${NAMESPACE}" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
    if [[ -n "${INGRESS_IP}" ]]; then
        echo "Ingress è®¿é—®: http://${INGRESS_IP}"
    fi
    
    # ç«¯å£è½¬å‘è®¿é—®
    echo -e "\n${YELLOW}ğŸ’¡ ä¸´æ—¶è®¿é—®å‘½ä»¤:${NC}"
    echo "kubectl port-forward -n ${NAMESPACE} service/websocket-service 8080:3000"
    echo "ç„¶åè®¿é—®: http://localhost:8080"
}

# å¥åº·æ£€æŸ¥
health_check() {
    echo -e "${GREEN}ğŸ¥ æ‰§è¡Œå¥åº·æ£€æŸ¥...${NC}"
    
    # ç«¯å£è½¬å‘è¿›è¡Œå¥åº·æ£€æŸ¥
    kubectl port-forward -n "${NAMESPACE}" service/websocket-service 8080:3000 > /dev/null 2>&1 &
    PORT_FORWARD_PID=$!
    
    sleep 3
    
    if curl -f -s http://localhost:8080/health > /dev/null 2>&1; then
        echo "âœ… å¥åº·æ£€æŸ¥é€šè¿‡"
    else
        echo -e "${YELLOW}âš ï¸  å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ Pod æ—¥å¿—${NC}"
    fi
    
    # æ¸…ç†ç«¯å£è½¬å‘
    kill $PORT_FORWARD_PID 2>/dev/null || true
}

# æ˜¾ç¤ºæœ‰ç”¨çš„å‘½ä»¤
show_useful_commands() {
    echo -e "\n${BLUE}ğŸ“‹ æœ‰ç”¨çš„ç®¡ç†å‘½ä»¤:${NC}"
    
    cat << EOF
# æŸ¥çœ‹ Pod æ—¥å¿—
kubectl logs -f deployment/${APP_NAME} -n ${NAMESPACE}

# æŸ¥çœ‹æ‰€æœ‰èµ„æº
kubectl get all -n ${NAMESPACE}

# æè¿°éƒ¨ç½²çŠ¶æ€
kubectl describe deployment ${APP_NAME} -n ${NAMESPACE}

# æ‰©ç¼©å®¹
kubectl scale deployment ${APP_NAME} --replicas=5 -n ${NAMESPACE}

# æŸ¥çœ‹äº‹ä»¶
kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp'

# è¿›å…¥ Pod
kubectl exec -it deployment/${APP_NAME} -n ${NAMESPACE} -- /bin/sh

# ç«¯å£è½¬å‘
kubectl port-forward -n ${NAMESPACE} service/websocket-service 8080:3000

# æŸ¥çœ‹èµ„æºä½¿ç”¨
kubectl top pods -n ${NAMESPACE}

# åˆ é™¤éƒ¨ç½²
kubectl delete -f k8s/ --ignore-not-found=true
EOF
}

# ä¸»å‡½æ•°
main() {
    echo -e "${BLUE}å¼€å§‹ Kubernetes éƒ¨ç½²æµç¨‹${NC}"
    
    check_prerequisites
    create_namespace
    apply_configs
    apply_rbac
    deploy_application
    apply_ingress
    apply_network_policy
    apply_hpa
    verify_deployment
    health_check
    show_useful_commands
    
    echo -e "\n${GREEN}ğŸ‰ Kubernetes éƒ¨ç½²å®Œæˆï¼${NC}"
}

# é”™è¯¯å¤„ç†
cleanup_on_error() {
    echo -e "${RED}âŒ éƒ¨ç½²è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯${NC}"
    echo "æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯:"
    kubectl get events -n "${NAMESPACE}" --sort-by='.lastTimestamp' | tail -10
}

trap cleanup_on_error ERR

# æ‰§è¡Œä¸»å‡½æ•°
main "$@"</pre>

        <p><strong>æ­¥éª¤ 12: éƒ¨ç½²å’Œç®¡ç†</strong></p>
        <pre># 1. å‡†å¤‡éƒ¨ç½²ç¯å¢ƒ
chmod +x scripts/*.sh

# 2. æ£€æŸ¥ Kubernetes é›†ç¾¤
kubectl cluster-info
kubectl get nodes

# 3. æ„å»ºå’Œæ¨é€é•œåƒï¼ˆå¦‚æœéœ€è¦ï¼‰
docker build -t websocket-docker:v1.0.0 -f docker/Dockerfile .
docker tag websocket-docker:v1.0.0 your-registry/websocket-docker:v1.0.0
docker push your-registry/websocket-docker:v1.0.0

# 4. æ‰§è¡Œéƒ¨ç½²
./scripts/deploy.sh v1.0.0

# 5. éªŒè¯éƒ¨ç½²
kubectl get all -n websocket-app
kubectl get pods -n websocket-app -w

# 6. æµ‹è¯•æœåŠ¡
kubectl port-forward -n websocket-app service/websocket-service 8080:3000 &
curl http://localhost:8080/health
curl http://localhost:8080/metrics

# 7. æŸ¥çœ‹æ—¥å¿—
kubectl logs -f deployment/websocket-server -n websocket-app

# 8. æ‰©ç¼©å®¹æµ‹è¯•
kubectl scale deployment websocket-server --replicas=5 -n websocket-app
kubectl get hpa -n websocket-app -w

# 9. æ»šåŠ¨æ›´æ–°
kubectl set image deployment/websocket-server websocket-server=websocket-docker:v1.0.1 -n websocket-app
kubectl rollout status deployment/websocket-server -n websocket-app

# 10. æ•…éšœæ’æŸ¥
kubectl describe pod <pod-name> -n websocket-app
kubectl get events -n websocket-app --sort-by='.lastTimestamp'</pre>

        <p><strong>ğŸ¯ ä»Šæ—¥æ”¶è·</strong></p>
        <ul>
            <li>âœ… ç¼–å†™äº†å®Œæ•´çš„ Kubernetes éƒ¨ç½²æ¸…å•</li>
            <li>âœ… é…ç½®äº† Deploymentã€Serviceã€Ingress ç­‰æ ¸å¿ƒèµ„æº</li>
            <li>âœ… å®ç°äº†å¥åº·æ£€æŸ¥ã€èµ„æºé™åˆ¶å’Œè‡ªåŠ¨ä¼¸ç¼©</li>
            <li>âœ… è®¾ç½®äº† RBACã€ç½‘ç»œç­–ç•¥ç­‰å®‰å…¨é…ç½®</li>
            <li>âœ… åˆ›å»ºäº†è‡ªåŠ¨åŒ–éƒ¨ç½²å’Œç®¡ç†è„šæœ¬</li>
            <li>âœ… æŒæ¡äº† K8s åº”ç”¨çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸç®¡ç†</li>
            <li>âœ… ç†è§£äº†äº‘åŸç”Ÿåº”ç”¨çš„éƒ¨ç½²æœ€ä½³å®è·µ</li>
        </ul>

        <p><strong>ğŸ’¡ æ‰©å±•ç»ƒä¹ </strong></p>
        <ul>
            <li>é…ç½® PersistentVolume æŒä¹…åŒ–å­˜å‚¨</li>
            <li>å®ç°å¤šç¯å¢ƒé…ç½®ç®¡ç†</li>
            <li>æ·»åŠ  Prometheus ServiceMonitor</li>
            <li>é…ç½® Pod åäº²å’Œæ€§è§„åˆ™</li>
        </ul>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-23</strong></p>
        <h2>Day 23 - ConfigMap åŠ¨æ€é…ç½®ç®¡ç†</h2>
        <p>ä»Šå¤©ä½ å°†æ·±å…¥å­¦ä¹  Kubernetes ConfigMap çš„é«˜çº§ç”¨æ³•ï¼Œå®ç°åº”ç”¨é…ç½®çš„åŠ¨æ€ç®¡ç†å’Œçƒ­æ›´æ–°ã€‚ä½ å°†å­¦ä¼šåˆ›å»ºå¤šç¯å¢ƒé…ç½®ã€é…ç½®æ–‡ä»¶çƒ­é‡è½½ã€ä»¥åŠé…ç½®å˜æ›´çš„è‡ªåŠ¨åŒ–ç®¡ç†ã€‚</p>
        
        <p><strong>ğŸ¯ ä»Šæ—¥ç›®æ ‡</strong></p>
        <ul>
            <li>æŒæ¡ ConfigMap çš„åˆ›å»ºå’Œç®¡ç†æ–¹æ³•</li>
            <li>å®ç°é…ç½®æ–‡ä»¶çš„çƒ­é‡è½½æœºåˆ¶</li>
            <li>é…ç½®å¤šç¯å¢ƒå‚æ•°ç®¡ç†</li>
            <li>å®ç°é…ç½®å˜æ›´çš„è‡ªåŠ¨åŒ–éƒ¨ç½²</li>
            <li>å­¦ä¹ é…ç½®å®‰å…¨å’Œç‰ˆæœ¬æ§åˆ¶</li>
        </ul>

        <p>ğŸ”— <a href="https://kubernetes.io/docs/concepts/configuration/configmap/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>

        <p><strong>æ­¥éª¤ 1: åŠ¨æ€é…ç½®é¡¹ç›®ç»“æ„</strong></p>
        <pre>ğŸ“ é…ç½®ç®¡ç†é¡¹ç›®ç»“æ„ï¼š
day23_configmap_management/
â”œâ”€â”€ configs/
â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”œâ”€â”€ app-config.yaml
â”‚   â”‚   â”œâ”€â”€ nginx.conf
â”‚   â”‚   â””â”€â”€ logging.toml
â”‚   â”œâ”€â”€ environments/
â”‚   â”‚   â”œâ”€â”€ dev/
â”‚   â”‚   â”‚   â”œâ”€â”€ app-config.yaml
â”‚   â”‚   â”‚   â””â”€â”€ overrides.env
â”‚   â”‚   â”œâ”€â”€ staging/
â”‚   â”‚   â”‚   â”œâ”€â”€ app-config.yaml
â”‚   â”‚   â”‚   â””â”€â”€ overrides.env
â”‚   â”‚   â””â”€â”€ prod/
â”‚   â”‚       â”œâ”€â”€ app-config.yaml
â”‚   â”‚       â””â”€â”€ overrides.env
â”‚   â””â”€â”€ secrets/
â”‚       â”œâ”€â”€ dev-secrets.yaml
â”‚       â”œâ”€â”€ staging-secrets.yaml
â”‚       â””â”€â”€ prod-secrets.yaml
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”œâ”€â”€ configmap.yaml
â”‚   â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”‚   â””â”€â”€ service.yaml
â”‚   â”œâ”€â”€ overlays/
â”‚   â”‚   â”œâ”€â”€ dev/
â”‚   â”‚   â”œâ”€â”€ staging/
â”‚   â”‚   â””â”€â”€ prod/
â”‚   â””â”€â”€ configmap-watcher.yaml
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ update-config.sh
â”‚   â”œâ”€â”€ deploy-config.sh
â”‚   â”œâ”€â”€ validate-config.sh
â”‚   â””â”€â”€ watch-config.sh
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ config.rs
â”‚   â”œâ”€â”€ watcher.rs
â”‚   â””â”€â”€ reload.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ README.md</pre>

        <p><strong>æ­¥éª¤ 2: å¢å¼ºçš„é…ç½®ç®¡ç† (src/config.rs)</strong></p>
        <pre>use clap::Parser;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, fs, net::SocketAddr, path::Path, sync::Arc, time::Duration};
use tokio::sync::RwLock;
use tracing::{error, info, warn};

#[derive(Parser, Debug, Clone)]
#[command(name = "websocket-server")]
pub struct Config {
    #[arg(long, env = "CONFIG_FILE", default_value = "/app/config/app-config.yaml")]
    pub config_file: String,
    
    #[arg(long, env = "WATCH_CONFIG", default_value = "true")]
    pub watch_config: bool,
    
    #[arg(long, env = "RELOAD_INTERVAL", default_value = "30")]
    pub reload_interval: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub server: ServerConfig,
    pub logging: LoggingConfig,
    pub metrics: MetricsConfig,
    pub websocket: WebSocketConfig,
    pub features: FeatureFlags,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub bind_addr: SocketAddr,
    pub max_connections: usize,
    pub read_timeout: u64,
    pub write_timeout: u64,
    pub idle_timeout: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoggingConfig {
    pub level: String,
    pub format: String,
    pub enable_file_logging: bool,
    pub file_path: Option<String>,
    pub rotation: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricsConfig {
    pub enabled: bool,
    pub bind_addr: SocketAddr,
    pub path: String,
    pub namespace: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebSocketConfig {
    pub channel_capacity: usize,
    pub message_size_limit: usize,
    pub ping_interval: u64,
    pub pong_timeout: u64,
    pub close_timeout: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FeatureFlags {
    pub enable_auth: bool,
    pub enable_rate_limiting: bool,
    pub enable_metrics: bool,
    pub enable_tracing: bool,
    pub debug_mode: bool,
}

impl Default for AppConfig {
    fn default() -> Self {
        Self {
            server: ServerConfig {
                bind_addr: "0.0.0.0:3000".parse().unwrap(),
                max_connections: 1000,
                read_timeout: 30,
                write_timeout: 30,
                idle_timeout: 300,
            },
            logging: LoggingConfig {
                level: "info".to_string(),
                format: "json".to_string(),
                enable_file_logging: true,
                file_path: Some("/app/logs/app.log".to_string()),
                rotation: "daily".to_string(),
            },
            metrics: MetricsConfig {
                enabled: true,
                bind_addr: "0.0.0.0:9090".parse().unwrap(),
                path: "/metrics".to_string(),
                namespace: "websocket".to_string(),
            },
            websocket: WebSocketConfig {
                channel_capacity: 1000,
                message_size_limit: 64 * 1024, // 64KB
                ping_interval: 30,
                pong_timeout: 10,
                close_timeout: 5,
            },
            features: FeatureFlags {
                enable_auth: true,
                enable_rate_limiting: true,
                enable_metrics: true,
                enable_tracing: true,
                debug_mode: false,
            },
        }
    }
}

pub struct ConfigManager {
    config: Arc<RwLock<AppConfig>>,
    config_file: String,
    reload_callbacks: Vec<Box<dyn Fn(&AppConfig) + Send + Sync>>,
}

impl ConfigManager {
    pub fn new(config_file: String) -> anyhow::Result<Self> {
        let config = Self::load_config(&config_file)?;
        
        Ok(Self {
            config: Arc::new(RwLock::new(config)),
            config_file,
            reload_callbacks: Vec::new(),
        })
    }
    
    pub async fn get_config(&self) -> AppConfig {
        self.config.read().await.clone()
    }
    
    pub fn load_config(config_file: &str) -> anyhow::Result<AppConfig> {
        if !Path::new(config_file).exists() {
            warn!("é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {}, ä½¿ç”¨é»˜è®¤é…ç½®", config_file);
            return Ok(AppConfig::default());
        }
        
        let content = fs::read_to_string(config_file)?;
        let mut config: AppConfig = serde_yaml::from_str(&content)?;
        
        // ä»ç¯å¢ƒå˜é‡è¦†ç›–é…ç½®
        Self::override_from_env(&mut config);
        
        info!("é…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸ: {}", config_file);
        Ok(config)
    }
    
    fn override_from_env(config: &mut AppConfig) {
        // æœåŠ¡å™¨é…ç½®
        if let Ok(addr) = std::env::var("BIND_ADDR") {
            if let Ok(socket_addr) = addr.parse() {
                config.server.bind_addr = socket_addr;
            }
        }
        
        if let Ok(max_conn) = std::env::var("MAX_CONNECTIONS") {
            if let Ok(value) = max_conn.parse() {
                config.server.max_connections = value;
            }
        }
        
        // æ—¥å¿—é…ç½®
        if let Ok(level) = std::env::var("LOG_LEVEL") {
            config.logging.level = level;
        }
        
        if let Ok(format) = std::env::var("LOG_FORMAT") {
            config.logging.format = format;
        }
        
        // WebSocket é…ç½®
        if let Ok(capacity) = std::env::var("CHANNEL_CAPACITY") {
            if let Ok(value) = capacity.parse() {
                config.websocket.channel_capacity = value;
            }
        }
        
        // åŠŸèƒ½å¼€å…³
        if let Ok(auth) = std::env::var("ENABLE_AUTH") {
            config.features.enable_auth = auth.parse().unwrap_or(true);
        }
        
        if let Ok(metrics) = std::env::var("ENABLE_METRICS") {
            config.features.enable_metrics = metrics.parse().unwrap_or(true);
        }
        
        if let Ok(debug) = std::env::var("DEBUG_MODE") {
            config.features.debug_mode = debug.parse().unwrap_or(false);
        }
    }
    
    pub async fn reload_config(&self) -> anyhow::Result<bool> {
        let new_config = Self::load_config(&self.config_file)?;
        let mut current_config = self.config.write().await;
        
        // æ£€æŸ¥é…ç½®æ˜¯å¦æœ‰å˜åŒ–
        let config_changed = !self.configs_equal(&*current_config, &new_config);
        
        if config_changed {
            info!("æ£€æµ‹åˆ°é…ç½®å˜åŒ–ï¼Œé‡æ–°åŠ è½½é…ç½®");
            *current_config = new_config.clone();
            
            // æ‰§è¡Œå›è°ƒå‡½æ•°
            for callback in &self.reload_callbacks {
                callback(&new_config);
            }
            
            info!("é…ç½®é‡è½½å®Œæˆ");
        } else {
            info!("é…ç½®æ— å˜åŒ–ï¼Œè·³è¿‡é‡è½½");
        }
        
        Ok(config_changed)
    }
    
    fn configs_equal(&self, a: &AppConfig, b: &AppConfig) -> bool {
        // ç®€å•çš„é…ç½®æ¯”è¾ƒï¼Œå®é™…é¡¹ç›®ä¸­å¯èƒ½éœ€è¦æ›´å¤æ‚çš„æ¯”è¾ƒé€»è¾‘
        serde_json::to_string(a).unwrap() == serde_json::to_string(b).unwrap()
    }
    
    pub fn add_reload_callback<F>(&mut self, callback: F) 
    where
        F: Fn(&AppConfig) + Send + Sync + 'static,
    {
        self.reload_callbacks.push(Box::new(callback));
    }
    
    pub async fn start_config_watcher(&self, interval: Duration) {
        let config_file = self.config_file.clone();
        let config = self.config.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(interval);
            let mut last_modified = None;
            
            loop {
                interval.tick().await;
                
                match fs::metadata(&config_file) {
                    Ok(metadata) => {
                        let modified = metadata.modified().ok();
                        
                        if last_modified.is_none() {
                            last_modified = modified;
                            continue;
                        }
                        
                        if modified != last_modified {
                            info!("æ£€æµ‹åˆ°é…ç½®æ–‡ä»¶å˜åŒ–: {}", config_file);
                            last_modified = modified;
                            
                            match Self::load_config(&config_file) {
                                Ok(new_config) => {
                                    let mut current_config = config.write().await;
                                    *current_config = new_config;
                                    info!("é…ç½®è‡ªåŠ¨é‡è½½å®Œæˆ");
                                }
                                Err(e) => {
                                    error!("é…ç½®é‡è½½å¤±è´¥: {}", e);
                                }
                            }
                        }
                    }
                    Err(e) => {
                        warn!("æ— æ³•è¯»å–é…ç½®æ–‡ä»¶å…ƒæ•°æ®: {}", e);
                    }
                }
            }
        });
    }
}</pre>

        <p><strong>æ­¥éª¤ 3: é…ç½®æ–‡ä»¶ç¤ºä¾‹ (configs/base/app-config.yaml)</strong></p>
        <pre>server:
  bind_addr: "0.0.0.0:3000"
  max_connections: 2000
  read_timeout: 30
  write_timeout: 30
  idle_timeout: 300

logging:
  level: "info"
  format: "json"
  enable_file_logging: true
  file_path: "/app/logs/app.log"
  rotation: "daily"

metrics:
  enabled: true
  bind_addr: "0.0.0.0:9090"
  path: "/metrics"
  namespace: "websocket"

websocket:
  channel_capacity: 2000
  message_size_limit: 65536  # 64KB
  ping_interval: 30
  pong_timeout: 10
  close_timeout: 5

features:
  enable_auth: true
  enable_rate_limiting: true
  enable_metrics: true
  enable_tracing: true
  debug_mode: false</pre>

        <p><strong>æ­¥éª¤ 4: ç¯å¢ƒç‰¹å®šé…ç½® (configs/environments/prod/app-config.yaml)</strong></p>
        <pre>server:
  bind_addr: "0.0.0.0:3000"
  max_connections: 5000
  read_timeout: 60
  write_timeout: 60
  idle_timeout: 600

logging:
  level: "warn"
  format: "json"
  enable_file_logging: true
  file_path: "/app/logs/websocket-prod.log"
  rotation: "hourly"

metrics:
  enabled: true
  bind_addr: "0.0.0.0:9090"
  path: "/metrics"
  namespace: "websocket_prod"

websocket:
  channel_capacity: 5000
  message_size_limit: 131072  # 128KB
  ping_interval: 45
  pong_timeout: 15
  close_timeout: 10

features:
  enable_auth: true
  enable_rate_limiting: true
  enable_metrics: true
  enable_tracing: false
  debug_mode: false</pre>

        <p><strong>æ­¥éª¤ 5: å¤šç¯å¢ƒ ConfigMap (k8s/base/configmap.yaml)</strong></p>
        <pre>apiVersion: v1
kind: ConfigMap
metadata:
  name: websocket-base-config
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: config
    config.kubernetes.io/type: base
data:
  app-config.yaml: |
    server:
      bind_addr: "0.0.0.0:3000"
      max_connections: 2000
      read_timeout: 30
      write_timeout: 30
      idle_timeout: 300
    
    logging:
      level: "info"
      format: "json"
      enable_file_logging: true
      file_path: "/app/logs/app.log"
      rotation: "daily"
    
    metrics:
      enabled: true
      bind_addr: "0.0.0.0:9090"
      path: "/metrics"
      namespace: "websocket"
    
    websocket:
      channel_capacity: 2000
      message_size_limit: 65536
      ping_interval: 30
      pong_timeout: 10
      close_timeout: 5
    
    features:
      enable_auth: true
      enable_rate_limiting: true
      enable_metrics: true
      enable_tracing: true
      debug_mode: false

  nginx.conf: |
    events {
        worker_connections 1024;
    }
    
    http {
        include /etc/nginx/mime.types;
        default_type application/octet-stream;
        
        # æ—¥å¿—æ ¼å¼
        log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                       '$status $body_bytes_sent "$http_referer" '
                       '"$http_user_agent" "$http_x_forwarded_for"';
        
        access_log /var/log/nginx/access.log main;
        error_log /var/log/nginx/error.log warn;
        
        # æ€§èƒ½ä¼˜åŒ–
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 65;
        types_hash_max_size 2048;
        
        # Gzip å‹ç¼©
        gzip on;
        gzip_vary on;
        gzip_min_length 1024;
        gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
        
        upstream websocket_backend {
            server localhost:3000;
            keepalive 32;
        }
        
        map $http_upgrade $connection_upgrade {
            default upgrade;
            '' close;
        }
        
        server {
            listen 80;
            server_name _;
            
            # å¥åº·æ£€æŸ¥
            location /nginx-health {
                access_log off;
                return 200 "healthy\n";
                add_header Content-Type text/plain;
            }
            
            # WebSocket å‡çº§
            location /ws {
                proxy_pass http://websocket_backend;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection $connection_upgrade;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                
                # WebSocket ç‰¹å®šè®¾ç½®
                proxy_connect_timeout 60s;
                proxy_send_timeout 60s;
                proxy_read_timeout 60s;
                proxy_buffering off;
            }
            
            # HTTP API
            location / {
                proxy_pass http://websocket_backend;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                
                # ç¼“å­˜è®¾ç½®
                proxy_cache_bypass $http_upgrade;
                proxy_no_cache $http_upgrade;
            }
        }
    }

  logging.toml: |
    [appenders.stdout]
    kind = "console"
    
    [appenders.file]
    kind = "rolling_file"
    path = "/app/logs/app.log"
    
    [appenders.file.policy]
    kind = "time"
    pattern = "%Y%m%d"
    
    [loggers.websocket]
    level = "info"
    appenders = ["stdout", "file"]
    additive = false
    
    [root]
    level = "info"
    appenders = ["stdout"]

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: websocket-env-config
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: env-config
data:
  # åŸºç¡€ç¯å¢ƒå˜é‡
  RUST_LOG: "info"
  LOG_LEVEL: "info"
  LOG_FORMAT: "json"
  ENABLE_METRICS: "true"
  ENABLE_AUTH: "true"
  DEBUG_MODE: "false"
  
  # æœåŠ¡å™¨é…ç½®
  BIND_ADDR: "0.0.0.0:3000"
  MAX_CONNECTIONS: "2000"
  READ_TIMEOUT: "30"
  WRITE_TIMEOUT: "30"
  IDLE_TIMEOUT: "300"
  
  # WebSocket é…ç½®
  CHANNEL_CAPACITY: "2000"
  MESSAGE_SIZE_LIMIT: "65536"
  PING_INTERVAL: "30"
  PONG_TIMEOUT: "10"
  CLOSE_TIMEOUT: "5"
  
  # é…ç½®æ–‡ä»¶è·¯å¾„
  CONFIG_FILE: "/app/config/app-config.yaml"
  WATCH_CONFIG: "true"
  RELOAD_INTERVAL: "30"</pre>

        <p><strong>æ­¥éª¤ 6: é…ç½®æ›´æ–°è„šæœ¬ (scripts/update-config.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}ğŸ”§ ConfigMap åŠ¨æ€æ›´æ–°å·¥å…·${NC}"

# é…ç½®å‚æ•°
NAMESPACE="${NAMESPACE:-websocket-app}"
CONFIG_NAME="${CONFIG_NAME:-websocket-base-config}"
ENV_CONFIG_NAME="${ENV_CONFIG_NAME:-websocket-env-config}"
ENVIRONMENT="${ENVIRONMENT:-dev}"
DRY_RUN="${DRY_RUN:-false}"

# æ˜¾ç¤ºç”¨æ³•
usage() {
    cat << EOF
ç”¨æ³•: $0 [é€‰é¡¹]

é€‰é¡¹:
    -n, --namespace NAMESPACE       Kubernetes å‘½åç©ºé—´ (é»˜è®¤: websocket-app)
    -c, --config CONFIG_NAME        ConfigMap åç§° (é»˜è®¤: websocket-base-config)
    -e, --environment ENVIRONMENT   ç¯å¢ƒåç§° (dev/staging/prod, é»˜è®¤: dev)
    -d, --dry-run                   ä»…æ˜¾ç¤ºå°†è¦æ‰§è¡Œçš„æ“ä½œï¼Œä¸å®é™…æ‰§è¡Œ
    -h, --help                      æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯

ç¤ºä¾‹:
    $0 -e prod                      æ›´æ–°ç”Ÿäº§ç¯å¢ƒé…ç½®
    $0 -n my-app -c my-config       æ›´æ–°æŒ‡å®šå‘½åç©ºé—´å’Œé…ç½®
    $0 -d -e staging                é¢„è§ˆ staging ç¯å¢ƒé…ç½®æ›´æ–°
EOF
}

# è§£æå‘½ä»¤è¡Œå‚æ•°
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -c|--config)
            CONFIG_NAME="$2"
            shift 2
            ;;
        -e|--environment)
            ENVIRONMENT="$2"
            shift 2
            ;;
        -d|--dry-run)
            DRY_RUN="true"
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "æœªçŸ¥é€‰é¡¹: $1"
            usage
            exit 1
            ;;
    esac
done

# éªŒè¯ç¯å¢ƒ
validate_environment() {
    case $ENVIRONMENT in
        dev|staging|prod)
            echo -e "${GREEN}âœ… ç¯å¢ƒéªŒè¯é€šè¿‡: $ENVIRONMENT${NC}"
            ;;
        *)
            echo -e "${RED}âŒ ä¸æ”¯æŒçš„ç¯å¢ƒ: $ENVIRONMENT${NC}"
            echo "æ”¯æŒçš„ç¯å¢ƒ: dev, staging, prod"
            exit 1
            ;;
    esac
}

# æ£€æŸ¥å‰ææ¡ä»¶
check_prerequisites() {
    echo -e "${GREEN}ğŸ” æ£€æŸ¥å‰ææ¡ä»¶...${NC}"
    
    # æ£€æŸ¥ kubectl
    if ! command -v kubectl > /dev/null 2>&1; then
        echo -e "${RED}âŒ kubectl æœªå®‰è£…${NC}"
        exit 1
    fi
    
    # æ£€æŸ¥é›†ç¾¤è¿æ¥
    if ! kubectl cluster-info > /dev/null 2>&1; then
        echo -e "${RED}âŒ æ— æ³•è¿æ¥åˆ° Kubernetes é›†ç¾¤${NC}"
        exit 1
    fi
    
    # æ£€æŸ¥å‘½åç©ºé—´
    if ! kubectl get namespace "$NAMESPACE" > /dev/null 2>&1; then
        echo -e "${RED}âŒ å‘½åç©ºé—´ä¸å­˜åœ¨: $NAMESPACE${NC}"
        exit 1
    fi
    
    # æ£€æŸ¥é…ç½®æ–‡ä»¶
    local config_file="configs/environments/${ENVIRONMENT}/app-config.yaml"
    if [[ ! -f "$config_file" ]]; then
        echo -e "${RED}âŒ é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: $config_file${NC}"
        exit 1
    fi
    
    echo "âœ… å‰ææ¡ä»¶æ£€æŸ¥é€šè¿‡"
}

# éªŒè¯é…ç½®æ–‡ä»¶
validate_config() {
    echo -e "${GREEN}ğŸ” éªŒè¯é…ç½®æ–‡ä»¶...${NC}"
    
    local config_file="configs/environments/${ENVIRONMENT}/app-config.yaml"
    
    # æ£€æŸ¥ YAML è¯­æ³•
    if command -v yq > /dev/null 2>&1; then
        if ! yq eval . "$config_file" > /dev/null 2>&1; then
            echo -e "${RED}âŒ é…ç½®æ–‡ä»¶ YAML è¯­æ³•é”™è¯¯: $config_file${NC}"
            exit 1
        fi
        echo "âœ… YAML è¯­æ³•éªŒè¯é€šè¿‡"
    else
        echo -e "${YELLOW}âš ï¸  yq æœªå®‰è£…ï¼Œè·³è¿‡ YAML è¯­æ³•æ£€æŸ¥${NC}"
    fi
    
    # æ£€æŸ¥å¿…éœ€å­—æ®µ
    local required_fields=(
        ".server.bind_addr"
        ".server.max_connections"
        ".logging.level"
        ".websocket.channel_capacity"
    )
    
    if command -v yq > /dev/null 2>&1; then
        for field in "${required_fields[@]}"; do
            if ! yq eval "$field" "$config_file" > /dev/null 2>&1; then
                echo -e "${RED}âŒ ç¼ºå°‘å¿…éœ€å­—æ®µ: $field${NC}"
                exit 1
            fi
        done
        echo "âœ… å¿…éœ€å­—æ®µéªŒè¯é€šè¿‡"
    fi
}

# åˆ›å»ºæˆ–æ›´æ–° ConfigMap
update_configmap() {
    echo -e "${GREEN}ğŸ”„ æ›´æ–° ConfigMap...${NC}"
    
    local config_file="configs/environments/${ENVIRONMENT}/app-config.yaml"
    local nginx_config="configs/base/nginx.conf"
    local logging_config="configs/base/logging.toml"
    
    # æ„å»º kubectl å‘½ä»¤
    local kubectl_cmd="kubectl create configmap $CONFIG_NAME"
    kubectl_cmd+=" --from-file=app-config.yaml=$config_file"
    
    if [[ -f "$nginx_config" ]]; then
        kubectl_cmd+=" --from-file=nginx.conf=$nginx_config"
    fi
    
    if [[ -f "$logging_config" ]]; then
        kubectl_cmd+=" --from-file=logging.toml=$logging_config"
    fi
    
    kubectl_cmd+=" --namespace=$NAMESPACE"
    kubectl_cmd+=" --dry-run=client -o yaml"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${BLUE}ğŸ“‹ å°†è¦æ‰§è¡Œçš„æ“ä½œ (dry-run):${NC}"
        echo "$kubectl_cmd"
        echo ""
        eval "$kubectl_cmd"
    else
        # åº”ç”¨é…ç½®
        eval "$kubectl_cmd" | kubectl apply -f -
        echo "âœ… ConfigMap æ›´æ–°å®Œæˆ"
    fi
}

# æ›´æ–°ç¯å¢ƒå˜é‡ ConfigMap
update_env_configmap() {
    echo -e "${GREEN}ğŸ”„ æ›´æ–°ç¯å¢ƒå˜é‡ ConfigMap...${NC}"
    
    local env_file="configs/environments/${ENVIRONMENT}/overrides.env"
    
    if [[ -f "$env_file" ]]; then
        local kubectl_cmd="kubectl create configmap $ENV_CONFIG_NAME"
        kubectl_cmd+=" --from-env-file=$env_file"
        kubectl_cmd+=" --namespace=$NAMESPACE"
        kubectl_cmd+=" --dry-run=client -o yaml"
        
        if [[ "$DRY_RUN" == "true" ]]; then
            echo -e "${BLUE}ğŸ“‹ ç¯å¢ƒå˜é‡ ConfigMap (dry-run):${NC}"
            eval "$kubectl_cmd"
        else
            eval "$kubectl_cmd" | kubectl apply -f -
            echo "âœ… ç¯å¢ƒå˜é‡ ConfigMap æ›´æ–°å®Œæˆ"
        fi
    else
        echo -e "${YELLOW}âš ï¸  ç¯å¢ƒå˜é‡æ–‡ä»¶ä¸å­˜åœ¨: $env_file${NC}"
    fi
}

# æ»šåŠ¨é‡å¯éƒ¨ç½²
restart_deployment() {
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${BLUE}ğŸ“‹ å°†è¦é‡å¯çš„éƒ¨ç½² (dry-run):${NC}"
        kubectl get deployments -n "$NAMESPACE" -l app.kubernetes.io/name=websocket-server
        return
    fi
    
    echo -e "${GREEN}ğŸ”„ é‡å¯ç›¸å…³éƒ¨ç½²...${NC}"
    
    # æ·»åŠ é…ç½®å˜æ›´æ³¨è§£ä»¥è§¦å‘æ»šåŠ¨æ›´æ–°
    local timestamp=$(date -u +"%Y%m%dT%H%M%SZ")
    
    kubectl patch deployment websocket-server -n "$NAMESPACE" -p \
        "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"config.kubernetes.io/last-updated\":\"$timestamp\"}}}}}"
    
    # ç­‰å¾…éƒ¨ç½²å®Œæˆ
    kubectl rollout status deployment/websocket-server -n "$NAMESPACE" --timeout=300s
    
    echo "âœ… éƒ¨ç½²é‡å¯å®Œæˆ"
}

# éªŒè¯é…ç½®ç”Ÿæ•ˆ
verify_config() {
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${BLUE}ğŸ“‹ é…ç½®éªŒè¯å°†åœ¨å®é™…éƒ¨ç½²åæ‰§è¡Œ${NC}"
        return
    fi
    
    echo -e "${GREEN}ğŸ” éªŒè¯é…ç½®ç”Ÿæ•ˆ...${NC}"
    
    # ç­‰å¾… Pod å°±ç»ª
    sleep 10
    
    # æ£€æŸ¥ Pod çŠ¶æ€
    local pod_name=$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/name=websocket-server -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
    
    if [[ -n "$pod_name" ]]; then
        echo "æ£€æŸ¥ Pod: $pod_name"
        
        # æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦æŒ‚è½½æ­£ç¡®
        if kubectl exec "$pod_name" -n "$NAMESPACE" -- test -f /app/config/app-config.yaml > /dev/null 2>&1; then
            echo "âœ… é…ç½®æ–‡ä»¶æŒ‚è½½æˆåŠŸ"
        else
            echo -e "${YELLOW}âš ï¸  é…ç½®æ–‡ä»¶æŒ‚è½½æ£€æŸ¥å¤±è´¥${NC}"
        fi
        
        # æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
        if kubectl exec "$pod_name" -n "$NAMESPACE" -- wget -q --spider http://localhost:3000/health > /dev/null 2>&1; then
            echo "âœ… æœåŠ¡å¥åº·æ£€æŸ¥é€šè¿‡"
        else
            echo -e "${YELLOW}âš ï¸  æœåŠ¡å¥åº·æ£€æŸ¥å¤±è´¥${NC}"
        fi
    else
        echo -e "${YELLOW}âš ï¸  æœªæ‰¾åˆ°è¿è¡Œä¸­çš„ Pod${NC}"
    fi
}

# æ˜¾ç¤ºé…ç½®å·®å¼‚
show_config_diff() {
    echo -e "${GREEN}ğŸ“Š é…ç½®å˜æ›´å¯¹æ¯”...${NC}"
    
    local current_config="/tmp/current-config.yaml"
    local new_config="configs/environments/${ENVIRONMENT}/app-config.yaml"
    
    # è·å–å½“å‰é…ç½®
    if kubectl get configmap "$CONFIG_NAME" -n "$NAMESPACE" -o jsonpath='{.data.app-config\.yaml}' > "$current_config" 2>/dev/null; then
        echo "å½“å‰é…ç½® vs æ–°é…ç½®:"
        
        if command -v diff > /dev/null 2>&1; then
            diff -u "$current_config" "$new_config" || true
        else
            echo "diff å‘½ä»¤ä¸å¯ç”¨ï¼Œæ— æ³•æ˜¾ç¤ºå·®å¼‚"
        fi
        
        rm -f "$current_config"
    else
        echo "æ— æ³•è·å–å½“å‰é…ç½®ï¼Œå¯èƒ½æ˜¯é¦–æ¬¡éƒ¨ç½²"
    fi
}

# ç”Ÿæˆé…ç½®æŠ¥å‘Š
generate_report() {
    local report_file="config-update-report-$(date +%Y%m%d-%H%M%S).md"
    
    cat > "$report_file" << EOF
# ConfigMap æ›´æ–°æŠ¥å‘Š

**æ›´æ–°æ—¶é—´**: $(date)
**ç¯å¢ƒ**: $ENVIRONMENT
**å‘½åç©ºé—´**: $NAMESPACE
**ConfigMap**: $CONFIG_NAME

## æ›´æ–°å†…å®¹

### é…ç½®æ–‡ä»¶
- åº”ç”¨é…ç½®: configs/environments/${ENVIRONMENT}/app-config.yaml
- Nginx é…ç½®: configs/base/nginx.conf
- æ—¥å¿—é…ç½®: configs/base/logging.toml

### ç¯å¢ƒå˜é‡
$(if [[ -f "configs/environments/${ENVIRONMENT}/overrides.env" ]]; then
    echo "- ç¯å¢ƒå˜é‡è¦†ç›–: configs/environments/${ENVIRONMENT}/overrides.env"
else
    echo "- æ— ç¯å¢ƒå˜é‡è¦†ç›–æ–‡ä»¶"
fi)

## æ‰§è¡Œç»“æœ

$(if [[ "$DRY_RUN" == "true" ]]; then
    echo "âœ… Dry-run æ¨¡å¼ï¼Œæœªå®é™…æ‰§è¡Œæ›´æ–°"
else
    echo "âœ… é…ç½®æ›´æ–°æˆåŠŸå®Œæˆ"
fi)

## éªŒè¯ç»“æœ

$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/name=websocket-server -o wide 2>/dev/null || echo "Pod çŠ¶æ€æ£€æŸ¥å¤±è´¥")

EOF
    
    echo -e "${GREEN}ğŸ“‹ é…ç½®æŠ¥å‘Šå·²ç”Ÿæˆ: $report_file${NC}"
}

# ä¸»å‡½æ•°
main() {
    echo -e "${BLUE}å¼€å§‹ ConfigMap æ›´æ–°æµç¨‹${NC}"
    echo "ç¯å¢ƒ: $ENVIRONMENT"
    echo "å‘½åç©ºé—´: $NAMESPACE"
    echo "ConfigMap: $CONFIG_NAME"
    echo ""
    
    validate_environment
    check_prerequisites
    validate_config
    show_config_diff
    update_configmap
    update_env_configmap
    
    if [[ "$DRY_RUN" != "true" ]]; then
        restart_deployment
        verify_config
    fi
    
    generate_report
    
    echo -e "\n${GREEN}ğŸ‰ ConfigMap æ›´æ–°æµç¨‹å®Œæˆï¼${NC}"
}

# é”™è¯¯å¤„ç†
cleanup_on_error() {
    echo -e "${RED}âŒ æ›´æ–°è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯${NC}"
    echo "è¯·æ£€æŸ¥ä»¥ä¸‹å†…å®¹:"
    echo "1. é…ç½®æ–‡ä»¶è¯­æ³•æ˜¯å¦æ­£ç¡®"
    echo "2. Kubernetes é›†ç¾¤è¿æ¥æ˜¯å¦æ­£å¸¸"
    echo "3. å‘½åç©ºé—´å’Œèµ„æºæ˜¯å¦å­˜åœ¨"
}

trap cleanup_on_error ERR

# æ‰§è¡Œä¸»å‡½æ•°
main "$@"</pre>

        <p><strong>æ­¥éª¤ 7: é…ç½®éªŒè¯è„šæœ¬ (scripts/validate-config.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}ğŸ” é…ç½®æ–‡ä»¶éªŒè¯å·¥å…·${NC}"

# éªŒè¯å•ä¸ªé…ç½®æ–‡ä»¶
validate_config_file() {
    local config_file="$1"
    local env_name="$2"
    
    echo -e "${GREEN}ğŸ“‹ éªŒè¯é…ç½®æ–‡ä»¶: $config_file${NC}"
    
    if [[ ! -f "$config_file" ]]; then
        echo -e "${RED}âŒ é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: $config_file${NC}"
        return 1
    fi
    
    # YAML è¯­æ³•æ£€æŸ¥
    if command -v yq > /dev/null 2>&1; then
        if ! yq eval . "$config_file" > /dev/null 2>&1; then
            echo -e "${RED}âŒ YAML è¯­æ³•é”™è¯¯${NC}"
            return 1
        fi
        echo "âœ… YAML è¯­æ³•æ­£ç¡®"
    else
        echo -e "${YELLOW}âš ï¸  yq æœªå®‰è£…ï¼Œè·³è¿‡ YAML è¯­æ³•æ£€æŸ¥${NC}"
    fi
    
    # å­—æ®µéªŒè¯
    local errors=0
    
    # å¿…éœ€å­—æ®µæ£€æŸ¥
    local required_fields=(
        ".server.bind_addr"
        ".server.max_connections"
        ".logging.level"
        ".websocket.channel_capacity"
        ".features.enable_auth"
    )
    
    for field in "${required_fields[@]}"; do
        if command -v yq > /dev/null 2>&1; then
            if ! yq eval "$field" "$config_file" > /dev/null 2>&1; then
                echo -e "${RED}âŒ ç¼ºå°‘å¿…éœ€å­—æ®µ: $field${NC}"
                ((errors++))
            fi
        fi
    done
    
    # å€¼èŒƒå›´æ£€æŸ¥
    if command -v yq > /dev/null 2>&1; then
        local max_conn=$(yq eval '.server.max_connections' "$config_file" 2>/dev/null)
        if [[ "$max_conn" =~ ^[0-9]+$ ]]; then
            if [[ $max_conn -lt 1 || $max_conn -gt 100000 ]]; then
                echo -e "${YELLOW}âš ï¸  max_connections å€¼å¯èƒ½ä¸åˆç†: $max_conn${NC}"
            fi
        fi
        
        local log_level=$(yq eval '.logging.level' "$config_file" 2>/dev/null)
        case "$log_level" in
            trace|debug|info|warn|error)
                ;;
            *)
                echo -e "${YELLOW}âš ï¸  ä¸æ”¯æŒçš„æ—¥å¿—çº§åˆ«: $log_level${NC}"
                ;;
        esac
    fi
    
    if [[ $errors -eq 0 ]]; then
        echo -e "${GREEN}âœ… é…ç½®æ–‡ä»¶éªŒè¯é€šè¿‡: $env_name${NC}"
        return 0
    else
        echo -e "${RED}âŒ é…ç½®æ–‡ä»¶éªŒè¯å¤±è´¥: $env_name (é”™è¯¯æ•°: $errors)${NC}"
        return 1
    fi
}

# éªŒè¯æ‰€æœ‰ç¯å¢ƒé…ç½®
validate_all_configs() {
    echo -e "${GREEN}ğŸ” éªŒè¯æ‰€æœ‰ç¯å¢ƒé…ç½®...${NC}"
    
    local total_errors=0
    local environments=("dev" "staging" "prod")
    
    for env in "${environments[@]}"; do
        local config_file="configs/environments/$env/app-config.yaml"
        
        if ! validate_config_file "$config_file" "$env"; then
            ((total_errors++))
        fi
        echo ""
    done
    
    # éªŒè¯åŸºç¡€é…ç½®
    if [[ -f "configs/base/app-config.yaml" ]]; then
        if ! validate_config_file "configs/base/app-config.yaml" "base"; then
            ((total_errors++))
        fi
    fi
    
    if [[ $total_errors -eq 0 ]]; then
        echo -e "${GREEN}ğŸ‰ æ‰€æœ‰é…ç½®æ–‡ä»¶éªŒè¯é€šè¿‡ï¼${NC}"
        return 0
    else
        echo -e "${RED}âŒ é…ç½®éªŒè¯å¤±è´¥ï¼Œå‘ç° $total_errors ä¸ªé”™è¯¯${NC}"
        return 1
    fi
}

# é…ç½®å·®å¼‚å¯¹æ¯”
compare_configs() {
    local env1="$1"
    local env2="$2"
    
    echo -e "${GREEN}ğŸ“Š é…ç½®å·®å¼‚å¯¹æ¯”: $env1 vs $env2${NC}"
    
    local config1="configs/environments/$env1/app-config.yaml"
    local config2="configs/environments/$env2/app-config.yaml"
    
    if [[ ! -f "$config1" ]]; then
        echo -e "${RED}âŒ é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: $config1${NC}"
        return 1
    fi
    
    if [[ ! -f "$config2" ]]; then
        echo -e "${RED}âŒ é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: $config2${NC}"
        return 1
    fi
    
    if command -v diff > /dev/null 2>&1; then
        echo "å·®å¼‚è¯¦æƒ…:"
        diff -u "$config1" "$config2" || true
    else
        echo -e "${YELLOW}âš ï¸  diff å‘½ä»¤ä¸å¯ç”¨${NC}"
    fi
}

# ç”Ÿæˆé…ç½®æ–‡æ¡£
generate_config_docs() {
    echo -e "${GREEN}ğŸ“‹ ç”Ÿæˆé…ç½®æ–‡æ¡£...${NC}"
    
    local doc_file="CONFIG_DOCS.md"
    
    cat > "$doc_file" << 'EOF'
# WebSocket æœåŠ¡é…ç½®æ–‡æ¡£

## é…ç½®æ–‡ä»¶ç»“æ„

### æœåŠ¡å™¨é…ç½® (server)

| å­—æ®µ | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|------|------|--------|------|
| bind_addr | string | "0.0.0.0:3000" | æœåŠ¡å™¨ç»‘å®šåœ°å€ |
| max_connections | number | 2000 | æœ€å¤§å¹¶å‘è¿æ¥æ•° |
| read_timeout | number | 30 | è¯»å–è¶…æ—¶æ—¶é—´(ç§’) |
| write_timeout | number | 30 | å†™å…¥è¶…æ—¶æ—¶é—´(ç§’) |
| idle_timeout | number | 300 | ç©ºé—²è¶…æ—¶æ—¶é—´(ç§’) |

### æ—¥å¿—é…ç½® (logging)

| å­—æ®µ | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|------|------|--------|------|
| level | string | "info" | æ—¥å¿—çº§åˆ« (trace/debug/info/warn/error) |
| format | string | "json" | æ—¥å¿—æ ¼å¼ (json/text) |
| enable_file_logging | boolean | true | æ˜¯å¦å¯ç”¨æ–‡ä»¶æ—¥å¿— |
| file_path | string | "/app/logs/app.log" | æ—¥å¿—æ–‡ä»¶è·¯å¾„ |
| rotation | string | "daily" | æ—¥å¿—è½®è½¬ç­–ç•¥ |

### WebSocket é…ç½® (websocket)

| å­—æ®µ | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|------|------|--------|------|
| channel_capacity | number | 2000 | å¹¿æ’­é€šé“å®¹é‡ |
| message_size_limit | number | 65536 | æ¶ˆæ¯å¤§å°é™åˆ¶(å­—èŠ‚) |
| ping_interval | number | 30 | Ping é—´éš”æ—¶é—´(ç§’) |
| pong_timeout | number | 10 | Pong è¶…æ—¶æ—¶é—´(ç§’) |
| close_timeout | number | 5 | å…³é—­è¶…æ—¶æ—¶é—´(ç§’) |

### åŠŸèƒ½å¼€å…³ (features)

| å­—æ®µ | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|------|------|--------|------|
| enable_auth | boolean | true | å¯ç”¨èº«ä»½éªŒè¯ |
| enable_rate_limiting | boolean | true | å¯ç”¨é€Ÿç‡é™åˆ¶ |
| enable_metrics | boolean | true | å¯ç”¨æŒ‡æ ‡æ”¶é›† |
| enable_tracing | boolean | true | å¯ç”¨é“¾è·¯è¿½è¸ª |
| debug_mode | boolean | false | å¯ç”¨è°ƒè¯•æ¨¡å¼ |

## ç¯å¢ƒå·®å¼‚

EOF

    # æ·»åŠ ç¯å¢ƒé…ç½®å¯¹æ¯”
    echo "### å¼€å‘ç¯å¢ƒ (dev)" >> "$doc_file"
    if [[ -f "configs/environments/dev/app-config.yaml" ]] && command -v yq > /dev/null 2>&1; then
        echo '```yaml' >> "$doc_file"
        yq eval '.' "configs/environments/dev/app-config.yaml" >> "$doc_file"
        echo '```' >> "$doc_file"
    fi
    
    echo "### ç”Ÿäº§ç¯å¢ƒ (prod)" >> "$doc_file"
    if [[ -f "configs/environments/prod/app-config.yaml" ]] && command -v yq > /dev/null 2>&1; then
        echo '```yaml' >> "$doc_file"
        yq eval '.' "configs/environments/prod/app-config.yaml" >> "$doc_file"
        echo '```' >> "$doc_file"
    fi
    
    echo -e "${GREEN}âœ… é…ç½®æ–‡æ¡£å·²ç”Ÿæˆ: $doc_file${NC}"
}

# ä¸»å‡½æ•°
main() {
    case "${1:-validate}" in
        validate)
            validate_all_configs
            ;;
        compare)
            if [[ $# -lt 3 ]]; then
                echo "ç”¨æ³•: $0 compare <env1> <env2>"
                exit 1
            fi
            compare_configs "$2" "$3"
            ;;
        docs)
            generate_config_docs
            ;;
        single)
            if [[ $# -lt 2 ]]; then
                echo "ç”¨æ³•: $0 single <config-file>"
                exit 1
            fi
            validate_config_file "$2" "$(basename "$2")"
            ;;
        *)
            echo "ç”¨æ³•: $0 {validate|compare|docs|single}"
            echo ""
            echo "å‘½ä»¤:"
            echo "  validate     éªŒè¯æ‰€æœ‰ç¯å¢ƒé…ç½®"
            echo "  compare      æ¯”è¾ƒä¸¤ä¸ªç¯å¢ƒé…ç½®"
            echo "  docs         ç”Ÿæˆé…ç½®æ–‡æ¡£"
            echo "  single       éªŒè¯å•ä¸ªé…ç½®æ–‡ä»¶"
            exit 1
            ;;
    esac
}

main "$@"</pre>

        <p><strong>æ­¥éª¤ 8: è¿è¡Œå’Œæµ‹è¯•</strong></p>
        <pre># 1. éªŒè¯é…ç½®æ–‡ä»¶
chmod +x scripts/*.sh
./scripts/validate-config.sh

# 2. ç”Ÿæˆé…ç½®æ–‡æ¡£
./scripts/validate-config.sh docs

# 3. æ¯”è¾ƒä¸åŒç¯å¢ƒé…ç½®
./scripts/validate-config.sh compare dev prod

# 4. æ›´æ–°å¼€å‘ç¯å¢ƒé…ç½®ï¼ˆdry-runï¼‰
./scripts/update-config.sh -e dev -d

# 5. å®é™…æ›´æ–°å¼€å‘ç¯å¢ƒé…ç½®
./scripts/update-config.sh -e dev

# 6. æ›´æ–°ç”Ÿäº§ç¯å¢ƒé…ç½®
./scripts/update-config.sh -e prod -n websocket-prod

# 7. éªŒè¯ ConfigMap åˆ›å»º
kubectl get configmaps -n websocket-app
kubectl describe configmap websocket-base-config -n websocket-app

# 8. æµ‹è¯•é…ç½®çƒ­é‡è½½
kubectl exec deployment/websocket-server -n websocket-app -- \
  cat /app/config/app-config.yaml

# 9. æ›´æ–°é…ç½®å¹¶éªŒè¯é‡è½½
echo "ä¿®æ”¹é…ç½®æ–‡ä»¶åé‡æ–°åº”ç”¨..."
./scripts/update-config.sh -e dev

# 10. ç›‘æ§é…ç½®å˜æ›´
kubectl logs -f deployment/websocket-server -n websocket-app | grep -i config</pre>

        <p><strong>ğŸ¯ ä»Šæ—¥æ”¶è·</strong></p>
        <ul>
            <li>âœ… æŒæ¡äº† ConfigMap çš„é«˜çº§ç”¨æ³•å’Œç®¡ç†</li>
            <li>âœ… å®ç°äº†é…ç½®æ–‡ä»¶çš„åŠ¨æ€çƒ­é‡è½½æœºåˆ¶</li>
            <li>âœ… å»ºç«‹äº†å¤šç¯å¢ƒé…ç½®ç®¡ç†ä½“ç³»</li>
            <li>âœ… åˆ›å»ºäº†é…ç½®éªŒè¯å’Œå·®å¼‚å¯¹æ¯”å·¥å…·</li>
            <li>âœ… å®ç°äº†é…ç½®å˜æ›´çš„è‡ªåŠ¨åŒ–éƒ¨ç½²</li>
            <li>âœ… å­¦ä¼šäº†é…ç½®å®‰å…¨å’Œç‰ˆæœ¬æ§åˆ¶æœ€ä½³å®è·µ</li>
            <li>âœ… å»ºç«‹äº†å®Œæ•´çš„é…ç½®ç®¡ç†å·¥ä½œæµ</li>
        </ul>

        <p><strong>ğŸ’¡ æ‰©å±•ç»ƒä¹ </strong></p>
        <ul>
            <li>é›†æˆé…ç½®ä¸­å¿ƒï¼ˆå¦‚ Consulã€etcdï¼‰</li>
            <li>å®ç°é…ç½®åŠ å¯†å’Œè§£å¯†</li>
            <li>æ·»åŠ é…ç½®å˜æ›´å®¡è®¡æ—¥å¿—</li>
            <li>å®ç°è“ç»¿éƒ¨ç½²é…ç½®åˆ‡æ¢</li>
        </ul>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-24</strong></p>
        <h2>Day 24 - minikube å¯åŠ¨ä¸è®¿é—®æµ‹è¯•</h2>
        <p>ä»Šå¤©ä½ å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ Minikube åœ¨æœ¬åœ°ç¯å¢ƒä¸­åˆ›å»º Kubernetes é›†ç¾¤ï¼Œå¹¶éªŒè¯ä¹‹å‰åˆ›å»ºçš„ WebSocket æœåŠ¡åœ¨ Kubernetes ç¯å¢ƒä¸­çš„è¿è¡Œæƒ…å†µã€‚è¿™æ˜¯ä»æœ¬åœ°å¼€å‘è¿‡æ¸¡åˆ° Kubernetes çš„é‡è¦ä¸€æ­¥ã€‚</p>
        
        <h3>ğŸ¯ å­¦ä¹ ç›®æ ‡</h3>
        <ul>
            <li>å®‰è£…å’Œé…ç½® Minikube æœ¬åœ° Kubernetes ç¯å¢ƒ</li>
            <li>éƒ¨ç½² WebSocket æœåŠ¡åˆ° Minikube é›†ç¾¤</li>
            <li>å­¦ä¹ æœåŠ¡æš´éœ²å’Œè®¿é—®çš„å¤šç§æ–¹å¼</li>
            <li>æŒæ¡æœ¬åœ° Kubernetes é›†ç¾¤çš„è°ƒè¯•æŠ€å·§</li>
            <li>éªŒè¯æœåŠ¡çš„å¯ç”¨æ€§å’Œæ€§èƒ½</li>
        </ul>

        <h3>ğŸ“ é¡¹ç›®ç»“æ„</h3>
        <pre>day24_minikube_testing/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ server.rs
â”‚   â”œâ”€â”€ config.rs
â”‚   â””â”€â”€ health.rs
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ namespace.yaml
â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”œâ”€â”€ service.yaml
â”‚   â”œâ”€â”€ ingress.yaml
â”‚   â””â”€â”€ configmap.yaml
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ setup-minikube.sh
â”‚   â”œâ”€â”€ deploy.sh
â”‚   â”œâ”€â”€ test-service.sh
â”‚   â”œâ”€â”€ cleanup.sh
â”‚   â””â”€â”€ monitoring.sh
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ integration_test.rs
â”‚   â””â”€â”€ load_test.rs
â”œâ”€â”€ web/
â”‚   â””â”€â”€ test-client.html
â”œâ”€â”€ configs/
â”‚   â”œâ”€â”€ minikube.yaml
â”‚   â””â”€â”€ local.yaml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ .dockerignore
â””â”€â”€ README.md</pre>

        <h3>ğŸš€ å®ç°æ­¥éª¤</h3>

        <h4>æ­¥éª¤ 1: åˆ›å»ºä¼˜åŒ–çš„ WebSocket æœåŠ¡</h4>
        <p><strong>Cargo.toml:</strong></p>
        <pre><code>[package]
name = "websocket-minikube"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws", "macros"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.21"
futures-util = "0.3"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
anyhow = "1.0"
clap = { version = "4.0", features = ["derive"] }
config = "0.14"
notify = "6.0"</code></pre>

        <p><strong>src/main.rs:</strong></p>
        <pre><code>use axum::{
    extract::{ws::WebSocketUpgrade, State},
    response::Response,
    routing::{get, post},
    Json, Router,
};
use std::{collections::HashMap, net::SocketAddr, sync::Arc};
use tokio::sync::RwLock;
use tower_http::{cors::CorsLayer, trace::TraceLayer};
use tracing::{info, warn};
use uuid::Uuid;

mod config;
mod health;
mod server;

use config::ConfigManager;
use health::{HealthStatus, ReadinessStatus};
use server::{AppState, ClientInfo};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt()
        .with_env_filter(std::env::var("RUST_LOG").unwrap_or_else(|_| "info".into()))
        .init();

    info!("ğŸš€ Starting WebSocket Server for Minikube");

    // åˆå§‹åŒ–é…ç½®ç®¡ç†å™¨
    let config_manager = ConfigManager::new("configs/local.yaml").await?;
    let config = config_manager.get_config().await;
    
    info!("ğŸ“‹ Configuration loaded: {:?}", config);

    // åˆ›å»ºåº”ç”¨çŠ¶æ€
    let app_state = Arc::new(AppState {
        clients: RwLock::new(HashMap::new()),
        health: RwLock::new(HealthStatus::healthy()),
        readiness: RwLock::new(ReadinessStatus::ready()),
        config_manager,
        metrics: Default::default(),
    });

    // å¯åŠ¨é…ç½®çƒ­é‡è½½
    let state_clone = app_state.clone();
    tokio::spawn(async move {
        if let Err(e) = state_clone.config_manager.start_hot_reload().await {
            warn!("é…ç½®çƒ­é‡è½½å¤±è´¥: {}", e);
        }
    });

    // åˆ›å»ºè·¯ç”±
    let app = create_app(app_state);

    // å¯åŠ¨æœåŠ¡å™¨
    let addr = SocketAddr::from(([0, 0, 0, 0], config.server.port));
    info!("ğŸ¯ Server listening on {}", addr);
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}

fn create_app(state: Arc<AppState>) -> Router {
    Router::new()
        .route("/ws", get(websocket_handler))
        .route("/health", get(health_handler))
        .route("/ready", get(readiness_handler))
        .route("/metrics", get(metrics_handler))
        .route("/clients", get(clients_handler))
        .route("/config", get(config_handler))
        .route("/config/reload", post(reload_config_handler))
        .with_state(state)
        .layer(CorsLayer::permissive())
        .layer(TraceLayer::new_for_http())
}

async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<Arc<AppState>>,
) -> Response {
    let client_id = Uuid::new_v4();
    info!("ğŸ”— New WebSocket connection attempt: {}", client_id);
    
    ws.on_upgrade(move |socket| server::handle_websocket(socket, state, client_id))
}

async fn health_handler(State(state): State<Arc<AppState>>) -> Json<HealthStatus> {
    Json(state.health.read().await.clone())
}

async fn readiness_handler(State(state): State<Arc<AppState>>) -> Json<ReadinessStatus> {
    Json(state.readiness.read().await.clone())
}

async fn metrics_handler(State(state): State<Arc<AppState>>) -> Json<serde_json::Value> {
    let clients = state.clients.read().await;
    let metrics = serde_json::json!({
        "connected_clients": clients.len(),
        "total_connections": state.metrics.total_connections.load(std::sync::atomic::Ordering::Relaxed),
        "messages_sent": state.metrics.messages_sent.load(std::sync::atomic::Ordering::Relaxed),
        "messages_received": state.metrics.messages_received.load(std::sync::atomic::Ordering::Relaxed),
        "uptime_seconds": state.metrics.start_time.elapsed().as_secs(),
    });
    Json(metrics)
}

async fn clients_handler(State(state): State<Arc<AppState>>) -> Json<Vec<ClientInfo>> {
    let clients = state.clients.read().await;
    let client_list: Vec<ClientInfo> = clients.values().cloned().collect();
    Json(client_list)
}

async fn config_handler(State(state): State<Arc<AppState>>) -> Json<config::AppConfig> {
    Json(state.config_manager.get_config().await)
}

async fn reload_config_handler(State(state): State<Arc<AppState>>) -> Json<serde_json::Value> {
    match state.config_manager.reload_config().await {
        Ok(_) => Json(serde_json::json!({"status": "success", "message": "é…ç½®é‡è½½æˆåŠŸ"})),
        Err(e) => Json(serde_json::json!({"status": "error", "message": format!("é…ç½®é‡è½½å¤±è´¥: {}", e)})),
    }
}</code></pre>

        <h4>æ­¥éª¤ 2: Minikube è®¾ç½®è„šæœ¬</h4>
        <p><strong>scripts/setup-minikube.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "ğŸš€ Setting up Minikube for WebSocket Server Testing"

# æ£€æŸ¥ Minikube æ˜¯å¦å·²å®‰è£…
if ! command -v minikube &> /dev/null; then
    echo "âŒ Minikube not found. Please install Minikube first."
    echo "ğŸ“‹ Installation guide: https://minikube.sigs.k8s.io/docs/start/"
    exit 1
fi

# æ£€æŸ¥ kubectl æ˜¯å¦å·²å®‰è£…
if ! command -v kubectl &> /dev/null; then
    echo "âŒ kubectl not found. Please install kubectl first."
    exit 1
fi

echo "âœ… Prerequisites check passed"

# å¯åŠ¨ Minikube
echo "ğŸ”„ Starting Minikube cluster..."
minikube start \
    --driver=docker \
    --cpus=2 \
    --memory=4096 \
    --disk-size=20g \
    --kubernetes-version=v1.28.0 \
    --addons=ingress,metrics-server,dashboard

echo "â³ Waiting for cluster to be ready..."
kubectl wait --for=condition=ready nodes --all --timeout=300s

# å¯ç”¨å¿…è¦çš„æ’ä»¶
echo "ğŸ”§ Enabling Minikube addons..."
minikube addons enable ingress
minikube addons enable metrics-server
minikube addons enable dashboard

# é…ç½® Docker ç¯å¢ƒ
echo "ğŸ³ Configuring Docker environment..."
eval $(minikube docker-env)

# æ„å»º Docker é•œåƒ
echo "ğŸ—ï¸ Building WebSocket server image..."
docker build -t websocket-server:local .

# éªŒè¯é›†ç¾¤çŠ¶æ€
echo "ğŸ“Š Cluster status:"
kubectl cluster-info
echo ""
kubectl get nodes
echo ""
kubectl get pods -A

echo "âœ… Minikube setup completed successfully!"
echo "ğŸŒ Dashboard URL: $(minikube dashboard --url)"
echo "ğŸ“ Use 'kubectl get pods -A' to check all pods"
echo "ğŸ”— Use 'minikube service --all' to see all services"</code></pre>

        <h4>æ­¥éª¤ 3: Kubernetes éƒ¨ç½²é…ç½®</h4>
        <p><strong>k8s/namespace.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: Namespace
metadata:
  name: websocket-app
  labels:
    name: websocket-app
    environment: local
    managed-by: minikube</code></pre>

        <p><strong>k8s/configmap.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: websocket-config
  namespace: websocket-app
data:
  config.yaml: |
    server:
      port: 3000
      host: "0.0.0.0"
      max_connections: 1000
      heartbeat_interval: 30
      read_timeout: 60
      write_timeout: 60
    
    websocket:
      max_frame_size: 65536
      max_message_size: 1048576
      compression: true
      ping_interval: 30
      pong_timeout: 10
    
    logging:
      level: "info"
      format: "json"
      output: "stdout"
    
    metrics:
      enabled: true
      port: 9090
      path: "/metrics"</code></pre>

        <p><strong>k8s/deployment.yaml:</strong></p>
        <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: websocket-server
  namespace: websocket-app
  labels:
    app: websocket-server
    version: v1
spec:
  replicas: 2
  selector:
    matchLabels:
      app: websocket-server
  template:
    metadata:
      labels:
        app: websocket-server
        version: v1
    spec:
      containers:
      - name: websocket-server
        image: websocket-server:local
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
          name: websocket
        - containerPort: 9090
          name: metrics
        env:
        - name: RUST_LOG
          value: "info"
        - name: CONFIG_PATH
          value: "/app/config/config.yaml"
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
          failureThreshold: 3
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: config-volume
        configMap:
          name: websocket-config</code></pre>

        <p><strong>k8s/service.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: Service
metadata:
  name: websocket-service
  namespace: websocket-app
  labels:
    app: websocket-server
spec:
  type: NodePort
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30000
    name: websocket
  - port: 9090
    targetPort: 9090
    nodePort: 30090
    name: metrics
  selector:
    app: websocket-server</code></pre>

        <h4>æ­¥éª¤ 4: éƒ¨ç½²å’Œæµ‹è¯•è„šæœ¬</h4>
        <p><strong>scripts/deploy.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "ğŸš€ Deploying WebSocket Server to Minikube"

# ç¡®ä¿ä½¿ç”¨ Minikube çš„ Docker ç¯å¢ƒ
eval $(minikube docker-env)

# æ„å»ºæœ€æ–°çš„é•œåƒ
echo "ğŸ—ï¸ Building Docker image..."
docker build -t websocket-server:local . --no-cache

# åº”ç”¨ Kubernetes é…ç½®
echo "ğŸ“¦ Applying Kubernetes manifests..."
kubectl apply -f k8s/namespace.yaml
kubectl apply -f k8s/configmap.yaml
kubectl apply -f k8s/deployment.yaml
kubectl apply -f k8s/service.yaml

# ç­‰å¾…éƒ¨ç½²å®Œæˆ
echo "â³ Waiting for deployment to be ready..."
kubectl rollout status deployment/websocket-server -n websocket-app --timeout=300s

# ç­‰å¾… Pod å‡†å¤‡å°±ç»ª
echo "â³ Waiting for pods to be ready..."
kubectl wait --for=condition=ready pod -l app=websocket-server -n websocket-app --timeout=300s

# æ˜¾ç¤ºéƒ¨ç½²çŠ¶æ€
echo "ğŸ“Š Deployment status:"
kubectl get pods -n websocket-app -o wide
echo ""
kubectl get services -n websocket-app
echo ""

# è·å–æœåŠ¡è®¿é—®ä¿¡æ¯
MINIKUBE_IP=$(minikube ip)
SERVICE_PORT=$(kubectl get service websocket-service -n websocket-app -o jsonpath='{.spec.ports[0].nodePort}')
METRICS_PORT=$(kubectl get service websocket-service -n websocket-app -o jsonpath='{.spec.ports[1].nodePort}')

echo "âœ… Deployment completed successfully!"
echo ""
echo "ğŸŒ Service Access Information:"
echo "   WebSocket URL: ws://$MINIKUBE_IP:$SERVICE_PORT/ws"
echo "   Health Check: http://$MINIKUBE_IP:$SERVICE_PORT/health"
echo "   Metrics: http://$MINIKUBE_IP:$METRICS_PORT/metrics"
echo ""
echo "ğŸ“ Useful commands:"
echo "   kubectl logs -f deployment/websocket-server -n websocket-app"
echo "   kubectl exec -it deployment/websocket-server -n websocket-app -- /bin/bash"
echo "   minikube service websocket-service -n websocket-app"</code></pre>

        <p><strong>scripts/test-service.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "ğŸ§ª Testing WebSocket Service in Minikube"

# è·å–æœåŠ¡ä¿¡æ¯
MINIKUBE_IP=$(minikube ip)
SERVICE_PORT=$(kubectl get service websocket-service -n websocket-app -o jsonpath='{.spec.ports[0].nodePort}')
METRICS_PORT=$(kubectl get service websocket-service -n websocket-app -o jsonpath='{.spec.ports[1].nodePort}')

BASE_URL="http://$MINIKUBE_IP:$SERVICE_PORT"
METRICS_URL="http://$MINIKUBE_IP:$METRICS_PORT"

echo "ğŸ” Testing endpoints..."
echo "Base URL: $BASE_URL"

# æµ‹è¯•å¥åº·æ£€æŸ¥
echo "ğŸ¥ Testing health endpoint..."
if curl -s "$BASE_URL/health" | jq .; then
    echo "âœ… Health check passed"
else
    echo "âŒ Health check failed"
    exit 1
fi

# æµ‹è¯•å°±ç»ªæ€§æ£€æŸ¥
echo "ğŸš¦ Testing readiness endpoint..."
if curl -s "$BASE_URL/ready" | jq .; then
    echo "âœ… Readiness check passed"
else
    echo "âŒ Readiness check failed"
    exit 1
fi

# æµ‹è¯•æŒ‡æ ‡ç«¯ç‚¹
echo "ğŸ“Š Testing metrics endpoint..."
if curl -s "$BASE_URL/metrics" | jq .; then
    echo "âœ… Metrics endpoint accessible"
else
    echo "âŒ Metrics endpoint failed"
fi

# æµ‹è¯•å®¢æˆ·ç«¯åˆ—è¡¨
echo "ğŸ‘¥ Testing clients endpoint..."
if curl -s "$BASE_URL/clients" | jq .; then
    echo "âœ… Clients endpoint accessible"
else
    echo "âŒ Clients endpoint failed"
fi

# WebSocket è¿æ¥æµ‹è¯•
echo "ğŸ”Œ Testing WebSocket connection..."
timeout 10s websocat "ws://$MINIKUBE_IP:$SERVICE_PORT/ws" <<< "Hello from test!" | head -5 || {
    echo "âš ï¸ WebSocket test requires 'websocat' tool"
    echo "Install with: cargo install websocat"
}

# è´Ÿè½½æµ‹è¯•
echo "âš¡ Running simple load test..."
echo "Sending 10 concurrent requests..."
for i in {1..10}; do
    curl -s "$BASE_URL/health" > /dev/null &
done
wait

echo "âœ… All tests completed!"
echo ""
echo "ğŸŒ Service URLs:"
echo "   WebSocket: ws://$MINIKUBE_IP:$SERVICE_PORT/ws"
echo "   Dashboard: http://$MINIKUBE_IP:$SERVICE_PORT"
echo "   Health: $BASE_URL/health"
echo "   Metrics: $BASE_URL/metrics"</code></pre>

        <h4>æ­¥éª¤ 5: ç›‘æ§å’Œè°ƒè¯•è„šæœ¬</h4>
        <p><strong>scripts/monitoring.sh:</strong></p>
        <pre><code>#!/bin/bash

echo "ğŸ“Š WebSocket Server Monitoring Dashboard"
echo "======================================="

# è·å–æœåŠ¡ä¿¡æ¯
MINIKUBE_IP=$(minikube ip)
SERVICE_PORT=$(kubectl get service websocket-service -n websocket-app -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "N/A")

if [ "$SERVICE_PORT" = "N/A" ]; then
    echo "âŒ Service not found. Please deploy first."
    exit 1
fi

BASE_URL="http://$MINIKUBE_IP:$SERVICE_PORT"

# æ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯
echo "ğŸŒ Service Information:"
echo "   Minikube IP: $MINIKUBE_IP"
echo "   Service Port: $SERVICE_PORT"
echo "   Base URL: $BASE_URL"
echo ""

# ç›‘æ§å¾ªç¯
while true; do
    clear
    echo "ğŸ“Š WebSocket Server Real-time Monitoring"
    echo "======================================="
    echo "â° Time: $(date)"
    echo ""
    
    # Pod çŠ¶æ€
    echo "ğŸ  Pod Status:"
    kubectl get pods -n websocket-app -o wide
    echo ""
    
    # æœåŠ¡çŠ¶æ€
    echo "ğŸŒ Service Status:"
    kubectl get services -n websocket-app
    echo ""
    
    # å¥åº·çŠ¶æ€
    echo "ğŸ¥ Health Status:"
    if HEALTH=$(curl -s "$BASE_URL/health" 2>/dev/null); then
        echo "$HEALTH" | jq .
    else
        echo "âŒ Health check failed"
    fi
    echo ""
    
    # æŒ‡æ ‡ä¿¡æ¯
    echo "ğŸ“ˆ Metrics:"
    if METRICS=$(curl -s "$BASE_URL/metrics" 2>/dev/null); then
        echo "$METRICS" | jq .
    else
        echo "âŒ Metrics unavailable"
    fi
    echo ""
    
    # è¿æ¥çš„å®¢æˆ·ç«¯
    echo "ğŸ‘¥ Connected Clients:"
    if CLIENTS=$(curl -s "$BASE_URL/clients" 2>/dev/null); then
        echo "$CLIENTS" | jq .
    else
        echo "âŒ Client information unavailable"
    fi
    echo ""
    
    # èµ„æºä½¿ç”¨æƒ…å†µ
    echo "ğŸ’» Resource Usage:"
    kubectl top pods -n websocket-app 2>/dev/null || echo "âŒ Metrics server not available"
    echo ""
    
    echo "Press Ctrl+C to exit monitoring..."
    sleep 5
done</code></pre>

        <h4>æ­¥éª¤ 6: æµ‹è¯•å®¢æˆ·ç«¯</h4>
        <p><strong>web/test-client.html:</strong></p>
        <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;WebSocket Minikube Test Client&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .status {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
        }
        .status-item {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            min-width: 120px;
        }
        .connected { background-color: #d4edda; color: #155724; }
        .disconnected { background-color: #f8d7da; color: #721c24; }
        .pending { background-color: #fff3cd; color: #856404; }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .connect-btn { background-color: #28a745; color: white; }
        .disconnect-btn { background-color: #dc3545; color: white; }
        .test-btn { background-color: #007bff; color: white; }
        .clear-btn { background-color: #6c757d; color: white; }
        button:hover { opacity: 0.8; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .message-area {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .input-section, .log-section {
            flex: 1;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
        }
        .log {
            height: 400px;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .metrics {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .metric-item {
            background: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;ğŸš€ WebSocket Minikube Test Client&lt;/h1&gt;
            &lt;p&gt;æµ‹è¯•éƒ¨ç½²åœ¨ Minikube ä¸­çš„ WebSocket æœåŠ¡&lt;/p&gt;
        &lt;/div&gt;

        &lt;div class="status"&gt;
            &lt;div id="connectionStatus" class="status-item disconnected"&gt;
                &lt;strong&gt;è¿æ¥çŠ¶æ€&lt;/strong&gt;&lt;br&gt;
                &lt;span id="statusText"&gt;æœªè¿æ¥&lt;/span&gt;
            &lt;/div&gt;
            &lt;div id="messageCount" class="status-item pending"&gt;
                &lt;strong&gt;æ¶ˆæ¯è®¡æ•°&lt;/strong&gt;&lt;br&gt;
                &lt;span id="countText"&gt;å‘é€: 0 | æ¥æ”¶: 0&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div&gt;
            &lt;label for="serverUrl"&gt;WebSocket æœåŠ¡å™¨ URL:&lt;/label&gt;
            &lt;input type="text" id="serverUrl" 
                   value="ws://192.168.49.2:30000/ws" 
                   placeholder="ws://minikube-ip:port/ws"&gt;
        &lt;/div&gt;

        &lt;div class="controls"&gt;
            &lt;button id="connectBtn" class="connect-btn"&gt;ğŸ”Œ è¿æ¥&lt;/button&gt;
            &lt;button id="disconnectBtn" class="disconnect-btn" disabled&gt;ğŸ”Œ æ–­å¼€&lt;/button&gt;
            &lt;button id="pingBtn" class="test-btn" disabled&gt;ğŸ“¡ å‘é€ Ping&lt;/button&gt;
            &lt;button id="testBtn" class="test-btn" disabled&gt;ğŸ§ª å‹åŠ›æµ‹è¯•&lt;/button&gt;
            &lt;button id="clearBtn" class="clear-btn"&gt;ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—&lt;/button&gt;
            &lt;button id="metricsBtn" class="test-btn"&gt;ğŸ“Š è·å–æŒ‡æ ‡&lt;/button&gt;
        &lt;/div&gt;

        &lt;div class="message-area"&gt;
            &lt;div class="input-section"&gt;
                &lt;h3&gt;ğŸ’¬ å‘é€æ¶ˆæ¯&lt;/h3&gt;
                &lt;input type="text" id="messageInput" 
                       placeholder="è¾“å…¥è¦å‘é€çš„æ¶ˆæ¯..." 
                       disabled&gt;
                &lt;button id="sendBtn" class="test-btn" disabled&gt;ğŸ“¤ å‘é€&lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="log-section"&gt;
                &lt;h3&gt;ğŸ“‹ è¿æ¥æ—¥å¿—&lt;/h3&gt;
                &lt;div id="log" class="log"&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="metrics"&gt;
            &lt;h3&gt;ğŸ“Š æœåŠ¡å™¨æŒ‡æ ‡&lt;/h3&gt;
            &lt;div id="metricsGrid" class="metric-grid"&gt;
                &lt;div class="metric-item"&gt;
                    &lt;strong&gt;è¿æ¥çš„å®¢æˆ·ç«¯&lt;/strong&gt;&lt;br&gt;
                    &lt;span id="connectedClients"&gt;-&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="metric-item"&gt;
                    &lt;strong&gt;æ€»è¿æ¥æ•°&lt;/strong&gt;&lt;br&gt;
                    &lt;span id="totalConnections"&gt;-&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="metric-item"&gt;
                    &lt;strong&gt;å·²å‘é€æ¶ˆæ¯&lt;/strong&gt;&lt;br&gt;
                    &lt;span id="messagesSent"&gt;-&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="metric-item"&gt;
                    &lt;strong&gt;å·²æ¥æ”¶æ¶ˆæ¯&lt;/strong&gt;&lt;br&gt;
                    &lt;span id="messagesReceived"&gt;-&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="metric-item"&gt;
                    &lt;strong&gt;è¿è¡Œæ—¶é—´&lt;/strong&gt;&lt;br&gt;
                    &lt;span id="uptime"&gt;-&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        class WebSocketTestClient {
            constructor() {
                this.ws = null;
                this.sentCount = 0;
                this.receivedCount = 0;
                this.initializeElements();
                this.bindEvents();
                this.updateMinikubeUrl();
            }

            initializeElements() {
                this.elements = {
                    serverUrl: document.getElementById('serverUrl'),
                    connectBtn: document.getElementById('connectBtn'),
                    disconnectBtn: document.getElementById('disconnectBtn'),
                    pingBtn: document.getElementById('pingBtn'),
                    testBtn: document.getElementById('testBtn'),
                    clearBtn: document.getElementById('clearBtn'),
                    metricsBtn: document.getElementById('metricsBtn'),
                    messageInput: document.getElementById('messageInput'),
                    sendBtn: document.getElementById('sendBtn'),
                    log: document.getElementById('log'),
                    statusText: document.getElementById('statusText'),
                    countText: document.getElementById('countText'),
                    connectionStatus: document.getElementById('connectionStatus')
                };
            }

            bindEvents() {
                this.elements.connectBtn.onclick = () => this.connect();
                this.elements.disconnectBtn.onclick = () => this.disconnect();
                this.elements.pingBtn.onclick = () => this.sendPing();
                this.elements.testBtn.onclick = () => this.runStressTest();
                this.elements.clearBtn.onclick = () => this.clearLog();
                this.elements.metricsBtn.onclick = () => this.fetchMetrics();
                this.elements.sendBtn.onclick = () => this.sendMessage();
                
                this.elements.messageInput.onkeypress = (e) => {
                    if (e.key === 'Enter') this.sendMessage();
                };
            }

            async updateMinikubeUrl() {
                try {
                    // å°è¯•è‡ªåŠ¨è·å– Minikube IP
                    const response = await fetch('/api/minikube-info');
                    if (response.ok) {
                        const info = await response.json();
                        this.elements.serverUrl.value = `ws://${info.ip}:${info.port}/ws`;
                    }
                } catch (e) {
                    this.log('âš ï¸ æ— æ³•è‡ªåŠ¨è·å– Minikube ä¿¡æ¯ï¼Œè¯·æ‰‹åŠ¨è¾“å…¥ URL');
                }
            }

            connect() {
                const url = this.elements.serverUrl.value.trim();
                if (!url) {
                    this.log('âŒ è¯·è¾“å…¥ WebSocket URL');
                    return;
                }

                this.log(`ğŸ”Œ æ­£åœ¨è¿æ¥åˆ°: ${url}`);
                this.updateConnectionStatus('connecting', 'è¿æ¥ä¸­...');

                try {
                    this.ws = new WebSocket(url);
                    
                    this.ws.onopen = () => {
                        this.log('âœ… WebSocket è¿æ¥æˆåŠŸ!');
                        this.updateConnectionStatus('connected', 'å·²è¿æ¥');
                        this.setControlsState(true);
                    };

                    this.ws.onmessage = (event) => {
                        this.receivedCount++;
                        this.updateCounters();
                        this.log(`ğŸ“¥ æ”¶åˆ°æ¶ˆæ¯: ${event.data}`);
                    };

                    this.ws.onclose = (event) => {
                        this.log(`ğŸ”Œ è¿æ¥å…³é—­: ${event.code} - ${event.reason}`);
                        this.updateConnectionStatus('disconnected', 'æœªè¿æ¥');
                        this.setControlsState(false);
                    };

                    this.ws.onerror = (error) => {
                        this.log(`âŒ è¿æ¥é”™è¯¯: ${error}`);
                        this.updateConnectionStatus('disconnected', 'è¿æ¥å¤±è´¥');
                        this.setControlsState(false);
                    };

                } catch (error) {
                    this.log(`âŒ åˆ›å»ºè¿æ¥å¤±è´¥: ${error.message}`);
                    this.updateConnectionStatus('disconnected', 'è¿æ¥å¤±è´¥');
                }
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                    this.log('ğŸ”Œ ä¸»åŠ¨æ–­å¼€è¿æ¥');
                }
            }

            sendMessage() {
                const message = this.elements.messageInput.value.trim();
                if (!message) return;

                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(message);
                    this.sentCount++;
                    this.updateCounters();
                    this.log(`ğŸ“¤ å‘é€æ¶ˆæ¯: ${message}`);
                    this.elements.messageInput.value = '';
                } else {
                    this.log('âŒ è¿æ¥æœªå»ºç«‹ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
                }
            }

            sendPing() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const pingMsg = `ping-${Date.now()}`;
                    this.ws.send(pingMsg);
                    this.sentCount++;
                    this.updateCounters();
                    this.log(`ğŸ“¡ å‘é€ Ping: ${pingMsg}`);
                } else {
                    this.log('âŒ è¿æ¥æœªå»ºç«‹ï¼Œæ— æ³•å‘é€ Ping');
                }
            }

            async runStressTest() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    this.log('âŒ è¿æ¥æœªå»ºç«‹ï¼Œæ— æ³•è¿›è¡Œå‹åŠ›æµ‹è¯•');
                    return;
                }

                this.log('âš¡ å¼€å§‹å‹åŠ›æµ‹è¯•...');
                const startTime = Date.now();
                const messageCount = 100;

                for (let i = 0; i < messageCount; i++) {
                    const message = `stress-test-${i}-${Date.now()}`;
                    this.ws.send(message);
                    this.sentCount++;
                    
                    // æ¯ 10 æ¡æ¶ˆæ¯ç­‰å¾…ä¸€å°æ®µæ—¶é—´
                    if (i % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }

                const duration = Date.now() - startTime;
                this.updateCounters();
                this.log(`âš¡ å‹åŠ›æµ‹è¯•å®Œæˆ: å‘é€ ${messageCount} æ¡æ¶ˆæ¯ï¼Œè€—æ—¶ ${duration}ms`);
            }

            async fetchMetrics() {
                try {
                    const baseUrl = this.elements.serverUrl.value.replace('ws://', 'http://').replace('/ws', '');
                    const response = await fetch(`${baseUrl}/metrics`);
                    
                    if (response.ok) {
                        const metrics = await response.json();
                        this.updateMetricsDisplay(metrics);
                        this.log('ğŸ“Š æŒ‡æ ‡æ›´æ–°æˆåŠŸ');
                    } else {
                        this.log(`âŒ è·å–æŒ‡æ ‡å¤±è´¥: ${response.status}`);
                    }
                } catch (error) {
                    this.log(`âŒ è·å–æŒ‡æ ‡é”™è¯¯: ${error.message}`);
                }
            }

            updateMetricsDisplay(metrics) {
                document.getElementById('connectedClients').textContent = metrics.connected_clients || '-';
                document.getElementById('totalConnections').textContent = metrics.total_connections || '-';
                document.getElementById('messagesSent').textContent = metrics.messages_sent || '-';
                document.getElementById('messagesReceived').textContent = metrics.messages_received || '-';
                document.getElementById('uptime').textContent = metrics.uptime_seconds ? 
                    `${Math.floor(metrics.uptime_seconds / 60)}åˆ†${metrics.uptime_seconds % 60}ç§’` : '-';
            }

            updateConnectionStatus(status, text) {
                this.elements.connectionStatus.className = `status-item ${status}`;
                this.elements.statusText.textContent = text;
            }

            updateCounters() {
                this.elements.countText.textContent = `å‘é€: ${this.sentCount} | æ¥æ”¶: ${this.receivedCount}`;
            }

            setControlsState(connected) {
                this.elements.connectBtn.disabled = connected;
                this.elements.disconnectBtn.disabled = !connected;
                this.elements.pingBtn.disabled = !connected;
                this.elements.testBtn.disabled = !connected;
                this.elements.messageInput.disabled = !connected;
                this.elements.sendBtn.disabled = !connected;
            }

            clearLog() {
                this.elements.log.textContent = '';
                this.sentCount = 0;
                this.receivedCount = 0;
                this.updateCounters();
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.elements.log.textContent += `[${timestamp}] ${message}\n`;
                this.elements.log.scrollTop = this.elements.log.scrollHeight;
            }
        }

        // åˆå§‹åŒ–å®¢æˆ·ç«¯
        const client = new WebSocketTestClient();
        
        // å®šæœŸè·å–æŒ‡æ ‡
        setInterval(() => {
            if (document.visibilityState === 'visible') {
                client.fetchMetrics();
            }
        }, 10000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

        <h3>ğŸ¯ ä½¿ç”¨æ­¥éª¤</h3>
        <ol>
            <li><strong>å®‰è£… Minikube:</strong></li>
            <pre><code># macOS
brew install minikube

# Ubuntu/Debian
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube</code></pre>

            <li><strong>è®¾ç½®å’Œå¯åŠ¨ Minikube:</strong></li>
            <pre><code>chmod +x scripts/*.sh
./scripts/setup-minikube.sh</code></pre>

            <li><strong>éƒ¨ç½² WebSocket æœåŠ¡:</strong></li>
            <pre><code>./scripts/deploy.sh</code></pre>

            <li><strong>æµ‹è¯•æœåŠ¡:</strong></li>
            <pre><code>./scripts/test-service.sh</code></pre>

            <li><strong>ç›‘æ§æœåŠ¡:</strong></li>
            <pre><code>./scripts/monitoring.sh</code></pre>

            <li><strong>ä½¿ç”¨ Web å®¢æˆ·ç«¯æµ‹è¯•:</strong></li>
            <pre><code># åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€
open web/test-client.html

# æˆ–è€…å¯åŠ¨æœ¬åœ°æœåŠ¡å™¨
python3 -m http.server 8080
# ç„¶åè®¿é—® http://localhost:8080/web/test-client.html</code></pre>
        </ol>

        <h3>ğŸ” å¸¸ç”¨è°ƒè¯•å‘½ä»¤</h3>
        <pre><code># æŸ¥çœ‹ Pod çŠ¶æ€
kubectl get pods -n websocket-app -o wide

# æŸ¥çœ‹ Pod æ—¥å¿—
kubectl logs -f deployment/websocket-server -n websocket-app

# è¿›å…¥ Pod å†…éƒ¨
kubectl exec -it deployment/websocket-server -n websocket-app -- /bin/bash

# æŸ¥çœ‹æœåŠ¡ä¿¡æ¯
kubectl describe service websocket-service -n websocket-app

# ç«¯å£è½¬å‘åˆ°æœ¬åœ°
kubectl port-forward service/websocket-service 8080:3000 -n websocket-app

# ä½¿ç”¨ Minikube æœåŠ¡
minikube service websocket-service -n websocket-app

# æŸ¥çœ‹ Minikube ä»ªè¡¨æ¿
minikube dashboard</code></pre>

        <h3>ğŸŒŸ é«˜çº§åŠŸèƒ½</h3>
        <ul>
            <li><strong>å¤šç§è®¿é—®æ–¹å¼:</strong> NodePortã€port-forwardã€minikube service</li>
            <li><strong>å¥åº·æ£€æŸ¥:</strong> è‡ªåŠ¨å¥åº·å’Œå°±ç»ªæ€§æ£€æŸ¥</li>
            <li><strong>æŒ‡æ ‡ç›‘æ§:</strong> å†…ç½®æŒ‡æ ‡ç«¯ç‚¹å’Œå®æ—¶ç›‘æ§</li>
            <li><strong>é…ç½®ç®¡ç†:</strong> ConfigMap çƒ­é‡è½½</li>
            <li><strong>èµ„æºé™åˆ¶:</strong> CPU å’Œå†…å­˜èµ„æºç®¡ç†</li>
            <li><strong>è´Ÿè½½æµ‹è¯•:</strong> å†…ç½®å‹åŠ›æµ‹è¯•åŠŸèƒ½</li>
            <li><strong>å®æ—¶ç›‘æ§:</strong> è‡ªåŠ¨åˆ·æ–°çš„ç›‘æ§ä»ªè¡¨æ¿</li>
        </ul>

        <h3>ğŸ“ å­¦ä¹ è¦ç‚¹</h3>
        <ul>
            <li>ç†è§£ Minikube ä½œä¸ºæœ¬åœ° Kubernetes å¼€å‘ç¯å¢ƒçš„ä»·å€¼</li>
            <li>æŒæ¡ Kubernetes æœåŠ¡æš´éœ²çš„å¤šç§æ–¹å¼</li>
            <li>å­¦ä¼šä½¿ç”¨ kubectl è¿›è¡Œåº”ç”¨ç®¡ç†å’Œè°ƒè¯•</li>
            <li>å®è·µå®¹å™¨åŒ–åº”ç”¨çš„å¥åº·æ£€æŸ¥å’Œç›‘æ§</li>
            <li>ä½“éªŒ Kubernetes çš„è‡ªåŠ¨æ¢å¤å’Œæ‰©å±•èƒ½åŠ›</li>
        </ul>

        <p>ğŸ”— <a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-25</strong></p>
        <h2>Day 25 - Helm Chart åˆè¯†ï¼ˆå¯é€‰ï¼‰</h2>
        <p>ä»Šå¤©ä½ å°†å­¦ä¹  Helm Chart çš„åˆ›å»ºå’Œä½¿ç”¨ï¼Œå°†ä¹‹å‰çš„ Kubernetes é…ç½®è½¬æ¢ä¸ºå¯é‡ç”¨çš„æ¨¡æ¿ã€‚Helm æ˜¯ Kubernetes çš„åŒ…ç®¡ç†å™¨ï¼Œèƒ½å¤Ÿç®€åŒ–åº”ç”¨çš„éƒ¨ç½²ã€å‡çº§å’Œç®¡ç†è¿‡ç¨‹ã€‚</p>
        
        <h3>ğŸ¯ å­¦ä¹ ç›®æ ‡</h3>
        <ul>
            <li>ç†è§£ Helm Chart çš„æ¦‚å¿µå’Œä»·å€¼</li>
            <li>åˆ›å»º WebSocket æœåŠ¡çš„ Helm Chart</li>
            <li>å­¦ä¹ æ¨¡æ¿è¯­æ³•å’Œå€¼æ–‡ä»¶çš„ä½¿ç”¨</li>
            <li>å®ç°å¤šç¯å¢ƒéƒ¨ç½²é…ç½®</li>
            <li>æŒæ¡ Helm Chart çš„ç‰ˆæœ¬ç®¡ç†å’Œå‘å¸ƒ</li>
        </ul>

        <h3>ğŸ“ é¡¹ç›®ç»“æ„</h3>
        <pre>day25_helm_chart/
â”œâ”€â”€ websocket-chart/
â”‚   â”œâ”€â”€ Chart.yaml
â”‚   â”œâ”€â”€ values.yaml
â”‚   â”œâ”€â”€ values-dev.yaml
â”‚   â”œâ”€â”€ values-staging.yaml
â”‚   â”œâ”€â”€ values-prod.yaml
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”‚   â”œâ”€â”€ service.yaml
â”‚   â”‚   â”œâ”€â”€ configmap.yaml
â”‚   â”‚   â”œâ”€â”€ secret.yaml
â”‚   â”‚   â”œâ”€â”€ ingress.yaml
â”‚   â”‚   â”œâ”€â”€ hpa.yaml
â”‚   â”‚   â”œâ”€â”€ serviceaccount.yaml
â”‚   â”‚   â”œâ”€â”€ rbac.yaml
â”‚   â”‚   â”œâ”€â”€ networkpolicy.yaml
â”‚   â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”‚   â””â”€â”€ test-connection.yaml
â”‚   â”‚   â””â”€â”€ NOTES.txt
â”‚   â””â”€â”€ charts/
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ install-helm.sh
â”‚   â”œâ”€â”€ create-chart.sh
â”‚   â”œâ”€â”€ deploy-dev.sh
â”‚   â”œâ”€â”€ deploy-staging.sh
â”‚   â”œâ”€â”€ deploy-prod.sh
â”‚   â”œâ”€â”€ upgrade.sh
â”‚   â”œâ”€â”€ rollback.sh
â”‚   â””â”€â”€ package.sh
â”œâ”€â”€ environments/
â”‚   â”œâ”€â”€ dev.yaml
â”‚   â”œâ”€â”€ staging.yaml
â”‚   â””â”€â”€ production.yaml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ server.rs
â”‚   â”œâ”€â”€ config.rs
â”‚   â””â”€â”€ health.rs
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ Cargo.toml
â””â”€â”€ README.md</pre>

        <h3>ğŸš€ å®ç°æ­¥éª¤</h3>

        <h4>æ­¥éª¤ 1: å®‰è£…å’Œé…ç½® Helm</h4>
        <p><strong>scripts/install-helm.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "ğŸš€ Installing and Configuring Helm"

# æ£€æŸ¥æ“ä½œç³»ç»Ÿ
OS=$(uname -s | tr '[:upper:]' '[:lower:]')
ARCH=$(uname -m)

case $ARCH in
    x86_64) ARCH="amd64" ;;
    aarch64) ARCH="arm64" ;;
    armv7l) ARCH="arm" ;;
esac

# æ£€æŸ¥ Helm æ˜¯å¦å·²å®‰è£…
if command -v helm &> /dev/null; then
    echo "âœ… Helm is already installed: $(helm version --short)"
else
    echo "ğŸ“¦ Installing Helm..."
    
    # ä¸‹è½½å¹¶å®‰è£… Helm
    HELM_VERSION="v3.13.3"
    HELM_TAR="helm-${HELM_VERSION}-${OS}-${ARCH}.tar.gz"
    HELM_URL="https://get.helm.sh/${HELM_TAR}"
    
    echo "ğŸ“¥ Downloading Helm ${HELM_VERSION}..."
    curl -fsSL "${HELM_URL}" -o "/tmp/${HELM_TAR}"
    
    echo "ğŸ“‚ Extracting Helm..."
    tar -zxf "/tmp/${HELM_TAR}" -C /tmp
    
    echo "ğŸ”§ Installing Helm to /usr/local/bin..."
    sudo mv "/tmp/${OS}-${ARCH}/helm" /usr/local/bin/helm
    sudo chmod +x /usr/local/bin/helm
    
    echo "ğŸ—‘ï¸ Cleaning up..."
    rm -rf "/tmp/${HELM_TAR}" "/tmp/${OS}-${ARCH}"
    
    echo "âœ… Helm installed successfully: $(helm version --short)"
fi

# éªŒè¯ Kubernetes è¿æ¥
echo "ğŸ” Verifying Kubernetes connection..."
if ! kubectl cluster-info &> /dev/null; then
    echo "âŒ Kubernetes cluster not accessible. Please check your kubeconfig."
    exit 1
fi

echo "âœ… Kubernetes cluster is accessible"

# æ·»åŠ å¸¸ç”¨çš„ Helm ä»“åº“
echo "ğŸ“š Adding popular Helm repositories..."
helm repo add stable https://charts.helm.sh/stable 2>/dev/null || true
helm repo add bitnami https://charts.bitnami.com/bitnami 2>/dev/null || true
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts 2>/dev/null || true
helm repo add grafana https://grafana.github.io/helm-charts 2>/dev/null || true

echo "ğŸ”„ Updating Helm repositories..."
helm repo update

echo "ğŸ“‹ Available repositories:"
helm repo list

echo "âœ… Helm setup completed successfully!"</code></pre>

        <h4>æ­¥éª¤ 2: åˆ›å»º Helm Chart</h4>
        <p><strong>websocket-chart/Chart.yaml:</strong></p>
        <pre><code>apiVersion: v2
name: websocket-server
description: A production-ready WebSocket server built with Rust and Axum
type: application
version: 1.0.0
appVersion: "1.0.0"

home: https://github.com/your-username/websocket-server
sources:
  - https://github.com/your-username/websocket-server

maintainers:
  - name: Your Name
    email: your.email@example.com
    url: https://github.com/your-username

keywords:
  - websocket
  - rust
  - axum
  - real-time
  - server

annotations:
  category: Infrastructure
  licenses: MIT</code></pre>

        <p><strong>websocket-chart/values.yaml:</strong></p>
        <pre><code># Default values for websocket-server
# This is a YAML-formatted file.

replicaCount: 2

image:
  repository: websocket-server
  pullPolicy: IfNotPresent
  tag: "latest"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

podAnnotations: {}

podSecurityContext:
  fsGroup: 2000

securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000

service:
  type: ClusterIP
  port: 3000
  targetPort: 3000
  nodePort: 30000
  metricsPort: 9090

ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: websocket-server.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}

# WebSocket server configuration
config:
  server:
    port: 3000
    host: "0.0.0.0"
    maxConnections: 1000
    heartbeatInterval: 30
    readTimeout: 60
    writeTimeout: 60
  
  websocket:
    maxFrameSize: 65536
    maxMessageSize: 1048576
    compression: true
    pingInterval: 30
    pongTimeout: 10
  
  logging:
    level: "info"
    format: "json"
    output: "stdout"
  
  metrics:
    enabled: true
    port: 9090
    path: "/metrics"

# Health check configuration
healthCheck:
  enabled: true
  livenessProbe:
    httpGet:
      path: /health
      port: 3000
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  
  readinessProbe:
    httpGet:
      path: /ready
      port: 3000
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3

# Network policy
networkPolicy:
  enabled: false
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from: []
      ports:
        - protocol: TCP
          port: 3000
  egress:
    - {}

# RBAC configuration
rbac:
  create: true
  rules:
    - apiGroups: [""]
      resources: ["configmaps"]
      verbs: ["get", "list", "watch"]

# Environment-specific settings
environment: "development"

# External secrets (if using external secret management)
externalSecrets:
  enabled: false
  secretStore: ""
  secrets: []</code></pre>

        <h4>æ­¥éª¤ 3: åˆ›å»ºæ¨¡æ¿æ–‡ä»¶</h4>
        <p><strong>websocket-chart/templates/deployment.yaml:</strong></p>
        <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "websocket-server.fullname" . }}
  labels:
    {{- include "websocket-server.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "websocket-server.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
        {{- with .Values.podAnnotations }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
      labels:
        {{- include "websocket-server.selectorLabels" . | nindent 8 }}
    spec:
      {{- with .Values.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      serviceAccountName: {{ include "websocket-server.serviceAccountName" . }}
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}
      containers:
        - name: {{ .Chart.Name }}
          securityContext:
            {{- toYaml .Values.securityContext | nindent 12 }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: websocket
              containerPort: {{ .Values.service.targetPort }}
              protocol: TCP
            - name: metrics
              containerPort: {{ .Values.service.metricsPort }}
              protocol: TCP
          env:
            - name: RUST_LOG
              value: {{ .Values.config.logging.level | quote }}
            - name: CONFIG_PATH
              value: "/app/config/config.yaml"
            - name: ENVIRONMENT
              value: {{ .Values.environment | quote }}
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          volumeMounts:
            - name: config-volume
              mountPath: /app/config
              readOnly: true
            - name: tmp
              mountPath: /tmp
          {{- if .Values.healthCheck.enabled }}
          livenessProbe:
            {{- toYaml .Values.healthCheck.livenessProbe | nindent 12 }}
          readinessProbe:
            {{- toYaml .Values.healthCheck.readinessProbe | nindent 12 }}
          {{- end }}
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      volumes:
        - name: config-volume
          configMap:
            name: {{ include "websocket-server.fullname" . }}-config
        - name: tmp
          emptyDir: {}
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}</code></pre>

        <p><strong>websocket-chart/templates/service.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: Service
metadata:
  name: {{ include "websocket-server.fullname" . }}
  labels:
    {{- include "websocket-server.labels" . | nindent 4 }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: websocket
      protocol: TCP
      name: websocket
      {{- if and (eq .Values.service.type "NodePort") .Values.service.nodePort }}
      nodePort: {{ .Values.service.nodePort }}
      {{- end }}
    - port: {{ .Values.service.metricsPort }}
      targetPort: metrics
      protocol: TCP
      name: metrics
  selector:
    {{- include "websocket-server.selectorLabels" . | nindent 4 }}</code></pre>

        <p><strong>websocket-chart/templates/configmap.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "websocket-server.fullname" . }}-config
  labels:
    {{- include "websocket-server.labels" . | nindent 4 }}
data:
  config.yaml: |
    server:
      port: {{ .Values.config.server.port }}
      host: {{ .Values.config.server.host | quote }}
      max_connections: {{ .Values.config.server.maxConnections }}
      heartbeat_interval: {{ .Values.config.server.heartbeatInterval }}
      read_timeout: {{ .Values.config.server.readTimeout }}
      write_timeout: {{ .Values.config.server.writeTimeout }}
    
    websocket:
      max_frame_size: {{ .Values.config.websocket.maxFrameSize }}
      max_message_size: {{ .Values.config.websocket.maxMessageSize }}
      compression: {{ .Values.config.websocket.compression }}
      ping_interval: {{ .Values.config.websocket.pingInterval }}
      pong_timeout: {{ .Values.config.websocket.pongTimeout }}
    
    logging:
      level: {{ .Values.config.logging.level | quote }}
      format: {{ .Values.config.logging.format | quote }}
      output: {{ .Values.config.logging.output | quote }}
    
    metrics:
      enabled: {{ .Values.config.metrics.enabled }}
      port: {{ .Values.config.metrics.port }}
      path: {{ .Values.config.metrics.path | quote }}
    
    environment: {{ .Values.environment | quote }}</code></pre>

        <p><strong>websocket-chart/templates/_helpers.tpl:</strong></p>
        <pre><code>{{/*
Expand the name of the chart.
*/}}
{{- define "websocket-server.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
*/}}
{{- define "websocket-server.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- if contains $name .Release.Name }}
{{- .Release.Name | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}
{{- end }}

{{/*
Create chart name and version as used by the chart label.
*/}}
{{- define "websocket-server.chart" -}}
{{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "websocket-server.labels" -}}
helm.sh/chart: {{ include "websocket-server.chart" . }}
{{ include "websocket-server.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
environment: {{ .Values.environment }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "websocket-server.selectorLabels" -}}
app.kubernetes.io/name: {{ include "websocket-server.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{/*
Create the name of the service account to use
*/}}
{{- define "websocket-server.serviceAccountName" -}}
{{- if .Values.serviceAccount.create }}
{{- default (include "websocket-server.fullname" .) .Values.serviceAccount.name }}
{{- else }}
{{- default "default" .Values.serviceAccount.name }}
{{- end }}
{{- end }}</code></pre>

        <h4>æ­¥éª¤ 4: ç¯å¢ƒç‰¹å®šçš„å€¼æ–‡ä»¶</h4>
        <p><strong>websocket-chart/values-dev.yaml:</strong></p>
        <pre><code># Development environment values
environment: "development"

replicaCount: 1

image:
  tag: "dev"
  pullPolicy: Always

service:
  type: NodePort
  nodePort: 30000

ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/websocket-services: "websocket-server-dev"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
  hosts:
    - host: websocket-dev.local
      paths:
        - path: /
          pathType: Prefix

resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 50m
    memory: 64Mi

config:
  server:
    maxConnections: 100
  logging:
    level: "debug"

autoscaling:
  enabled: false

healthCheck:
  livenessProbe:
    initialDelaySeconds: 10
  readinessProbe:
    initialDelaySeconds: 5</code></pre>

        <p><strong>websocket-chart/values-staging.yaml:</strong></p>
        <pre><code># Staging environment values
environment: "staging"

replicaCount: 2

image:
  tag: "staging"
  pullPolicy: Always

service:
  type: ClusterIP

ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/websocket-services: "websocket-server-staging"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    cert-manager.io/cluster-issuer: "letsencrypt-staging"
  hosts:
    - host: websocket-staging.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: websocket-staging-tls
      hosts:
        - websocket-staging.example.com

resources:
  limits:
    cpu: 400m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

config:
  server:
    maxConnections: 500
  logging:
    level: "info"

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 5
  targetCPUUtilizationPercentage: 70

networkPolicy:
  enabled: true</code></pre>

        <p><strong>websocket-chart/values-prod.yaml:</strong></p>
        <pre><code># Production environment values
environment: "production"

replicaCount: 3

image:
  tag: "1.0.0"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP

ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/websocket-services: "websocket-server-prod"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: websocket.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: websocket-prod-tls
      hosts:
        - websocket.example.com

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 200m
    memory: 256Mi

config:
  server:
    maxConnections: 2000
  logging:
    level: "warn"
    format: "json"

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 20
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

networkPolicy:
  enabled: true

# Production-specific settings
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65534
  fsGroup: 65534

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 65534

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - websocket-server
        topologyKey: kubernetes.io/hostname</code></pre>

        <h4>æ­¥éª¤ 5: éƒ¨ç½²è„šæœ¬</h4>
        <p><strong>scripts/deploy-dev.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "ğŸš€ Deploying WebSocket Server to Development Environment"

CHART_NAME="websocket-server"
NAMESPACE="websocket-dev"
RELEASE_NAME="websocket-dev"

# åˆ›å»ºå‘½åç©ºé—´
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# ç¡®ä¿ Docker é•œåƒå¯ç”¨ï¼ˆç”¨äº Minikubeï¼‰
if command -v minikube &> /dev/null && minikube status &> /dev/null; then
    echo "ğŸ³ Building image for Minikube..."
    eval $(minikube docker-env)
    docker build -t websocket-server:dev .
fi

# éƒ¨ç½² Helm Chart
echo "ğŸ“¦ Installing/Upgrading Helm release..."
helm upgrade --install $RELEASE_NAME ./websocket-chart \
    --namespace $NAMESPACE \
    --values ./websocket-chart/values-dev.yaml \
    --wait \
    --timeout=300s

# æ˜¾ç¤ºéƒ¨ç½²çŠ¶æ€
echo "ğŸ“Š Deployment status:"
kubectl get pods -n $NAMESPACE
echo ""
kubectl get services -n $NAMESPACE
echo ""

# ç­‰å¾… Pod å‡†å¤‡å°±ç»ª
echo "â³ Waiting for pods to be ready..."
kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=websocket-server -n $NAMESPACE --timeout=300s

# æ˜¾ç¤ºè®¿é—®ä¿¡æ¯
echo "âœ… Development deployment completed!"
echo ""
echo "ğŸŒ Access Information:"
if command -v minikube &> /dev/null && minikube status &> /dev/null; then
    MINIKUBE_IP=$(minikube ip)
    SERVICE_PORT=$(kubectl get service $RELEASE_NAME -n $NAMESPACE -o jsonpath='{.spec.ports[0].nodePort}')
    echo "   WebSocket URL: ws://$MINIKUBE_IP:$SERVICE_PORT/ws"
    echo "   Health Check: http://$MINIKUBE_IP:$SERVICE_PORT/health"
else
    echo "   Use: kubectl port-forward service/$RELEASE_NAME 8080:3000 -n $NAMESPACE"
    echo "   Then access: ws://localhost:8080/ws"
fi
echo ""
echo "ğŸ“ Useful commands:"
echo "   helm status $RELEASE_NAME -n $NAMESPACE"
echo "   kubectl logs -f deployment/$RELEASE_NAME -n $NAMESPACE"
echo "   helm uninstall $RELEASE_NAME -n $NAMESPACE"</code></pre>

        <p><strong>scripts/deploy-staging.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "ğŸš€ Deploying WebSocket Server to Staging Environment"

CHART_NAME="websocket-server"
NAMESPACE="websocket-staging"
RELEASE_NAME="websocket-staging"

# åˆ›å»ºå‘½åç©ºé—´
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# éƒ¨ç½² Helm Chart
echo "ğŸ“¦ Installing/Upgrading Helm release..."
helm upgrade --install $RELEASE_NAME ./websocket-chart \
    --namespace $NAMESPACE \
    --values ./websocket-chart/values-staging.yaml \
    --wait \
    --timeout=300s

# æ˜¾ç¤ºéƒ¨ç½²çŠ¶æ€
echo "ğŸ“Š Deployment status:"
kubectl get pods -n $NAMESPACE
echo ""
kubectl get services -n $NAMESPACE
echo ""
kubectl get ingress -n $NAMESPACE
echo ""

# ç­‰å¾… Pod å‡†å¤‡å°±ç»ª
echo "â³ Waiting for pods to be ready..."
kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=websocket-server -n $NAMESPACE --timeout=300s

# è¿è¡Œæµ‹è¯•
echo "ğŸ§ª Running connection tests..."
helm test $RELEASE_NAME -n $NAMESPACE

echo "âœ… Staging deployment completed!"
echo ""
echo "ğŸŒ Access Information:"
echo "   WebSocket URL: wss://websocket-staging.example.com/ws"
echo "   Health Check: https://websocket-staging.example.com/health"
echo ""
echo "ğŸ“ Useful commands:"
echo "   helm status $RELEASE_NAME -n $NAMESPACE"
echo "   kubectl logs -f deployment/$RELEASE_NAME -n $NAMESPACE"
echo "   helm rollback $RELEASE_NAME -n $NAMESPACE"</code></pre>

        <h4>æ­¥éª¤ 6: Helm Chart æµ‹è¯•</h4>
        <p><strong>websocket-chart/templates/tests/test-connection.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: "{{ include "websocket-server.fullname" . }}-test-connection"
  labels:
    {{- include "websocket-server.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": test
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  restartPolicy: Never
  containers:
    - name: wget
      image: busybox:1.35
      command: ['wget']
      args: ['{{ include "websocket-server.fullname" . }}:{{ .Values.service.port }}/health']
    - name: websocket-test
      image: appropriate/curl:latest
      command: 
        - /bin/sh
        - -c
        - |
          echo "Testing health endpoint..."
          curl -f http://{{ include "websocket-server.fullname" . }}:{{ .Values.service.port }}/health
          
          echo "Testing readiness endpoint..."
          curl -f http://{{ include "websocket-server.fullname" . }}:{{ .Values.service.port }}/ready
          
          echo "Testing metrics endpoint..."
          curl -f http://{{ include "websocket-server.fullname" . }}:{{ .Values.service.port }}/metrics
          
          echo "All tests passed!"</code></pre>

        <p><strong>websocket-chart/templates/NOTES.txt:</strong></p>
        <pre><code>ğŸ‰ WebSocket Server has been deployed successfully!

Environment: {{ .Values.environment }}
Release: {{ .Release.Name }}
Namespace: {{ .Release.Namespace }}

ğŸŒ Access Information:
{{- if .Values.ingress.enabled }}
{{- range $host := .Values.ingress.hosts }}
  {{- range .paths }}
  WebSocket URL: {{ if $.Values.ingress.tls }}wss{{ else }}ws{{ end }}://{{ $host.host }}{{ .path }}ws
  Health Check: {{ if $.Values.ingress.tls }}https{{ else }}http{{ end }}://{{ $host.host }}{{ .path }}health
  {{- end }}
{{- end }}
{{- else if contains "NodePort" .Values.service.type }}
  export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ include "websocket-server.fullname" . }})
  export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")
  WebSocket URL: ws://$NODE_IP:$NODE_PORT/ws
  Health Check: http://$NODE_IP:$NODE_PORT/health
{{- else if contains "LoadBalancer" .Values.service.type }}
  NOTE: It may take a few minutes for the LoadBalancer IP to be available.
        You can watch the status by running 'kubectl get --namespace {{ .Release.Namespace }} svc -w {{ include "websocket-server.fullname" . }}'
  export SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ include "websocket-server.fullname" . }} --template "{{"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}"}}")
  WebSocket URL: ws://$SERVICE_IP:{{ .Values.service.port }}/ws
  Health Check: http://$SERVICE_IP:{{ .Values.service.port }}/health
{{- else if contains "ClusterIP" .Values.service.type }}
  kubectl --namespace {{ .Release.Namespace }} port-forward svc/{{ include "websocket-server.fullname" . }} 8080:{{ .Values.service.port }}
  WebSocket URL: ws://127.0.0.1:8080/ws
  Health Check: http://127.0.0.1:8080/health
{{- end }}

ğŸ“ Useful Commands:
  Check status: helm status {{ .Release.Name }} -n {{ .Release.Namespace }}
  View logs: kubectl logs -f deployment/{{ include "websocket-server.fullname" . }} -n {{ .Release.Namespace }}
  Run tests: helm test {{ .Release.Name }} -n {{ .Release.Namespace }}
  
ğŸ“Š Monitoring:
  Metrics: {{ if .Values.ingress.enabled }}{{ if .Values.ingress.tls }}https{{ else }}http{{ end }}://{{ (index .Values.ingress.hosts 0).host }}/metrics{{ else }}kubectl port-forward svc/{{ include "websocket-server.fullname" . }} 9090:{{ .Values.service.metricsPort }} -n {{ .Release.Namespace }}{{ end }}

ğŸ”§ Management:
  Upgrade: helm upgrade {{ .Release.Name }} ./websocket-chart -n {{ .Release.Namespace }}
  Rollback: helm rollback {{ .Release.Name }} -n {{ .Release.Namespace }}
  Uninstall: helm uninstall {{ .Release.Name }} -n {{ .Release.Namespace }}

{{- if .Values.autoscaling.enabled }}
ğŸ”„ Auto-scaling is enabled:
  Min replicas: {{ .Values.autoscaling.minReplicas }}
  Max replicas: {{ .Values.autoscaling.maxReplicas }}
  Target CPU: {{ .Values.autoscaling.targetCPUUtilizationPercentage }}%
  {{- if .Values.autoscaling.targetMemoryUtilizationPercentage }}
  Target Memory: {{ .Values.autoscaling.targetMemoryUtilizationPercentage }}%
  {{- end }}
{{- end }}</code></pre>

        <h3>ğŸ¯ ä½¿ç”¨æ­¥éª¤</h3>
        <ol>
            <li><strong>å®‰è£… Helm:</strong></li>
            <pre><code>chmod +x scripts/*.sh
./scripts/install-helm.sh</code></pre>

            <li><strong>éªŒè¯ Chart è¯­æ³•:</strong></li>
            <pre><code>helm lint ./websocket-chart
helm template websocket-dev ./websocket-chart --values ./websocket-chart/values-dev.yaml</code></pre>

            <li><strong>éƒ¨ç½²åˆ°å¼€å‘ç¯å¢ƒ:</strong></li>
            <pre><code>./scripts/deploy-dev.sh</code></pre>

            <li><strong>è¿è¡Œæµ‹è¯•:</strong></li>
            <pre><code>helm test websocket-dev -n websocket-dev</code></pre>

            <li><strong>å‡çº§éƒ¨ç½²:</strong></li>
            <pre><code>helm upgrade websocket-dev ./websocket-chart \
    --namespace websocket-dev \
    --values ./websocket-chart/values-dev.yaml</code></pre>

            <li><strong>æŸ¥çœ‹éƒ¨ç½²çŠ¶æ€:</strong></li>
            <pre><code>helm status websocket-dev -n websocket-dev
helm history websocket-dev -n websocket-dev</code></pre>
        </ol>

        <h3>ğŸ”§ é«˜çº§æ“ä½œ</h3>
        <pre><code># æ‰“åŒ… Chart
helm package ./websocket-chart

# æ¨é€åˆ° Chart ä»“åº“
helm repo add my-repo https://my-chart-repo.com
helm push websocket-server-1.0.0.tgz my-repo

# å›æ»šåˆ°ä¸Šä¸€ç‰ˆæœ¬
helm rollback websocket-dev 1 -n websocket-dev

# æŸ¥çœ‹æ¸²æŸ“åçš„æ¨¡æ¿
helm get manifest websocket-dev -n websocket-dev

# éªŒè¯ Chart å€¼
helm show values ./websocket-chart

# è°ƒè¯•æ¨¡æ¿
helm template websocket-dev ./websocket-chart --debug</code></pre>

        <h3>ğŸŒŸ Helm Chart ç‰¹æ€§</h3>
        <ul>
            <li><strong>æ¨¡æ¿åŒ–éƒ¨ç½²:</strong> æ”¯æŒå¤šç¯å¢ƒé…ç½®å’Œå‚æ•°åŒ–</li>
            <li><strong>ç‰ˆæœ¬ç®¡ç†:</strong> æ”¯æŒå‡çº§ã€å›æ»šå’Œå†å²è®°å½•</li>
            <li><strong>ä¾èµ–ç®¡ç†:</strong> å¯ä»¥åŒ…å«å­ Chart å’Œä¾èµ–é¡¹</li>
            <li><strong>é’©å­æœºåˆ¶:</strong> æ”¯æŒéƒ¨ç½²å‰åçš„è‡ªå®šä¹‰æ“ä½œ</li>
            <li><strong>æµ‹è¯•é›†æˆ:</strong> å†…ç½®è¿æ¥å’ŒåŠŸèƒ½æµ‹è¯•</li>
            <li><strong>å®‰å…¨é…ç½®:</strong> åŒ…å« RBACã€ç½‘ç»œç­–ç•¥å’Œå®‰å…¨ä¸Šä¸‹æ–‡</li>
            <li><strong>ç›‘æ§é›†æˆ:</strong> æ”¯æŒè‡ªåŠ¨æ‰©å±•å’Œèµ„æºç›‘æ§</li>
        </ul>

        <h3>ğŸ“ å­¦ä¹ è¦ç‚¹</h3>
        <ul>
            <li>ç†è§£ Helm Chart çš„ç»“æ„å’Œæ¨¡æ¿è¯­æ³•</li>
            <li>æŒæ¡å¤šç¯å¢ƒé…ç½®ç®¡ç†çš„æœ€ä½³å®è·µ</li>
            <li>å­¦ä¼šä½¿ç”¨ Helm è¿›è¡Œåº”ç”¨çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†</li>
            <li>å®è·µ Chart çš„æµ‹è¯•ã€æ‰“åŒ…å’Œå‘å¸ƒæµç¨‹</li>
            <li>ä½“éªŒ Kubernetes åº”ç”¨çš„æ ‡å‡†åŒ–éƒ¨ç½²æ–¹å¼</li>
        </ul>

        <p>ğŸ”— <a href="https://helm.sh/docs/chart_template_guide/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-26</strong></p>
        <h2>Day 26 - ç¼–å†™é¡¹ç›®è¯´æ˜ README.md</h2>
        <p>ä»Šå¤©ä½ å°†å­¦ä¹ å¦‚ä½•ç¼–å†™ä¸“ä¸šçš„é¡¹ç›®æ–‡æ¡£ï¼ŒåŒ…æ‹¬å®Œæ•´çš„ README.md å’Œç›¸å…³æ–‡æ¡£ã€‚å¥½çš„æ–‡æ¡£æ˜¯å¼€æºé¡¹ç›®æˆåŠŸçš„å…³é”®ï¼Œèƒ½å¤Ÿå¸®åŠ©ç”¨æˆ·å¿«é€Ÿç†è§£ã€å®‰è£…å’Œä½¿ç”¨ä½ çš„é¡¹ç›®ã€‚</p>
        
        <h3>ğŸ¯ å­¦ä¹ ç›®æ ‡</h3>
        <ul>
            <li>å­¦ä¹  Markdown è¯­æ³•å’Œæ–‡æ¡£ç»“æ„è®¾è®¡</li>
            <li>ç¼–å†™æ¸…æ™°ã€å…¨é¢çš„é¡¹ç›®è¯´æ˜æ–‡æ¡£</li>
            <li>åˆ›å»ºç”¨æˆ·å‹å¥½çš„å®‰è£…å’Œä½¿ç”¨æŒ‡å—</li>
            <li>åˆ¶ä½œé¡¹ç›®æ¼”ç¤ºå’Œæˆªå›¾å±•ç¤º</li>
            <li>å»ºç«‹å®Œæ•´çš„é¡¹ç›®æ–‡æ¡£ä½“ç³»</li>
        </ul>

        <h3>ğŸ“ é¡¹ç›®ç»“æ„</h3>
        <pre>day26_project_documentation/
â”œâ”€â”€ README.md
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ installation.md
â”‚   â”œâ”€â”€ configuration.md
â”‚   â”œâ”€â”€ api-reference.md
â”‚   â”œâ”€â”€ deployment.md
â”‚   â”œâ”€â”€ troubleshooting.md
â”‚   â”œâ”€â”€ contributing.md
â”‚   â”œâ”€â”€ changelog.md
â”‚   â””â”€â”€ examples/
â”‚       â”œâ”€â”€ basic-usage.md
â”‚       â”œâ”€â”€ advanced-features.md
â”‚       â””â”€â”€ kubernetes-deployment.md
â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ logo.png
â”‚   â”œâ”€â”€ architecture.png
â”‚   â”œâ”€â”€ demo.gif
â”‚   â””â”€â”€ screenshots/
â”‚       â”œâ”€â”€ dashboard.png
â”‚       â”œâ”€â”€ monitoring.png
â”‚       â””â”€â”€ test-client.png
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ basic-client.js
â”‚   â”œâ”€â”€ python-client.py
â”‚   â”œâ”€â”€ stress-test.js
â”‚   â””â”€â”€ docker-compose.yml
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ generate-docs.sh
â”‚   â”œâ”€â”€ update-readme.sh
â”‚   â””â”€â”€ create-demo.sh
â”œâ”€â”€ .github/
â”‚   â”œâ”€â”€ ISSUE_TEMPLATE/
â”‚   â”‚   â”œâ”€â”€ bug_report.md
â”‚   â”‚   â””â”€â”€ feature_request.md
â”‚   â””â”€â”€ PULL_REQUEST_TEMPLATE.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ SECURITY.md
â”œâ”€â”€ CODE_OF_CONDUCT.md
â””â”€â”€ src/
    â”œâ”€â”€ main.rs
    â”œâ”€â”€ server.rs
    â”œâ”€â”€ config.rs
    â””â”€â”€ health.rs</pre>

        <h3>ğŸš€ å®ç°æ­¥éª¤</h3>

        <h4>æ­¥éª¤ 1: ä¸» README.md æ–‡ä»¶</h4>
        <p><strong>README.md:</strong></p>
        <pre><code># ğŸš€ WebSocket Server

[![Rust](https://img.shields.io/badge/rust-1.70+-orange.svg)](https://www.rust-lang.org)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Build Status](https://github.com/your-username/websocket-server/workflows/CI/badge.svg)](https://github.com/your-username/websocket-server/actions)
[![Docker Pulls](https://img.shields.io/docker/pulls/your-username/websocket-server)](https://hub.docker.com/r/your-username/websocket-server)
[![Kubernetes](https://img.shields.io/badge/kubernetes-ready-brightgreen.svg)](https://kubernetes.io/)

A high-performance, production-ready WebSocket server built with Rust and Axum, featuring real-time messaging, comprehensive monitoring, and cloud-native deployment capabilities.

![Demo](assets/demo.gif)

## âœ¨ Features

- ğŸš€ **High Performance**: Built with Rust and Tokio for maximum concurrency
- ğŸ”„ **Real-time Messaging**: Bi-directional WebSocket communication
- ğŸ“Š **Comprehensive Monitoring**: Built-in metrics, health checks, and observability
- â˜ï¸ **Cloud Native**: Docker and Kubernetes ready with Helm charts
- ğŸ”§ **Hot Configuration**: Dynamic configuration reloading without restarts
- ğŸ›¡ï¸ **Production Ready**: Structured logging, error handling, and security features
- ğŸ“ˆ **Auto-scaling**: Horizontal Pod Autoscaler support
- ğŸŒ **Multi-environment**: Development, staging, and production configurations

## ğŸ—ï¸ Architecture

![Architecture](assets/architecture.png)

The WebSocket server is designed with a modular architecture:

- **WebSocket Handler**: Manages client connections and message routing
- **Configuration Manager**: Hot-reloadable configuration system
- **Health System**: Comprehensive health and readiness checks
- **Metrics Collector**: Prometheus-compatible metrics
- **Security Layer**: Authentication, authorization, and rate limiting

## ğŸš€ Quick Start

### Prerequisites

- [Rust 1.70+](https://rustup.rs/)
- [Docker](https://docs.docker.com/get-docker/) (optional)
- [Kubernetes](https://kubernetes.io/docs/setup/) with [Helm](https://helm.sh/) (for production deployment)

### Local Development

1. **Clone the repository**
   ```bash
   git clone https://github.com/your-username/websocket-server.git
   cd websocket-server
   ```

2. **Install dependencies and run**
   ```bash
   cargo run
   ```

3. **Test the connection**
   ```bash
   # Open the test client
   open web/test-client.html
   
   # Or use WebSocket client
   cargo install websocat
   websocat ws://localhost:3000/ws
   ```

### Docker Deployment

```bash
# Build and run with Docker
docker build -t websocket-server .
docker run -p 3000:3000 -p 9090:9090 websocket-server

# Or use Docker Compose
docker-compose up -d
```

### Kubernetes Deployment

```bash
# Deploy with Helm
helm install websocket-server ./helm-chart \
  --namespace websocket-app \
  --create-namespace \
  --values ./helm-chart/values-prod.yaml
```

## ğŸ“– Documentation

- [ğŸ“‹ Installation Guide](docs/installation.md)
- [âš™ï¸ Configuration](docs/configuration.md)
- [ğŸš€ Deployment Guide](docs/deployment.md)
- [ğŸ“¡ API Reference](docs/api-reference.md)
- [ğŸ”§ Troubleshooting](docs/troubleshooting.md)
- [ğŸ¤ Contributing](docs/contributing.md)

## ğŸ¯ Usage Examples

### Basic WebSocket Client (JavaScript)

```javascript
const ws = new WebSocket('ws://localhost:3000/ws');

ws.onopen = () => {
    console.log('Connected to WebSocket server');
    ws.send('Hello, Server!');
};

ws.onmessage = (event) => {
    console.log('Received:', event.data);
};

ws.onclose = () => {
    console.log('Connection closed');
};
```

### Python Client Example

```python
import asyncio
import websockets
import json

async def client():
    uri = "ws://localhost:3000/ws"
    async with websockets.connect(uri) as websocket:
        # Send a message
        await websocket.send("Hello from Python!")
        
        # Receive response
        response = await websocket.recv()
        print(f"Received: {response}")

asyncio.run(client())
```

### Configuration Example

```yaml
server:
  port: 3000
  host: "0.0.0.0"
  max_connections: 1000

websocket:
  max_frame_size: 65536
  compression: true
  ping_interval: 30

logging:
  level: "info"
  format: "json"
```

## ğŸ“Š Monitoring

The server provides comprehensive monitoring capabilities:

### Health Endpoints

- `GET /health` - Basic health check
- `GET /ready` - Readiness probe for Kubernetes
- `GET /metrics` - Prometheus metrics

### Key Metrics

- `websocket_connections_total` - Total number of connections
- `websocket_messages_sent_total` - Messages sent counter
- `websocket_messages_received_total` - Messages received counter
- `websocket_connection_duration_seconds` - Connection duration histogram

### Grafana Dashboard

Import the provided Grafana dashboard from `monitoring/grafana-dashboard.json` to visualize:

- Connection statistics
- Message throughput
- Response times
- Error rates
- Resource utilization

![Monitoring Dashboard](assets/screenshots/monitoring.png)

## ğŸš€ Performance

### Benchmarks

| Metric | Value |
|--------|-------|
| Concurrent Connections | 10,000+ |
| Messages per Second | 100,000+ |
| Memory Usage | ~50MB (idle) |
| CPU Usage | <5% (normal load) |

### Load Testing

```bash
# Run performance tests
cargo run --release --bin load-test

# Or use the provided scripts
./scripts/load-test.sh
```

## ğŸ› ï¸ Development

### Building from Source

```bash
# Debug build
cargo build

# Release build
cargo build --release

# Run tests
cargo test

# Run with logging
RUST_LOG=debug cargo run
```

### Development Workflow

1. Make your changes
2. Run tests: `cargo test`
3. Check formatting: `cargo fmt`
4. Run linter: `cargo clippy`
5. Update documentation
6. Submit a pull request

### Project Structure

```
src/
â”œâ”€â”€ main.rs           # Application entry point
â”œâ”€â”€ server.rs         # WebSocket server implementation
â”œâ”€â”€ config.rs         # Configuration management
â”œâ”€â”€ health.rs         # Health check system
â””â”€â”€ lib.rs           # Library exports

helm-chart/          # Kubernetes Helm chart
â”œâ”€â”€ templates/       # Kubernetes manifests
â”œâ”€â”€ values.yaml      # Default configuration
â””â”€â”€ Chart.yaml       # Chart metadata

docs/               # Documentation
â”œâ”€â”€ api-reference.md
â”œâ”€â”€ deployment.md
â””â”€â”€ examples/

tests/              # Integration tests
â”œâ”€â”€ integration_test.rs
â””â”€â”€ load_test.rs
```

## ğŸ³ Docker

### Multi-stage Dockerfile

The project uses a multi-stage Docker build for optimal image size:

```dockerfile
FROM rust:1.70 as builder
# Build stage...

FROM debian:bookworm-slim
# Runtime stage...
```

### Image Variants

- `websocket-server:latest` - Latest stable release
- `websocket-server:v1.0.0` - Specific version
- `websocket-server:dev` - Development build

## â˜¸ï¸ Kubernetes

### Helm Chart Features

- ConfigMap-based configuration
- Horizontal Pod Autoscaler
- Ingress with TLS support
- Network policies
- RBAC configuration
- Health checks
- Resource limits

### Deployment Environments

- **Development**: Single replica, debug logging
- **Staging**: 2 replicas, SSL termination
- **Production**: 3+ replicas, auto-scaling, monitoring

## ğŸ”’ Security

### Security Features

- Non-root container execution
- Read-only root filesystem
- Network policies
- Resource limits
- Security contexts

### Security Scanning

```bash
# Scan for vulnerabilities
cargo audit

# Docker image scanning
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  aquasec/trivy websocket-server:latest
```

## ğŸ¤ Contributing

We welcome contributions! Please see our [Contributing Guide](docs/contributing.md) for details.

### Quick Contribution Steps

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/amazing-feature`
3. Make your changes
4. Add tests if applicable
5. Run the test suite: `cargo test`
6. Commit your changes: `git commit -m 'Add amazing feature'`
7. Push to the branch: `git push origin feature/amazing-feature`
8. Open a Pull Request

## ğŸ“ Changelog

See [CHANGELOG.md](docs/changelog.md) for version history and release notes.

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ†˜ Support

- ğŸ“– [Documentation](docs/)
- ğŸ› [Issue Tracker](https://github.com/your-username/websocket-server/issues)
- ğŸ’¬ [Discussions](https://github.com/your-username/websocket-server/discussions)
- ğŸ“§ Email: support@your-domain.com

## ğŸ† Acknowledgments

- [Tokio](https://tokio.rs/) - Asynchronous runtime
- [Axum](https://github.com/tokio-rs/axum) - Web framework
- [Serde](https://serde.rs/) - Serialization framework
- [Tracing](https://tracing.rs/) - Structured logging
- The Rust community for their amazing ecosystem

## ğŸŒŸ Star History

[![Star History Chart](https://api.star-history.com/svg?repos=your-username/websocket-server&type=Date)](https://star-history.com/#your-username/websocket-server&Date)

---

**Made with â¤ï¸ in Rust**</code></pre>

        <h4>æ­¥éª¤ 2: å®‰è£…æŒ‡å—</h4>
        <p><strong>docs/installation.md:</strong></p>
        <pre><code># ğŸ“‹ Installation Guide

This guide covers all the ways to install and run the WebSocket server.

## System Requirements

### Minimum Requirements
- **OS**: Linux, macOS, or Windows 10+
- **RAM**: 512MB
- **CPU**: 1 core
- **Disk**: 100MB free space

### Recommended Requirements
- **OS**: Linux (Ubuntu 20.04+ / CentOS 8+)
- **RAM**: 2GB+
- **CPU**: 2+ cores
- **Disk**: 1GB+ free space

## Installation Methods

### 1. From Source (Recommended for Development)

#### Prerequisites
```bash
# Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env

# Verify installation
rustc --version
cargo --version
```

#### Installation Steps
```bash
# Clone the repository
git clone https://github.com/your-username/websocket-server.git
cd websocket-server

# Build and install
cargo build --release

# Run the server
cargo run --release
```

### 2. Pre-built Binaries

Download pre-built binaries from the [releases page](https://github.com/your-username/websocket-server/releases).

```bash
# Linux x86_64
wget https://github.com/your-username/websocket-server/releases/latest/download/websocket-server-linux-x86_64.tar.gz
tar -xzf websocket-server-linux-x86_64.tar.gz
./websocket-server

# macOS
wget https://github.com/your-username/websocket-server/releases/latest/download/websocket-server-macos-x86_64.tar.gz
tar -xzf websocket-server-macos-x86_64.tar.gz
./websocket-server

# Windows
# Download websocket-server-windows-x86_64.zip and extract
```

### 3. Docker Installation

#### Pull from Docker Hub
```bash
docker pull your-username/websocket-server:latest
docker run -p 3000:3000 -p 9090:9090 your-username/websocket-server:latest
```

#### Build from Source
```bash
git clone https://github.com/your-username/websocket-server.git
cd websocket-server
docker build -t websocket-server .
docker run -p 3000:3000 -p 9090:9090 websocket-server
```

### 4. Package Managers

#### Homebrew (macOS)
```bash
brew tap your-username/tap
brew install websocket-server
```

#### Chocolatey (Windows)
```bash
choco install websocket-server
```

#### APT (Ubuntu/Debian)
```bash
curl -fsSL https://pkg.your-domain.com/key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/websocket-server.gpg
echo "deb [signed-by=/usr/share/keyrings/websocket-server.gpg] https://pkg.your-domain.com/apt stable main" | sudo tee /etc/apt/sources.list.d/websocket-server.list
sudo apt update
sudo apt install websocket-server
```

### 5. Kubernetes Installation

#### Using Helm (Recommended)
```bash
# Add Helm repository
helm repo add websocket-server https://charts.your-domain.com
helm repo update

# Install with default values
helm install my-websocket websocket-server/websocket-server

# Install with custom values
helm install my-websocket websocket-server/websocket-server \
  --values custom-values.yaml \
  --namespace websocket-app \
  --create-namespace
```

#### Using kubectl
```bash
# Apply Kubernetes manifests
kubectl apply -f https://raw.githubusercontent.com/your-username/websocket-server/main/k8s/
```

## Configuration

### Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `PORT` | `3000` | Server listening port |
| `HOST` | `0.0.0.0` | Server listening host |
| `RUST_LOG` | `info` | Log level |
| `CONFIG_PATH` | `config.yaml` | Configuration file path |

### Configuration File

Create a `config.yaml` file:

```yaml
server:
  port: 3000
  host: "0.0.0.0"
  max_connections: 1000

websocket:
  max_frame_size: 65536
  compression: true

logging:
  level: "info"
  format: "json"
```

## Verification

### Check Installation
```bash
# Check if server is running
curl http://localhost:3000/health

# Expected response
{"status":"healthy","timestamp":"2025-01-01T00:00:00Z"}
```

### Test WebSocket Connection
```bash
# Install websocat for testing
cargo install websocat

# Test connection
websocat ws://localhost:3000/ws
```

## Troubleshooting

### Common Issues

#### Port Already in Use
```bash
# Check what's using port 3000
lsof -i :3000

# Kill the process
kill -9 <PID>
```

#### Permission Denied
```bash
# Run with elevated privileges
sudo ./websocket-server

# Or use a different port
./websocket-server --port 8080
```

#### Firewall Issues
```bash
# Open port in firewall (Ubuntu)
sudo ufw allow 3000/tcp

# CentOS/RHEL
sudo firewall-cmd --permanent --add-port=3000/tcp
sudo firewall-cmd --reload
```

## Next Steps

- [Configuration Guide](configuration.md)
- [Deployment Guide](deployment.md)
- [API Reference](api-reference.md)
- [Examples](examples/)

## Getting Help

If you encounter issues during installation:

1. Check the [troubleshooting guide](troubleshooting.md)
2. Search [existing issues](https://github.com/your-username/websocket-server/issues)
3. Create a [new issue](https://github.com/your-username/websocket-server/issues/new) with:
   - Operating system and version
   - Installation method used
   - Error messages or logs
   - Steps to reproduce</code></pre>

        <h4>æ­¥éª¤ 3: API å‚è€ƒæ–‡æ¡£</h4>
        <p><strong>docs/api-reference.md:</strong></p>
        <pre><code># ğŸ“¡ API Reference

This document provides detailed information about all the APIs available in the WebSocket server.

## WebSocket API

### Connection Endpoint

**Endpoint**: `ws://localhost:3000/ws`

Establishes a WebSocket connection to the server.

#### Connection Flow

1. **Client connects** to the WebSocket endpoint
2. **Server accepts** and assigns a unique client ID
3. **Bidirectional communication** begins
4. **Server sends welcome message** with client information

#### Example Connection (JavaScript)

```javascript
const ws = new WebSocket('ws://localhost:3000/ws');

ws.onopen = function(event) {
    console.log('Connected to WebSocket server');
};

ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    console.log('Received:', data);
};

ws.onclose = function(event) {
    console.log('Connection closed:', event.code, event.reason);
};

ws.onerror = function(error) {
    console.error('WebSocket error:', error);
};
```

### Message Format

All WebSocket messages use JSON format:

```json
{
    "type": "message_type",
    "client_id": "uuid",
    "timestamp": "2025-01-01T00:00:00Z",
    "data": {
        // Message-specific data
    }
}
```

#### Message Types

| Type | Direction | Description |
|------|-----------|-------------|
| `welcome` | Server â†’ Client | Initial connection confirmation |
| `echo` | Server â†’ Client | Echo response to client messages |
| `ping` | Client â†’ Server | Heartbeat message |
| `pong` | Server â†’ Client | Heartbeat response |
| `error` | Server â†’ Client | Error notification |
| `disconnect` | Bidirectional | Connection termination |

#### Welcome Message

Sent when a client successfully connects:

```json
{
    "type": "welcome",
    "client_id": "550e8400-e29b-41d4-a716-446655440000",
    "timestamp": "2025-01-01T00:00:00Z",
    "data": {
        "server_version": "1.0.0",
        "max_message_size": 1048576,
        "ping_interval": 30
    }
}
```

#### Echo Message

Server echoes back client messages with metadata:

```json
{
    "type": "echo",
    "client_id": "550e8400-e29b-41d4-a716-446655440000",
    "timestamp": "2025-01-01T00:00:00Z",
    "data": {
        "original_message": "Hello, Server!",
        "message_size": 14,
        "echo_count": 1
    }
}
```

## HTTP API

### Health Check Endpoints

#### GET /health

Returns the health status of the server.

**Response:**
```json
{
    "status": "healthy",
    "timestamp": "2025-01-01T00:00:00Z",
    "uptime_seconds": 3600,
    "version": "1.0.0"
}
```

**Status Codes:**
- `200 OK` - Server is healthy
- `503 Service Unavailable` - Server is unhealthy

#### GET /ready

Returns the readiness status for Kubernetes probes.

**Response:**
```json
{
    "status": "ready",
    "timestamp": "2025-01-01T00:00:00Z",
    "checks": {
        "database": "ok",
        "external_service": "ok"
    }
}
```

**Status Codes:**
- `200 OK` - Server is ready
- `503 Service Unavailable` - Server is not ready

### Metrics Endpoint

#### GET /metrics

Returns Prometheus-compatible metrics.

**Response Format:** Prometheus text format

**Sample Response:**
```
# HELP websocket_connections_total Total number of WebSocket connections
# TYPE websocket_connections_total counter
websocket_connections_total 1234

# HELP websocket_active_connections Current number of active connections
# TYPE websocket_active_connections gauge
websocket_active_connections 45

# HELP websocket_messages_sent_total Total messages sent to clients
# TYPE websocket_messages_sent_total counter
websocket_messages_sent_total 5678

# HELP websocket_messages_received_total Total messages received from clients
# TYPE websocket_messages_received_total counter
websocket_messages_received_total 5432

# HELP websocket_connection_duration_seconds Duration of WebSocket connections
# TYPE websocket_connection_duration_seconds histogram
websocket_connection_duration_seconds_bucket{le="1"} 10
websocket_connection_duration_seconds_bucket{le="5"} 25
websocket_connection_duration_seconds_bucket{le="10"} 40
websocket_connection_duration_seconds_bucket{le="+Inf"} 45
websocket_connection_duration_seconds_sum 180.5
websocket_connection_duration_seconds_count 45
```

### Client Management Endpoints

#### GET /clients

Returns information about connected clients.

**Response:**
```json
{
    "total_clients": 2,
    "clients": [
        {
            "id": "550e8400-e29b-41d4-a716-446655440000",
            "connected_at": "2025-01-01T00:00:00Z",
            "remote_addr": "192.168.1.100:54321",
            "user_agent": "Mozilla/5.0...",
            "messages_sent": 10,
            "messages_received": 8,
            "last_activity": "2025-01-01T00:05:00Z"
        }
    ]
}
```

#### GET /clients/{client_id}

Returns information about a specific client.

**Parameters:**
- `client_id` (UUID) - The client identifier

**Response:**
```json
{
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "connected_at": "2025-01-01T00:00:00Z",
    "remote_addr": "192.168.1.100:54321",
    "user_agent": "Mozilla/5.0...",
    "messages_sent": 10,
    "messages_received": 8,
    "last_activity": "2025-01-01T00:05:00Z",
    "connection_duration_seconds": 300
}
```

### Configuration Endpoints

#### GET /config

Returns the current server configuration.

**Response:**
```json
{
    "server": {
        "port": 3000,
        "host": "0.0.0.0",
        "max_connections": 1000
    },
    "websocket": {
        "max_frame_size": 65536,
        "compression": true,
        "ping_interval": 30
    },
    "logging": {
        "level": "info",
        "format": "json"
    }
}
```

#### POST /config/reload

Reloads the server configuration from the config file.

**Response:**
```json
{
    "status": "success",
    "message": "Configuration reloaded successfully",
    "timestamp": "2025-01-01T00:00:00Z"
}
```

**Error Response:**
```json
{
    "status": "error",
    "message": "Failed to reload configuration: Invalid YAML syntax",
    "timestamp": "2025-01-01T00:00:00Z"
}
```

## Error Handling

### HTTP Error Responses

All HTTP errors follow this format:

```json
{
    "error": {
        "code": "ERROR_CODE",
        "message": "Human readable error message",
        "details": "Additional error details",
        "timestamp": "2025-01-01T00:00:00Z"
    }
}
```

### Common HTTP Status Codes

| Code | Description |
|------|-------------|
| `200` | Success |
| `400` | Bad Request |
| `404` | Not Found |
| `500` | Internal Server Error |
| `503` | Service Unavailable |

### WebSocket Error Messages

WebSocket errors are sent as JSON messages:

```json
{
    "type": "error",
    "client_id": "550e8400-e29b-41d4-a716-446655440000",
    "timestamp": "2025-01-01T00:00:00Z",
    "data": {
        "code": "MESSAGE_TOO_LARGE",
        "message": "Message exceeds maximum size limit",
        "max_size": 1048576
    }
}
```

### WebSocket Close Codes

| Code | Description |
|------|-------------|
| `1000` | Normal Closure |
| `1001` | Going Away |
| `1002` | Protocol Error |
| `1003` | Unsupported Data |
| `1006` | Abnormal Closure |
| `1009` | Message Too Big |
| `1011` | Internal Error |

## Rate Limiting

The server implements rate limiting to prevent abuse:

- **Connection Rate**: 100 connections per minute per IP
- **Message Rate**: 1000 messages per minute per connection
- **HTTP Rate**: 1000 requests per minute per IP

Rate limit headers are included in HTTP responses:

```
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 999
X-RateLimit-Reset: 1640995200
```

## Authentication (Future Feature)

The server is designed to support authentication in future versions:

### JWT Token Authentication

```javascript
const ws = new WebSocket('ws://localhost:3000/ws', [], {
    headers: {
        'Authorization': 'Bearer your-jwt-token'
    }
});
```

### API Key Authentication

```bash
curl -H "X-API-Key: your-api-key" http://localhost:3000/metrics
```

## Client Libraries

### Official Client Libraries

- **JavaScript/TypeScript**: `@websocket-server/client`
- **Python**: `websocket-server-client`
- **Go**: `github.com/your-username/websocket-server-go`
- **Rust**: `websocket-server-client`

### Community Libraries

- **Java**: `websocket-server-java` (community maintained)
- **C#**: `WebSocketServer.Client` (community maintained)

## Examples

See the [examples directory](../examples/) for complete client implementations in various languages.

## Changelog

API changes are documented in the [changelog](changelog.md) with proper versioning.

## Support

For API-related questions:
- Create an issue on [GitHub](https://github.com/your-username/websocket-server/issues)
- Join our [Discord community](https://discord.gg/your-invite)
- Email: api-support@your-domain.com</code></pre>

        <h4>æ­¥éª¤ 4: è´¡çŒ®æŒ‡å—</h4>
        <p><strong>docs/contributing.md:</strong></p>
        <pre><code># ğŸ¤ Contributing to WebSocket Server

Thank you for your interest in contributing to WebSocket Server! This guide will help you get started with contributing to the project.

## Table of Contents

- [Code of Conduct](#code-of-conduct)
- [Getting Started](#getting-started)
- [Development Setup](#development-setup)
- [How to Contribute](#how-to-contribute)
- [Pull Request Process](#pull-request-process)
- [Coding Standards](#coding-standards)
- [Testing](#testing)
- [Documentation](#documentation)
- [Community](#community)

## Code of Conduct

This project and everyone participating in it is governed by our [Code of Conduct](../CODE_OF_CONDUCT.md). By participating, you are expected to uphold this code.

## Getting Started

### Ways to Contribute

- ğŸ› **Bug Reports**: Help us identify and fix bugs
- âœ¨ **Feature Requests**: Suggest new features or improvements
- ğŸ“ **Documentation**: Improve or translate our documentation
- ğŸ’» **Code**: Implement features, fix bugs, or improve performance
- ğŸ§ª **Testing**: Write tests or test new features
- ğŸ¨ **Design**: Improve UI/UX of our web interfaces
- ğŸ“¢ **Outreach**: Write blog posts, speak at conferences, or spread the word

### Good First Issues

Look for issues labeled `good first issue` for beginner-friendly contributions:
- https://github.com/your-username/websocket-server/labels/good%20first%20issue

## Development Setup

### Prerequisites

- [Rust 1.70+](https://rustup.rs/)
- [Git](https://git-scm.com/)
- [Docker](https://docs.docker.com/get-docker/) (optional)

### Setup Steps

1. **Fork and Clone**
   ```bash
   # Fork the repository on GitHub, then clone your fork
   git clone https://github.com/YOUR-USERNAME/websocket-server.git
   cd websocket-server
   
   # Add upstream remote
   git remote add upstream https://github.com/your-username/websocket-server.git
   ```

2. **Install Dependencies**
   ```bash
   # Install Rust toolchain
   rustup install stable
   rustup default stable
   
   # Install development tools
   rustup component add clippy rustfmt
   cargo install cargo-watch cargo-audit
   ```

3. **Build and Test**
   ```bash
   # Build the project
   cargo build
   
   # Run tests
   cargo test
   
   # Start development server
   cargo run
   ```

4. **Verify Setup**
   ```bash
   # Check health endpoint
   curl http://localhost:3000/health
   
   # Run linter
   cargo clippy
   
   # Check formatting
   cargo fmt --check
   ```

## How to Contribute

### Reporting Bugs

Before creating bug reports, please check the [existing issues](https://github.com/your-username/websocket-server/issues) to avoid duplicates.

**How to Submit a Bug Report:**

1. Use the [bug report template](../.github/ISSUE_TEMPLATE/bug_report.md)
2. Provide detailed steps to reproduce
3. Include relevant logs and error messages
4. Specify your environment (OS, Rust version, etc.)

**Good Bug Report Example:**

```
**Bug**: WebSocket connection drops after 30 seconds of inactivity

**Environment**:
- OS: Ubuntu 20.04
- Rust: 1.70.0
- Server version: 1.0.0

**Steps to Reproduce**:
1. Connect to ws://localhost:3000/ws
2. Don't send any messages
3. Wait 30 seconds
4. Connection drops with code 1006

**Expected**: Connection should remain open
**Actual**: Connection drops unexpectedly

**Logs**:
```
[2025-01-01T00:00:30Z ERROR] Connection timeout for client abc-123
```
```

### Suggesting Features

We welcome feature suggestions! Please:

1. Use the [feature request template](../.github/ISSUE_TEMPLATE/feature_request.md)
2. Clearly describe the feature and its benefits
3. Consider the impact on existing functionality
4. Provide examples or mockups if applicable

### Contributing Code

1. **Choose an Issue**
   - Browse [open issues](https://github.com/your-username/websocket-server/issues)
   - Comment on the issue to let others know you're working on it
   - Ask questions if anything is unclear

2. **Create a Branch**
   ```bash
   git checkout -b feature/your-feature-name
   # or
   git checkout -b fix/your-bug-fix
   ```

3. **Make Changes**
   - Write clear, self-documenting code
   - Follow our [coding standards](#coding-standards)
   - Add tests for new functionality
   - Update documentation as needed

4. **Test Your Changes**
   ```bash
   # Run all tests
   cargo test
   
   # Run integration tests
   cargo test --test integration_test
   
   # Check for security vulnerabilities
   cargo audit
   
   # Lint your code
   cargo clippy -- -D warnings
   
   # Format your code
   cargo fmt
   ```

5. **Commit Your Changes**
   ```bash
   git add .
   git commit -m "feat: add new WebSocket compression feature
   
   - Implement deflate compression for WebSocket messages
   - Add configuration option for compression level
   - Update documentation and tests"
   ```

## Pull Request Process

### Before Submitting

- [ ] Tests pass locally: `cargo test`
- [ ] Code is properly formatted: `cargo fmt`
- [ ] No linting errors: `cargo clippy`
- [ ] Documentation is updated
- [ ] Commit messages follow our convention

### Commit Message Convention

We use [Conventional Commits](https://www.conventionalcommits.org/):

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

**Types:**
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting, etc.)
- `refactor`: Code refactoring
- `test`: Adding or updating tests
- `chore`: Maintenance tasks

**Examples:**
```
feat(websocket): add message compression support

fix(config): resolve configuration reload issue

docs(api): update WebSocket API documentation

test(integration): add load testing scenarios
```

### Pull Request Template

When you create a PR, please fill out our [template](../.github/PULL_REQUEST_TEMPLATE.md):

- **Description**: What does this PR do?
- **Type of Change**: Bug fix, new feature, etc.
- **Testing**: How was this tested?
- **Checklist**: Confirm all requirements are met

### Review Process

1. **Automated Checks**: GitHub Actions will run tests and linting
2. **Code Review**: Maintainers will review your code
3. **Feedback**: Address any requested changes
4. **Approval**: Once approved, your PR will be merged

## Coding Standards

### Rust Style Guide

We follow the [Rust Style Guide](https://doc.rust-lang.org/nightly/style-guide/) with these additions:

**Code Organization:**
- Use `mod.rs` for module declarations
- Group related functionality in modules
- Keep functions under 50 lines when possible
- Use meaningful variable and function names

**Error Handling:**
- Use `Result<T, E>` for fallible operations
- Implement proper error types with `thiserror`
- Log errors at appropriate levels
- Provide helpful error messages

**Documentation:**
- Document all public APIs with doc comments
- Include examples in doc comments
- Keep comments up-to-date with code changes

**Testing:**
- Write unit tests for all public functions
- Use integration tests for end-to-end scenarios
- Aim for >80% code coverage
- Use descriptive test names

### Code Example

```rust
use anyhow::Result;
use tracing::{info, warn};

/// Manages WebSocket client connections with automatic cleanup.
/// 
/// # Examples
/// 
/// ```rust
/// let manager = ConnectionManager::new(1000);
/// let client_id = manager.add_client(socket).await?;
/// ```
pub struct ConnectionManager {
    max_connections: usize,
    clients: Arc<RwLock<HashMap<Uuid, ClientInfo>>>,
}

impl ConnectionManager {
    /// Creates a new connection manager with the specified capacity.
    pub fn new(max_connections: usize) -> Self {
        Self {
            max_connections,
            clients: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// Adds a new client connection.
    /// 
    /// Returns the assigned client ID or an error if capacity is exceeded.
    pub async fn add_client(&self, socket: WebSocket) -> Result<Uuid> {
        let mut clients = self.clients.write().await;
        
        if clients.len() >= self.max_connections {
            warn!("Maximum connections reached: {}", self.max_connections);
            return Err(anyhow::anyhow!("Connection limit exceeded"));
        }
        
        let client_id = Uuid::new_v4();
        let client_info = ClientInfo::new(socket);
        
        clients.insert(client_id, client_info);
        info!("Client connected: {}", client_id);
        
        Ok(client_id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_add_client_success() {
        let manager = ConnectionManager::new(10);
        // Test implementation...
    }
    
    #[tokio::test]
    async fn test_add_client_capacity_exceeded() {
        let manager = ConnectionManager::new(0);
        // Test implementation...
    }
}
```

## Testing

### Test Categories

1. **Unit Tests**: Test individual functions and modules
2. **Integration Tests**: Test complete workflows
3. **Load Tests**: Test performance under load
4. **Security Tests**: Test for vulnerabilities

### Running Tests

```bash
# All tests
cargo test

# Unit tests only
cargo test --lib

# Integration tests only
cargo test --test integration_test

# Load tests (requires special setup)
cargo test --release --test load_test

# Test with logging
RUST_LOG=debug cargo test

# Test coverage (requires cargo-tarpaulin)
cargo install cargo-tarpaulin
cargo tarpaulin --html
```

### Writing Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    
    #[tokio::test]
    async fn test_websocket_connection() {
        // Setup
        let server = start_test_server().await;
        let client = connect_test_client(&server.addr).await;
        
        // Test
        client.send("Hello").await.unwrap();
        let response = client.receive().await.unwrap();
        
        // Assert
        assert_eq!(response.data, "Hello");
        assert!(response.timestamp.is_some());
    }
}
```

## Documentation

### Types of Documentation

1. **Code Documentation**: Inline comments and doc comments
2. **API Documentation**: Generated from doc comments
3. **User Documentation**: README, guides, tutorials
4. **Developer Documentation**: Contributing guide, architecture docs

### Writing Documentation

- Use clear, concise language
- Include practical examples
- Keep it up-to-date with code changes
- Consider non-native English speakers

### Building Documentation

```bash
# Generate API docs
cargo doc --open

# Check documentation
cargo doc --document-private-items

# Test documentation examples
cargo test --doc
```

## Community

### Getting Help

- **Discord**: [Join our Discord](https://discord.gg/your-invite)
- **GitHub Discussions**: [Ask questions](https://github.com/your-username/websocket-server/discussions)
- **Email**: dev-support@your-domain.com

### Maintainers

- [@maintainer1](https://github.com/maintainer1) - Lead Maintainer
- [@maintainer2](https://github.com/maintainer2) - Core Developer
- [@maintainer3](https://github.com/maintainer3) - Documentation Lead

### Recognition

Contributors are recognized in:
- [Contributors list](https://github.com/your-username/websocket-server/graphs/contributors)
- [Release notes](changelog.md)
- [Hall of Fame](https://websocket-server.dev/contributors) (website)

## Questions?

Don't hesitate to ask! We're here to help:
- Create a [discussion](https://github.com/your-username/websocket-server/discussions)
- Join our [Discord](https://discord.gg/your-invite)
- Email us at contributors@your-domain.com

Thank you for contributing to WebSocket Server! ğŸš€</code></pre>

        <h4>æ­¥éª¤ 5: æ–‡æ¡£ç”Ÿæˆè„šæœ¬</h4>
        <p><strong>scripts/generate-docs.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "ğŸ“š Generating Project Documentation"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if required tools are installed
check_requirements() {
    print_status "Checking requirements..."
    
    if ! command -v cargo &> /dev/null; then
        print_error "Cargo is not installed. Please install Rust."
        exit 1
    fi
    
    if ! command -v python3 &> /dev/null; then
        print_warning "Python3 not found. Some features may not work."
    fi
    
    if ! command -v node &> /dev/null; then
        print_warning "Node.js not found. Web documentation features may not work."
    fi
    
    print_success "Requirements check completed"
}

# Generate Rust API documentation
generate_api_docs() {
    print_status "Generating Rust API documentation..."
    
    # Generate documentation with all features
    cargo doc \
        --all-features \
        --no-deps \
        --document-private-items \
        --open
    
    print_success "Rust API documentation generated"
}

# Generate code coverage report
generate_coverage() {
    print_status "Generating code coverage report..."
    
    if command -v cargo-tarpaulin &> /dev/null; then
        cargo tarpaulin \
            --out Html \
            --output-dir docs/coverage \
            --exclude-files "tests/*" \
            --timeout 120
        
        print_success "Coverage report generated in docs/coverage/"
    else
        print_warning "cargo-tarpaulin not found. Install with: cargo install cargo-tarpaulin"
    fi
}

# Generate dependency tree
generate_dependency_tree() {
    print_status "Generating dependency tree..."
    
    if command -v cargo-tree &> /dev/null; then
        cargo tree --format "{p} {f}" > docs/dependencies.txt
        cargo tree --format "{p} {f}" --duplicates >> docs/dependencies.txt
        
        print_success "Dependency tree saved to docs/dependencies.txt"
    else
        print_warning "cargo-tree not found. Install with: cargo install cargo-tree"
    fi
}

# Generate security audit report
generate_security_audit() {
    print_status "Running security audit..."
    
    if command -v cargo-audit &> /dev/null; then
        cargo audit --format json > docs/security-audit.json || true
        cargo audit --format markdown > docs/security-audit.md || true
        
        print_success "Security audit saved to docs/"
    else
        print_warning "cargo-audit not found. Install with: cargo install cargo-audit"
    fi
}

# Generate performance benchmarks
generate_benchmarks() {
    print_status "Running performance benchmarks..."
    
    if [ -d "benches" ]; then
        cargo bench > docs/benchmarks.txt 2>&1 || true
        print_success "Benchmark results saved to docs/benchmarks.txt"
    else
        print_warning "No benchmarks directory found"
    fi
}

# Generate changelog from git history
generate_changelog() {
    print_status "Updating changelog..."
    
    # Check if git-cliff is available
    if command -v git-cliff &> /dev/null; then
        git-cliff --output docs/changelog.md
        print_success "Changelog updated"
    elif [ -f "CHANGELOG.md" ]; then
        cp CHANGELOG.md docs/changelog.md
        print_success "Changelog copied from root directory"
    else
        print_warning "No changelog generator found. Consider installing git-cliff"
    fi
}

# Validate all markdown files
validate_markdown() {
    print_status "Validating markdown files..."
    
    if command -v markdownlint &> /dev/null; then
        markdownlint docs/ README.md || true
        print_success "Markdown validation completed"
    else
        print_warning "markdownlint not found. Install with: npm install -g markdownlint-cli"
    fi
}

# Generate table of contents for README
update_readme_toc() {
    print_status "Updating README table of contents..."
    
    if command -v markdown-toc &> /dev/null; then
        markdown-toc -i README.md
        print_success "README table of contents updated"
    else
        print_warning "markdown-toc not found. Install with: npm install -g markdown-toc"
    fi
}

# Create documentation index
create_docs_index() {
    print_status "Creating documentation index..."
    
    cat > docs/README.md << 'EOF'
# ğŸ“š WebSocket Server Documentation

Welcome to the WebSocket Server documentation!

## ğŸ“– Documentation Structure

### User Documentation
- [Installation Guide](installation.md) - How to install and set up the server
- [Configuration Guide](configuration.md) - Configuration options and examples
- [Deployment Guide](deployment.md) - Production deployment instructions
- [Troubleshooting](troubleshooting.md) - Common issues and solutions

### Developer Documentation
- [API Reference](api-reference.md) - Complete API documentation
- [Contributing Guide](contributing.md) - How to contribute to the project
- [Architecture Overview](architecture.md) - System design and architecture
- [Examples](examples/) - Code examples and tutorials

### Reference
- [Changelog](changelog.md) - Version history and changes
- [Security Audit](security-audit.md) - Security vulnerability report
- [Dependencies](dependencies.txt) - Dependency tree and licenses
- [Coverage Report](coverage/) - Code coverage analysis
- [Benchmarks](benchmarks.txt) - Performance benchmark results

## ğŸš€ Quick Links

- [GitHub Repository](https://github.com/your-username/websocket-server)
- [Docker Hub](https://hub.docker.com/r/your-username/websocket-server)
- [Issue Tracker](https://github.com/your-username/websocket-server/issues)
- [Discussions](https://github.com/your-username/websocket-server/discussions)

## ğŸ†˜ Getting Help

- Check the [troubleshooting guide](troubleshooting.md)
- Search [existing issues](https://github.com/your-username/websocket-server/issues)
- Join our [Discord community](https://discord.gg/your-invite)
- Email: support@your-domain.com

---

Generated on $(date)
EOF
    
    print_success "Documentation index created"
}

# Generate example configurations
generate_example_configs() {
    print_status "Generating example configurations..."
    
    mkdir -p docs/examples/configs
    
    # Development configuration
    cat > docs/examples/configs/development.yaml << 'EOF'
# Development Configuration
server:
  port: 3000
  host: "0.0.0.0"
  max_connections: 100

websocket:
  max_frame_size: 65536
  max_message_size: 1048576
  compression: false
  ping_interval: 30
  pong_timeout: 10

logging:
  level: "debug"
  format: "pretty"
  output: "stdout"

metrics:
  enabled: true
  port: 9090
  path: "/metrics"

# Development-specific settings
debug:
  enable_debug_endpoints: true
  log_client_messages: true
EOF

    # Production configuration
    cat > docs/examples/configs/production.yaml << 'EOF'
# Production Configuration
server:
  port: 3000
  host: "0.0.0.0"
  max_connections: 10000

websocket:
  max_frame_size: 65536
  max_message_size: 1048576
  compression: true
  ping_interval: 30
  pong_timeout: 10

logging:
  level: "warn"
  format: "json"
  output: "stdout"

metrics:
  enabled: true
  port: 9090
  path: "/metrics"

# Production-specific settings
security:
  rate_limit_per_minute: 1000
  max_payload_size: 1048576
  enable_cors: false
EOF
    
    print_success "Example configurations generated"
}

# Main execution
main() {
    echo "ğŸš€ WebSocket Server Documentation Generator"
    echo "============================================="
    
    # Create docs directory if it doesn't exist
    mkdir -p docs/{coverage,examples/{configs,clients},assets}
    
    # Run all generation tasks
    check_requirements
    generate_api_docs
    generate_coverage
    generate_dependency_tree
    generate_security_audit
    generate_benchmarks
    generate_changelog
    validate_markdown
    update_readme_toc
    create_docs_index
    generate_example_configs
    
    echo ""
    echo "============================================="
    print_success "Documentation generation completed!"
    echo ""
    print_status "Generated files:"
    echo "  ğŸ“„ docs/README.md - Documentation index"
    echo "  ğŸ“Š docs/coverage/ - Code coverage report"
    echo "  ğŸ”’ docs/security-audit.md - Security audit"
    echo "  ğŸ“ˆ docs/benchmarks.txt - Performance benchmarks"
    echo "  ğŸ“ docs/changelog.md - Version changelog"
    echo "  ğŸŒ² docs/dependencies.txt - Dependency tree"
    echo "  âš™ï¸  docs/examples/configs/ - Example configurations"
    echo ""
    print_status "View the documentation:"
    echo "  ğŸŒ Open target/doc/websocket_server/index.html for API docs"
    echo "  ğŸ“– Check docs/README.md for documentation index"
    echo ""
}

# Run main function
main "$@"</code></pre>

        <h3>ğŸ¯ ä½¿ç”¨æ­¥éª¤</h3>
        <ol>
            <li><strong>ç”Ÿæˆæ–‡æ¡£:</strong></li>
            <pre><code>chmod +x scripts/generate-docs.sh
./scripts/generate-docs.sh</code></pre>

            <li><strong>éªŒè¯æ–‡æ¡£è´¨é‡:</strong></li>
            <pre><code># æ£€æŸ¥é“¾æ¥æœ‰æ•ˆæ€§
npm install -g markdown-link-check
find docs -name "*.md" -exec markdown-link-check {} \;

# æ£€æŸ¥æ‹¼å†™
npm install -g cspell
cspell "docs/**/*.md" "README.md"</code></pre>

            <li><strong>é¢„è§ˆæ–‡æ¡£:</strong></li>
            <pre><code># ä½¿ç”¨ Python å¯åŠ¨æœ¬åœ°æœåŠ¡å™¨
python3 -m http.server 8080
# è®¿é—® http://localhost:8080 æŸ¥çœ‹æ–‡æ¡£

# æˆ–ä½¿ç”¨ Node.js
npx serve .
</code></pre>
        </ol>

        <h3>ğŸŒŸ æ–‡æ¡£ç‰¹æ€§</h3>
        <ul>
            <li><strong>å®Œæ•´æ€§:</strong> æ¶µç›–å®‰è£…ã€é…ç½®ã€ä½¿ç”¨ã€éƒ¨ç½²å…¨æµç¨‹</li>
            <li><strong>å¤šå±‚æ¬¡:</strong> é¢å‘ç”¨æˆ·ã€å¼€å‘è€…ã€è´¡çŒ®è€…çš„ä¸åŒæ–‡æ¡£</li>
            <li><strong>å¯è§†åŒ–:</strong> åŒ…å«æ¶æ„å›¾ã€æ¼”ç¤ºåŠ¨å›¾ã€æˆªå›¾å±•ç¤º</li>
            <li><strong>äº¤äº’æ€§:</strong> æä¾›ä»£ç ç¤ºä¾‹å’Œå®é™…å¯è¿è¡Œçš„å®¢æˆ·ç«¯</li>
            <li><strong>ç»´æŠ¤æ€§:</strong> è‡ªåŠ¨åŒ–ç”Ÿæˆå’ŒéªŒè¯æœºåˆ¶</li>
            <li><strong>æ ‡å‡†åŒ–:</strong> éµå¾ªå¼€æºé¡¹ç›®æ–‡æ¡£æœ€ä½³å®è·µ</li>
            <li><strong>å¤šæ ¼å¼:</strong> æ”¯æŒ Markdownã€HTMLã€API æ–‡æ¡£ç­‰</li>
        </ul>

        <h3>ğŸ“ å­¦ä¹ è¦ç‚¹</h3>
        <ul>
            <li>æŒæ¡æŠ€æœ¯æ–‡æ¡£çš„ç»“æ„è®¾è®¡å’Œå†™ä½œæŠ€å·§</li>
            <li>å­¦ä¼šä½¿ç”¨ Markdown åˆ›å»ºä¸“ä¸šçš„é¡¹ç›®æ–‡æ¡£</li>
            <li>äº†è§£å¼€æºé¡¹ç›®æ–‡æ¡£çš„æ ‡å‡†å’Œæœ€ä½³å®è·µ</li>
            <li>å®è·µæ–‡æ¡£çš„è‡ªåŠ¨åŒ–ç”Ÿæˆå’Œç»´æŠ¤æµç¨‹</li>
            <li>ä½“éªŒç”¨æˆ·å‹å¥½çš„æ–‡æ¡£è®¾è®¡æ€è·¯</li>
        </ul>

        <p>ğŸ”— <a href="https://www.makeareadme.com/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-27</strong></p>
        <h2>Day 27 - æ¨é€é¡¹ç›®åˆ° GitHub</h2>
        <p>ä»Šå¤©ä½ å°†å­¦ä¹ å¦‚ä½•å°†é¡¹ç›®å‘å¸ƒåˆ° GitHubï¼ŒåŒ…æ‹¬ Git ä»“åº“åˆå§‹åŒ–ã€åˆ†æ”¯ç®¡ç†ã€CI/CD é…ç½®å’Œå¼€æºé¡¹ç›®ç®¡ç†ã€‚è¿™æ˜¯ç°ä»£è½¯ä»¶å¼€å‘ä¸å¯æˆ–ç¼ºçš„æŠ€èƒ½ï¼Œä¹Ÿæ˜¯é¡¹ç›®èµ°å‘å¼€æºå’Œåä½œçš„é‡è¦æ­¥éª¤ã€‚</p>
        
        <h3>ğŸ¯ å­¦ä¹ ç›®æ ‡</h3>
        <ul>
            <li>æŒæ¡ Git ç‰ˆæœ¬æ§åˆ¶å’Œåˆ†æ”¯ç®¡ç†ç­–ç•¥</li>
            <li>å­¦ä¼šåˆ›å»ºå’Œç®¡ç† GitHub ä»“åº“</li>
            <li>é…ç½® GitHub Actions CI/CD æµæ°´çº¿</li>
            <li>è®¾ç½®é¡¹ç›®å®‰å…¨å’Œè´¨é‡æ£€æŸ¥</li>
            <li>å®ç°è‡ªåŠ¨åŒ–å‘å¸ƒå’Œéƒ¨ç½²æµç¨‹</li>
        </ul>

        <h3>ğŸ“ é¡¹ç›®ç»“æ„</h3>
        <pre>day27_github_setup/
â”œâ”€â”€ .github/
â”‚   â”œâ”€â”€ workflows/
â”‚   â”‚   â”œâ”€â”€ ci.yml
â”‚   â”‚   â”œâ”€â”€ release.yml
â”‚   â”‚   â”œâ”€â”€ security.yml
â”‚   â”‚   â””â”€â”€ deploy.yml
â”‚   â”œâ”€â”€ ISSUE_TEMPLATE/
â”‚   â”‚   â”œâ”€â”€ bug_report.md
â”‚   â”‚   â”œâ”€â”€ feature_request.md
â”‚   â”‚   â””â”€â”€ security_issue.md
â”‚   â”œâ”€â”€ PULL_REQUEST_TEMPLATE.md
â”‚   â”œâ”€â”€ CODEOWNERS
â”‚   â””â”€â”€ dependabot.yml
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ setup-git.sh
â”‚   â”œâ”€â”€ create-release.sh
â”‚   â”œâ”€â”€ sync-fork.sh
â”‚   â””â”€â”€ github-setup.sh
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ CONTRIBUTING.md
â”‚   â”œâ”€â”€ CODE_OF_CONDUCT.md
â”‚   â”œâ”€â”€ SECURITY.md
â”‚   â””â”€â”€ SUPPORT.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ server.rs
â”‚   â”œâ”€â”€ config.rs
â”‚   â””â”€â”€ health.rs
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ integration_test.rs
â”‚   â””â”€â”€ e2e_test.rs
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .gitattributes
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ Cargo.toml
â””â”€â”€ rust-toolchain.toml</pre>

        <h3>ğŸš€ å®ç°æ­¥éª¤</h3>

        <h4>æ­¥éª¤ 1: Git ä»“åº“åˆå§‹åŒ–å’Œé…ç½®</h4>
        <p><strong>scripts/setup-git.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "ğŸš€ Setting up Git repository for WebSocket Server"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if git is installed
if ! command -v git &> /dev/null; then
    print_error "Git is not installed. Please install Git first."
    exit 1
fi

# Get user information
read -p "Enter your name for Git commits: " GIT_NAME
read -p "Enter your email for Git commits: " GIT_EMAIL
read -p "Enter your GitHub username: " GITHUB_USERNAME

# Configure Git globally if not already configured
if [ -z "$(git config --global user.name)" ]; then
    print_status "Configuring Git user information..."
    git config --global user.name "$GIT_NAME"
    git config --global user.email "$GIT_EMAIL"
    print_success "Git user configuration completed"
fi

# Configure Git settings for better experience
print_status "Configuring Git settings..."
git config --global init.defaultBranch main
git config --global pull.rebase false
git config --global core.autocrlf input
git config --global core.editor "code --wait" || git config --global core.editor "nano"
git config --global merge.conflictStyle diff3
git config --global diff.colorMoved zebra

# Initialize repository if not already a git repo
if [ ! -d ".git" ]; then
    print_status "Initializing Git repository..."
    git init
    print_success "Git repository initialized"
else
    print_warning "Already a Git repository"
fi

# Create .gitignore if it doesn't exist
if [ ! -f ".gitignore" ]; then
    print_status "Creating .gitignore file..."
    cat > .gitignore << 'EOF'
# Rust
/target/
**/*.rs.bk
*.pdb

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
*.log
logs/

# Environment variables
.env
.env.local
.env.*.local

# Node modules (for documentation tools)
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/

# Docker
.docker/

# Kubernetes
kubeconfig
*.kubeconfig

# Temporary files
*.tmp
*.temp
/tmp/

# Coverage reports
coverage/
*.profraw
tarpaulin-report.html

# Benchmarks
/benches/target/

# Documentation builds
/target/doc/
/docs/_build/

# Security
*.pem
*.key
*.crt
secrets.yaml
EOF
    print_success ".gitignore created"
fi

# Create .gitattributes for consistent line endings
if [ ! -f ".gitattributes" ]; then
    print_status "Creating .gitattributes file..."
    cat > .gitattributes << 'EOF'
# Auto detect text files and perform LF normalization
* text=auto

# Rust files
*.rs text eol=lf
*.toml text eol=lf

# Documentation
*.md text eol=lf
*.txt text eol=lf

# Scripts
*.sh text eol=lf
*.py text eol=lf
*.js text eol=lf
*.yml text eol=lf
*.yaml text eol=lf
*.json text eol=lf

# Binary files
*.png binary
*.jpg binary
*.jpeg binary
*.gif binary
*.ico binary
*.woff binary
*.woff2 binary
EOF
    print_success ".gitattributes created"
fi

# Create rust-toolchain.toml for consistent Rust version
if [ ! -f "rust-toolchain.toml" ]; then
    print_status "Creating rust-toolchain.toml..."
    cat > rust-toolchain.toml << 'EOF'
[toolchain]
channel = "stable"
components = ["rustfmt", "clippy", "rust-src"]
targets = ["x86_64-unknown-linux-gnu", "aarch64-unknown-linux-gnu"]
profile = "default"
EOF
    print_success "rust-toolchain.toml created"
fi

# Create initial commit if no commits exist
if [ -z "$(git log --oneline 2>/dev/null)" ]; then
    print_status "Creating initial commit..."
    git add .
    git commit -m "feat: initial commit

- Add WebSocket server implementation
- Configure development environment
- Add documentation and examples
- Set up CI/CD workflows

ğŸš€ Generated with Claude Code"
    print_success "Initial commit created"
fi

# Display current status
print_status "Repository status:"
git status --short
echo ""
git log --oneline -5

print_success "Git repository setup completed!"
echo ""
print_status "Next steps:"
echo "1. Create GitHub repository: gh repo create websocket-server --public"
echo "2. Add remote: git remote add origin https://github.com/$GITHUB_USERNAME/websocket-server.git"
echo "3. Push to GitHub: git push -u origin main"</code></pre>

        <h4>æ­¥éª¤ 2: GitHub Actions CI/CD é…ç½®</h4>
        <p><strong>.github/workflows/ci.yml:</strong></p>
        <pre><code>name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust:
          - stable
          - beta
          - 1.70.0  # MSRV (Minimum Supported Rust Version)
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
        components: rustfmt, clippy

    - name: Cache cargo registry
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ matrix.rust }}-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-${{ matrix.rust }}-
          ${{ runner.os }}-cargo-

    - name: Check formatting
      if: matrix.rust == 'stable'
      run: cargo fmt --all -- --check

    - name: Run clippy
      if: matrix.rust == 'stable'
      run: cargo clippy --all-targets --all-features -- -D warnings

    - name: Build
      run: cargo build --verbose --all-features

    - name: Run tests
      run: cargo test --verbose --all-features
      env:
        RUST_LOG: debug

    - name: Run integration tests
      run: cargo test --test integration_test --verbose
      env:
        RUST_LOG: debug

    - name: Generate documentation
      if: matrix.rust == 'stable'
      run: cargo doc --no-deps --all-features

  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable

    - name: Install cargo-tarpaulin
      run: cargo install cargo-tarpaulin

    - name: Generate coverage report
      run: cargo tarpaulin --verbose --all-features --workspace --timeout 120 --out xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: cobertura.xml
        fail_ci_if_error: true

  audit:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable

    - name: Install cargo-audit
      run: cargo install cargo-audit

    - name: Run security audit
      run: cargo audit

  docker:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [test]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: false
        tags: websocket-server:test
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Test Docker image
      run: |
        docker run --rm -d --name test-container -p 3000:3000 websocket-server:test
        sleep 10
        curl -f http://localhost:3000/health || exit 1
        docker stop test-container</code></pre>

        <h4>æ­¥éª¤ 3: GitHub ä»“åº“ç®¡ç†è„šæœ¬</h4>
        <p><strong>scripts/github-setup.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "ğŸš€ Setting up GitHub repository and integrations"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if GitHub CLI is installed
if ! command -v gh &> /dev/null; then
    print_error "GitHub CLI (gh) is not installed."
    print_warning "Please install it from: https://github.com/cli/cli#installation"
    print_warning "Or use the web interface to create the repository manually."
    exit 1
fi

# Check if user is authenticated
if ! gh auth status &> /dev/null; then
    print_warning "Not authenticated with GitHub. Please run: gh auth login"
    exit 1
fi

# Get repository information
read -p "Enter repository name (default: websocket-server): " REPO_NAME
REPO_NAME=${REPO_NAME:-websocket-server}

read -p "Enter repository description: " REPO_DESC
read -p "Make repository public? (y/N): " IS_PUBLIC

if [[ $IS_PUBLIC =~ ^[Yy]$ ]]; then
    VISIBILITY="--public"
else
    VISIBILITY="--private"
fi

# Create GitHub repository
print_status "Creating GitHub repository: $REPO_NAME"
if gh repo create "$REPO_NAME" $VISIBILITY --description "$REPO_DESC" --clone=false; then
    print_success "Repository created successfully"
else
    print_warning "Repository might already exist or creation failed"
fi

# Get GitHub username
GITHUB_USER=$(gh api user --jq '.login')

# Add remote if not already added
if ! git remote get-url origin &> /dev/null; then
    print_status "Adding GitHub remote..."
    git remote add origin "https://github.com/$GITHUB_USER/$REPO_NAME.git"
    print_success "Remote added"
else
    print_warning "Remote origin already exists"
fi

# Push to GitHub
print_status "Pushing code to GitHub..."
git push -u origin main

# Set up repository settings
print_status "Configuring repository settings..."

# Enable vulnerability alerts
gh api repos/$GITHUB_USER/$REPO_NAME --method PATCH --field has_vulnerability_alerts=true

# Set up branch protection
print_status "Setting up branch protection rules..."
gh api repos/$GITHUB_USER/$REPO_NAME/branches/main/protection \
    --method PUT \
    --field required_status_checks='{"strict":true,"contexts":["test","coverage","audit","docker"]}' \
    --field enforce_admins=true \
    --field required_pull_request_reviews='{"required_approving_review_count":1,"dismiss_stale_reviews":true,"require_code_owner_reviews":true}' \
    --field restrictions=null \
    --field allow_force_pushes=false \
    --field allow_deletions=false || print_warning "Branch protection setup failed (might require admin permissions)"

# Create repository labels
print_status "Creating repository labels..."
labels=(
    "bug,d73a4a,Something isn't working"
    "documentation,0075ca,Improvements or additions to documentation"
    "enhancement,a2eeef,New feature or request"
    "good first issue,7057ff,Good for newcomers"
    "help wanted,008672,Extra attention is needed"
    "priority:high,b60205,High priority"
    "priority:medium,fbca04,Medium priority"
    "priority:low,0e8a16,Low priority"
    "type:feature,0052cc,New feature"
    "type:bugfix,d93f0b,Bug fix"
    "type:docs,1d76db,Documentation"
    "status:in-progress,ededed,Work in progress"
    "status:needs-review,bfd4f2,Needs review"
)

for label in "${labels[@]}"; do
    IFS=',' read -r name color description <<< "$label"
    gh label create "$name" --color "$color" --description "$description" --force
done

print_success "Repository labels created"

# Set up repository topics
print_status "Adding repository topics..."
gh repo edit --add-topic "rust,websocket,server,axum,tokio,real-time,kubernetes,docker,ci-cd"

print_success "GitHub repository setup completed!"
echo ""
print_status "Repository URL: https://github.com/$GITHUB_USER/$REPO_NAME"
print_status "Actions URL: https://github.com/$GITHUB_USER/$REPO_NAME/actions"
echo ""
print_status "Next steps:"
echo "1. Set up repository secrets for CI/CD"
echo "2. Review and customize branch protection rules"
echo "3. Create your first release: git tag v0.1.0 && git push --tags"</code></pre>

        <h4>æ­¥éª¤ 4: è‡ªåŠ¨åŒ–å‘å¸ƒè„šæœ¬</h4>
        <p><strong>scripts/create-release.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "ğŸš€ Creating a new release for WebSocket Server"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check prerequisites
if ! command -v git &> /dev/null; then
    print_error "Git is not installed"
    exit 1
fi

if ! command -v cargo &> /dev/null; then
    print_error "Cargo is not installed"
    exit 1
fi

# Check if we're on main branch
CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "main" ]; then
    print_error "Not on main branch. Please switch to main branch first."
    exit 1
fi

# Check if working directory is clean
if [ -n "$(git status --porcelain)" ]; then
    print_error "Working directory is not clean. Please commit or stash changes."
    exit 1
fi

# Pull latest changes
print_status "Pulling latest changes from origin..."
git pull origin main

# Get current version from Cargo.toml
CURRENT_VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].version')
print_status "Current version: $CURRENT_VERSION"

# Ask for new version
echo "What type of release is this?"
echo "1) Patch (bug fixes)"
echo "2) Minor (new features, backward compatible)"
echo "3) Major (breaking changes)"
echo "4) Custom version"
read -p "Enter choice (1-4): " RELEASE_TYPE

case $RELEASE_TYPE in
    1)
        NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{$NF = $NF + 1;} 1' | sed 's/ /./g')
        ;;
    2)
        NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{$(NF-1) = $(NF-1) + 1; $NF = 0} 1' | sed 's/ /./g')
        ;;
    3)
        NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{$(NF-2) = $(NF-2) + 1; $(NF-1) = 0; $NF = 0} 1' | sed 's/ /./g')
        ;;
    4)
        read -p "Enter new version (e.g., 1.2.3): " NEW_VERSION
        ;;
    *)
        print_error "Invalid choice"
        exit 1
        ;;
esac

print_status "New version will be: $NEW_VERSION"
read -p "Continue? (y/N): " CONFIRM

if [[ ! $CONFIRM =~ ^[Yy]$ ]]; then
    print_warning "Release cancelled"
    exit 0
fi

# Update version in Cargo.toml
print_status "Updating Cargo.toml version..."
sed -i.bak "s/^version = \"$CURRENT_VERSION\"/version = \"$NEW_VERSION\"/" Cargo.toml
rm Cargo.toml.bak

# Update Cargo.lock
print_status "Updating Cargo.lock..."
cargo check --quiet

# Run tests to make sure everything works
print_status "Running tests..."
cargo test --all-features

# Generate changelog entry
print_status "Generating changelog entry..."
CHANGELOG_FILE="CHANGELOG.md"

# Get commits since last tag
LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
if [ -n "$LAST_TAG" ]; then
    COMMITS=$(git log --pretty=format:"- %s" $LAST_TAG..HEAD --reverse)
else
    COMMITS="- Initial release"
fi

# Create or update changelog
if [ ! -f "$CHANGELOG_FILE" ]; then
    echo "# Changelog" > $CHANGELOG_FILE
    echo "" >> $CHANGELOG_FILE
fi

# Add new version entry
TEMP_FILE=$(mktemp)
{
    echo "# Changelog"
    echo ""
    echo "## [v$NEW_VERSION] - $(date +%Y-%m-%d)"
    echo ""
    echo "$COMMITS"
    echo ""
    tail -n +3 "$CHANGELOG_FILE" 2>/dev/null || true
} > "$TEMP_FILE"
mv "$TEMP_FILE" "$CHANGELOG_FILE"

# Commit version bump and changelog
print_status "Committing version bump..."
git add Cargo.toml Cargo.lock $CHANGELOG_FILE
git commit -m "chore: bump version to v$NEW_VERSION

- Update version in Cargo.toml
- Update Cargo.lock
- Add changelog entry for v$NEW_VERSION

ğŸš€ Generated with Claude Code"

# Create and push tag
print_status "Creating git tag..."
git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"

# Push changes and tag
print_status "Pushing changes to GitHub..."
git push origin main
git push origin "v$NEW_VERSION"

# Create GitHub release if CLI is available
if command -v gh &> /dev/null; then
    print_status "Creating GitHub release..."
    gh release create "v$NEW_VERSION" \
        --title "Release v$NEW_VERSION" \
        --notes-from-tag \
        --target main
    
    print_success "GitHub release created!"
else
    print_warning "GitHub CLI not found. Please create the release manually."
fi

print_success "Release v$NEW_VERSION created successfully!"
echo ""
print_status "GitHub Actions will now build and publish:"
echo "  - Release binaries for multiple platforms"
echo "  - Docker images to Docker Hub"
echo "  - Crate to crates.io (if configured)"</code></pre>

        <h4>æ­¥éª¤ 5: Issue å’Œ PR æ¨¡æ¿</h4>
        <p><strong>.github/ISSUE_TEMPLATE/bug_report.md:</strong></p>
        <pre><code>---
name: ğŸ› Bug Report
about: Create a report to help us improve
title: '[BUG] '
labels: 'bug'
assignees: ''
---

## ğŸ› Bug Description
A clear and concise description of what the bug is.

## ğŸ”„ Steps to Reproduce
1. Go to '...'
2. Click on '....'
3. See error

## âœ… Expected Behavior
A clear description of what you expected to happen.

## âŒ Actual Behavior  
A clear description of what actually happened.

## ğŸŒ Environment
**Server Information:**
- OS: [e.g. Ubuntu 20.04, macOS 12.0]
- Rust version: [e.g. 1.70.0]
- WebSocket Server version: [e.g. 1.0.0]

**Client Information:**
- Browser/Client: [e.g. Chrome 91, Firefox 89]
- Client library: [e.g. native WebSocket, ws library]

## ğŸ“‹ Logs
<details>
<summary>Server Logs</summary>

```
Paste your server logs here
```
</details>

## âœ… Checklist
- [ ] I have searched for similar issues
- [ ] I have read the documentation
- [ ] I have provided all requested information</code></pre>

        <p><strong>.github/PULL_REQUEST_TEMPLATE.md:</strong></p>
        <pre><code># ğŸš€ Pull Request

## ğŸ“‹ Description
Brief description of the changes in this PR.

Fixes #(issue number)

## ğŸ”„ Type of Change
- [ ] ğŸ› Bug fix (non-breaking change which fixes an issue)
- [ ] âœ¨ New feature (non-breaking change which adds functionality)  
- [ ] ğŸ’¥ Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] ğŸ“ Documentation update
- [ ] ğŸ§ª Test improvements

## ğŸ§ª How Has This Been Tested?
Please describe the tests that you ran to verify your changes:

- [ ] Unit tests
- [ ] Integration tests
- [ ] Manual testing

## âœ… Checklist
**Code Quality:**
- [ ] My code follows the project's style guidelines
- [ ] I have performed a self-review of my own code
- [ ] I have run `cargo fmt` and `cargo clippy`

**Testing:**
- [ ] I have added tests that prove my fix is effective
- [ ] New and existing unit tests pass locally
- [ ] I have tested the WebSocket functionality manually

**Documentation:**
- [ ] I have updated the documentation accordingly
- [ ] I have added examples if this introduces new functionality

## ğŸ“ Additional Notes
Any additional information for reviewers.</code></pre>

        <h3>ğŸ¯ ä½¿ç”¨æ­¥éª¤</h3>
        <ol>
            <li><strong>åˆå§‹åŒ– Git ä»“åº“:</strong></li>
            <pre><code>chmod +x scripts/*.sh
./scripts/setup-git.sh</code></pre>

            <li><strong>åˆ›å»º GitHub ä»“åº“:</strong></li>
            <pre><code># å®‰è£… GitHub CLI
brew install gh  # macOS
# æˆ– apt install gh  # Ubuntu

# ç™»å½• GitHub
gh auth login

# åˆ›å»ºå¹¶é…ç½®ä»“åº“
./scripts/github-setup.sh</code></pre>

            <li><strong>æµ‹è¯• CI/CD æµæ°´çº¿:</strong></li>
            <pre><code># æ¨é€ä»£ç è§¦å‘ CI
git add .
git commit -m "feat: add awesome feature"
git push

# æŸ¥çœ‹ Actions çŠ¶æ€
gh run list</code></pre>

            <li><strong>åˆ›å»ºå‘å¸ƒç‰ˆæœ¬:</strong></li>
            <pre><code>./scripts/create-release.sh</code></pre>

            <li><strong>ç®¡ç†ä»“åº“è®¾ç½®:</strong></li>
            <pre><code># æŸ¥çœ‹ä»“åº“ä¿¡æ¯
gh repo view

# ç®¡ç†åˆ†æ”¯ä¿æŠ¤è§„åˆ™
gh api repos/:owner/:repo/branches/main/protection

# ç®¡ç† secrets
gh secret set DOCKER_USERNAME
gh secret set DOCKER_PASSWORD</code></pre>
        </ol>

        <h3>ğŸŒŸ GitHub é›†æˆç‰¹æ€§</h3>
        <ul>
            <li><strong>è‡ªåŠ¨åŒ– CI/CD:</strong> æµ‹è¯•ã€æ„å»ºã€å®‰å…¨æ‰«æå…¨æµç¨‹è‡ªåŠ¨åŒ–</li>
            <li><strong>å¤šå¹³å°æ„å»º:</strong> æ”¯æŒ Linuxã€macOSã€Windows å¤šæ¶æ„</li>
            <li><strong>Docker å‘å¸ƒ:</strong> è‡ªåŠ¨æ„å»ºå’Œå‘å¸ƒ Docker é•œåƒ</li>
            <li><strong>ä¾èµ–ç®¡ç†:</strong> Dependabot è‡ªåŠ¨æ›´æ–°ä¾èµ–</li>
            <li><strong>å®‰å…¨æ‰«æ:</strong> è‡ªåŠ¨å®‰å…¨æ¼æ´æ£€æµ‹å’Œä¿®å¤</li>
            <li><strong>ä»£ç è´¨é‡:</strong> è‡ªåŠ¨ä»£ç æ ¼å¼åŒ–å’Œé™æ€åˆ†æ</li>
            <li><strong>å‘å¸ƒç®¡ç†:</strong> è‡ªåŠ¨åŒ–ç‰ˆæœ¬å‘å¸ƒå’Œ changelog ç”Ÿæˆ</li>
        </ul>

        <h3>ğŸ“ å­¦ä¹ è¦ç‚¹</h3>
        <ul>
            <li>æŒæ¡ Git å·¥ä½œæµå’Œåˆ†æ”¯ç®¡ç†ç­–ç•¥</li>
            <li>å­¦ä¹  GitHub Actions çš„é…ç½®å’Œä½¿ç”¨</li>
            <li>äº†è§£å¼€æºé¡¹ç›®çš„ç®¡ç†å’Œåä½œæµç¨‹</li>
            <li>å®è·µ CI/CD æµæ°´çº¿çš„è®¾è®¡å’Œä¼˜åŒ–</li>
            <li>ä½“éªŒç°ä»£è½¯ä»¶å¼€å‘çš„è‡ªåŠ¨åŒ–å·¥å…·é“¾</li>
        </ul>

        <p>ğŸ”— <a href="https://docs.github.com/en/get-started" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-28</strong></p>
        <h2>Day 28 - Docker Hub éƒ¨ç½²ä¸å®¹å™¨æ³¨å†Œè¡¨ç®¡ç†</h2>
        <p>æŒæ¡ Docker Hub éƒ¨ç½²ç­–ç•¥ã€è‡ªåŠ¨åŒ–å‘å¸ƒæµæ°´çº¿ã€å¤šæ¶æ„é•œåƒæ„å»ºå’Œå®¹å™¨æ³¨å†Œè¡¨ç®¡ç†çš„æœ€ä½³å®è·µã€‚</p>
        
        <h3>å­¦ä¹ ç›®æ ‡</h3>
        <ul>
            <li>æŒæ¡ Docker Hub è´¦æˆ·è®¾ç½®å’Œä»“åº“ç®¡ç†</li>
            <li>å­¦ä¹ å¤šæ¶æ„ Docker é•œåƒæ„å»ºå’Œå‘å¸ƒ</li>
            <li>å®ç°è‡ªåŠ¨åŒ–å®¹å™¨å‘å¸ƒæµæ°´çº¿</li>
            <li>äº†è§£é•œåƒæ ‡ç­¾ç­–ç•¥å’Œç‰ˆæœ¬ç®¡ç†</li>
            <li>ä½“éªŒå®¹å™¨å®‰å…¨æ‰«æå’Œæ¼æ´ç®¡ç†</li>
            <li>å­¦ä¹ ç§æœ‰æ³¨å†Œè¡¨å’Œä¼ä¸šçº§éƒ¨ç½²ç­–ç•¥</li>
        </ul>
        <p>ğŸ”— <a href="https://docs.docker.com/docker-hub/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: Docker Hub è´¦æˆ·è®¾ç½®å’Œä»“åº“åˆ›å»º</strong></p>
        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day28_docker_deployment/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ websocket/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ server.rs
â”‚   â”‚   â”œâ”€â”€ client.rs
â”‚   â”‚   â””â”€â”€ message.rs
â”‚   â””â”€â”€ lib.rs
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ Dockerfile.alpine
â”œâ”€â”€ Dockerfile.distroless
â”œâ”€â”€ .dockerignore
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ docker-compose.prod.yml
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ build-multi-arch.sh
â”‚   â”œâ”€â”€ push-to-registry.sh
â”‚   â”œâ”€â”€ security-scan.sh
â”‚   â””â”€â”€ deploy-production.sh
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ docker-build.yml
â”‚       â”œâ”€â”€ docker-security.yml
â”‚       â””â”€â”€ docker-release.yml
â””â”€â”€ configs/
    â”œâ”€â”€ nginx.conf
    â”œâ”€â”€ docker-daemon.json
    â””â”€â”€ registry-config.yml</pre>

        <p><strong>Docker Hub è´¦æˆ·é…ç½®è„šæœ¬ï¼š</strong></p>
        <pre># scripts/setup-dockerhub.sh
#!/bin/bash
set -euo pipefail

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# æ£€æŸ¥ Docker æ˜¯å¦å®‰è£…
if ! command -v docker &> /dev/null; then
    log_error "Docker æœªå®‰è£…ï¼Œè¯·å…ˆå®‰è£… Docker"
    exit 1
fi

# æ£€æŸ¥ Docker æ˜¯å¦è¿è¡Œ
if ! docker info &> /dev/null; then
    log_error "Docker æœåŠ¡æœªè¿è¡Œï¼Œè¯·å¯åŠ¨ Docker"
    exit 1
fi

# Docker Hub ç™»å½•
log_info "é…ç½® Docker Hub è®¤è¯..."
read -p "è¾“å…¥ Docker Hub ç”¨æˆ·å: " DOCKER_USERNAME
read -s -p "è¾“å…¥ Docker Hub å¯†ç æˆ–è®¿é—®ä»¤ç‰Œ: " DOCKER_PASSWORD
echo

# ç™»å½•åˆ° Docker Hub
echo "$DOCKER_PASSWORD" | docker login --username "$DOCKER_USERNAME" --password-stdin

if [ $? -eq 0 ]; then
    log_info "Docker Hub ç™»å½•æˆåŠŸ"
else
    log_error "Docker Hub ç™»å½•å¤±è´¥"
    exit 1
fi

# ä¿å­˜é…ç½®
mkdir -p ~/.docker
cat > ~/.docker/config.json << EOF
{
    "auths": {
        "https://index.docker.io/v1/": {}
    },
    "experimental": "enabled",
    "features": {
        "buildkit": true
    }
}
EOF

# åˆ›å»º Docker Hub ä»“åº“é…ç½®
cat > .dockerhub-config << EOF
DOCKER_USERNAME=$DOCKER_USERNAME
DOCKER_REPOSITORY=rust-websocket-server
DOCKER_REGISTRY=docker.io
IMAGE_NAME=$DOCKER_USERNAME/rust-websocket-server
EOF

log_info "Docker Hub é…ç½®å®Œæˆ"
log_info "é…ç½®æ–‡ä»¶ä¿å­˜åœ¨: .dockerhub-config"
log_warn "è¯·ç¡®ä¿å°† .dockerhub-config æ·»åŠ åˆ° .gitignore ä¸­"</pre>

        <p><strong>æ­¥éª¤ 2: å¤šæ¶æ„ Dockerfile ä¼˜åŒ–</strong></p>
        <pre># Dockerfile - ç”Ÿäº§çº§å¤šé˜¶æ®µæ„å»º
# æ”¯æŒ linux/amd64, linux/arm64, linux/arm/v7
FROM --platform=$BUILDPLATFORM rust:1.75-alpine AS builder

# å®‰è£…æ„å»ºä¾èµ–
RUN apk add --no-cache \
    musl-dev \
    pkgconfig \
    openssl-dev \
    ca-certificates \
    git

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶ Cargo é…ç½®
COPY Cargo.toml Cargo.lock ./

# åˆ›å»ºç©ºçš„ src/main.rs ç”¨äºä¾èµ–ç¼“å­˜
RUN mkdir src && echo "fn main() {}" > src/main.rs

# æ„å»ºä¾èµ–ï¼ˆç¼“å­˜å±‚ï¼‰
RUN cargo build --release && rm -rf src

# å¤åˆ¶æºä»£ç 
COPY src ./src

# æ„å»ºåº”ç”¨
ARG TARGETPLATFORM
RUN case "$TARGETPLATFORM" in \
        "linux/amd64") TARGET="x86_64-unknown-linux-musl" ;; \
        "linux/arm64") TARGET="aarch64-unknown-linux-musl" ;; \
        "linux/arm/v7") TARGET="armv7-unknown-linux-musleabihf" ;; \
        *) echo "Unsupported platform: $TARGETPLATFORM" && exit 1 ;; \
    esac && \
    rustup target add $TARGET && \
    cargo build --release --target $TARGET && \
    cp target/$TARGET/release/rust-websocket-server /app/websocket-server

# è¿è¡Œæ—¶é•œåƒ
FROM scratch

# å¤åˆ¶ CA è¯ä¹¦
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# å¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /app/websocket-server /websocket-server

# åˆ›å»ºé root ç”¨æˆ·
COPY --from=builder /etc/passwd /etc/passwd
USER 1000:1000

# æš´éœ²ç«¯å£
EXPOSE 8080

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD ["/websocket-server", "--health-check"]

# å¯åŠ¨åº”ç”¨
ENTRYPOINT ["/websocket-server"]</pre>

        <p><strong>Alpine ç‰ˆæœ¬ Dockerfileï¼š</strong></p>
        <pre># Dockerfile.alpine - æ›´å°çš„é•œåƒä½†æœ‰ libc ä¾èµ–
FROM rust:1.75-alpine AS builder

RUN apk add --no-cache musl-dev pkgconfig openssl-dev

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

RUN cargo build --release --target x86_64-unknown-linux-musl

FROM alpine:3.19

RUN apk add --no-cache ca-certificates && \
    adduser -D -s /bin/sh -u 1000 appuser

COPY --from=builder /app/target/x86_64-unknown-linux-musl/release/rust-websocket-server /usr/local/bin/websocket-server

USER appuser
EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD websocket-server --health-check || exit 1

CMD ["websocket-server"]</pre>

        <p><strong>Distroless ç‰ˆæœ¬ Dockerfileï¼š</strong></p>
        <pre># Dockerfile.distroless - æœ€å°åŒ–å®‰å…¨é•œåƒ
FROM rust:1.75-bookworm AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

# é™æ€é“¾æ¥æ„å»º
ENV RUSTFLAGS="-C target-feature=+crt-static"
RUN cargo build --release --target x86_64-unknown-linux-gnu

FROM gcr.io/distroless/static-debian12:nonroot

COPY --from=builder /app/target/x86_64-unknown-linux-gnu/release/rust-websocket-server /websocket-server

EXPOSE 8080
USER nonroot:nonroot

ENTRYPOINT ["/websocket-server"]</pre>

        <p><strong>æ­¥éª¤ 3: å¤šæ¶æ„æ„å»ºè„šæœ¬</strong></p>
        <pre># scripts/build-multi-arch.sh
#!/bin/bash
set -euo pipefail

source .dockerhub-config

# é¢œè‰²è¾“å‡º
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# ç‰ˆæœ¬ç®¡ç†
VERSION=${1:-$(date +%Y%m%d-%H%M%S)}
LATEST_TAG="latest"
VERSION_TAG="v$VERSION"

log_info "æ„å»ºå¤šæ¶æ„ Docker é•œåƒ..."
log_info "ç‰ˆæœ¬: $VERSION_TAG"
log_info "é•œåƒå: $IMAGE_NAME"

# ç¡®ä¿ buildx å¯ç”¨
docker buildx version || {
    log_error "Docker buildx ä¸å¯ç”¨ï¼Œè¯·æ›´æ–° Docker"
    exit 1
}

# åˆ›å»ºå¤šæ¶æ„æ„å»ºå™¨
BUILDER_NAME="rust-websocket-builder"
if ! docker buildx ls | grep -q "$BUILDER_NAME"; then
    log_info "åˆ›å»ºå¤šæ¶æ„æ„å»ºå™¨..."
    docker buildx create --name "$BUILDER_NAME" --driver docker-container --bootstrap
fi

# ä½¿ç”¨æ„å»ºå™¨
docker buildx use "$BUILDER_NAME"

# æ„å»ºå¹¶æ¨é€å¤šæ¶æ„é•œåƒ
log_info "å¼€å§‹å¤šæ¶æ„æ„å»º..."

# ä¸»é•œåƒï¼ˆscratch åŸºç¡€ï¼‰
docker buildx build \
    --platform linux/amd64,linux/arm64,linux/arm/v7 \
    --tag "$IMAGE_NAME:$LATEST_TAG" \
    --tag "$IMAGE_NAME:$VERSION_TAG" \
    --tag "$IMAGE_NAME:scratch-$VERSION_TAG" \
    --push \
    -f Dockerfile \
    .

# Alpine é•œåƒ
docker buildx build \
    --platform linux/amd64,linux/arm64 \
    --tag "$IMAGE_NAME:alpine" \
    --tag "$IMAGE_NAME:alpine-$VERSION_TAG" \
    --push \
    -f Dockerfile.alpine \
    .

# Distroless é•œåƒ
docker buildx build \
    --platform linux/amd64,linux/arm64 \
    --tag "$IMAGE_NAME:distroless" \
    --tag "$IMAGE_NAME:distroless-$VERSION_TAG" \
    --push \
    -f Dockerfile.distroless \
    .

log_info "å¤šæ¶æ„é•œåƒæ„å»ºå®Œæˆï¼"
log_info "å¯ç”¨æ ‡ç­¾ï¼š"
echo "  - $IMAGE_NAME:latest"
echo "  - $IMAGE_NAME:$VERSION_TAG"
echo "  - $IMAGE_NAME:alpine"
echo "  - $IMAGE_NAME:distroless"

# æ˜¾ç¤ºé•œåƒä¿¡æ¯
log_info "éªŒè¯é•œåƒä¿¡æ¯..."
docker buildx imagetools inspect "$IMAGE_NAME:$LATEST_TAG"</pre>

        <p><strong>æ­¥éª¤ 4: è‡ªåŠ¨åŒ–å‘å¸ƒæµæ°´çº¿</strong></p>
        <pre># .github/workflows/docker-release.yml
name: Docker Release

on:
  push:
    tags:
      - 'v*'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version'
        required: true
        default: 'v1.0.0'

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write

    strategy:
      matrix:
        dockerfile:
          - { file: 'Dockerfile', tag: 'latest', platforms: 'linux/amd64,linux/arm64,linux/arm/v7' }
          - { file: 'Dockerfile.alpine', tag: 'alpine', platforms: 'linux/amd64,linux/arm64' }
          - { file: 'Dockerfile.distroless', tag: 'distroless', platforms: 'linux/amd64,linux/arm64' }

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        flavor: |
          latest=false
          suffix=-${{ matrix.dockerfile.tag }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=${{ matrix.dockerfile.tag }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ matrix.dockerfile.file }}
        platforms: ${{ matrix.dockerfile.platforms }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        provenance: true
        sbom: true

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.dockerfile.tag }}
        format: spdx-json
        output-file: sbom-${{ matrix.dockerfile.tag }}.spdx.json

    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom-${{ matrix.dockerfile.tag }}
        path: sbom-${{ matrix.dockerfile.tag }}.spdx.json

  security-scan:
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      security-events: write

    strategy:
      matrix:
        tag: ['latest', 'alpine', 'distroless']

    steps:
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.tag }}
        format: 'sarif'
        output: 'trivy-results-${{ matrix.tag }}.sarif'

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results-${{ matrix.tag }}.sarif'

  update-readme:
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
    - name: Update Docker Hub README
      uses: peter-evans/dockerhub-description@v4
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
        repository: ${{ env.IMAGE_NAME }}
        readme-filepath: ./README.md</pre>

        <p><strong>æ­¥éª¤ 5: å®‰å…¨æ‰«æå’Œæ¼æ´ç®¡ç†</strong></p>
        <pre># scripts/security-scan.sh
#!/bin/bash
set -euo pipefail

source .dockerhub-config

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# å®‰è£… Trivy
install_trivy() {
    if ! command -v trivy &> /dev/null; then
        log_info "å®‰è£… Trivy å®‰å…¨æ‰«æå·¥å…·..."
        if [[ "$OSTYPE" == "darwin"* ]]; then
            brew install trivy
        elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
        else
            log_error "ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿ"
            exit 1
        fi
    fi
}

# æ‰«æé•œåƒæ¼æ´
scan_image() {
    local image=$1
    local output_dir="security-reports"
    
    mkdir -p "$output_dir"
    
    log_info "æ‰«æé•œåƒ: $image"
    
    # æ¼æ´æ‰«æ
    trivy image \
        --format json \
        --output "$output_dir/vuln-${image//\//-}.json" \
        "$image"
    
    # ç”Ÿæˆ HTML æŠ¥å‘Š
    trivy image \
        --format template \
        --template '@contrib/html.tpl' \
        --output "$output_dir/vuln-${image//\//-}.html" \
        "$image"
    
    # æ£€æŸ¥é«˜å±æ¼æ´
    HIGH_VULNS=$(trivy image --format json "$image" | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")] | length')
    
    if [ "$HIGH_VULNS" -gt 0 ]; then
        log_warn "å‘ç° $HIGH_VULNS ä¸ªé«˜å±æ¼æ´"
        trivy image --severity HIGH,CRITICAL "$image"
    else
        log_info "æœªå‘ç°é«˜å±æ¼æ´"
    fi
}

# é…ç½®æ‰«æ
scan_configuration() {
    local dockerfile=$1
    
    log_info "æ‰«æé…ç½®æ–‡ä»¶: $dockerfile"
    
    # Dockerfile æœ€ä½³å®è·µæ£€æŸ¥
    trivy config \
        --format json \
        --output "security-reports/config-${dockerfile}.json" \
        "$dockerfile"
    
    # æ˜¾ç¤ºé…ç½®é—®é¢˜
    trivy config "$dockerfile"
}

# ä¸»æ‰«ææµç¨‹
main() {
    install_trivy
    
    log_info "å¼€å§‹å®‰å…¨æ‰«æ..."
    
    # æ‰«æ Dockerfile é…ç½®
    for dockerfile in Dockerfile Dockerfile.alpine Dockerfile.distroless; do
        if [ -f "$dockerfile" ]; then
            scan_configuration "$dockerfile"
        fi
    done
    
    # æ‰«ææ„å»ºçš„é•œåƒ
    IMAGES=(
        "$IMAGE_NAME:latest"
        "$IMAGE_NAME:alpine"
        "$IMAGE_NAME:distroless"
    )
    
    for image in "${IMAGES[@]}"; do
        if docker image inspect "$image" &> /dev/null; then
            scan_image "$image"
        else
            log_warn "é•œåƒä¸å­˜åœ¨: $image"
        fi
    done
    
    log_info "å®‰å…¨æ‰«æå®Œæˆï¼ŒæŠ¥å‘Šä¿å­˜åœ¨ security-reports/ ç›®å½•"
}

main "$@"</pre>

        <p><strong>æ­¥éª¤ 6: ç”Ÿäº§éƒ¨ç½²é…ç½®</strong></p>
        <pre># docker-compose.prod.yml
version: '3.8'

services:
  websocket-server:
    image: ${DOCKER_USERNAME}/rust-websocket-server:latest
    container_name: websocket-server-prod
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      - RUST_LOG=info
      - WEBSOCKET_HOST=0.0.0.0
      - WEBSOCKET_PORT=8080
      - MAX_CONNECTIONS=1000
      - CONNECTION_TIMEOUT=300
    volumes:
      - ./logs:/app/logs:rw
      - ./configs/server.toml:/app/config.toml:ro
    networks:
      - websocket-net
    healthcheck:
      test: ["CMD", "/websocket-server", "--health-check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    read_only: true
    tmpfs:
      - /tmp:size=100M,noexec,nosuid,nodev

  nginx:
    image: nginx:alpine
    container_name: nginx-proxy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./configs/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certs:/etc/nginx/certs:ro
      - ./logs/nginx:/var/log/nginx:rw
    networks:
      - websocket-net
    depends_on:
      websocket-server:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 128M

  redis:
    image: redis:alpine
    container_name: redis-cache
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis-data:/data
    networks:
      - websocket-net
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M

  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./configs/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    networks:
      - websocket-net
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
      - '--web.enable-lifecycle'

networks:
  websocket-net:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  redis-data:
    driver: local
  prometheus-data:
    driver: local</pre>

        <p><strong>ç”Ÿäº§éƒ¨ç½²è„šæœ¬ï¼š</strong></p>
        <pre># scripts/deploy-production.sh
#!/bin/bash
set -euo pipefail

source .dockerhub-config

# ç¯å¢ƒå˜é‡
ENVIRONMENT=${1:-production}
COMPOSE_FILE="docker-compose.prod.yml"

log_info() {
    echo -e "\033[0;32m[INFO]\033[0m $1"
}

log_warn() {
    echo -e "\033[1;33m[WARN]\033[0m $1"
}

log_error() {
    echo -e "\033[0;31m[ERROR]\033[0m $1"
}

# æ£€æŸ¥ä¾èµ–
check_dependencies() {
    local deps=("docker" "docker-compose")
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            log_error "$dep æœªå®‰è£…"
            exit 1
        fi
    done
}

# åˆ›å»ºå¿…è¦ç›®å½•
setup_directories() {
    local dirs=("logs" "logs/nginx" "configs" "certs")
    
    for dir in "${dirs[@]}"; do
        mkdir -p "$dir"
    done
}

# ç”Ÿæˆç¯å¢ƒé…ç½®
generate_env_file() {
    cat > .env << EOF
# Docker é…ç½®
DOCKER_USERNAME=$DOCKER_USERNAME
COMPOSE_PROJECT_NAME=websocket-prod

# å®‰å…¨é…ç½®
REDIS_PASSWORD=$(openssl rand -base64 32)

# æœåŠ¡é…ç½®
WEBSOCKET_MAX_CONNECTIONS=1000
WEBSOCKET_CONNECTION_TIMEOUT=300

# æ—¥å¿—é…ç½®
LOG_LEVEL=info
LOG_RETENTION_DAYS=30
EOF
    
    log_info "ç¯å¢ƒé…ç½®å·²ç”Ÿæˆ: .env"
}

# æ‹‰å–æœ€æ–°é•œåƒ
pull_images() {
    log_info "æ‹‰å–æœ€æ–°é•œåƒ..."
    docker-compose -f "$COMPOSE_FILE" pull
}

# å¥åº·æ£€æŸ¥
health_check() {
    local service=$1
    local retries=30
    
    log_info "ç­‰å¾… $service æœåŠ¡å¯åŠ¨..."
    
    for i in $(seq 1 $retries); do
        if docker-compose -f "$COMPOSE_FILE" exec -T "$service" wget --quiet --tries=1 --spider http://localhost:8080/health 2>/dev/null; then
            log_info "$service æœåŠ¡å¥åº·æ£€æŸ¥é€šè¿‡"
            return 0
        fi
        
        log_warn "å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œé‡è¯• $i/$retries"
        sleep 5
    done
    
    log_error "$service æœåŠ¡å¯åŠ¨å¤±è´¥"
    return 1
}

# éƒ¨ç½²æœåŠ¡
deploy() {
    log_info "å¼€å§‹éƒ¨ç½²åˆ° $ENVIRONMENT ç¯å¢ƒ..."
    
    # åœæ­¢æ—§æœåŠ¡
    docker-compose -f "$COMPOSE_FILE" down --remove-orphans
    
    # æ¸…ç†æ— ç”¨é•œåƒ
    docker image prune -f
    
    # å¯åŠ¨æœåŠ¡
    docker-compose -f "$COMPOSE_FILE" up -d
    
    # ç­‰å¾…æœåŠ¡å¯åŠ¨
    sleep 10
    
    # å¥åº·æ£€æŸ¥
    if health_check "websocket-server"; then
        log_info "éƒ¨ç½²æˆåŠŸï¼"
        
        # æ˜¾ç¤ºæœåŠ¡çŠ¶æ€
        docker-compose -f "$COMPOSE_FILE" ps
        
        # æ˜¾ç¤ºè®¿é—®ä¿¡æ¯
        echo "===================="
        echo "æœåŠ¡è®¿é—®ä¿¡æ¯ï¼š"
        echo "WebSocket: ws://localhost:8080"
        echo "ç›‘æ§é¢æ¿: http://localhost:9090"
        echo "===================="
    else
        log_error "éƒ¨ç½²å¤±è´¥"
        docker-compose -f "$COMPOSE_FILE" logs
        exit 1
    fi
}

# ä¸»æµç¨‹
main() {
    check_dependencies
    setup_directories
    generate_env_file
    pull_images
    deploy
}

# æ‰§è¡Œä¸»æµç¨‹
main "$@"</pre>

        <p><strong>æ­¥éª¤ 7: ç§æœ‰æ³¨å†Œè¡¨é…ç½®</strong></p>
        <pre># configs/registry-config.yml
version: 0.1
log:
  fields:
    service: registry
storage:
  cache:
    blobdescriptor: inmemory
  filesystem:
    rootdirectory: /var/lib/registry
  delete:
    enabled: true
http:
  addr: :5000
  headers:
    X-Content-Type-Options: [nosniff]
    Access-Control-Allow-Origin: ['*']
    Access-Control-Allow-Methods: ['HEAD', 'GET', 'OPTIONS', 'DELETE']
    Access-Control-Allow-Headers: ['Authorization', 'Accept', 'Cache-Control']
auth:
  htpasswd:
    realm: basic-realm
    path: /auth/htpasswd
health:
  storagedriver:
    enabled: true
    interval: 10s
    threshold: 3</pre>

        <p><strong>ç§æœ‰æ³¨å†Œè¡¨éƒ¨ç½²ï¼š</strong></p>
        <pre># docker-compose.registry.yml
version: '3.8'

services:
  registry:
    image: registry:2
    container_name: private-registry
    restart: unless-stopped
    ports:
      - "5000:5000"
    environment:
      REGISTRY_CONFIG_PATH: /etc/docker/registry/config.yml
    volumes:
      - ./configs/registry-config.yml:/etc/docker/registry/config.yml:ro
      - ./auth:/auth:ro
      - registry-data:/var/lib/registry
    networks:
      - registry-net

  registry-ui:
    image: joxit/docker-registry-ui:latest
    container_name: registry-ui
    restart: unless-stopped
    ports:
      - "8081:80"
    environment:
      REGISTRY_TITLE: Private Docker Registry
      REGISTRY_URL: http://registry:5000
      DELETE_IMAGES: true
      SHOW_CONTENT_DIGEST: true
    networks:
      - registry-net
    depends_on:
      - registry

networks:
  registry-net:
    driver: bridge

volumes:
  registry-data:
    driver: local</pre>

        <p><strong>æ­¥éª¤ 8: ç›‘æ§å’Œæ—¥å¿—ç®¡ç†</strong></p>
        <pre># configs/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "rules/*.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'websocket-server'
    static_configs:
      - targets: ['websocket-server:8080']
    metrics_path: '/metrics'
    scrape_interval: 10s

  - job_name: 'docker'
    static_configs:
      - targets: ['docker-exporter:9323']

  - job_name: 'node'
    static_configs:
      - targets: ['node-exporter:9100']</pre>

        <p><strong>å®è·µç»ƒä¹ ï¼š</strong></p>
        <ol>
            <li><strong>åŸºç¡€ Docker Hub éƒ¨ç½²</strong>
                <pre>cd day28_docker_deployment
./scripts/setup-dockerhub.sh
./scripts/build-multi-arch.sh v1.0.0</pre>
            </li>
            <li><strong>è‡ªåŠ¨åŒ–å®‰å…¨æ‰«æ</strong>
                <pre>./scripts/security-scan.sh
cat security-reports/vuln-*.json | jq '.Results[].Vulnerabilities | length'</pre>
            </li>
            <li><strong>ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²</strong>
                <pre>./scripts/deploy-production.sh production
docker-compose -f docker-compose.prod.yml logs -f</pre>
            </li>
            <li><strong>ç§æœ‰æ³¨å†Œè¡¨è®¾ç½®</strong>
                <pre>docker-compose -f docker-compose.registry.yml up -d
docker tag rust-websocket-server:latest localhost:5000/rust-websocket-server:latest
docker push localhost:5000/rust-websocket-server:latest</pre>
            </li>
        </ol>

        <p><strong>Docker Hub æœ€ä½³å®è·µï¼š</strong></p>
        <ul>
            <li>ä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬æ ‡ç­¾ (v1.0.0, v1.1.0)</li>
            <li>ä¸ºä¸åŒç”¨ä¾‹æä¾›å¤šç§é•œåƒå˜ä½“ (alpine, distroless)</li>
            <li>å¯ç”¨è‡ªåŠ¨æ„å»ºå’Œå®‰å…¨æ‰«æ</li>
            <li>ç¼–å†™è¯¦ç»†çš„ README æ–‡æ¡£</li>
            <li>å®šæœŸæ›´æ–°åŸºç¡€é•œåƒå’Œä¾èµ–</li>
            <li>ä½¿ç”¨å¤šé˜¶æ®µæ„å»ºå‡å°é•œåƒå¤§å°</li>
            <li>å®æ–½é•œåƒç­¾åå’ŒéªŒè¯</li>
            <li>ç›‘æ§é•œåƒä¸‹è½½å’Œä½¿ç”¨æƒ…å†µ</li>
        </ul>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-29</strong></p>
        <h2>Day 29 - ç»¼åˆçŸ¥è¯†å›é¡¾ä¸æ¶æ„ä¼˜åŒ–åˆ†æ</h2>
        <p>ç³»ç»Ÿå›é¡¾ Rust WebSocket é¡¹ç›®çš„å®Œæ•´æŠ€æœ¯æ ˆï¼Œè¿›è¡Œæ¶æ„åˆ†æå’Œæ€§èƒ½ä¼˜åŒ–ï¼Œåˆ¶å®šä¼ä¸šçº§éƒ¨ç½²å’Œæ‰©å±•ç­–ç•¥ã€‚</p>
        
        <h3>å­¦ä¹ ç›®æ ‡</h3>
        <ul>
            <li>å…¨é¢å›é¡¾ Rust è¯­è¨€æ ¸å¿ƒæ¦‚å¿µå’Œæœ€ä½³å®è·µ</li>
            <li>åˆ†æ WebSocket æœåŠ¡æ¶æ„è®¾è®¡å’Œæ€§èƒ½ç‰¹å¾</li>
            <li>è¯„ä¼°å®¹å™¨åŒ–éƒ¨ç½²å’Œ Kubernetes é›†æˆæ•ˆæœ</li>
            <li>åˆ¶å®šå¯è§‚æµ‹æ€§ã€å®‰å…¨æ€§å’Œå¯æ‰©å±•æ€§ä¼˜åŒ–è®¡åˆ’</li>
            <li>å‡†å¤‡ä¼ä¸šçº§é¡¹ç›®éƒ¨ç½²å’Œè¿ç»´ç­–ç•¥</li>
            <li>è®¾è®¡æœªæ¥åŠŸèƒ½æ‰©å±•å’ŒæŠ€æœ¯æ¼”è¿›è·¯çº¿å›¾</li>
        </ul>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: Rust è¯­è¨€çŸ¥è¯†ç‚¹å›é¡¾</strong></p>
        <pre>ğŸ“ é¡¹ç›®ç»“æ„ï¼š
day29_knowledge_review/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ review/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ basics.rs
â”‚   â”‚   â”œâ”€â”€ ownership.rs
â”‚   â”‚   â”œâ”€â”€ error_handling.rs
â”‚   â”‚   â”œâ”€â”€ async_programming.rs
â”‚   â”‚   â”œâ”€â”€ traits_generics.rs
â”‚   â”‚   â””â”€â”€ performance.rs
â”‚   â”œâ”€â”€ analysis/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ architecture.rs
â”‚   â”‚   â”œâ”€â”€ performance_metrics.rs
â”‚   â”‚   â”œâ”€â”€ security_audit.rs
â”‚   â”‚   â””â”€â”€ scalability.rs
â”‚   â””â”€â”€ planning/
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ optimization.rs
â”‚       â”œâ”€â”€ deployment.rs
â”‚       â””â”€â”€ roadmap.rs
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ benches/
â”‚   â”œâ”€â”€ websocket_performance.rs
â”‚   â”œâ”€â”€ memory_usage.rs
â”‚   â””â”€â”€ concurrent_connections.rs
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ architecture-review.md
â”‚   â”œâ”€â”€ performance-analysis.md
â”‚   â”œâ”€â”€ security-checklist.md
â”‚   â””â”€â”€ deployment-guide.md
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ review-checklist.sh
â”‚   â”œâ”€â”€ performance-test.sh
â”‚   â”œâ”€â”€ security-scan.sh
â”‚   â””â”€â”€ generate-report.sh
â””â”€â”€ configs/
    â”œâ”€â”€ prometheus-rules.yml
    â”œâ”€â”€ grafana-dashboard.json
    â””â”€â”€ alerting-rules.yml</pre>

        <p><strong>Rust åŸºç¡€æ¦‚å¿µå›é¡¾ä»£ç ï¼š</strong></p>
        <pre># src/review/basics.rs
//! Rust åŸºç¡€è¯­æ³•å’Œæ¦‚å¿µå›é¡¾

use std::collections::HashMap;
use std::fmt::Display;

/// åŸºç¡€è¯­æ³•å›é¡¾å’Œæœ€ä½³å®è·µæ¼”ç¤º
pub struct RustBasicsReview;

impl RustBasicsReview {
    /// å˜é‡ç»‘å®šå’Œå¯å˜æ€§å›é¡¾
    pub fn variable_bindings_review() {
        println!("=== å˜é‡ç»‘å®šå’Œå¯å˜æ€§ ===");
        
        // ä¸å¯å˜ç»‘å®šï¼ˆé»˜è®¤ï¼‰
        let immutable_value = 42;
        println!("ä¸å¯å˜å€¼: {}", immutable_value);
        
        // å¯å˜ç»‘å®š
        let mut mutable_value = 10;
        println!("åˆå§‹å¯å˜å€¼: {}", mutable_value);
        mutable_value += 5;
        println!("ä¿®æ”¹åå¯å˜å€¼: {}", mutable_value);
        
        // å˜é‡é®è”½ï¼ˆshadowingï¼‰
        let x = 5;
        let x = x * 2; // é®è”½å‰é¢çš„ x
        let x = format!("å€¼æ˜¯ {}", x); // æ”¹å˜ç±»å‹
        println!("é®è”½åçš„å€¼: {}", x);
        
        // å¸¸é‡
        const MAX_CONNECTIONS: u32 = 1000;
        println!("æœ€å¤§è¿æ¥æ•°: {}", MAX_CONNECTIONS);
    }
    
    /// æ•°æ®ç±»å‹å›é¡¾
    pub fn data_types_review() {
        println!("=== æ•°æ®ç±»å‹å›é¡¾ ===");
        
        // æ ‡é‡ç±»å‹
        let integer: i32 = 42;
        let float: f64 = 3.14159;
        let boolean: bool = true;
        let character: char = 'ğŸ¦€';
        
        println!("æ•´æ•°: {}, æµ®ç‚¹: {}, å¸ƒå°”: {}, å­—ç¬¦: {}", 
                integer, float, boolean, character);
        
        // å¤åˆç±»å‹
        let tuple: (i32, f64, bool) = (500, 6.4, true);
        let array: [i32; 5] = [1, 2, 3, 4, 5];
        
        let (x, y, z) = tuple; // å…ƒç»„è§£æ„
        println!("å…ƒç»„è§£æ„: x={}, y={}, z={}", x, y, z);
        println!("æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ : {}", array[0]);
        
        // å­—ç¬¦ä¸²ç±»å‹
        let string_literal = "Hello"; // &str
        let owned_string = String::from("World"); // String
        let concatenated = format!("{} {}", string_literal, owned_string);
        println!("å­—ç¬¦ä¸²è¿æ¥: {}", concatenated);
    }
    
    /// æ§åˆ¶æµå›é¡¾
    pub fn control_flow_review() {
        println!("=== æ§åˆ¶æµå›é¡¾ ===");
        
        // if è¡¨è¾¾å¼
        let number = 42;
        let result = if number % 2 == 0 {
            "å¶æ•°"
        } else {
            "å¥‡æ•°"
        };
        println!("{} æ˜¯ {}", number, result);
        
        // å¾ªç¯
        println!("for å¾ªç¯:");
        for i in 1..=5 {
            println!("  è®¡æ•°: {}", i);
        }
        
        println!("while å¾ªç¯:");
        let mut counter = 3;
        while counter > 0 {
            println!("  å€’è®¡æ—¶: {}", counter);
            counter -= 1;
        }
        
        println!("loop å¾ªç¯:");
        let mut x = 0;
        let result = loop {
            x += 1;
            if x == 3 {
                break x * 2; // loop å¯ä»¥è¿”å›å€¼
            }
        };
        println!("  loop è¿”å›å€¼: {}", result);
        
        // match è¡¨è¾¾å¼
        let value = Some(5);
        match value {
            Some(x) if x > 3 => println!("å¤§äº 3 çš„å€¼: {}", x),
            Some(x) => println!("å€¼: {}", x),
            None => println!("æ²¡æœ‰å€¼"),
        }
    }
    
    /// å‡½æ•°å’Œé—­åŒ…å›é¡¾
    pub fn functions_closures_review() {
        println!("=== å‡½æ•°å’Œé—­åŒ…å›é¡¾ ===");
        
        // æ™®é€šå‡½æ•°
        fn add(a: i32, b: i32) -> i32 {
            a + b // è¡¨è¾¾å¼è¿”å›
        }
        
        println!("å‡½æ•°è°ƒç”¨: 5 + 3 = {}", add(5, 3));
        
        // é—­åŒ…
        let multiply = |x: i32, y: i32| x * y;
        println!("é—­åŒ…è°ƒç”¨: 4 * 6 = {}", multiply(4, 6));
        
        // æ•è·ç¯å¢ƒçš„é—­åŒ…
        let factor = 10;
        let scale = |x: i32| x * factor; // æ•è· factor
        println!("ç¯å¢ƒæ•è·é—­åŒ…: 5 * {} = {}", factor, scale(5));
        
        // é«˜é˜¶å‡½æ•°
        let numbers = vec![1, 2, 3, 4, 5];
        let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect();
        println!("æ˜ å°„æ“ä½œ: {:?} -> {:?}", numbers, doubled);
        
        let sum: i32 = numbers.iter().fold(0, |acc, x| acc + x);
        println!("æŠ˜å æ“ä½œ: æ•°ç»„å’Œ = {}", sum);
    }
}</pre>

        <p><strong>æ­¥éª¤ 2: æ‰€æœ‰æƒç³»ç»Ÿæ·±åº¦å›é¡¾</strong></p>
        <pre># src/review/ownership.rs
//! æ‰€æœ‰æƒã€å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸç³»ç»Ÿå›é¡¾

use std::rc::Rc;
use std::sync::Arc;
use std::cell::RefCell;

/// æ‰€æœ‰æƒç³»ç»Ÿå›é¡¾
pub struct OwnershipReview;

impl OwnershipReview {
    /// æ‰€æœ‰æƒè½¬ç§»å›é¡¾
    pub fn ownership_transfer_review() {
        println!("=== æ‰€æœ‰æƒè½¬ç§»å›é¡¾ ===");
        
        // ç§»åŠ¨è¯­ä¹‰
        let s1 = String::from("Hello");
        let s2 = s1; // s1 çš„æ‰€æœ‰æƒè½¬ç§»ç»™ s2
        // println!("{}", s1); // ç¼–è¯‘é”™è¯¯: s1 å·²ç»å¤±æ•ˆ
        println!("s2 æ‹¥æœ‰å­—ç¬¦ä¸²: {}", s2);
        
        // å…‹éš†
        let s3 = s2.clone(); // æ·±åº¦å¤åˆ¶
        println!("s2: {}, s3: {}", s2, s3); // éƒ½æœ‰æ•ˆ
        
        // å‡½æ•°å‚æ•°çš„æ‰€æœ‰æƒè½¬ç§»
        fn take_ownership(s: String) {
            println!("å‡½æ•°æ‹¥æœ‰: {}", s);
        } // s åœ¨è¿™é‡Œè¢«é”€æ¯
        
        let s4 = String::from("World");
        take_ownership(s4);
        // println!("{}", s4); // ç¼–è¯‘é”™è¯¯: s4 å·²å¤±æ•ˆ
        
        // è¿”å›æ‰€æœ‰æƒ
        fn give_ownership() -> String {
            String::from("ç»™äºˆæ‰€æœ‰æƒ")
        }
        
        let s5 = give_ownership();
        println!("è·å¾—æ‰€æœ‰æƒ: {}", s5);
    }
    
    /// å€Ÿç”¨å’Œå¼•ç”¨å›é¡¾
    pub fn borrowing_references_review() {
        println!("=== å€Ÿç”¨å’Œå¼•ç”¨å›é¡¾ ===");
        
        let s = String::from("Hello World");
        
        // ä¸å¯å˜å€Ÿç”¨
        let len = calculate_length(&s);
        println!("å­—ç¬¦ä¸² '{}' çš„é•¿åº¦æ˜¯ {}", s, len);
        
        fn calculate_length(s: &String) -> usize {
            s.len()
        } // s æ˜¯å¼•ç”¨ï¼Œä¸æ‹¥æœ‰æ‰€æœ‰æƒ
        
        // å¯å˜å€Ÿç”¨
        let mut s = String::from("Hello");
        change_string(&mut s);
        println!("ä¿®æ”¹åçš„å­—ç¬¦ä¸²: {}", s);
        
        fn change_string(s: &mut String) {
            s.push_str(", World!");
        }
        
        // å€Ÿç”¨è§„åˆ™æ¼”ç¤º
        let mut s = String::from("ç¤ºä¾‹");
        let r1 = &s; // ä¸å¯å˜å€Ÿç”¨
        let r2 = &s; // å¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜å€Ÿç”¨
        println!("r1: {}, r2: {}", r1, r2);
        
        // r1 å’Œ r2 åœ¨è¿™é‡Œä¸å†ä½¿ç”¨
        let r3 = &mut s; // å¯å˜å€Ÿç”¨ï¼ˆåœ¨ä¸å¯å˜å€Ÿç”¨ç»“æŸåï¼‰
        println!("r3: {}", r3);
    }
    
    /// ç”Ÿå‘½å‘¨æœŸå›é¡¾
    pub fn lifetimes_review() {
        println!("=== ç”Ÿå‘½å‘¨æœŸå›é¡¾ ===");
        
        // ç”Ÿå‘½å‘¨æœŸæ³¨è§£
        fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
            if x.len() > y.len() {
                x
            } else {
                y
            }
        }
        
        let string1 = String::from("é•¿å­—ç¬¦ä¸²");
        let string2 = "çŸ­";
        let result = longest(string1.as_str(), string2);
        println!("æ›´é•¿çš„å­—ç¬¦ä¸²: {}", result);
        
        // ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
        struct ImportantExcerpt<'a> {
            part: &'a str,
        }
        
        let novel = String::from("å¾ˆä¹…å¾ˆä¹…ä»¥å‰ã€‚åœ¨ä¸€ä¸ªé¥è¿œçš„æ˜Ÿç³»...");
        let first_sentence = novel.split('.').next().expect("æ‰¾ä¸åˆ°å¥å·");
        let i = ImportantExcerpt {
            part: first_sentence,
        };
        println!("é‡è¦æ‘˜å½•: {}", i.part);
    }
    
    /// æ™ºèƒ½æŒ‡é’ˆå›é¡¾
    pub fn smart_pointers_review() {
        println!("=== æ™ºèƒ½æŒ‡é’ˆå›é¡¾ ===");
        
        // Box<T> - å †åˆ†é…
        let b = Box::new(5);
        println!("Box ä¸­çš„å€¼: {}", b);
        
        // Rc<T> - å¼•ç”¨è®¡æ•°ï¼ˆå•çº¿ç¨‹ï¼‰
        let rc_value = Rc::new(String::from("å…±äº«å€¼"));
        let rc1 = Rc::clone(&rc_value);
        let rc2 = Rc::clone(&rc_value);
        println!("Rc å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&rc_value));
        println!("é€šè¿‡ rc1 è®¿é—®: {}", rc1);
        println!("é€šè¿‡ rc2 è®¿é—®: {}", rc2);
        
        // Arc<T> - åŸå­å¼•ç”¨è®¡æ•°ï¼ˆå¤šçº¿ç¨‹ï¼‰
        let arc_value = Arc::new(42);
        let arc1 = Arc::clone(&arc_value);
        let arc2 = Arc::clone(&arc_value);
        println!("Arc å€¼: {}, å¼•ç”¨è®¡æ•°: {}", arc1, Arc::strong_count(&arc_value));
        
        // RefCell<T> - å†…éƒ¨å¯å˜æ€§
        let data = RefCell::new(5);
        println!("RefCell åˆå§‹å€¼: {}", data.borrow());
        *data.borrow_mut() = 10;
        println!("RefCell ä¿®æ”¹å: {}", data.borrow());
        
        // Rc<RefCell<T>> ç»„åˆä½¿ç”¨
        let shared_mutable = Rc::new(RefCell::new(vec![1, 2, 3]));
        let shared1 = Rc::clone(&shared_mutable);
        let shared2 = Rc::clone(&shared_mutable);
        
        shared1.borrow_mut().push(4);
        shared2.borrow_mut().push(5);
        
        println!("å…±äº«å¯å˜æ•°æ®: {:?}", shared_mutable.borrow());
    }
}</pre>

        <p><strong>æ­¥éª¤ 3: å¼‚æ­¥ç¼–ç¨‹å›é¡¾</strong></p>
        <pre># src/review/async_programming.rs
//! å¼‚æ­¥ç¼–ç¨‹å’Œå¹¶å‘æ¨¡å‹å›é¡¾

use std::time::Duration;
use tokio::time::{sleep, timeout};
use tokio::sync::{mpsc, Mutex, RwLock};
use tokio::task;
use futures::future::{join, join_all, select, Either};
use std::sync::Arc;

/// å¼‚æ­¥ç¼–ç¨‹å›é¡¾
pub struct AsyncProgrammingReview;

impl AsyncProgrammingReview {
    /// Future å’Œ async/await å›é¡¾
    pub async fn futures_async_await_review() {
        println!("=== Future å’Œ async/await å›é¡¾ ===");
        
        // åŸºç¡€ async å‡½æ•°
        async fn simple_async_function() -> String {
            sleep(Duration::from_millis(100)).await;
            "å¼‚æ­¥å‡½æ•°å®Œæˆ".to_string()
        }
        
        let result = simple_async_function().await;
        println!("å¼‚æ­¥ç»“æœ: {}", result);
        
        // å¤šä¸ªå¼‚æ­¥æ“ä½œå¹¶å‘æ‰§è¡Œ
        async fn fetch_data(id: u32) -> String {
            sleep(Duration::from_millis(50 * id as u64)).await;
            format!("æ•°æ® {}", id)
        }
        
        let (data1, data2, data3) = join!(
            fetch_data(1),
            fetch_data(2),
            fetch_data(3)
        );
        
        println!("å¹¶å‘è·å–: {}, {}, {}", data1, data2, data3);
        
        // è¶…æ—¶å¤„ç†
        let slow_operation = async {
            sleep(Duration::from_secs(2)).await;
            "æ…¢æ“ä½œå®Œæˆ"
        };
        
        match timeout(Duration::from_millis(500), slow_operation).await {
            Ok(result) => println!("æ“ä½œå®Œæˆ: {}", result),
            Err(_) => println!("æ“ä½œè¶…æ—¶"),
        }
    }
    
    /// ä»»åŠ¡å’Œå¹¶å‘å›é¡¾
    pub async fn tasks_concurrency_review() {
        println!("=== ä»»åŠ¡å’Œå¹¶å‘å›é¡¾ ===");
        
        // ç”Ÿæˆå¼‚æ­¥ä»»åŠ¡
        let task1 = task::spawn(async {
            sleep(Duration::from_millis(100)).await;
            "ä»»åŠ¡ 1 å®Œæˆ"
        });
        
        let task2 = task::spawn(async {
            sleep(Duration::from_millis(200)).await;
            "ä»»åŠ¡ 2 å®Œæˆ"
        });
        
        // ç­‰å¾…ä»»åŠ¡å®Œæˆ
        let (result1, result2) = join!(task1, task2);
        println!("ä»»åŠ¡ç»“æœ: {:?}, {:?}", result1, result2);
        
        // ä»»åŠ¡é›†åˆ
        let tasks: Vec<_> = (1..=5)
            .map(|i| task::spawn(async move {
                sleep(Duration::from_millis(i * 50)).await;
                format!("ä»»åŠ¡ {} å®Œæˆ", i)
            }))
            .collect();
        
        let results = join_all(tasks).await;
        for result in results {
            match result {
                Ok(value) => println!("ä»»åŠ¡æˆåŠŸ: {}", value),
                Err(e) => println!("ä»»åŠ¡å¤±è´¥: {}", e),
            }
        }
    }
    
    /// é€šé“å’Œæ¶ˆæ¯ä¼ é€’å›é¡¾
    pub async fn channels_message_passing_review() {
        println!("=== é€šé“å’Œæ¶ˆæ¯ä¼ é€’å›é¡¾ ===");
        
        // å•å‘é€è€…å•æ¥æ”¶è€…é€šé“
        let (tx, mut rx) = mpsc::channel::<String>(32);
        
        // å‘é€è€…ä»»åŠ¡
        let sender_task = task::spawn(async move {
            for i in 1..=5 {
                let message = format!("æ¶ˆæ¯ {}", i);
                if tx.send(message.clone()).await.is_ok() {
                    println!("å‘é€: {}", message);
                }
                sleep(Duration::from_millis(100)).await;
            }
        });
        
        // æ¥æ”¶è€…ä»»åŠ¡
        let receiver_task = task::spawn(async move {
            while let Some(message) = rx.recv().await {
                println!("æ¥æ”¶: {}", message);
            }
        });
        
        join!(sender_task, receiver_task);
        
        // å¤šå‘é€è€…å•æ¥æ”¶è€…
        let (tx, mut rx) = mpsc::channel::<String>(32);
        
        let senders: Vec<_> = (1..=3)
            .map(|id| {
                let tx = tx.clone();
                task::spawn(async move {
                    for i in 1..=3 {
                        let message = format!("å‘é€è€… {} æ¶ˆæ¯ {}", id, i);
                        let _ = tx.send(message).await;
                        sleep(Duration::from_millis(50)).await;
                    }
                })
            })
            .collect();
        
        drop(tx); // å…³é—­ä¸»å‘é€è€…
        
        let receiver = task::spawn(async move {
            while let Some(message) = rx.recv().await {
                println!("å¤šå‘é€è€…æ¥æ”¶: {}", message);
            }
        });
        
        join_all(senders).await;
        receiver.await.unwrap();
    }
    
    /// å¼‚æ­¥åŒæ­¥åŸè¯­å›é¡¾
    pub async fn async_synchronization_review() {
        println!("=== å¼‚æ­¥åŒæ­¥åŸè¯­å›é¡¾ ===");
        
        // å¼‚æ­¥ Mutex
        let data = Arc::new(Mutex::new(0));
        let mut handles = vec![];
        
        for i in 0..5 {
            let data = Arc::clone(&data);
            let handle = task::spawn(async move {
                let mut num = data.lock().await;
                *num += 1;
                println!("ä»»åŠ¡ {} å¢åŠ è®¡æ•°å™¨åˆ°: {}", i, *num);
                sleep(Duration::from_millis(10)).await;
            });
            handles.push(handle);
        }
        
        join_all(handles).await;
        println!("æœ€ç»ˆè®¡æ•°å™¨å€¼: {}", *data.lock().await);
        
        // å¼‚æ­¥ RwLock
        let data = Arc::new(RwLock::new(vec![1, 2, 3]));
        
        // å¤šä¸ªè¯»å–è€…
        let readers: Vec<_> = (0..3)
            .map(|i| {
                let data = Arc::clone(&data);
                task::spawn(async move {
                    let guard = data.read().await;
                    println!("è¯»å–è€… {}: {:?}", i, *guard);
                    sleep(Duration::from_millis(100)).await;
                })
            })
            .collect();
        
        // ä¸€ä¸ªå†™å…¥è€…
        let writer = {
            let data = Arc::clone(&data);
            task::spawn(async move {
                sleep(Duration::from_millis(150)).await;
                let mut guard = data.write().await;
                guard.push(4);
                println!("å†™å…¥è€…æ·»åŠ å…ƒç´ : {:?}", *guard);
            })
        };
        
        join_all(readers).await;
        writer.await.unwrap();
        
        println!("æœ€ç»ˆæ•°æ®: {:?}", *data.read().await);
    }
    
    /// å¼‚æ­¥é”™è¯¯å¤„ç†å›é¡¾
    pub async fn async_error_handling_review() {
        println!("=== å¼‚æ­¥é”™è¯¯å¤„ç†å›é¡¾ ===");
        
        // Result åœ¨å¼‚æ­¥ä¸­çš„ä½¿ç”¨
        async fn fallible_operation(succeed: bool) -> Result<String, &'static str> {
            sleep(Duration::from_millis(100)).await;
            if succeed {
                Ok("æ“ä½œæˆåŠŸ".to_string())
            } else {
                Err("æ“ä½œå¤±è´¥")
            }
        }
        
        // ä½¿ç”¨ ? æ“ä½œç¬¦
        async fn chain_operations() -> Result<String, &'static str> {
            let result1 = fallible_operation(true).await?;
            let result2 = fallible_operation(true).await?;
            Ok(format!("{} -> {}", result1, result2))
        }
        
        match chain_operations().await {
            Ok(result) => println!("é“¾å¼æ“ä½œæˆåŠŸ: {}", result),
            Err(e) => println!("é“¾å¼æ“ä½œå¤±è´¥: {}", e),
        }
        
        // ä½¿ç”¨ select å¤„ç†å¤šä¸ª Future
        let future1 = fallible_operation(true);
        let future2 = sleep(Duration::from_millis(200));
        
        match select(Box::pin(future1), Box::pin(future2)).await {
            Either::Left((result, _)) => match result {
                Ok(value) => println!("ç¬¬ä¸€ä¸ªå®Œæˆ: {}", value),
                Err(e) => println!("ç¬¬ä¸€ä¸ªå¤±è´¥: {}", e),
            },
            Either::Right((_, _)) => println!("è¶…æ—¶æˆ–ç¬¬äºŒä¸ªå®Œæˆ"),
        }
    }
}</pre>

        <p><strong>æ­¥éª¤ 4: WebSocket æ¶æ„æ€§èƒ½åˆ†æ</strong></p>
        <pre># src/analysis/architecture.rs
//! WebSocket æœåŠ¡æ¶æ„åˆ†æå’Œä¼˜åŒ–å»ºè®®

use std::collections::HashMap;
use serde::{Deserialize, Serialize};

/// æ¶æ„åˆ†ææŠ¥å‘Š
#[derive(Debug, Serialize, Deserialize)]
pub struct ArchitectureAnalysis {
    pub components: Vec<ComponentAnalysis>,
    pub performance_metrics: PerformanceMetrics,
    pub scalability_assessment: ScalabilityAssessment,
    pub security_evaluation: SecurityEvaluation,
    pub recommendations: Vec<OptimizationRecommendation>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ComponentAnalysis {
    pub name: String,
    pub purpose: String,
    pub strengths: Vec<String>,
    pub weaknesses: Vec<String>,
    pub dependencies: Vec<String>,
    pub complexity_score: u8, // 1-10
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PerformanceMetrics {
    pub connection_handling: ConnectionMetrics,
    pub message_throughput: ThroughputMetrics,
    pub memory_usage: MemoryMetrics,
    pub cpu_utilization: CpuMetrics,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ConnectionMetrics {
    pub max_concurrent_connections: u32,
    pub connection_establishment_time_ms: f64,
    pub connection_cleanup_time_ms: f64,
    pub heartbeat_overhead_percentage: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ThroughputMetrics {
    pub messages_per_second: u32,
    pub bytes_per_second: u64,
    pub broadcast_latency_ms: f64,
    pub unicast_latency_ms: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MemoryMetrics {
    pub base_memory_mb: u64,
    pub memory_per_connection_kb: u64,
    pub message_buffer_size_mb: u64,
    pub peak_memory_usage_mb: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CpuMetrics {
    pub idle_cpu_percentage: f64,
    pub cpu_per_connection_percentage: f64,
    pub message_processing_cpu_percentage: f64,
    pub serialization_cpu_percentage: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScalabilityAssessment {
    pub horizontal_scaling: ScalingAnalysis,
    pub vertical_scaling: ScalingAnalysis,
    pub bottlenecks: Vec<String>,
    pub scaling_recommendations: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScalingAnalysis {
    pub feasibility: String, // "Easy", "Moderate", "Difficult"
    pub limitations: Vec<String>,
    pub required_changes: Vec<String>,
    pub estimated_effort: String, // "Low", "Medium", "High"
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityEvaluation {
    pub authentication: SecurityComponent,
    pub authorization: SecurityComponent,
    pub data_protection: SecurityComponent,
    pub network_security: SecurityComponent,
    pub vulnerability_assessment: Vec<SecurityIssue>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityComponent {
    pub status: String, // "Implemented", "Partial", "Missing"
    pub strength: String, // "Strong", "Adequate", "Weak"
    pub recommendations: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityIssue {
    pub severity: String, // "Critical", "High", "Medium", "Low"
    pub description: String,
    pub impact: String,
    pub mitigation: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OptimizationRecommendation {
    pub category: String,
    pub priority: String, // "Critical", "High", "Medium", "Low"
    pub description: String,
    pub implementation_effort: String,
    pub expected_impact: String,
    pub dependencies: Vec<String>,
}

/// æ¶æ„åˆ†æå™¨
pub struct ArchitectureAnalyzer;

impl ArchitectureAnalyzer {
    /// æ‰§è¡Œå®Œæ•´çš„æ¶æ„åˆ†æ
    pub fn analyze_websocket_architecture() -> ArchitectureAnalysis {
        println!("æ‰§è¡Œ WebSocket æ¶æ„åˆ†æ...");
        
        let components = Self::analyze_components();
        let performance_metrics = Self::analyze_performance();
        let scalability_assessment = Self::assess_scalability();
        let security_evaluation = Self::evaluate_security();
        let recommendations = Self::generate_recommendations();
        
        ArchitectureAnalysis {
            components,
            performance_metrics,
            scalability_assessment,
            security_evaluation,
            recommendations,
        }
    }
    
    fn analyze_components() -> Vec<ComponentAnalysis> {
        vec![
            ComponentAnalysis {
                name: "WebSocket Server Core".to_string(),
                purpose: "å¤„ç† WebSocket è¿æ¥å’Œæ¶ˆæ¯è·¯ç”±".to_string(),
                strengths: vec![
                    "åŸºäº Tokio çš„é«˜æ€§èƒ½å¼‚æ­¥ I/O".to_string(),
                    "å†…å­˜é«˜æ•ˆçš„è¿æ¥ç®¡ç†".to_string(),
                    "æ”¯æŒèƒŒå‹æ§åˆ¶".to_string(),
                ],
                weaknesses: vec![
                    "å•å®ä¾‹æ‰©å±•é™åˆ¶".to_string(),
                    "ç¼ºå°‘è¿æ¥æ± ç®¡ç†".to_string(),
                ],
                dependencies: vec!["tokio".to_string(), "tokio-tungstenite".to_string()],
                complexity_score: 7,
            },
            ComponentAnalysis {
                name: "Message Broadcasting System".to_string(),
                purpose: "å¤šå®¢æˆ·ç«¯æ¶ˆæ¯å¹¿æ’­å’Œè·¯ç”±".to_string(),
                strengths: vec![
                    "é«˜æ•ˆçš„æ‰‡å‡ºæ¶ˆæ¯åˆ†å‘".to_string(),
                    "æ”¯æŒé€‰æ‹©æ€§å¹¿æ’­".to_string(),
                ],
                weaknesses: vec![
                    "å†…å­˜ä¸­çŠ¶æ€ç®¡ç†".to_string(),
                    "ç¼ºå°‘æ¶ˆæ¯æŒä¹…åŒ–".to_string(),
                ],
                dependencies: vec!["tokio::sync".to_string()],
                complexity_score: 6,
            },
            ComponentAnalysis {
                name: "Authentication & Authorization".to_string(),
                purpose: "ç”¨æˆ·èº«ä»½éªŒè¯å’Œæƒé™æ§åˆ¶".to_string(),
                strengths: vec![
                    "JWT token éªŒè¯".to_string(),
                    "çµæ´»çš„æƒé™æ¨¡å‹".to_string(),
                ],
                weaknesses: vec![
                    "ç¼ºå°‘ token åˆ·æ–°æœºåˆ¶".to_string(),
                    "æƒé™ç¼“å­˜ç­–ç•¥ä¸å®Œå–„".to_string(),
                ],
                dependencies: vec!["jsonwebtoken".to_string()],
                complexity_score: 5,
            },
        ]
    }
    
    fn analyze_performance() -> PerformanceMetrics {
        PerformanceMetrics {
            connection_handling: ConnectionMetrics {
                max_concurrent_connections: 10000,
                connection_establishment_time_ms: 2.5,
                connection_cleanup_time_ms: 1.2,
                heartbeat_overhead_percentage: 3.5,
            },
            message_throughput: ThroughputMetrics {
                messages_per_second: 50000,
                bytes_per_second: 5242880, // 5 MB/s
                broadcast_latency_ms: 1.8,
                unicast_latency_ms: 0.9,
            },
            memory_usage: MemoryMetrics {
                base_memory_mb: 128,
                memory_per_connection_kb: 4,
                message_buffer_size_mb: 256,
                peak_memory_usage_mb: 512,
            },
            cpu_utilization: CpuMetrics {
                idle_cpu_percentage: 85.0,
                cpu_per_connection_percentage: 0.01,
                message_processing_cpu_percentage: 8.0,
                serialization_cpu_percentage: 4.5,
            },
        }
    }
    
    fn assess_scalability() -> ScalabilityAssessment {
        ScalabilityAssessment {
            horizontal_scaling: ScalingAnalysis {
                feasibility: "Moderate".to_string(),
                limitations: vec![
                    "éœ€è¦å¤–éƒ¨çŠ¶æ€å­˜å‚¨".to_string(),
                    "æ¶ˆæ¯è·¯ç”±å¤æ‚æ€§å¢åŠ ".to_string(),
                ],
                required_changes: vec![
                    "å®ç° Redis é›†ç¾¤æ”¯æŒ".to_string(),
                    "æ·»åŠ æœåŠ¡å‘ç°æœºåˆ¶".to_string(),
                    "å®ç°è·¨èŠ‚ç‚¹æ¶ˆæ¯ä¼ é€’".to_string(),
                ],
                estimated_effort: "High".to_string(),
            },
            vertical_scaling: ScalingAnalysis {
                feasibility: "Easy".to_string(),
                limitations: vec![
                    "å•æœºç¡¬ä»¶é™åˆ¶".to_string(),
                    "å‚ç›´æ‰©å±•æˆæœ¬é«˜".to_string(),
                ],
                required_changes: vec![
                    "ä¼˜åŒ–å†…å­˜ä½¿ç”¨".to_string(),
                    "è°ƒæ•´çº¿ç¨‹æ± å¤§å°".to_string(),
                ],
                estimated_effort: "Low".to_string(),
            },
            bottlenecks: vec![
                "æ¶ˆæ¯åºåˆ—åŒ–æ€§èƒ½".to_string(),
                "å¹¿æ’­æ‰‡å‡ºé™åˆ¶".to_string(),
                "å•å®ä¾‹è¿æ¥æ•°ä¸Šé™".to_string(),
            ],
            scaling_recommendations: vec![
                "å®ç°æ¶ˆæ¯é˜Ÿåˆ—ä¸­é—´ä»¶".to_string(),
                "æ·»åŠ è´Ÿè½½å‡è¡¡å™¨".to_string(),
                "ä½¿ç”¨å¾®æœåŠ¡æ¶æ„".to_string(),
            ],
        }
    }
    
    fn evaluate_security() -> SecurityEvaluation {
        SecurityEvaluation {
            authentication: SecurityComponent {
                status: "Implemented".to_string(),
                strength: "Adequate".to_string(),
                recommendations: vec![
                    "æ·»åŠ å¤šå› ç´ è®¤è¯".to_string(),
                    "å®ç° token é»‘åå•".to_string(),
                ],
            },
            authorization: SecurityComponent {
                status: "Partial".to_string(),
                strength: "Weak".to_string(),
                recommendations: vec![
                    "å®ç°åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶".to_string(),
                    "æ·»åŠ ç»†ç²’åº¦æƒé™æ£€æŸ¥".to_string(),
                ],
            },
            data_protection: SecurityComponent {
                status: "Partial".to_string(),
                strength: "Adequate".to_string(),
                recommendations: vec![
                    "å¯ç”¨æ¶ˆæ¯åŠ å¯†".to_string(),
                    "å®ç°ç«¯åˆ°ç«¯åŠ å¯†".to_string(),
                ],
            },
            network_security: SecurityComponent {
                status: "Implemented".to_string(),
                strength: "Strong".to_string(),
                recommendations: vec![
                    "æ·»åŠ  DDoS é˜²æŠ¤".to_string(),
                    "å®ç°é€Ÿç‡é™åˆ¶".to_string(),
                ],
            },
            vulnerability_assessment: vec![
                SecurityIssue {
                    severity: "Medium".to_string(),
                    description: "ç¼ºå°‘è¾“å…¥éªŒè¯å’Œæ¶ˆæ¯’".to_string(),
                    impact: "æ½œåœ¨çš„æ³¨å…¥æ”»å‡»é£é™©".to_string(),
                    mitigation: "å®ç°ä¸¥æ ¼çš„è¾“å…¥éªŒè¯".to_string(),
                },
                SecurityIssue {
                    severity: "Low".to_string(),
                    description: "æ—¥å¿—å¯èƒ½åŒ…å«æ•æ„Ÿä¿¡æ¯".to_string(),
                    impact: "ä¿¡æ¯æ³„éœ²é£é™©".to_string(),
                    mitigation: "å®ç°æ—¥å¿—è„±æ•".to_string(),
                },
            ],
        }
    }
    
    fn generate_recommendations() -> Vec<OptimizationRecommendation> {
        vec![
            OptimizationRecommendation {
                category: "Performance".to_string(),
                priority: "High".to_string(),
                description: "å®ç°æ¶ˆæ¯æ‰¹å¤„ç†ä»¥æé«˜ååé‡".to_string(),
                implementation_effort: "Medium".to_string(),
                expected_impact: "æå‡ 30% æ¶ˆæ¯å¤„ç†æ€§èƒ½".to_string(),
                dependencies: vec!["æ¶ˆæ¯é˜Ÿåˆ—é‡æ„".to_string()],
            },
            OptimizationRecommendation {
                category: "Scalability".to_string(),
                priority: "Critical".to_string(),
                description: "å®ç° Redis é›†ç¾¤æ”¯æŒä»¥å®ç°æ°´å¹³æ‰©å±•".to_string(),
                implementation_effort: "High".to_string(),
                expected_impact: "æ”¯æŒæ— é™æ°´å¹³æ‰©å±•".to_string(),
                dependencies: vec!["Redis Cluster".to_string(), "æœåŠ¡å‘ç°".to_string()],
            },
            OptimizationRecommendation {
                category: "Security".to_string(),
                priority: "High".to_string(),
                description: "å®ç°ç«¯åˆ°ç«¯æ¶ˆæ¯åŠ å¯†".to_string(),
                implementation_effort: "Medium".to_string(),
                expected_impact: "å®Œå…¨ä¿æŠ¤æ¶ˆæ¯éšç§".to_string(),
                dependencies: vec!["å¯†é’¥ç®¡ç†ç³»ç»Ÿ".to_string()],
            },
            OptimizationRecommendation {
                category: "Observability".to_string(),
                priority: "Medium".to_string(),
                description: "é›†æˆåˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿ".to_string(),
                implementation_effort: "Medium".to_string(),
                expected_impact: "æ”¹å–„ç³»ç»Ÿå¯è§‚æµ‹æ€§".to_string(),
                dependencies: vec!["Jaeger".to_string(), "OpenTelemetry".to_string()],
            },
        ]
    }
    
    /// ç”Ÿæˆæ¶æ„åˆ†ææŠ¥å‘Š
    pub fn generate_report(analysis: &ArchitectureAnalysis) -> String {
        let mut report = String::new();
        
        report.push_str("# WebSocket æœåŠ¡æ¶æ„åˆ†ææŠ¥å‘Š\n\n");
        
        report.push_str("## ç»„ä»¶åˆ†æ\n");
        for component in &analysis.components {
            report.push_str(&format!("### {}\n", component.name));
            report.push_str(&format!("**ç›®çš„**: {}\n", component.purpose));
            report.push_str(&format!("**å¤æ‚åº¦**: {}/10\n", component.complexity_score));
            
            report.push_str("**ä¼˜åŠ¿**:\n");
            for strength in &component.strengths {
                report.push_str(&format!("- {}\n", strength));
            }
            
            report.push_str("**å¼±ç‚¹**:\n");
            for weakness in &component.weaknesses {
                report.push_str(&format!("- {}\n", weakness));
            }
            report.push_str("\n");
        }
        
        report.push_str("## æ€§èƒ½æŒ‡æ ‡\n");
        let perf = &analysis.performance_metrics;
        report.push_str(&format!("- æœ€å¤§å¹¶å‘è¿æ¥: {}\n", perf.connection_handling.max_concurrent_connections));
        report.push_str(&format!("- æ¶ˆæ¯ååé‡: {} msg/s\n", perf.message_throughput.messages_per_second));
        report.push_str(&format!("- åŸºç¡€å†…å­˜ä½¿ç”¨: {} MB\n", perf.memory_usage.base_memory_mb));
        report.push_str(&format!("- ç©ºé—² CPU ä½¿ç”¨: {:.1}%\n", perf.cpu_utilization.idle_cpu_percentage));
        
        report.push_str("\n## æ‰©å±•æ€§è¯„ä¼°\n");
        report.push_str(&format!("- æ°´å¹³æ‰©å±•å¯è¡Œæ€§: {}\n", analysis.scalability_assessment.horizontal_scaling.feasibility));
        report.push_str(&format!("- å‚ç›´æ‰©å±•å¯è¡Œæ€§: {}\n", analysis.scalability_assessment.vertical_scaling.feasibility));
        
        report.push_str("\n## ä¼˜åŒ–å»ºè®®\n");
        for rec in &analysis.recommendations {
            report.push_str(&format!("### {} (ä¼˜å…ˆçº§: {})\n", rec.description, rec.priority));
            report.push_str(&format!("- å®æ–½éš¾åº¦: {}\n", rec.implementation_effort));
            report.push_str(&format!("- é¢„æœŸå½±å“: {}\n", rec.expected_impact));
            report.push_str("\n");
        }
        
        report
    }
}</pre>

        <p><strong>æ­¥éª¤ 5: æ€§èƒ½åŸºå‡†æµ‹è¯•</strong></p>
        <pre># benches/websocket_performance.rs
//! WebSocket æœåŠ¡æ€§èƒ½åŸºå‡†æµ‹è¯•

use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use tokio::runtime::Runtime;
use tokio::time::{Duration, Instant};
use tokio_tungstenite::{connect_async, tungstenite::Message};
use futures::sink::SinkExt;
use futures::stream::StreamExt;
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};

/// WebSocket æ€§èƒ½æµ‹è¯•ç»“æ„
pub struct WebSocketBenchmark {
    runtime: Runtime,
    server_url: String,
}

impl WebSocketBenchmark {
    pub fn new() -> Self {
        Self {
            runtime: Runtime::new().unwrap(),
            server_url: "ws://localhost:8080".to_string(),
        }
    }
    
    /// å•è¿æ¥æ¶ˆæ¯ååé‡æµ‹è¯•
    pub fn single_connection_throughput(&self, message_count: usize) -> Duration {
        self.runtime.block_on(async {
            let start = Instant::now();
            
            let (ws_stream, _) = connect_async(&self.server_url)
                .await
                .expect("è¿æ¥å¤±è´¥");
            
            let (mut write, mut read) = ws_stream.split();
            
            // å‘é€æ¶ˆæ¯ä»»åŠ¡
            let send_task = tokio::spawn(async move {
                for i in 0..message_count {
                    let message = format!("æ€§èƒ½æµ‹è¯•æ¶ˆæ¯ {}", i);
                    write.send(Message::Text(message)).await.unwrap();
                }
            });
            
            // æ¥æ”¶æ¶ˆæ¯ä»»åŠ¡
            let recv_task = tokio::spawn(async move {
                let mut received = 0;
                while received < message_count {
                    if let Some(msg) = read.next().await {
                        match msg {
                            Ok(Message::Text(_)) => received += 1,
                            _ => {}
                        }
                    }
                }
            });
            
            tokio::join!(send_task, recv_task);
            start.elapsed()
        })
    }
    
    /// å¤šè¿æ¥å¹¶å‘æµ‹è¯•
    pub fn concurrent_connections(&self, connection_count: usize, messages_per_connection: usize) -> Duration {
        self.runtime.block_on(async {
            let start = Instant::now();
            let counter = Arc::new(AtomicU64::new(0));
            
            let tasks: Vec<_> = (0..connection_count)
                .map(|i| {
                    let counter = Arc::clone(&counter);
                    let server_url = self.server_url.clone();
                    
                    tokio::spawn(async move {
                        let (ws_stream, _) = connect_async(&server_url)
                            .await
                            .expect("è¿æ¥å¤±è´¥");
                        
                        let (mut write, mut read) = ws_stream.split();
                        
                        // å‘é€ä»»åŠ¡
                        let send_task = tokio::spawn(async move {
                            for j in 0..messages_per_connection {
                                let message = format!("è¿æ¥ {} æ¶ˆæ¯ {}", i, j);
                                write.send(Message::Text(message)).await.unwrap();
                            }
                        });
                        
                        // æ¥æ”¶ä»»åŠ¡
                        let recv_task = tokio::spawn(async move {
                            let mut received = 0;
                            while received < messages_per_connection {
                                if let Some(msg) = read.next().await {
                                    match msg {
                                        Ok(Message::Text(_)) => {
                                            received += 1;
                                            counter.fetch_add(1, Ordering::Relaxed);
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        });
                        
                        tokio::join!(send_task, recv_task);
                    })
                })
                .collect();
            
            futures::future::join_all(tasks).await;
            
            let total_messages = counter.load(Ordering::Relaxed);
            println!("æ€»å¤„ç†æ¶ˆæ¯æ•°: {}", total_messages);
            
            start.elapsed()
        })
    }
    
    /// æ¶ˆæ¯å¤§å°æ€§èƒ½æµ‹è¯•
    pub fn message_size_performance(&self, message_size: usize, message_count: usize) -> Duration {
        self.runtime.block_on(async {
            let start = Instant::now();
            
            let (ws_stream, _) = connect_async(&self.server_url)
                .await
                .expect("è¿æ¥å¤±è´¥");
            
            let (mut write, mut read) = ws_stream.split();
            
            // ç”ŸæˆæŒ‡å®šå¤§å°çš„æ¶ˆæ¯
            let large_message = "A".repeat(message_size);
            
            // å‘é€ä»»åŠ¡
            let send_task = tokio::spawn(async move {
                for _ in 0..message_count {
                    write.send(Message::Text(large_message.clone())).await.unwrap();
                }
            });
            
            // æ¥æ”¶ä»»åŠ¡
            let recv_task = tokio::spawn(async move {
                let mut received = 0;
                while received < message_count {
                    if let Some(msg) = read.next().await {
                        match msg {
                            Ok(Message::Text(_)) => received += 1,
                            _ => {}
                        }
                    }
                }
            });
            
            tokio::join!(send_task, recv_task);
            start.elapsed()
        })
    }
}

/// Criterion åŸºå‡†æµ‹è¯•å‡½æ•°
fn websocket_benchmarks(c: &mut Criterion) {
    let benchmark = WebSocketBenchmark::new();
    
    // æ¶ˆæ¯ååé‡æµ‹è¯•
    let mut group = c.benchmark_group("message_throughput");
    for message_count in [100, 500, 1000, 5000].iter() {
        group.bench_with_input(
            BenchmarkId::new("single_connection", message_count),
            message_count,
            |b, &message_count| {
                b.iter(|| {
                    let duration = benchmark.single_connection_throughput(message_count);
                    black_box(duration)
                });
            },
        );
    }
    group.finish();
    
    // å¹¶å‘è¿æ¥æµ‹è¯•
    let mut group = c.benchmark_group("concurrent_connections");
    for &(connections, messages) in [(10, 100), (50, 50), (100, 10)].iter() {
        group.bench_with_input(
            BenchmarkId::new("concurrent", format!("{}conn_{}msg", connections, messages)),
            &(connections, messages),
            |b, &(connections, messages)| {
                b.iter(|| {
                    let duration = benchmark.concurrent_connections(connections, messages);
                    black_box(duration)
                });
            },
        );
    }
    group.finish();
    
    // æ¶ˆæ¯å¤§å°æµ‹è¯•
    let mut group = c.benchmark_group("message_size");
    for &(size, count) in [(1024, 100), (10240, 50), (102400, 10)].iter() {
        group.bench_with_input(
            BenchmarkId::new("size_performance", format!("{}bytes", size)),
            &(size, count),
            |b, &(size, count)| {
                b.iter(|| {
                    let duration = benchmark.message_size_performance(size, count);
                    black_box(duration)
                });
            },
        );
    }
    group.finish();
}

criterion_group!(benches, websocket_benchmarks);
criterion_main!(benches);</pre>

        <p><strong>æ­¥éª¤ 6: éƒ¨ç½²ç­–ç•¥è§„åˆ’</strong></p>
        <pre># src/planning/deployment.rs
//! éƒ¨ç½²ç­–ç•¥å’Œè¿ç»´è§„åˆ’

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// éƒ¨ç½²ç­–ç•¥è§„åˆ’
#[derive(Debug, Serialize, Deserialize)]
pub struct DeploymentStrategy {
    pub environments: HashMap<String, EnvironmentConfig>,
    pub scaling_policies: ScalingPolicies,
    pub monitoring_setup: MonitoringSetup,
    pub backup_strategy: BackupStrategy,
    pub disaster_recovery: DisasterRecoveryPlan,
    pub maintenance_procedures: MaintenanceProcedures,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EnvironmentConfig {
    pub name: String,
    pub infrastructure: InfrastructureConfig,
    pub resources: ResourceAllocation,
    pub security: SecurityConfig,
    pub networking: NetworkConfig,
    pub dependencies: Vec<DependencyConfig>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct InfrastructureConfig {
    pub platform: String, // "Kubernetes", "Docker Swarm", "ECS", etc.
    pub region: String,
    pub availability_zones: Vec<String>,
    pub node_types: Vec<NodeType>,
    pub storage_classes: Vec<StorageClass>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NodeType {
    pub name: String,
    pub instance_type: String,
    pub cpu_cores: u32,
    pub memory_gb: u32,
    pub storage_gb: u32,
    pub network_performance: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StorageClass {
    pub name: String,
    pub storage_type: String, // "SSD", "HDD", "NVMe"
    pub iops: u32,
    pub throughput_mbps: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ResourceAllocation {
    pub websocket_server: ServiceResources,
    pub redis_cluster: ServiceResources,
    pub prometheus: ServiceResources,
    pub grafana: ServiceResources,
    pub load_balancer: ServiceResources,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ServiceResources {
    pub replicas: u32,
    pub cpu_request: String,
    pub cpu_limit: String,
    pub memory_request: String,
    pub memory_limit: String,
    pub storage_request: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScalingPolicies {
    pub horizontal_pod_autoscaler: HpaConfig,
    pub vertical_pod_autoscaler: VpaConfig,
    pub cluster_autoscaler: ClusterAutoscalerConfig,
    pub custom_metrics: Vec<CustomMetric>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct HpaConfig {
    pub enabled: bool,
    pub min_replicas: u32,
    pub max_replicas: u32,
    pub target_cpu_utilization: u32,
    pub target_memory_utilization: u32,
    pub scale_up_policies: ScalePolicies,
    pub scale_down_policies: ScalePolicies,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScalePolicies {
    pub stabilization_window_seconds: u32,
    pub select_policy: String, // "Max", "Min", "Disabled"
    pub policies: Vec<ScalePolicy>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScalePolicy {
    pub type_: String, // "Percent", "Pods"
    pub value: u32,
    pub period_seconds: u32,
}

/// éƒ¨ç½²ç­–ç•¥è§„åˆ’å™¨
pub struct DeploymentPlanner;

impl DeploymentPlanner {
    /// ç”Ÿæˆå®Œæ•´çš„éƒ¨ç½²ç­–ç•¥
    pub fn create_deployment_strategy() -> DeploymentStrategy {
        println!("ç”Ÿæˆéƒ¨ç½²ç­–ç•¥è§„åˆ’...");
        
        let mut environments = HashMap::new();
        
        // å¼€å‘ç¯å¢ƒé…ç½®
        environments.insert("development".to_string(), Self::create_dev_environment());
        
        // æµ‹è¯•ç¯å¢ƒé…ç½®
        environments.insert("staging".to_string(), Self::create_staging_environment());
        
        // ç”Ÿäº§ç¯å¢ƒé…ç½®
        environments.insert("production".to_string(), Self::create_production_environment());
        
        DeploymentStrategy {
            environments,
            scaling_policies: Self::create_scaling_policies(),
            monitoring_setup: Self::create_monitoring_setup(),
            backup_strategy: Self::create_backup_strategy(),
            disaster_recovery: Self::create_disaster_recovery_plan(),
            maintenance_procedures: Self::create_maintenance_procedures(),
        }
    }
    
    fn create_dev_environment() -> EnvironmentConfig {
        EnvironmentConfig {
            name: "development".to_string(),
            infrastructure: InfrastructureConfig {
                platform: "Kubernetes".to_string(),
                region: "us-west-2".to_string(),
                availability_zones: vec!["us-west-2a".to_string()],
                node_types: vec![
                    NodeType {
                        name: "dev-worker".to_string(),
                        instance_type: "t3.medium".to_string(),
                        cpu_cores: 2,
                        memory_gb: 4,
                        storage_gb: 20,
                        network_performance: "Moderate".to_string(),
                    }
                ],
                storage_classes: vec![
                    StorageClass {
                        name: "gp2".to_string(),
                        storage_type: "SSD".to_string(),
                        iops: 100,
                        throughput_mbps: 250,
                    }
                ],
            },
            resources: ResourceAllocation {
                websocket_server: ServiceResources {
                    replicas: 1,
                    cpu_request: "100m".to_string(),
                    cpu_limit: "500m".to_string(),
                    memory_request: "128Mi".to_string(),
                    memory_limit: "512Mi".to_string(),
                    storage_request: None,
                },
                redis_cluster: ServiceResources {
                    replicas: 1,
                    cpu_request: "50m".to_string(),
                    cpu_limit: "200m".to_string(),
                    memory_request: "64Mi".to_string(),
                    memory_limit: "256Mi".to_string(),
                    storage_request: Some("1Gi".to_string()),
                },
                prometheus: ServiceResources {
                    replicas: 1,
                    cpu_request: "100m".to_string(),
                    cpu_limit: "300m".to_string(),
                    memory_request: "256Mi".to_string(),
                    memory_limit: "1Gi".to_string(),
                    storage_request: Some("5Gi".to_string()),
                },
                grafana: ServiceResources {
                    replicas: 1,
                    cpu_request: "50m".to_string(),
                    cpu_limit: "200m".to_string(),
                    memory_request: "128Mi".to_string(),
                    memory_limit: "512Mi".to_string(),
                    storage_request: Some("1Gi".to_string()),
                },
                load_balancer: ServiceResources {
                    replicas: 1,
                    cpu_request: "50m".to_string(),
                    cpu_limit: "100m".to_string(),
                    memory_request: "64Mi".to_string(),
                    memory_limit: "128Mi".to_string(),
                    storage_request: None,
                },
            },
            security: SecurityConfig {
                network_policies_enabled: false,
                pod_security_policies_enabled: false,
                tls_enabled: false,
                rbac_enabled: true,
                secrets_encryption: false,
            },
            networking: NetworkConfig {
                service_mesh_enabled: false,
                ingress_controller: "nginx".to_string(),
                dns_policy: "ClusterFirst".to_string(),
                network_plugin: "flannel".to_string(),
            },
            dependencies: vec![
                DependencyConfig {
                    name: "redis".to_string(),
                    version: "7.0".to_string(),
                    config_override: HashMap::new(),
                }
            ],
        }
    }
    
    fn create_production_environment() -> EnvironmentConfig {
        EnvironmentConfig {
            name: "production".to_string(),
            infrastructure: InfrastructureConfig {
                platform: "Kubernetes".to_string(),
                region: "us-west-2".to_string(),
                availability_zones: vec![
                    "us-west-2a".to_string(),
                    "us-west-2b".to_string(),
                    "us-west-2c".to_string(),
                ],
                node_types: vec![
                    NodeType {
                        name: "prod-worker".to_string(),
                        instance_type: "c5.2xlarge".to_string(),
                        cpu_cores: 8,
                        memory_gb: 16,
                        storage_gb: 100,
                        network_performance: "High".to_string(),
                    }
                ],
                storage_classes: vec![
                    StorageClass {
                        name: "gp3".to_string(),
                        storage_type: "SSD".to_string(),
                        iops: 3000,
                        throughput_mbps: 125,
                    }
                ],
            },
            resources: ResourceAllocation {
                websocket_server: ServiceResources {
                    replicas: 3,
                    cpu_request: "1000m".to_string(),
                    cpu_limit: "2000m".to_string(),
                    memory_request: "1Gi".to_string(),
                    memory_limit: "4Gi".to_string(),
                    storage_request: None,
                },
                redis_cluster: ServiceResources {
                    replicas: 3,
                    cpu_request: "500m".to_string(),
                    cpu_limit: "1000m".to_string(),
                    memory_request: "1Gi".to_string(),
                    memory_limit: "4Gi".to_string(),
                    storage_request: Some("10Gi".to_string()),
                },
                prometheus: ServiceResources {
                    replicas: 2,
                    cpu_request: "500m".to_string(),
                    cpu_limit: "1000m".to_string(),
                    memory_request: "2Gi".to_string(),
                    memory_limit: "8Gi".to_string(),
                    storage_request: Some("100Gi".to_string()),
                },
                grafana: ServiceResources {
                    replicas: 2,
                    cpu_request: "200m".to_string(),
                    cpu_limit: "500m".to_string(),
                    memory_request: "512Mi".to_string(),
                    memory_limit: "2Gi".to_string(),
                    storage_request: Some("10Gi".to_string()),
                },
                load_balancer: ServiceResources {
                    replicas: 2,
                    cpu_request: "200m".to_string(),
                    cpu_limit: "500m".to_string(),
                    memory_request: "256Mi".to_string(),
                    memory_limit: "1Gi".to_string(),
                    storage_request: None,
                },
            },
            security: SecurityConfig {
                network_policies_enabled: true,
                pod_security_policies_enabled: true,
                tls_enabled: true,
                rbac_enabled: true,
                secrets_encryption: true,
            },
            networking: NetworkConfig {
                service_mesh_enabled: true,
                ingress_controller: "istio-gateway".to_string(),
                dns_policy: "ClusterFirst".to_string(),
                network_plugin: "calico".to_string(),
            },
            dependencies: vec![
                DependencyConfig {
                    name: "redis-cluster".to_string(),
                    version: "7.0".to_string(),
                    config_override: HashMap::from([
                        ("cluster-enabled".to_string(), "yes".to_string()),
                        ("cluster-config-file".to_string(), "nodes.conf".to_string()),
                    ]),
                }
            ],
        }
    }
    
    // ... (å…¶ä»–è¾…åŠ©æ–¹æ³•å®ç°)
}

// è¾…åŠ©ç»“æ„å®šä¹‰
#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityConfig {
    pub network_policies_enabled: bool,
    pub pod_security_policies_enabled: bool,
    pub tls_enabled: bool,
    pub rbac_enabled: bool,
    pub secrets_encryption: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkConfig {
    pub service_mesh_enabled: bool,
    pub ingress_controller: String,
    pub dns_policy: String,
    pub network_plugin: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DependencyConfig {
    pub name: String,
    pub version: String,
    pub config_override: HashMap<String, String>,
}</pre>

        <p><strong>å®è·µç»ƒä¹ ï¼š</strong></p>
        <ol>
            <li><strong>çŸ¥è¯†ç‚¹å›é¡¾æµ‹è¯•</strong>
                <pre>cd day29_knowledge_review
cargo run --bin review_basics
cargo run --bin review_ownership
cargo run --bin review_async</pre>
            </li>
            <li><strong>æ¶æ„åˆ†ææ‰§è¡Œ</strong>
                <pre>cargo run --bin architecture_analysis > reports/architecture_report.md
cat reports/architecture_report.md</pre>
            </li>
            <li><strong>æ€§èƒ½åŸºå‡†æµ‹è¯•</strong>
                <pre>cargo bench --bench websocket_performance
cat target/criterion/report/index.html</pre>
            </li>
            <li><strong>éƒ¨ç½²ç­–ç•¥ç”Ÿæˆ</strong>
                <pre>cargo run --bin deployment_planner > deployment_strategy.json
jq '.environments.production' deployment_strategy.json</pre>
            </li>
        </ol>

        <p><strong>æŠ€æœ¯æ ˆå›é¡¾æ€»ç»“ï¼š</strong></p>
        <ul>
            <li><strong>æ ¸å¿ƒè¯­è¨€ç‰¹æ€§</strong>: æ‰€æœ‰æƒã€å€Ÿç”¨ã€ç”Ÿå‘½å‘¨æœŸã€trait ç³»ç»Ÿ</li>
            <li><strong>å¼‚æ­¥ç¼–ç¨‹</strong>: Futureã€async/awaitã€tokio ç”Ÿæ€</li>
            <li><strong>ç½‘ç»œç¼–ç¨‹</strong>: WebSocket åè®®å®ç°ã€è¿æ¥ç®¡ç†</li>
            <li><strong>å¹¶å‘æ¨¡å‹</strong>: æ¶ˆæ¯ä¼ é€’ã€å…±äº«çŠ¶æ€ã€åŒæ­¥åŸè¯­</li>
            <li><strong>é”™è¯¯å¤„ç†</strong>: Result ç±»å‹ã€é”™è¯¯ä¼ æ’­ã€é”™è¯¯æ¢å¤</li>
            <li><strong>æ€§èƒ½ä¼˜åŒ–</strong>: é›¶æˆæœ¬æŠ½è±¡ã€å†…å­˜ç®¡ç†ã€ç¼–è¯‘å™¨ä¼˜åŒ–</li>
            <li><strong>å®¹å™¨åŒ–</strong>: Docker å¤šé˜¶æ®µæ„å»ºã€é•œåƒä¼˜åŒ–</li>
            <li><strong>ç¼–æ’éƒ¨ç½²</strong>: Kubernetesã€Helm Chartsã€æœåŠ¡ç½‘æ ¼</li>
            <li><strong>å¯è§‚æµ‹æ€§</strong>: æ—¥å¿—ã€æŒ‡æ ‡ã€åˆ†å¸ƒå¼è¿½è¸ª</li>
            <li><strong>å®‰å…¨å®è·µ</strong>: è®¤è¯æˆæƒã€ç½‘ç»œå®‰å…¨ã€å®¹å™¨å®‰å…¨</li>
        </ul>
    
        <p class="date"><strong>ğŸ—“ï¸ 2025-08-30</strong></p>
        <h2>Day 30 - æœ€ç»ˆé¡¹ç›®é›†æˆä¸ç”Ÿäº§å°±ç»ªæ€§å‡†å¤‡</h2>
        <p>æ•´åˆæ‰€æœ‰ç»„ä»¶æ„å»ºå®Œæ•´çš„ç”Ÿäº§çº§ WebSocket æœåŠ¡ï¼Œå®æ–½ä¼ä¸šçº§è´¨é‡ä¿è¯å’Œå‘å¸ƒå‡†å¤‡æµç¨‹ã€‚</p>
        
        <h3>å­¦ä¹ ç›®æ ‡</h3>
        <ul>
            <li>é›†æˆæ‰€æœ‰é¡¹ç›®ç»„ä»¶å½¢æˆå®Œæ•´çš„æœåŠ¡ç³»ç»Ÿ</li>
            <li>å®æ–½ä¼ä¸šçº§ä»£ç è´¨é‡ä¿è¯å’Œæµ‹è¯•è¦†ç›–</li>
            <li>å®Œæˆç”Ÿäº§ç¯å¢ƒé…ç½®å’Œéƒ¨ç½²è‡ªåŠ¨åŒ–</li>
            <li>å»ºç«‹ç›‘æ§ã€å‘Šè­¦å’Œè¿ç»´ç®¡ç†ä½“ç³»</li>
            <li>æ‰§è¡Œæ€§èƒ½å‹æµ‹å’Œå®¹é‡è§„åˆ’éªŒè¯</li>
            <li>å®Œå–„æ–‡æ¡£å’Œç”¨æˆ·æŒ‡å—å‡†å¤‡å‘å¸ƒ</li>
        </ul>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: å®Œæ•´é¡¹ç›®é›†æˆæ¶æ„</strong></p>
        <pre>ğŸ“ æœ€ç»ˆé¡¹ç›®ç»“æ„ï¼š
day30_production_ready/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ server/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ websocket.rs
â”‚   â”‚   â”œâ”€â”€ auth.rs
â”‚   â”‚   â”œâ”€â”€ middleware.rs
â”‚   â”‚   â””â”€â”€ handlers.rs
â”‚   â”œâ”€â”€ client/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ connection.rs
â”‚   â”‚   â”œâ”€â”€ manager.rs
â”‚   â”‚   â””â”€â”€ pool.rs
â”‚   â”œâ”€â”€ message/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ types.rs
â”‚   â”‚   â”œâ”€â”€ router.rs
â”‚   â”‚   â”œâ”€â”€ broadcast.rs
â”‚   â”‚   â””â”€â”€ persistence.rs
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ settings.rs
â”‚   â”‚   â”œâ”€â”€ validation.rs
â”‚   â”‚   â””â”€â”€ environment.rs
â”‚   â”œâ”€â”€ monitoring/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ metrics.rs
â”‚   â”‚   â”œâ”€â”€ health.rs
â”‚   â”‚   â”œâ”€â”€ tracing.rs
â”‚   â”‚   â””â”€â”€ alerts.rs
â”‚   â”œâ”€â”€ storage/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ redis.rs
â”‚   â”‚   â”œâ”€â”€ persistence.rs
â”‚   â”‚   â””â”€â”€ cache.rs
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ crypto.rs
â”‚       â”œâ”€â”€ validation.rs
â”‚       â””â”€â”€ error.rs
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ integration/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ websocket_tests.rs
â”‚   â”‚   â”œâ”€â”€ auth_tests.rs
â”‚   â”‚   â”œâ”€â”€ load_tests.rs
â”‚   â”‚   â””â”€â”€ e2e_tests.rs
â”‚   â”œâ”€â”€ unit/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ message_tests.rs
â”‚   â”‚   â”œâ”€â”€ client_tests.rs
â”‚   â”‚   â””â”€â”€ config_tests.rs
â”‚   â””â”€â”€ fixtures/
â”‚       â”œâ”€â”€ test_data.json
â”‚       â”œâ”€â”€ mock_responses.json
â”‚       â””â”€â”€ test_configs.toml
â”œâ”€â”€ benches/
â”‚   â”œâ”€â”€ connection_benchmark.rs
â”‚   â”œâ”€â”€ message_throughput.rs
â”‚   â”œâ”€â”€ memory_usage.rs
â”‚   â””â”€â”€ concurrent_load.rs
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ simple_client.rs
â”‚   â”œâ”€â”€ chat_room.rs
â”‚   â”œâ”€â”€ broadcast_server.rs
â”‚   â””â”€â”€ load_generator.rs
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ websocket_api.md
â”‚   â”‚   â”œâ”€â”€ rest_api.md
â”‚   â”‚   â””â”€â”€ authentication.md
â”‚   â”œâ”€â”€ deployment/
â”‚   â”‚   â”œâ”€â”€ kubernetes.md
â”‚   â”‚   â”œâ”€â”€ docker.md
â”‚   â”‚   â”œâ”€â”€ monitoring.md
â”‚   â”‚   â””â”€â”€ troubleshooting.md
â”‚   â”œâ”€â”€ development/
â”‚   â”‚   â”œâ”€â”€ contributing.md
â”‚   â”‚   â”œâ”€â”€ architecture.md
â”‚   â”‚   â””â”€â”€ testing.md
â”‚   â””â”€â”€ user_guide/
â”‚       â”œâ”€â”€ getting_started.md
â”‚       â”œâ”€â”€ configuration.md
â”‚       â””â”€â”€ best_practices.md
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ build/
â”‚   â”‚   â”œâ”€â”€ release.sh
â”‚   â”‚   â”œâ”€â”€ docker-build.sh
â”‚   â”‚   â””â”€â”€ cross-compile.sh
â”‚   â”œâ”€â”€ deploy/
â”‚   â”‚   â”œâ”€â”€ production.sh
â”‚   â”‚   â”œâ”€â”€ staging.sh
â”‚   â”‚   â””â”€â”€ rollback.sh
â”‚   â”œâ”€â”€ test/
â”‚   â”‚   â”œâ”€â”€ integration.sh
â”‚   â”‚   â”œâ”€â”€ load-test.sh
â”‚   â”‚   â””â”€â”€ security-test.sh
â”‚   â””â”€â”€ maintenance/
â”‚       â”œâ”€â”€ backup.sh
â”‚       â”œâ”€â”€ cleanup.sh
â”‚       â””â”€â”€ health-check.sh
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”‚   â”œâ”€â”€ service.yaml
â”‚   â”‚   â”œâ”€â”€ configmap.yaml
â”‚   â”‚   â””â”€â”€ secrets.yaml
â”‚   â”œâ”€â”€ overlays/
â”‚   â”‚   â”œâ”€â”€ development/
â”‚   â”‚   â”œâ”€â”€ staging/
â”‚   â”‚   â””â”€â”€ production/
â”‚   â””â”€â”€ monitoring/
â”‚       â”œâ”€â”€ prometheus.yaml
â”‚       â”œâ”€â”€ grafana.yaml
â”‚       â””â”€â”€ alertmanager.yaml
â”œâ”€â”€ helm/
â”‚   â”œâ”€â”€ Chart.yaml
â”‚   â”œâ”€â”€ values.yaml
â”‚   â”œâ”€â”€ templates/
â”‚   â””â”€â”€ charts/
â”œâ”€â”€ configs/
â”‚   â”œâ”€â”€ production.toml
â”‚   â”œâ”€â”€ staging.toml
â”‚   â”œâ”€â”€ development.toml
â”‚   â””â”€â”€ monitoring/
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ ci.yml
â”‚       â”œâ”€â”€ release.yml
â”‚       â”œâ”€â”€ security.yml
â”‚       â””â”€â”€ deploy.yml
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ README.md
â”œâ”€â”€ CHANGELOG.md
â”œâ”€â”€ LICENSE
â””â”€â”€ SECURITY.md</pre>

        <p><strong>ä¸»æœåŠ¡å™¨é›†æˆå®ç°ï¼š</strong></p>
        <pre># src/main.rs
//! ç”Ÿäº§çº§ WebSocket æœåŠ¡å™¨ä¸»å…¥å£

use std::net::SocketAddr;
use std::sync::Arc;
use tokio::signal;
use tracing::{info, error, warn};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

use day30_production_ready::{
    config::{Config, Environment},
    server::WebSocketServer,
    monitoring::{MetricsCollector, HealthChecker},
    storage::StorageManager,
    Result, AppError,
};

#[tokio::main]
async fn main() -> Result<()> {
    // åˆå§‹åŒ–æ—¥å¿—å’Œè¿½è¸ª
    init_tracing()?;
    
    info!("å¯åŠ¨ Rust WebSocket ç”Ÿäº§æœåŠ¡å™¨");
    
    // åŠ è½½é…ç½®
    let config = Config::from_environment()?;
    info!("é…ç½®åŠ è½½å®Œæˆ: ç¯å¢ƒ={:?}", config.environment);
    
    // éªŒè¯é…ç½®
    config.validate()?;
    info!("é…ç½®éªŒè¯é€šè¿‡");
    
    // åˆå§‹åŒ–å­˜å‚¨
    let storage = Arc::new(StorageManager::new(&config.storage).await?);
    info!("å­˜å‚¨ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
    
    // åˆå§‹åŒ–ç›‘æ§
    let metrics = Arc::new(MetricsCollector::new(&config.monitoring)?);
    let health_checker = Arc::new(HealthChecker::new(storage.clone(), metrics.clone()));
    info!("ç›‘æ§ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
    
    // åˆ›å»ºæœåŠ¡å™¨å®ä¾‹
    let server = WebSocketServer::new(
        config.clone(),
        storage.clone(),
        metrics.clone(),
        health_checker.clone(),
    ).await?;
    
    info!("WebSocket æœåŠ¡å™¨åˆ›å»ºå®Œæˆ");
    
    // å¯åŠ¨å¥åº·æ£€æŸ¥æœåŠ¡
    let health_addr: SocketAddr = format!("{}:{}", 
        config.server.host, 
        config.server.health_port
    ).parse()?;
    
    let health_server = start_health_server(health_addr, health_checker.clone());
    
    // å¯åŠ¨æŒ‡æ ‡æœåŠ¡
    let metrics_addr: SocketAddr = format!("{}:{}", 
        config.server.host, 
        config.server.metrics_port
    ).parse()?;
    
    let metrics_server = start_metrics_server(metrics_addr, metrics.clone());
    
    // å¯åŠ¨ä¸» WebSocket æœåŠ¡
    let main_addr: SocketAddr = format!("{}:{}", 
        config.server.host, 
        config.server.port
    ).parse()?;
    
    info!("æœåŠ¡å™¨å¯åŠ¨åœ°å€:");
    info!("  WebSocket: ws://{}", main_addr);
    info!("  å¥åº·æ£€æŸ¥: http://{}/health", health_addr);
    info!("  æŒ‡æ ‡: http://{}/metrics", metrics_addr);
    
    // ä¼˜é›…å…³é—­ä¿¡å·å¤„ç†
    let shutdown_signal = setup_shutdown_signal();
    
    // å¹¶å‘è¿è¡Œæ‰€æœ‰æœåŠ¡
    tokio::select! {
        result = server.run(main_addr) => {
            match result {
                Ok(_) => info!("WebSocket æœåŠ¡å™¨æ­£å¸¸é€€å‡º"),
                Err(e) => error!("WebSocket æœåŠ¡å™¨é”™è¯¯: {}", e),
            }
        }
        result = health_server => {
            match result {
                Ok(_) => info!("å¥åº·æ£€æŸ¥æœåŠ¡å™¨æ­£å¸¸é€€å‡º"),
                Err(e) => error!("å¥åº·æ£€æŸ¥æœåŠ¡å™¨é”™è¯¯: {}", e),
            }
        }
        result = metrics_server => {
            match result {
                Ok(_) => info!("æŒ‡æ ‡æœåŠ¡å™¨æ­£å¸¸é€€å‡º"),
                Err(e) => error!("æŒ‡æ ‡æœåŠ¡å™¨é”™è¯¯: {}", e),
            }
        }
        _ = shutdown_signal => {
            info!("æ¥æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­...");
        }
    }
    
    // æ‰§è¡Œæ¸…ç†æ“ä½œ
    info!("æ‰§è¡Œæ¸…ç†æ“ä½œ...");
    storage.close().await?;
    metrics.flush().await?;
    
    info!("æœåŠ¡å™¨å·²å®Œå…¨å…³é—­");
    Ok(())
}

/// åˆå§‹åŒ–è¿½è¸ªå’Œæ—¥å¿—ç³»ç»Ÿ
fn init_tracing() -> Result<()> {
    let env_filter = tracing_subscriber::EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| "day30_production_ready=info,tower_http=debug".into());
    
    // æ§åˆ¶å°è¾“å‡ºå±‚
    let console_layer = tracing_subscriber::fmt::layer()
        .with_target(true)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true);
    
    // JSON æ ¼å¼è¾“å‡ºå±‚ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
    let json_layer = tracing_subscriber::fmt::layer()
        .json()
        .with_current_span(false)
        .with_span_list(true);
    
    // OpenTelemetry å±‚
    let tracer = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(opentelemetry_otlp::new_exporter().tonic())
        .install_batch(opentelemetry::runtime::Tokio)?;
    
    let telemetry_layer = tracing_opentelemetry::layer().with_tracer(tracer);
    
    // ç»„åˆæ‰€æœ‰å±‚
    tracing_subscriber::registry()
        .with(env_filter)
        .with(console_layer)
        .with(json_layer)
        .with(telemetry_layer)
        .init();
    
    Ok(())
}

/// å¯åŠ¨å¥åº·æ£€æŸ¥æœåŠ¡å™¨
async fn start_health_server(
    addr: SocketAddr,
    health_checker: Arc<HealthChecker>,
) -> Result<()> {
    use axum::{
        routing::get,
        response::Json,
        http::StatusCode,
        Router,
    };
    
    let health_router = Router::new()
        .route("/health", get({
            let checker = health_checker.clone();
            move || async move {
                match checker.check_all().await {
                    Ok(status) => (StatusCode::OK, Json(status)),
                    Err(_) => (StatusCode::SERVICE_UNAVAILABLE, Json(serde_json::json!({
                        "status": "unhealthy"
                    }))),
                }
            }
        }))
        .route("/health/ready", get({
            let checker = health_checker.clone();
            move || async move {
                match checker.check_readiness().await {
                    Ok(_) => StatusCode::OK,
                    Err(_) => StatusCode::SERVICE_UNAVAILABLE,
                }
            }
        }))
        .route("/health/live", get(|| async {
            StatusCode::OK
        }));
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, health_router).await?;
    
    Ok(())
}

/// å¯åŠ¨æŒ‡æ ‡æœåŠ¡å™¨
async fn start_metrics_server(
    addr: SocketAddr,
    metrics: Arc<MetricsCollector>,
) -> Result<()> {
    use axum::{
        routing::get,
        response::Response,
        http::{StatusCode, header},
        Router,
    };
    use prometheus::{Encoder, TextEncoder};
    
    let metrics_router = Router::new()
        .route("/metrics", get({
            let metrics = metrics.clone();
            move || async move {
                let encoder = TextEncoder::new();
                let metric_families = metrics.registry().gather();
                
                match encoder.encode_to_string(&metric_families) {
                    Ok(output) => Response::builder()
                        .status(StatusCode::OK)
                        .header(header::CONTENT_TYPE, encoder.format_type())
                        .body(output)
                        .unwrap(),
                    Err(_) => Response::builder()
                        .status(StatusCode::INTERNAL_SERVER_ERROR)
                        .body("Failed to encode metrics".to_string())
                        .unwrap(),
                }
            }
        }));
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, metrics_router).await?;
    
    Ok(())
}

/// è®¾ç½®ä¼˜é›…å…³é—­ä¿¡å·å¤„ç†
async fn setup_shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            info!("æ¥æ”¶åˆ° Ctrl+C ä¿¡å·");
        },
        _ = terminate => {
            info!("æ¥æ”¶åˆ°ç»ˆæ­¢ä¿¡å·");
        },
    }
}</pre>

        <p><strong>æ­¥éª¤ 2: ä¼ä¸šçº§é…ç½®ç®¡ç†</strong></p>
        <pre># src/config/mod.rs
//! ä¼ä¸šçº§é…ç½®ç®¡ç†ç³»ç»Ÿ

use std::path::Path;
use serde::{Deserialize, Serialize};
use config::{Config as ConfigBuilder, Environment as ConfigEnv, File};
use validator::{Validate, ValidationError};

use crate::{Result, AppError};

/// åº”ç”¨ç¨‹åºé…ç½®
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct Config {
    /// è¿è¡Œç¯å¢ƒ
    pub environment: Environment,
    
    /// æœåŠ¡å™¨é…ç½®
    #[validate]
    pub server: ServerConfig,
    
    /// å­˜å‚¨é…ç½®
    #[validate]
    pub storage: StorageConfig,
    
    /// ç›‘æ§é…ç½®
    #[validate] 
    pub monitoring: MonitoringConfig,
    
    /// å®‰å…¨é…ç½®
    #[validate]
    pub security: SecurityConfig,
    
    /// æ—¥å¿—é…ç½®
    #[validate]
    pub logging: LoggingConfig,
}

/// è¿è¡Œç¯å¢ƒæšä¸¾
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Environment {
    Development,
    Testing,
    Staging,
    Production,
}

/// æœåŠ¡å™¨é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct ServerConfig {
    /// ç»‘å®šåœ°å€
    #[validate(ip)]
    pub host: String,
    
    /// WebSocket ç«¯å£
    #[validate(range(min = 1024, max = 65535))]
    pub port: u16,
    
    /// å¥åº·æ£€æŸ¥ç«¯å£
    #[validate(range(min = 1024, max = 65535))]
    pub health_port: u16,
    
    /// æŒ‡æ ‡ç«¯å£
    #[validate(range(min = 1024, max = 65535))]
    pub metrics_port: u16,
    
    /// æœ€å¤§è¿æ¥æ•°
    #[validate(range(min = 1, max = 100000))]
    pub max_connections: usize,
    
    /// è¿æ¥è¶…æ—¶ï¼ˆç§’ï¼‰
    #[validate(range(min = 30, max = 3600))]
    pub connection_timeout: u64,
    
    /// å¿ƒè·³é—´éš”ï¼ˆç§’ï¼‰
    #[validate(range(min = 10, max = 300))]
    pub heartbeat_interval: u64,
    
    /// å·¥ä½œçº¿ç¨‹æ•°
    #[validate(range(min = 1, max = 128))]
    pub worker_threads: usize,
    
    /// å¯ç”¨ TLS
    pub tls_enabled: bool,
    
    /// TLS è¯ä¹¦è·¯å¾„
    pub tls_cert_path: Option<String>,
    
    /// TLS ç§é’¥è·¯å¾„
    pub tls_key_path: Option<String>,
}

/// å­˜å‚¨é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct StorageConfig {
    /// Redis é…ç½®
    #[validate]
    pub redis: RedisConfig,
    
    /// æ•°æ®åº“é…ç½®
    pub database: Option<DatabaseConfig>,
    
    /// ç¼“å­˜é…ç½®
    #[validate]
    pub cache: CacheConfig,
}

/// Redis é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct RedisConfig {
    /// Redis URL
    #[validate(url)]
    pub url: String,
    
    /// è¿æ¥æ± å¤§å°
    #[validate(range(min = 1, max = 100))]
    pub pool_size: u32,
    
    /// è¿æ¥è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
    #[validate(range(min = 100, max = 30000))]
    pub connect_timeout_ms: u64,
    
    /// å‘½ä»¤è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
    #[validate(range(min = 100, max = 30000))]
    pub command_timeout_ms: u64,
    
    /// é›†ç¾¤æ¨¡å¼
    pub cluster_mode: bool,
    
    /// é›†ç¾¤èŠ‚ç‚¹
    pub cluster_nodes: Vec<String>,
}

/// ç›‘æ§é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct MonitoringConfig {
    /// å¯ç”¨æŒ‡æ ‡æ”¶é›†
    pub metrics_enabled: bool,
    
    /// æŒ‡æ ‡æ”¶é›†é—´éš”ï¼ˆç§’ï¼‰
    #[validate(range(min = 1, max = 300))]
    pub metrics_interval: u64,
    
    /// å¯ç”¨åˆ†å¸ƒå¼è¿½è¸ª
    pub tracing_enabled: bool,
    
    /// è¿½è¸ªå¯¼å‡ºå™¨ç«¯ç‚¹
    pub tracing_endpoint: Option<String>,
    
    /// é‡‡æ ·ç‡ï¼ˆ0.0 - 1.0ï¼‰
    #[validate(range(min = 0.0, max = 1.0))]
    pub tracing_sample_rate: f64,
    
    /// å¯ç”¨å¥åº·æ£€æŸ¥
    pub health_check_enabled: bool,
    
    /// å¥åº·æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
    #[validate(range(min = 5, max = 300))]
    pub health_check_interval: u64,
    
    /// Prometheus é…ç½®
    pub prometheus: PrometheusConfig,
}

/// Prometheus é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct PrometheusConfig {
    /// å¯ç”¨ Prometheus æŒ‡æ ‡
    pub enabled: bool,
    
    /// æŒ‡æ ‡å‰ç¼€
    #[validate(length(min = 1, max = 50))]
    pub metrics_prefix: String,
    
    /// æ¨é€ç½‘å…³ URL
    pub pushgateway_url: Option<String>,
    
    /// æ¨é€é—´éš”ï¼ˆç§’ï¼‰
    #[validate(range(min = 10, max = 3600))]
    pub push_interval: u64,
}

impl Config {
    /// ä»ç¯å¢ƒå˜é‡å’Œé…ç½®æ–‡ä»¶åŠ è½½é…ç½®
    pub fn from_environment() -> Result<Self> {
        let env = std::env::var("RUST_ENV")
            .unwrap_or_else(|_| "development".to_string());
        
        let config_file = format!("configs/{}.toml", env);
        
        let mut builder = ConfigBuilder::builder()
            // é»˜è®¤é…ç½®
            .add_source(File::with_name("configs/default").required(false))
            // ç¯å¢ƒç‰¹å®šé…ç½®
            .add_source(File::with_name(&config_file).required(false))
            // æœ¬åœ°è¦†ç›–é…ç½®
            .add_source(File::with_name("configs/local").required(false))
            // ç¯å¢ƒå˜é‡è¦†ç›–
            .add_source(
                ConfigEnv::with_prefix("WEBSOCKET")
                    .separator("__")
                    .list_separator(",")
            );
        
        let config = builder.build()?;
        let mut settings: Config = config.try_deserialize()?;
        
        // è®¾ç½®ç¯å¢ƒ
        settings.environment = match env.as_str() {
            "development" => Environment::Development,
            "testing" => Environment::Testing,
            "staging" => Environment::Staging,
            "production" => Environment::Production,
            _ => Environment::Development,
        };
        
        Ok(settings)
    }
    
    /// éªŒè¯é…ç½®
    pub fn validate(&self) -> Result<()> {
        // ä½¿ç”¨ validator crate è¿›è¡ŒéªŒè¯
        self.validate()
            .map_err(|e| AppError::ConfigError(format!("é…ç½®éªŒè¯å¤±è´¥: {}", e)))?;
        
        // è‡ªå®šä¹‰éªŒè¯é€»è¾‘
        self.validate_custom()?;
        
        Ok(())
    }
    
    /// è‡ªå®šä¹‰éªŒè¯é€»è¾‘
    fn validate_custom(&self) -> Result<()> {
        // ç«¯å£å†²çªæ£€æŸ¥
        let ports = vec![
            self.server.port,
            self.server.health_port,
            self.server.metrics_port,
        ];
        
        for (i, &port1) in ports.iter().enumerate() {
            for &port2 in ports.iter().skip(i + 1) {
                if port1 == port2 {
                    return Err(AppError::ConfigError(
                        format!("ç«¯å£å†²çª: {}", port1)
                    ));
                }
            }
        }
        
        // TLS é…ç½®æ£€æŸ¥
        if self.server.tls_enabled {
            if self.server.tls_cert_path.is_none() || self.server.tls_key_path.is_none() {
                return Err(AppError::ConfigError(
                    "å¯ç”¨ TLS æ—¶å¿…é¡»æä¾›è¯ä¹¦å’Œç§é’¥è·¯å¾„".to_string()
                ));
            }
        }
        
        // ç”Ÿäº§ç¯å¢ƒç‰¹å®šæ£€æŸ¥
        if self.environment == Environment::Production {
            if !self.server.tls_enabled {
                return Err(AppError::ConfigError(
                    "ç”Ÿäº§ç¯å¢ƒå¿…é¡»å¯ç”¨ TLS".to_string()
                ));
            }
            
            if self.security.jwt_secret.len() < 32 {
                return Err(AppError::ConfigError(
                    "ç”Ÿäº§ç¯å¢ƒ JWT å¯†é’¥é•¿åº¦å¿…é¡»è‡³å°‘ 32 å­—ç¬¦".to_string()
                ));
            }
        }
        
        Ok(())
    }
    
    /// æ˜¯å¦ä¸ºç”Ÿäº§ç¯å¢ƒ
    pub fn is_production(&self) -> bool {
        self.environment == Environment::Production
    }
    
    /// æ˜¯å¦ä¸ºå¼€å‘ç¯å¢ƒ
    pub fn is_development(&self) -> bool {
        self.environment == Environment::Development
    }
    
    /// è·å–å®Œæ•´çš„ WebSocket åœ°å€
    pub fn websocket_address(&self) -> String {
        let protocol = if self.server.tls_enabled { "wss" } else { "ws" };
        format!("{}://{}:{}", protocol, self.server.host, self.server.port)
    }
}</pre>

        <p><strong>æ­¥éª¤ 3: ç»¼åˆé›†æˆæµ‹è¯•å¥—ä»¶</strong></p>
        <pre># tests/integration/e2e_tests.rs
//! ç«¯åˆ°ç«¯é›†æˆæµ‹è¯•å¥—ä»¶

use std::time::Duration;
use tokio::time::timeout;
use tokio_tungstenite::{connect_async, tungstenite::Message};
use futures::{SinkExt, StreamExt};
use serde_json::json;
use uuid::Uuid;

use day30_production_ready::{
    config::Config,
    server::WebSocketServer,
    test_utils::{TestEnvironment, TestClient},
};

/// ç«¯åˆ°ç«¯æµ‹è¯•ä¸Šä¸‹æ–‡
struct E2ETestContext {
    environment: TestEnvironment,
    server_url: String,
    auth_token: String,
}

impl E2ETestContext {
    async fn new() -> Self {
        let environment = TestEnvironment::new().await;
        let config = environment.config();
        let server_url = format!("ws://{}:{}", config.server.host, config.server.port);
        let auth_token = environment.generate_test_token("test_user", vec!["user"]).await;
        
        Self {
            environment,
            server_url,
            auth_token,
        }
    }
    
    async fn create_authenticated_client(&self) -> TestClient {
        TestClient::connect(&self.server_url, &self.auth_token).await
    }
}

#[tokio::test]
async fn test_complete_chat_flow() {
    let ctx = E2ETestContext::new().await;
    
    // åˆ›å»ºå¤šä¸ªå®¢æˆ·ç«¯
    let mut client1 = ctx.create_authenticated_client().await;
    let mut client2 = ctx.create_authenticated_client().await;
    let mut client3 = ctx.create_authenticated_client().await;
    
    // å®¢æˆ·ç«¯1åŠ å…¥æˆ¿é—´
    let join_room_msg = json!({
        "type": "join_room",
        "room": "test_room",
        "user": "user1"
    });
    
    client1.send_message(join_room_msg.to_string()).await;
    
    // éªŒè¯åŠ å…¥æˆ¿é—´å“åº”
    let response = timeout(Duration::from_secs(5), client1.receive_message())
        .await
        .expect("è¶…æ—¶")
        .expect("æ¥æ”¶æ¶ˆæ¯å¤±è´¥");
    
    let response_json: serde_json::Value = serde_json::from_str(&response).unwrap();
    assert_eq!(response_json["type"], "room_joined");
    assert_eq!(response_json["room"], "test_room");
    
    // å®¢æˆ·ç«¯2ä¹ŸåŠ å…¥ç›¸åŒæˆ¿é—´
    let join_room_msg2 = json!({
        "type": "join_room",
        "room": "test_room", 
        "user": "user2"
    });
    
    client2.send_message(join_room_msg2.to_string()).await;
    
    // ç­‰å¾…å®¢æˆ·ç«¯2çš„åŠ å…¥ç¡®è®¤
    let _response2 = timeout(Duration::from_secs(5), client2.receive_message())
        .await
        .expect("è¶…æ—¶")
        .expect("æ¥æ”¶æ¶ˆæ¯å¤±è´¥");
    
    // å®¢æˆ·ç«¯1åº”è¯¥æ”¶åˆ°ç”¨æˆ·åŠ å…¥é€šçŸ¥
    let user_joined = timeout(Duration::from_secs(5), client1.receive_message())
        .await
        .expect("è¶…æ—¶")
        .expect("æ¥æ”¶æ¶ˆæ¯å¤±è´¥");
    
    let user_joined_json: serde_json::Value = serde_json::from_str(&user_joined).unwrap();
    assert_eq!(user_joined_json["type"], "user_joined");
    assert_eq!(user_joined_json["user"], "user2");
    
    // å®¢æˆ·ç«¯1å‘é€èŠå¤©æ¶ˆæ¯
    let chat_msg = json!({
        "type": "chat_message",
        "room": "test_room",
        "message": "Hello everyone!",
        "user": "user1"
    });
    
    client1.send_message(chat_msg.to_string()).await;
    
    // å®¢æˆ·ç«¯2åº”è¯¥æ”¶åˆ°èŠå¤©æ¶ˆæ¯
    let received_chat = timeout(Duration::from_secs(5), client2.receive_message())
        .await
        .expect("è¶…æ—¶")
        .expect("æ¥æ”¶æ¶ˆæ¯å¤±è´¥");
    
    let received_chat_json: serde_json::Value = serde_json::from_str(&received_chat).unwrap();
    assert_eq!(received_chat_json["type"], "chat_message");
    assert_eq!(received_chat_json["message"], "Hello everyone!");
    assert_eq!(received_chat_json["user"], "user1");
    
    // æµ‹è¯•å¹¿æ’­æ¶ˆæ¯
    let broadcast_msg = json!({
        "type": "broadcast",
        "message": "Server announcement",
        "priority": "high"
    });
    
    // ç®¡ç†å‘˜å‘é€å¹¿æ’­ï¼ˆéœ€è¦adminæƒé™ï¼‰
    let admin_token = ctx.environment.generate_test_token("admin", vec!["admin"]).await;
    let mut admin_client = TestClient::connect(&ctx.server_url, &admin_token).await;
    
    admin_client.send_message(broadcast_msg.to_string()).await;
    
    // æ‰€æœ‰å®¢æˆ·ç«¯éƒ½åº”è¯¥æ”¶åˆ°å¹¿æ’­æ¶ˆæ¯
    for client in [&mut client1, &mut client2, &mut client3] {
        let broadcast_received = timeout(Duration::from_secs(5), client.receive_message())
            .await
            .expect("è¶…æ—¶")
            .expect("æ¥æ”¶æ¶ˆæ¯å¤±è´¥");
        
        let broadcast_json: serde_json::Value = serde_json::from_str(&broadcast_received).unwrap();
        assert_eq!(broadcast_json["type"], "broadcast");
        assert_eq!(broadcast_json["message"], "Server announcement");
    }
    
    // æµ‹è¯•ç¦»å¼€æˆ¿é—´
    let leave_room_msg = json!({
        "type": "leave_room",
        "room": "test_room",
        "user": "user1"
    });
    
    client1.send_message(leave_room_msg.to_string()).await;
    
    // å®¢æˆ·ç«¯2åº”è¯¥æ”¶åˆ°ç”¨æˆ·ç¦»å¼€é€šçŸ¥
    let user_left = timeout(Duration::from_secs(5), client2.receive_message())
        .await
        .expect("è¶…æ—¶")
        .expect("æ¥æ”¶æ¶ˆæ¯å¤±è´¥");
    
    let user_left_json: serde_json::Value = serde_json::from_str(&user_left).unwrap();
    assert_eq!(user_left_json["type"], "user_left");
    assert_eq!(user_left_json["user"], "user1");
    
    // æ¸…ç†èµ„æº
    client1.close().await;
    client2.close().await;
    client3.close().await;
    admin_client.close().await;
}

#[tokio::test]
async fn test_authentication_and_authorization() {
    let ctx = E2ETestContext::new().await;
    
    // æµ‹è¯•æ— æ•ˆ token
    let result = TestClient::connect_with_invalid_token(&ctx.server_url).await;
    assert!(result.is_err(), "åº”è¯¥æ‹’ç»æ— æ•ˆ token");
    
    // æµ‹è¯•è¿‡æœŸ token
    let expired_token = ctx.environment.generate_expired_token("user").await;
    let result = TestClient::connect(&ctx.server_url, &expired_token).await;
    // è¿æ¥åº”è¯¥å¤±è´¥æˆ–åœ¨è®¤è¯æ—¶æ–­å¼€
    
    // æµ‹è¯•æƒé™æ£€æŸ¥
    let user_token = ctx.environment.generate_test_token("user", vec!["user"]).await;
    let mut user_client = TestClient::connect(&ctx.server_url, &user_token).await;
    
    // æ™®é€šç”¨æˆ·å°è¯•æ‰§è¡Œç®¡ç†å‘˜æ“ä½œ
    let admin_action = json!({
        "type": "admin_action",
        "action": "shutdown_server"
    });
    
    user_client.send_message(admin_action.to_string()).await;
    
    // åº”è¯¥æ”¶åˆ°æƒé™é”™è¯¯
    let error_response = timeout(Duration::from_secs(5), user_client.receive_message())
        .await
        .expect("è¶…æ—¶")
        .expect("æ¥æ”¶æ¶ˆæ¯å¤±è´¥");
    
    let error_json: serde_json::Value = serde_json::from_str(&error_response).unwrap();
    assert_eq!(error_json["type"], "error");
    assert_eq!(error_json["code"], "insufficient_permissions");
    
    user_client.close().await;
}

#[tokio::test]
async fn test_connection_limits_and_throttling() {
    let ctx = E2ETestContext::new().await;
    let max_connections = ctx.environment.config().server.max_connections;
    
    // åˆ›å»ºå¤§é‡è¿æ¥æ¥è¿‘é™åˆ¶
    let mut clients = Vec::new();
    for i in 0..max_connections.min(50) { // é™åˆ¶æµ‹è¯•è§„æ¨¡
        let token = ctx.environment.generate_test_token(
            &format!("user_{}", i), 
            vec!["user"]
        ).await;
        
        match TestClient::connect(&ctx.server_url, &token).await {
            Ok(client) => clients.push(client),
            Err(_) => break, // è¾¾åˆ°è¿æ¥é™åˆ¶
        }
    }
    
    println!("æˆåŠŸåˆ›å»º {} ä¸ªè¿æ¥", clients.len());
    
    // å°è¯•åˆ›å»ºè¶…å‡ºé™åˆ¶çš„è¿æ¥
    let overflow_token = ctx.environment.generate_test_token("overflow_user", vec!["user"]).await;
    if clients.len() >= max_connections {
        let result = timeout(
            Duration::from_secs(10),
            TestClient::connect(&ctx.server_url, &overflow_token)
        ).await;
        
        // è¿æ¥åº”è¯¥è¢«æ‹’ç»æˆ–è¶…æ—¶
        assert!(result.is_err() || result.unwrap().is_err());
    }
    
    // æµ‹è¯•æ¶ˆæ¯é€Ÿç‡é™åˆ¶
    if let Some(client) = clients.first_mut() {
        // å¿«é€Ÿå‘é€å¤§é‡æ¶ˆæ¯
        for i in 0..100 {
            let msg = json!({
                "type": "test_message",
                "content": format!("Spam message {}", i)
            });
            
            let result = timeout(
                Duration::from_millis(100),
                client.send_message(msg.to_string())
            ).await;
            
            if result.is_err() {
                println!("åœ¨ç¬¬ {} æ¡æ¶ˆæ¯æ—¶è§¦å‘é€Ÿç‡é™åˆ¶", i);
                break;
            }
        }
    }
    
    // æ¸…ç†æ‰€æœ‰è¿æ¥
    for mut client in clients {
        client.close().await;
    }
}

#[tokio::test]
async fn test_error_handling_and_recovery() {
    let ctx = E2ETestContext::new().await;
    
    let mut client = ctx.create_authenticated_client().await;
    
    // æµ‹è¯•å‘é€æ ¼å¼é”™è¯¯çš„æ¶ˆæ¯
    client.send_raw_message("invalid json {").await;
    
    let error_response = timeout(Duration::from_secs(5), client.receive_message())
        .await
        .expect("è¶…æ—¶")
        .expect("æ¥æ”¶æ¶ˆæ¯å¤±è´¥");
    
    let error_json: serde_json::Value = serde_json::from_str(&error_response).unwrap();
    assert_eq!(error_json["type"], "error");
    assert_eq!(error_json["code"], "invalid_message_format");
    
    // æµ‹è¯•å®¢æˆ·ç«¯åœ¨é”™è¯¯åä»ç„¶å¯ä»¥æ­£å¸¸é€šä¿¡
    let valid_msg = json!({
        "type": "ping"
    });
    
    client.send_message(valid_msg.to_string()).await;
    
    let pong_response = timeout(Duration::from_secs(5), client.receive_message())
        .await
        .expect("è¶…æ—¶")
        .expect("æ¥æ”¶æ¶ˆæ¯å¤±è´¥");
    
    let pong_json: serde_json::Value = serde_json::from_str(&pong_response).unwrap();
    assert_eq!(pong_json["type"], "pong");
    
    client.close().await;
}

#[tokio::test]
async fn test_performance_under_load() {
    let ctx = E2ETestContext::new().await;
    
    // åˆ›å»ºå¤šä¸ªå®¢æˆ·ç«¯è¿›è¡Œå¹¶å‘æµ‹è¯•
    let client_count = 10;
    let messages_per_client = 100;
    
    let mut handles = Vec::new();
    
    for i in 0..client_count {
        let server_url = ctx.server_url.clone();
        let token = ctx.environment.generate_test_token(
            &format!("load_user_{}", i),
            vec!["user"]
        ).await;
        
        let handle = tokio::spawn(async move {
            let mut client = TestClient::connect(&server_url, &token).await.unwrap();
            
            let start_time = std::time::Instant::now();
            
            // å‘é€æ¶ˆæ¯
            for j in 0..messages_per_client {
                let msg = json!({
                    "type": "load_test",
                    "client_id": i,
                    "message_id": j,
                    "timestamp": chrono::Utc::now().timestamp()
                });
                
                client.send_message(msg.to_string()).await;
                
                // å°å»¶è¿Ÿä»¥é¿å…è¿‡åº¦å‹åŠ›
                tokio::time::sleep(Duration::from_millis(10)).await;
            }
            
            let send_duration = start_time.elapsed();
            client.close().await;
            
            (i, send_duration)
        });
        
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰å®¢æˆ·ç«¯å®Œæˆ
    let results = futures::future::join_all(handles).await;
    
    let mut total_duration = Duration::ZERO;
    for result in results {
        let (client_id, duration) = result.unwrap();
        println!("å®¢æˆ·ç«¯ {} å®Œæˆï¼Œè€—æ—¶: {:?}", client_id, duration);
        total_duration = total_duration.max(duration);
    }
    
    println!("è´Ÿè½½æµ‹è¯•å®Œæˆï¼Œæ€»è€—æ—¶: {:?}", total_duration);
    
    // éªŒè¯æ€§èƒ½æŒ‡æ ‡
    let total_messages = client_count * messages_per_client;
    let messages_per_second = total_messages as f64 / total_duration.as_secs_f64();
    
    println!("ååé‡: {:.2} æ¶ˆæ¯/ç§’", messages_per_second);
    
    // åŸºæœ¬æ€§èƒ½è¦æ±‚
    assert!(messages_per_second > 100.0, "æ¶ˆæ¯ååé‡è¿‡ä½: {:.2}", messages_per_second);
    assert!(total_duration < Duration::from_secs(60), "æµ‹è¯•æ‰§è¡Œæ—¶é—´è¿‡é•¿: {:?}", total_duration);
}</pre>

        <p><strong>æ­¥éª¤ 4: ç”Ÿäº§çº§éƒ¨ç½²è‡ªåŠ¨åŒ–</strong></p>
        <pre># scripts/deploy/production.sh
#!/bin/bash
# ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²è„šæœ¬

set -euo pipefail

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# æ—¥å¿—å‡½æ•°
log_info() {
    echo -e "${GREEN}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_step() {
    echo -e "${BLUE}[STEP]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

# é…ç½®å˜é‡
NAMESPACE="websocket-prod"
DEPLOYMENT_NAME="websocket-server"
IMAGE_TAG=${1:-latest}
HELM_RELEASE="websocket-prod"
KUBECONFIG=${KUBECONFIG:-~/.kube/config}

# éªŒè¯å·¥å…·
check_dependencies() {
    log_step "æ£€æŸ¥éƒ¨ç½²ä¾èµ–..."
    
    local deps=("kubectl" "helm" "docker" "curl" "jq")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            log_error "$dep æœªå®‰è£…"
            exit 1
        fi
    done
    
    # æ£€æŸ¥ Kubernetes è¿æ¥
    if ! kubectl cluster-info &> /dev/null; then
        log_error "æ— æ³•è¿æ¥åˆ° Kubernetes é›†ç¾¤"
        exit 1
    fi
    
    log_info "æ‰€æœ‰ä¾èµ–æ£€æŸ¥é€šè¿‡"
}

# é¢„éƒ¨ç½²éªŒè¯
pre_deployment_checks() {
    log_step "æ‰§è¡Œé¢„éƒ¨ç½²æ£€æŸ¥..."
    
    # æ£€æŸ¥é•œåƒæ˜¯å¦å­˜åœ¨
    local image="websocket-server:$IMAGE_TAG"
    if ! docker manifest inspect "$image" &> /dev/null; then
        log_error "é•œåƒ $image ä¸å­˜åœ¨"
        exit 1
    fi
    
    # æ£€æŸ¥ Helm Chart
    if ! helm lint helm/websocket-server/; then
        log_error "Helm Chart éªŒè¯å¤±è´¥"
        exit 1
    fi
    
    # æ£€æŸ¥é›†ç¾¤èµ„æº
    local available_nodes=$(kubectl get nodes --no-headers | grep Ready | wc -l)
    if [ "$available_nodes" -lt 3 ]; then
        log_warn "å¯ç”¨èŠ‚ç‚¹æ•°é‡è¾ƒå°‘: $available_nodes"
    fi
    
    log_info "é¢„éƒ¨ç½²æ£€æŸ¥å®Œæˆ"
}

# åˆ›å»ºå‘½åç©ºé—´
create_namespace() {
    log_step "åˆ›å»º/éªŒè¯å‘½åç©ºé—´..."
    
    if ! kubectl get namespace "$NAMESPACE" &> /dev/null; then
        kubectl create namespace "$NAMESPACE"
        log_info "å‘½åç©ºé—´ $NAMESPACE å·²åˆ›å»º"
    else
        log_info "å‘½åç©ºé—´ $NAMESPACE å·²å­˜åœ¨"
    fi
    
    # è®¾ç½®èµ„æºé…é¢
    kubectl apply -f - <<EOF
apiVersion: v1
kind: ResourceQuota
metadata:
  name: websocket-quota
  namespace: $NAMESPACE
spec:
  hard:
    requests.cpu: "10"
    requests.memory: 20Gi
    limits.cpu: "20"
    limits.memory: 40Gi
    persistentvolumeclaims: "10"
    services: "5"
    secrets: "10"
    configmaps: "10"
EOF
    
    log_info "èµ„æºé…é¢å·²åº”ç”¨"
}

# éƒ¨ç½² Secrets
deploy_secrets() {
    log_step "éƒ¨ç½²æœºå¯†ä¿¡æ¯..."
    
    # æ£€æŸ¥å¿…éœ€çš„ç¯å¢ƒå˜é‡
    local required_vars=("JWT_SECRET" "REDIS_PASSWORD" "TLS_CERT" "TLS_KEY")
    for var in "${required_vars[@]}"; do
        if [ -z "${!var:-}" ]; then
            log_error "ç¯å¢ƒå˜é‡ $var æœªè®¾ç½®"
            exit 1
        fi
    done
    
    # åˆ›å»º TLS Secret
    kubectl create secret tls websocket-tls \
        --cert=<(echo "$TLS_CERT" | base64 -d) \
        --key=<(echo "$TLS_KEY" | base64 -d) \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    # åˆ›å»ºåº”ç”¨ Secret
    kubectl create secret generic websocket-secrets \
        --from-literal=jwt-secret="$JWT_SECRET" \
        --from-literal=redis-password="$REDIS_PASSWORD" \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    log_info "æœºå¯†ä¿¡æ¯éƒ¨ç½²å®Œæˆ"
}

# éƒ¨ç½²ä¾èµ–æœåŠ¡
deploy_dependencies() {
    log_step "éƒ¨ç½²ä¾èµ–æœåŠ¡..."
    
    # éƒ¨ç½² Redis é›†ç¾¤
    helm repo add bitnami https://charts.bitnami.com/bitnami
    helm repo update
    
    helm upgrade --install redis-cluster bitnami/redis-cluster \
        --namespace="$NAMESPACE" \
        --set auth.enabled=true \
        --set auth.password="$REDIS_PASSWORD" \
        --set cluster.nodes=6 \
        --set cluster.replicas=1 \
        --set persistence.enabled=true \
        --set persistence.size=10Gi \
        --set resources.requests.memory=1Gi \
        --set resources.requests.cpu=500m \
        --set resources.limits.memory=2Gi \
        --set resources.limits.cpu=1000m \
        --wait --timeout=600s
    
    # éƒ¨ç½² Prometheus
    helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
    helm repo update
    
    helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
        --namespace="$NAMESPACE" \
        --set prometheus.prometheusSpec.retention=30d \
        --set prometheus.prometheusSpec.storageSpec.volumeClaimTemplate.spec.resources.requests.storage=50Gi \
        --set grafana.persistence.enabled=true \
        --set grafana.persistence.size=10Gi \
        --wait --timeout=600s
    
    log_info "ä¾èµ–æœåŠ¡éƒ¨ç½²å®Œæˆ"
}

# éƒ¨ç½²ä¸»åº”ç”¨
deploy_application() {
    log_step "éƒ¨ç½² WebSocket æœåŠ¡..."
    
    # å‡†å¤‡ Helm values
    cat > /tmp/production-values.yaml <<EOF
image:
  repository: websocket-server
  tag: "$IMAGE_TAG"
  pullPolicy: Always

replicaCount: 3

resources:
  requests:
    cpu: 1000m
    memory: 1Gi
  limits:
    cpu: 2000m
    memory: 4Gi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

service:
  type: ClusterIP
  port: 8080
  targetPort: 8080

ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/websocket-services: "$DEPLOYMENT_NAME"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: ws.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: websocket-tls
      hosts:
        - ws.example.com

config:
  environment: production
  server:
    host: "0.0.0.0"
    port: 8080
    maxConnections: 10000
    tlsEnabled: true
  monitoring:
    metricsEnabled: true
    tracingEnabled: true

secrets:
  jwtSecret: "websocket-secrets"
  redisPassword: "websocket-secrets"

redis:
  enabled: false
  externalRedis:
    host: "redis-cluster"
    port: 6379
    auth: true

monitoring:
  serviceMonitor:
    enabled: true
    interval: 30s

podDisruptionBudget:
  enabled: true
  minAvailable: 2

networkPolicy:
  enabled: true
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx
      ports:
      - protocol: TCP
        port: 8080
    - from:
      - namespaceSelector:
          matchLabels:
            name: monitoring
      ports:
      - protocol: TCP
        port: 9090

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

podSecurityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
EOF
    
    # éƒ¨ç½²åº”ç”¨
    helm upgrade --install "$HELM_RELEASE" helm/websocket-server/ \
        --namespace="$NAMESPACE" \
        --values=/tmp/production-values.yaml \
        --wait --timeout=600s
    
    log_info "WebSocket æœåŠ¡éƒ¨ç½²å®Œæˆ"
}

# éƒ¨ç½²åéªŒè¯
post_deployment_verification() {
    log_step "æ‰§è¡Œéƒ¨ç½²åéªŒè¯..."
    
    # ç­‰å¾… Pods å°±ç»ª
    log_info "ç­‰å¾… Pods å°±ç»ª..."
    kubectl wait --for=condition=ready pod \
        -l app.kubernetes.io/name=websocket-server \
        --namespace="$NAMESPACE" \
        --timeout=300s
    
    # æ£€æŸ¥æœåŠ¡çŠ¶æ€
    local ready_pods=$(kubectl get pods -l app.kubernetes.io/name=websocket-server \
        --namespace="$NAMESPACE" --no-headers | grep Running | wc -l)
    log_info "å°±ç»ªçš„ Pods æ•°é‡: $ready_pods"
    
    # å¥åº·æ£€æŸ¥
    local service_ip=$(kubectl get service "$DEPLOYMENT_NAME" \
        --namespace="$NAMESPACE" -o jsonpath='{.spec.clusterIP}')
    
    kubectl run health-check --rm -i --restart=Never --image=curlimages/curl -- \
        curl -f "http://$service_ip:8080/health" || {
        log_error "å¥åº·æ£€æŸ¥å¤±è´¥"
        exit 1
    }
    
    # æ£€æŸ¥æŒ‡æ ‡ç«¯ç‚¹
    kubectl run metrics-check --rm -i --restart=Never --image=curlimages/curl -- \
        curl -f "http://$service_ip:9090/metrics" || {
        log_warn "æŒ‡æ ‡ç«¯ç‚¹æ£€æŸ¥å¤±è´¥"
    }
    
    log_info "éƒ¨ç½²éªŒè¯å®Œæˆ"
}

# é…ç½®ç›‘æ§å‘Šè­¦
setup_monitoring() {
    log_step "é…ç½®ç›‘æ§å‘Šè­¦..."
    
    # åº”ç”¨ Prometheus è§„åˆ™
    kubectl apply -f k8s/monitoring/prometheus-rules.yaml -n "$NAMESPACE"
    
    # é…ç½® Grafana ä»ªè¡¨æ¿
    kubectl create configmap websocket-dashboard \
        --from-file=configs/monitoring/grafana-dashboard.json \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    log_info "ç›‘æ§é…ç½®å®Œæˆ"
}

# æ¸…ç†ä¸´æ—¶æ–‡ä»¶
cleanup() {
    log_step "æ¸…ç†ä¸´æ—¶æ–‡ä»¶..."
    rm -f /tmp/production-values.yaml
    log_info "æ¸…ç†å®Œæˆ"
}

# ä¸»éƒ¨ç½²æµç¨‹
main() {
    log_info "å¼€å§‹ç”Ÿäº§ç¯å¢ƒéƒ¨ç½² - é•œåƒæ ‡ç­¾: $IMAGE_TAG"
    
    # è®¾ç½®é”™è¯¯å¤„ç†
    trap cleanup EXIT
    
    check_dependencies
    pre_deployment_checks
    create_namespace
    deploy_secrets
    deploy_dependencies
    deploy_application
    post_deployment_verification
    setup_monitoring
    
    log_info "ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å®Œæˆï¼"
    log_info "è®¿é—®åœ°å€: https://ws.example.com"
    log_info "ç›‘æ§é¢æ¿: https://grafana.example.com"
    
    # æ˜¾ç¤ºéƒ¨ç½²çŠ¶æ€
    echo
    log_info "éƒ¨ç½²çŠ¶æ€æ¦‚è§ˆ:"
    kubectl get all -n "$NAMESPACE"
}

# æ‰§è¡Œä¸»æµç¨‹
main "$@"</pre>

        <p><strong>æ­¥éª¤ 5: è¿ç»´ç›‘æ§å’Œå‘Šè­¦ä½“ç³»</strong></p>
        <pre># k8s/monitoring/prometheus-rules.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: websocket-server-rules
  namespace: websocket-prod
  labels:
    app: websocket-server
    prometheus: kube-prometheus
    role: alert-rules
spec:
  groups:
  - name: websocket-server.rules
    interval: 30s
    rules:
    # è¿æ¥æ•°æŒ‡æ ‡
    - record: websocket:connection_count
      expr: sum(websocket_active_connections) by (instance)
    
    - record: websocket:connection_rate
      expr: rate(websocket_connections_total[5m])
    
    # æ¶ˆæ¯å¤„ç†æŒ‡æ ‡
    - record: websocket:message_rate
      expr: rate(websocket_messages_total[5m])
    
    - record: websocket:message_latency_p99
      expr: histogram_quantile(0.99, rate(websocket_message_duration_seconds_bucket[5m]))
    
    # é”™è¯¯ç‡æŒ‡æ ‡
    - record: websocket:error_rate
      expr: rate(websocket_errors_total[5m])
    
    # èµ„æºä½¿ç”¨æŒ‡æ ‡
    - record: websocket:memory_usage_percent
      expr: (container_memory_working_set_bytes{container="websocket-server"} / container_spec_memory_limit_bytes{container="websocket-server"}) * 100
    
    - record: websocket:cpu_usage_percent
      expr: rate(container_cpu_usage_seconds_total{container="websocket-server"}[5m]) * 100

  - name: websocket-server.alerts
    rules:
    # æœåŠ¡å¯ç”¨æ€§å‘Šè­¦
    - alert: WebSocketServerDown
      expr: up{job="websocket-server"} == 0
      for: 1m
      labels:
        severity: critical
        service: websocket-server
      annotations:
        summary: "WebSocket æœåŠ¡å™¨å®ä¾‹å®•æœº"
        description: "WebSocket æœåŠ¡å™¨å®ä¾‹ {{ $labels.instance }} å·²å®•æœºè¶…è¿‡1åˆ†é’Ÿ"
        runbook_url: "https://docs.example.com/runbooks/websocket-server-down"
    
    # é«˜è¿æ¥æ•°å‘Šè­¦
    - alert: HighConnectionCount
      expr: websocket:connection_count > 8000
      for: 5m
      labels:
        severity: warning
        service: websocket-server
      annotations:
        summary: "WebSocket è¿æ¥æ•°è¿‡é«˜"
        description: "å®ä¾‹ {{ $labels.instance }} è¿æ¥æ•° {{ $value }} è¶…è¿‡é˜ˆå€¼"
        runbook_url: "https://docs.example.com/runbooks/high-connection-count"
    
    # è¿æ¥æ•°æ¥è¿‘é™åˆ¶å‘Šè­¦
    - alert: ConnectionLimitApproaching
      expr: websocket:connection_count > 9500
      for: 2m
      labels:
        severity: critical
        service: websocket-server
      annotations:
        summary: "WebSocket è¿æ¥æ•°æ¥è¿‘é™åˆ¶"
        description: "å®ä¾‹ {{ $labels.instance }} è¿æ¥æ•° {{ $value }} æ¥è¿‘10000é™åˆ¶"
        runbook_url: "https://docs.example.com/runbooks/connection-limit"
    
    # é«˜é”™è¯¯ç‡å‘Šè­¦
    - alert: HighErrorRate
      expr: websocket:error_rate > 10
      for: 2m
      labels:
        severity: warning
        service: websocket-server  
      annotations:
        summary: "WebSocket é”™è¯¯ç‡è¿‡é«˜"
        description: "å®ä¾‹ {{ $labels.instance }} é”™è¯¯ç‡ {{ $value }}/s è¶…è¿‡é˜ˆå€¼"
        runbook_url: "https://docs.example.com/runbooks/high-error-rate"
    
    # æ¶ˆæ¯å»¶è¿Ÿå‘Šè­¦
    - alert: HighMessageLatency
      expr: websocket:message_latency_p99 > 1.0
      for: 5m
      labels:
        severity: warning
        service: websocket-server
      annotations:
        summary: "WebSocket æ¶ˆæ¯å»¶è¿Ÿè¿‡é«˜"
        description: "å®ä¾‹ {{ $labels.instance }} P99å»¶è¿Ÿ {{ $value }}s è¶…è¿‡1ç§’"
        runbook_url: "https://docs.example.com/runbooks/high-latency"
    
    # å†…å­˜ä½¿ç”¨å‘Šè­¦
    - alert: HighMemoryUsage
      expr: websocket:memory_usage_percent > 85
      for: 5m
      labels:
        severity: warning
        service: websocket-server
      annotations:
        summary: "WebSocket æœåŠ¡å™¨å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜"
        description: "å®ä¾‹ {{ $labels.instance }} å†…å­˜ä½¿ç”¨ç‡ {{ $value }}% è¶…è¿‡85%"
        runbook_url: "https://docs.example.com/runbooks/high-memory"
    
    # CPU ä½¿ç”¨å‘Šè­¦
    - alert: HighCPUUsage
      expr: websocket:cpu_usage_percent > 80
      for: 10m
      labels:
        severity: warning
        service: websocket-server
      annotations:
        summary: "WebSocket æœåŠ¡å™¨ CPU ä½¿ç”¨ç‡è¿‡é«˜"
        description: "å®ä¾‹ {{ $labels.instance }} CPUä½¿ç”¨ç‡ {{ $value }}% æŒç»­è¶…è¿‡80%"
        runbook_url: "https://docs.example.com/runbooks/high-cpu"
    
    # Redis è¿æ¥å‘Šè­¦
    - alert: RedisConnectionFailed
      expr: websocket_redis_connection_errors_total > 0
      for: 1m
      labels:
        severity: critical
        service: websocket-server
      annotations:
        summary: "Redis è¿æ¥å¤±è´¥"
        description: "WebSocket æœåŠ¡æ— æ³•è¿æ¥åˆ° Redis"
        runbook_url: "https://docs.example.com/runbooks/redis-connection"
    
    # Pod é‡å¯å‘Šè­¦
    - alert: PodRestartingTooOften
      expr: rate(kube_pod_container_status_restarts_total{container="websocket-server"}[1h]) * 3600 > 5
      for: 5m
      labels:
        severity: warning
        service: websocket-server
      annotations:
        summary: "Pod é‡å¯è¿‡äºé¢‘ç¹"
        description: "Pod {{ $labels.pod }} åœ¨è¿‡å»1å°æ—¶å†…é‡å¯è¶…è¿‡5æ¬¡"
        runbook_url: "https://docs.example.com/runbooks/pod-restarts"
    
    # ç£ç›˜ç©ºé—´å‘Šè­¦
    - alert: DiskSpaceRunningLow
      expr: (node_filesystem_avail_bytes{mountpoint="/"} / node_filesystem_size_bytes{mountpoint="/"}) * 100 < 20
      for: 5m
      labels:
        severity: warning
        service: infrastructure
      annotations:
        summary: "ç£ç›˜ç©ºé—´ä¸è¶³"
        description: "èŠ‚ç‚¹ {{ $labels.instance }} æ ¹åˆ†åŒºå‰©ä½™ç©ºé—´ {{ $value }}% ä½äº20%"
        runbook_url: "https://docs.example.com/runbooks/disk-space"</pre>

        <p><strong>å®è·µç»ƒä¹ ï¼š</strong></p>
        <ol>
            <li><strong>å®Œæ•´é¡¹ç›®æ„å»º</strong>
                <pre>cd day30_production_ready
cargo build --release
cargo test --all
cargo bench</pre>
            </li>
            <li><strong>Docker é•œåƒæ„å»º</strong>
                <pre>docker build -t websocket-server:v1.0.0 .
docker run --rm -p 8080:8080 websocket-server:v1.0.0</pre>
            </li>
            <li><strong>é›†æˆæµ‹è¯•æ‰§è¡Œ</strong>
                <pre>cargo test --test integration
cargo test --test e2e_tests</pre>
            </li>
            <li><strong>ç”Ÿäº§éƒ¨ç½²</strong>
                <pre>./scripts/deploy/production.sh v1.0.0
kubectl get all -n websocket-prod</pre>
            </li>
            <li><strong>è´Ÿè½½æµ‹è¯•éªŒè¯</strong>
                <pre>./scripts/test/load-test.sh
./scripts/test/security-test.sh</pre>
            </li>
        </ol>

        <p><strong>ç”Ÿäº§å°±ç»ªæ£€æŸ¥æ¸…å•ï¼š</strong></p>
        <ul>
            <li>âœ… <strong>ä»£ç è´¨é‡</strong>: æµ‹è¯•è¦†ç›–ç‡ > 90%ï¼Œé™æ€åˆ†æé€šè¿‡</li>
            <li>âœ… <strong>æ€§èƒ½éªŒè¯</strong>: è´Ÿè½½æµ‹è¯•ã€å†…å­˜æ³„æ¼æ£€æŸ¥ã€å»¶è¿Ÿåˆ†æ</li>
            <li>âœ… <strong>å®‰å…¨å®¡è®¡</strong>: æ¼æ´æ‰«æã€æƒé™éªŒè¯ã€åŠ å¯†å®æ–½</li>
            <li>âœ… <strong>å¯è§‚æµ‹æ€§</strong>: æ—¥å¿—ã€æŒ‡æ ‡ã€è¿½è¸ªã€å‘Šè­¦é…ç½®</li>
            <li>âœ… <strong>é«˜å¯ç”¨æ€§</strong>: å¤šå‰¯æœ¬ã€å¥åº·æ£€æŸ¥ã€è‡ªåŠ¨æ•…éšœè½¬ç§»</li>
            <li>âœ… <strong>æ‰©å±•æ€§</strong>: æ°´å¹³æ‰©å±•ã€è´Ÿè½½å‡è¡¡ã€èµ„æºç®¡ç†</li>
            <li>âœ… <strong>è¿ç»´è‡ªåŠ¨åŒ–</strong>: CI/CD æµæ°´çº¿ã€éƒ¨ç½²è„šæœ¬ã€å›æ»šç­–ç•¥</li>
            <li>âœ… <strong>æ–‡æ¡£å®Œæ•´</strong>: API æ–‡æ¡£ã€éƒ¨ç½²æŒ‡å—ã€æ•…éšœæ’æŸ¥æ‰‹å†Œ</li>
        </ul>

        <p class="date"><strong>ğŸ—“ï¸ 2025-08-31</strong></p>
        <h2>Day 31 - é¡¹ç›®éªŒæ”¶ä¸æœ€ç»ˆéƒ¨ç½²éªŒè¯</h2>
        <p>æ‰§è¡Œå…¨é¢çš„é¡¹ç›®éªŒæ”¶æµ‹è¯•ï¼Œå®Œæˆæœ€ç»ˆç”Ÿäº§éƒ¨ç½²ï¼Œå¹¶å»ºç«‹é•¿æœŸè¿ç»´å’ŒæŒç»­æ”¹è¿›æœºåˆ¶ã€‚</p>
        
        <h3>å­¦ä¹ ç›®æ ‡</h3>
        <ul>
            <li>æ‰§è¡Œå…¨é¢çš„é¡¹ç›®éªŒæ”¶å’Œè´¨é‡è¯„ä¼°</li>
            <li>å®Œæˆæœ€ç»ˆç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å’ŒéªŒè¯</li>
            <li>å»ºç«‹è¿ç»´ç›‘æ§å’Œå‘Šè­¦ä½“ç³»</li>
            <li>åˆ¶å®šæŒç»­é›†æˆå’ŒæŒç»­éƒ¨ç½²æµç¨‹</li>
            <li>æ„å»ºé¡¹ç›®æ–‡æ¡£å’ŒçŸ¥è¯†ä¼ æ‰¿ä½“ç³»</li>
            <li>è§„åˆ’æœªæ¥æŠ€æœ¯æ¼”è¿›å’Œæ‰©å±•è·¯çº¿</li>
        </ul>
        <p>ğŸ”— <a href="https://doc.rust-lang.org/book/" target="_blank">é˜…è¯»å¯¹åº”å®˜æ–¹æ–‡æ¡£</a></p>
        
        <h3>è¯¦ç»†æ­¥éª¤ï¼š</h3>
        <p><strong>æ­¥éª¤ 1: å…¨é¢é¡¹ç›®éªŒæ”¶æµ‹è¯•</strong></p>
        <pre>ğŸ“ éªŒæ”¶æµ‹è¯•é¡¹ç›®ç»“æ„ï¼š
day31_project_validation/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ validation/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ functional_tests.rs
â”‚   â”‚   â”œâ”€â”€ performance_tests.rs
â”‚   â”‚   â”œâ”€â”€ security_tests.rs
â”‚   â”‚   â”œâ”€â”€ reliability_tests.rs
â”‚   â”‚   â””â”€â”€ acceptance_tests.rs
â”‚   â”œâ”€â”€ reporting/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ test_reporter.rs
â”‚   â”‚   â”œâ”€â”€ metrics_collector.rs
â”‚   â”‚   â””â”€â”€ dashboard_generator.rs
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ test_client.rs
â”‚       â”œâ”€â”€ load_generator.rs
â”‚       â””â”€â”€ data_generator.rs
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ acceptance/
â”‚   â”‚   â”œâ”€â”€ user_stories.rs
â”‚   â”‚   â”œâ”€â”€ business_requirements.rs
â”‚   â”‚   â””â”€â”€ integration_scenarios.rs
â”‚   â”œâ”€â”€ performance/
â”‚   â”‚   â”œâ”€â”€ load_tests.rs
â”‚   â”‚   â”œâ”€â”€ stress_tests.rs
â”‚   â”‚   â”œâ”€â”€ endurance_tests.rs
â”‚   â”‚   â””â”€â”€ scalability_tests.rs
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ auth_tests.rs
â”‚   â”‚   â”œâ”€â”€ vulnerability_tests.rs
â”‚   â”‚   â”œâ”€â”€ penetration_tests.rs
â”‚   â”‚   â””â”€â”€ compliance_tests.rs
â”‚   â””â”€â”€ reliability/
â”‚       â”œâ”€â”€ failover_tests.rs
â”‚       â”œâ”€â”€ recovery_tests.rs
â”‚       â”œâ”€â”€ chaos_tests.rs
â”‚       â””â”€â”€ availability_tests.rs
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ validation/
â”‚   â”‚   â”œâ”€â”€ run-all-tests.sh
â”‚   â”‚   â”œâ”€â”€ performance-validation.sh
â”‚   â”‚   â”œâ”€â”€ security-audit.sh
â”‚   â”‚   â””â”€â”€ compliance-check.sh
â”‚   â”œâ”€â”€ deployment/
â”‚   â”‚   â”œâ”€â”€ final-deploy.sh
â”‚   â”‚   â”œâ”€â”€ smoke-test.sh
â”‚   â”‚   â”œâ”€â”€ rollback.sh
â”‚   â”‚   â””â”€â”€ disaster-recovery.sh
â”‚   â””â”€â”€ reporting/
â”‚       â”œâ”€â”€ generate-report.sh
â”‚       â”œâ”€â”€ metrics-analysis.sh
â”‚       â””â”€â”€ dashboard-update.sh
â”œâ”€â”€ configs/
â”‚   â”œâ”€â”€ validation.toml
â”‚   â”œâ”€â”€ performance-thresholds.yaml
â”‚   â”œâ”€â”€ security-policies.json
â”‚   â””â”€â”€ acceptance-criteria.yaml
â”œâ”€â”€ reports/
â”‚   â”œâ”€â”€ validation-report.md
â”‚   â”œâ”€â”€ performance-analysis.md
â”‚   â”œâ”€â”€ security-audit.md
â”‚   â””â”€â”€ final-assessment.pdf
â””â”€â”€ docs/
    â”œâ”€â”€ validation-plan.md
    â”œâ”€â”€ deployment-guide.md
    â”œâ”€â”€ operational-runbook.md
    â””â”€â”€ post-deployment-checklist.md</pre>

        <p><strong>åŠŸèƒ½éªŒæ”¶æµ‹è¯•å®ç°ï¼š</strong></p>
        <pre># src/validation/functional_tests.rs
//! åŠŸèƒ½éªŒæ”¶æµ‹è¯•å¥—ä»¶

use std::time::Duration;
use tokio::time::timeout;
use serde_json::json;
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::utils::{TestClient, LoadGenerator, DataGenerator};
use crate::reporting::TestReporter;

/// åŠŸèƒ½éªŒæ”¶æµ‹è¯•å¥—ä»¶
pub struct FunctionalValidationSuite {
    reporter: TestReporter,
    test_clients: Vec<TestClient>,
    load_generator: LoadGenerator,
}

impl FunctionalValidationSuite {
    pub async fn new() -> Self {
        Self {
            reporter: TestReporter::new("functional_validation").await,
            test_clients: Vec::new(),
            load_generator: LoadGenerator::new().await,
        }
    }
    
    /// æ‰§è¡Œå®Œæ•´çš„åŠŸèƒ½éªŒæ”¶æµ‹è¯•
    pub async fn run_full_validation(&mut self) -> ValidationResult {
        self.reporter.start_test_suite("WebSocket åŠŸèƒ½éªŒæ”¶æµ‹è¯•").await;
        
        let mut results = ValidationResult::new();
        
        // 1. è¿æ¥å»ºç«‹éªŒè¯
        results.merge(self.test_connection_establishment().await);
        
        // 2. èº«ä»½è®¤è¯éªŒè¯
        results.merge(self.test_authentication_flow().await);
        
        // 3. æ¶ˆæ¯ä¼ è¾“éªŒè¯
        results.merge(self.test_message_transmission().await);
        
        // 4. æˆ¿é—´ç®¡ç†éªŒè¯
        results.merge(self.test_room_management().await);
        
        // 5. å¹¿æ’­åŠŸèƒ½éªŒè¯
        results.merge(self.test_broadcasting().await);
        
        // 6. é”™è¯¯å¤„ç†éªŒè¯
        results.merge(self.test_error_handling().await);
        
        // 7. èµ„æºæ¸…ç†éªŒè¯
        results.merge(self.test_resource_cleanup().await);
        
        self.reporter.finish_test_suite(results.clone()).await;
        results
    }
    
    /// æµ‹è¯•è¿æ¥å»ºç«‹åŠŸèƒ½
    async fn test_connection_establishment(&mut self) -> ValidationResult {
        self.reporter.start_test("è¿æ¥å»ºç«‹æµ‹è¯•").await;
        let mut result = ValidationResult::new();
        
        // æµ‹è¯•æ­£å¸¸è¿æ¥
        match TestClient::connect_with_valid_token().await {
            Ok(client) => {
                result.passed += 1;
                self.test_clients.push(client);
                self.reporter.log_success("æ­£å¸¸è¿æ¥å»ºç«‹æˆåŠŸ").await;
            }
            Err(e) => {
                result.failed += 1;
                self.reporter.log_error(&format!("æ­£å¸¸è¿æ¥å¤±è´¥: {}", e)).await;
            }
        }
        
        // æµ‹è¯•æ— æ•ˆè®¤è¯è¿æ¥
        match TestClient::connect_with_invalid_token().await {
            Err(_) => {
                result.passed += 1;
                self.reporter.log_success("æ— æ•ˆè®¤è¯æ­£ç¡®è¢«æ‹’ç»").await;
            }
            Ok(_) => {
                result.failed += 1;
                self.reporter.log_error("æ— æ•ˆè®¤è¯åº”è¯¥è¢«æ‹’ç»").await;
            }
        }
        
        // æµ‹è¯•å¹¶å‘è¿æ¥
        let concurrent_connections = 100;
        let start_time = std::time::Instant::now();
        
        let connection_tasks: Vec<_> = (0..concurrent_connections)
            .map(|i| {
                let client_id = format!("concurrent_client_{}", i);
                async move {
                    TestClient::connect_with_user_token(&client_id).await
                }
            })
            .collect();
        
        let connection_results = futures::future::join_all(connection_tasks).await;
        let successful_connections = connection_results.iter()
            .filter(|r| r.is_ok())
            .count();
        
        let connection_time = start_time.elapsed();
        
        if successful_connections >= concurrent_connections * 95 / 100 {
            result.passed += 1;
            self.reporter.log_success(&format!(
                "å¹¶å‘è¿æ¥æµ‹è¯•é€šè¿‡: {}/{} è¿æ¥æˆåŠŸï¼Œè€—æ—¶ {:?}",
                successful_connections, concurrent_connections, connection_time
            )).await;
        } else {
            result.failed += 1;
            self.reporter.log_error(&format!(
                "å¹¶å‘è¿æ¥æµ‹è¯•å¤±è´¥: ä»… {}/{} è¿æ¥æˆåŠŸ",
                successful_connections, concurrent_connections
            )).await;
        }
        
        result
    }
    
    /// æµ‹è¯•èº«ä»½è®¤è¯æµç¨‹
    async fn test_authentication_flow(&mut self) -> ValidationResult {
        self.reporter.start_test("èº«ä»½è®¤è¯æµç¨‹æµ‹è¯•").await;
        let mut result = ValidationResult::new();
        
        // æµ‹è¯• JWT Token éªŒè¯
        let test_cases = vec![
            ("æœ‰æ•ˆ token", TestClient::generate_valid_token("test_user"), true),
            ("è¿‡æœŸ token", TestClient::generate_expired_token("test_user"), false),
            ("æ— æ•ˆç­¾å", TestClient::generate_invalid_signature_token("test_user"), false),
            ("æ ¼å¼é”™è¯¯", "invalid.token.format".to_string(), false),
            ("ç©º token", "".to_string(), false),
        ];
        
        for (test_name, token, should_succeed) in test_cases {
            match TestClient::connect_with_token(&token).await {
                Ok(_) if should_succeed => {
                    result.passed += 1;
                    self.reporter.log_success(&format!("{} æµ‹è¯•é€šè¿‡", test_name)).await;
                }
                Err(_) if !should_succeed => {
                    result.passed += 1;
                    self.reporter.log_success(&format!("{} æ­£ç¡®è¢«æ‹’ç»", test_name)).await;
                }
                Ok(_) => {
                    result.failed += 1;
                    self.reporter.log_error(&format!("{} åº”è¯¥è¢«æ‹’ç»ä½†æˆåŠŸäº†", test_name)).await;
                }
                Err(_) => {
                    result.failed += 1;
                    self.reporter.log_error(&format!("{} åº”è¯¥æˆåŠŸä½†å¤±è´¥äº†", test_name)).await;
                }
            }
        }
        
        // æµ‹è¯•æƒé™éªŒè¯
        let user_client = TestClient::connect_with_user_token("regular_user").await.unwrap();
        let admin_client = TestClient::connect_with_admin_token("admin_user").await.unwrap();
        
        // æ™®é€šç”¨æˆ·å°è¯•ç®¡ç†å‘˜æ“ä½œ
        let admin_action = json!({
            "type": "admin_shutdown",
            "reason": "maintenance"
        });
        
        user_client.send_message(admin_action.to_string()).await;
        
        if let Ok(response) = timeout(Duration::from_secs(5), user_client.receive_message()).await {
            if let Ok(response) = response {
                let response_json: serde_json::Value = serde_json::from_str(&response).unwrap();
                if response_json["type"] == "error" && response_json["code"] == "insufficient_permissions" {
                    result.passed += 1;
                    self.reporter.log_success("æƒé™éªŒè¯æ­£ç¡®å·¥ä½œ").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("æƒé™éªŒè¯å¤±è´¥").await;
                }
            }
        }
        
        // ç®¡ç†å‘˜æ‰§è¡Œç®¡ç†å‘˜æ“ä½œ
        admin_client.send_message(json!({
            "type": "admin_stats",
            "query": "connection_count"
        }).to_string()).await;
        
        if let Ok(response) = timeout(Duration::from_secs(5), admin_client.receive_message()).await {
            if let Ok(response) = response {
                let response_json: serde_json::Value = serde_json::from_str(&response).unwrap();
                if response_json["type"] == "admin_stats_response" {
                    result.passed += 1;
                    self.reporter.log_success("ç®¡ç†å‘˜æ“ä½œæ­£ç¡®æ‰§è¡Œ").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("ç®¡ç†å‘˜æ“ä½œæ‰§è¡Œå¤±è´¥").await;
                }
            }
        }
        
        self.test_clients.push(user_client);
        self.test_clients.push(admin_client);
        
        result
    }
    
    /// æµ‹è¯•æ¶ˆæ¯ä¼ è¾“åŠŸèƒ½
    async fn test_message_transmission(&mut self) -> ValidationResult {
        self.reporter.start_test("æ¶ˆæ¯ä¼ è¾“æµ‹è¯•").await;
        let mut result = ValidationResult::new();
        
        let client1 = TestClient::connect_with_user_token("user1").await.unwrap();
        let client2 = TestClient::connect_with_user_token("user2").await.unwrap();
        
        // æµ‹è¯•æ–‡æœ¬æ¶ˆæ¯ä¼ è¾“
        let test_message = "Hello, WebSocket World! ğŸŒ";
        let message_payload = json!({
            "type": "direct_message",
            "to": "user2",
            "content": test_message,
            "timestamp": Utc::now().timestamp()
        });
        
        client1.send_message(message_payload.to_string()).await;
        
        // éªŒè¯æ¶ˆæ¯æ¥æ”¶
        if let Ok(response) = timeout(Duration::from_secs(5), client2.receive_message()).await {
            if let Ok(received_message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&received_message).unwrap();
                if msg_json["content"] == test_message {
                    result.passed += 1;
                    self.reporter.log_success("æ–‡æœ¬æ¶ˆæ¯ä¼ è¾“æˆåŠŸ").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("æ–‡æœ¬æ¶ˆæ¯å†…å®¹ä¸åŒ¹é…").await;
                }
            }
        } else {
            result.failed += 1;
            self.reporter.log_error("æ¶ˆæ¯æ¥æ”¶è¶…æ—¶").await;
        }
        
        // æµ‹è¯•äºŒè¿›åˆ¶æ¶ˆæ¯ä¼ è¾“
        let binary_data = vec![0x48, 0x65, 0x6c, 0x6c, 0x6f]; // "Hello" in bytes
        let binary_payload = json!({
            "type": "binary_message",
            "to": "user1",
            "data": base64::encode(&binary_data)
        });
        
        client2.send_message(binary_payload.to_string()).await;
        
        if let Ok(response) = timeout(Duration::from_secs(5), client1.receive_message()).await {
            if let Ok(received_message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&received_message).unwrap();
                if let Some(data_str) = msg_json["data"].as_str() {
                    if let Ok(decoded_data) = base64::decode(data_str) {
                        if decoded_data == binary_data {
                            result.passed += 1;
                            self.reporter.log_success("äºŒè¿›åˆ¶æ¶ˆæ¯ä¼ è¾“æˆåŠŸ").await;
                        } else {
                            result.failed += 1;
                            self.reporter.log_error("äºŒè¿›åˆ¶æ¶ˆæ¯æ•°æ®ä¸åŒ¹é…").await;
                        }
                    }
                }
            }
        } else {
            result.failed += 1;
            self.reporter.log_error("äºŒè¿›åˆ¶æ¶ˆæ¯æ¥æ”¶è¶…æ—¶").await;
        }
        
        // æµ‹è¯•å¤§æ¶ˆæ¯ä¼ è¾“
        let large_message = "A".repeat(1024 * 1024); // 1MB message
        let large_payload = json!({
            "type": "large_message",
            "to": "user2",
            "content": large_message
        });
        
        let start_time = std::time::Instant::now();
        client1.send_message(large_payload.to_string()).await;
        
        if let Ok(response) = timeout(Duration::from_secs(30), client2.receive_message()).await {
            let transmission_time = start_time.elapsed();
            if let Ok(received_message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&received_message).unwrap();
                if msg_json["content"].as_str().map(|s| s.len()) == Some(1024 * 1024) {
                    result.passed += 1;
                    self.reporter.log_success(&format!(
                        "å¤§æ¶ˆæ¯ä¼ è¾“æˆåŠŸï¼Œè€—æ—¶: {:?}", transmission_time
                    )).await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("å¤§æ¶ˆæ¯å¤§å°ä¸åŒ¹é…").await;
                }
            }
        } else {
            result.failed += 1;
            self.reporter.log_error("å¤§æ¶ˆæ¯ä¼ è¾“è¶…æ—¶").await;
        }
        
        self.test_clients.push(client1);
        self.test_clients.push(client2);
        
        result
    }
    
    /// æµ‹è¯•æˆ¿é—´ç®¡ç†åŠŸèƒ½
    async fn test_room_management(&mut self) -> ValidationResult {
        self.reporter.start_test("æˆ¿é—´ç®¡ç†æµ‹è¯•").await;
        let mut result = ValidationResult::new();
        
        let user1 = TestClient::connect_with_user_token("room_user1").await.unwrap();
        let user2 = TestClient::connect_with_user_token("room_user2").await.unwrap();
        let user3 = TestClient::connect_with_user_token("room_user3").await.unwrap();
        
        let room_name = format!("test_room_{}", Uuid::new_v4());
        
        // ç”¨æˆ·1åˆ›å»ºæˆ¿é—´
        user1.send_message(json!({
            "type": "create_room",
            "room": room_name,
            "max_users": 3
        }).to_string()).await;
        
        // éªŒè¯æˆ¿é—´åˆ›å»ºå“åº”
        if let Ok(response) = timeout(Duration::from_secs(5), user1.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "room_created" {
                    result.passed += 1;
                    self.reporter.log_success("æˆ¿é—´åˆ›å»ºæˆåŠŸ").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("æˆ¿é—´åˆ›å»ºå¤±è´¥").await;
                }
            }
        }
        
        // ç”¨æˆ·2åŠ å…¥æˆ¿é—´
        user2.send_message(json!({
            "type": "join_room",
            "room": room_name
        }).to_string()).await;
        
        // éªŒè¯åŠ å…¥æˆ¿é—´
        let mut join_confirmed = false;
        let mut user1_notified = false;
        
        // æ£€æŸ¥ç”¨æˆ·2çš„åŠ å…¥ç¡®è®¤
        if let Ok(response) = timeout(Duration::from_secs(5), user2.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "room_joined" {
                    join_confirmed = true;
                }
            }
        }
        
        // æ£€æŸ¥ç”¨æˆ·1æ˜¯å¦æ”¶åˆ°æ–°ç”¨æˆ·é€šçŸ¥
        if let Ok(response) = timeout(Duration::from_secs(5), user1.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "user_joined" {
                    user1_notified = true;
                }
            }
        }
        
        if join_confirmed && user1_notified {
            result.passed += 1;
            self.reporter.log_success("æˆ¿é—´åŠ å…¥åŠŸèƒ½æ­£å¸¸").await;
        } else {
            result.failed += 1;
            self.reporter.log_error("æˆ¿é—´åŠ å…¥åŠŸèƒ½å¼‚å¸¸").await;
        }
        
        // æµ‹è¯•æˆ¿é—´å†…å¹¿æ’­
        user1.send_message(json!({
            "type": "room_broadcast",
            "room": room_name,
            "message": "æ¬¢è¿å¤§å®¶æ¥åˆ°æµ‹è¯•æˆ¿é—´ï¼"
        }).to_string()).await;
        
        // éªŒè¯ç”¨æˆ·2æ”¶åˆ°å¹¿æ’­
        if let Ok(response) = timeout(Duration::from_secs(5), user2.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "room_broadcast" && msg_json["message"] == "æ¬¢è¿å¤§å®¶æ¥åˆ°æµ‹è¯•æˆ¿é—´ï¼" {
                    result.passed += 1;
                    self.reporter.log_success("æˆ¿é—´å¹¿æ’­åŠŸèƒ½æ­£å¸¸").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("æˆ¿é—´å¹¿æ’­å†…å®¹å¼‚å¸¸").await;
                }
            }
        } else {
            result.failed += 1;
            self.reporter.log_error("æˆ¿é—´å¹¿æ’­æ¥æ”¶è¶…æ—¶").await;
        }
        
        // æµ‹è¯•æˆ¿é—´äººæ•°é™åˆ¶
        user3.send_message(json!({
            "type": "join_room",
            "room": room_name
        }).to_string()).await;
        
        // å†å°è¯•åŠ å…¥ç¬¬4ä¸ªç”¨æˆ·ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
        let user4 = TestClient::connect_with_user_token("room_user4").await.unwrap();
        user4.send_message(json!({
            "type": "join_room",
            "room": room_name
        }).to_string()).await;
        
        if let Ok(response) = timeout(Duration::from_secs(5), user4.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "error" && msg_json["code"] == "room_full" {
                    result.passed += 1;
                    self.reporter.log_success("æˆ¿é—´äººæ•°é™åˆ¶æ­£å¸¸å·¥ä½œ").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("æˆ¿é—´äººæ•°é™åˆ¶å¤±æ•ˆ").await;
                }
            }
        }
        
        // æµ‹è¯•ç¦»å¼€æˆ¿é—´
        user2.send_message(json!({
            "type": "leave_room",
            "room": room_name
        }).to_string()).await;
        
        // éªŒè¯ç”¨æˆ·1æ”¶åˆ°ç¦»å¼€é€šçŸ¥
        if let Ok(response) = timeout(Duration::from_secs(5), user1.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "user_left" {
                    result.passed += 1;
                    self.reporter.log_success("ç¦»å¼€æˆ¿é—´åŠŸèƒ½æ­£å¸¸").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("ç¦»å¼€æˆ¿é—´é€šçŸ¥å¼‚å¸¸").await;
                }
            }
        }
        
        self.test_clients.extend(vec![user1, user2, user3, user4]);
        result
    }
    
    /// æ¸…ç†æµ‹è¯•èµ„æº
    async fn cleanup(&mut self) {
        self.reporter.log_info("æ¸…ç†æµ‹è¯•èµ„æº").await;
        
        for client in &mut self.test_clients {
            client.close().await;
        }
        self.test_clients.clear();
        
        self.reporter.log_info("èµ„æºæ¸…ç†å®Œæˆ").await;
    }
}

#[derive(Debug, Clone)]
pub struct ValidationResult {
    pub passed: u32,
    pub failed: u32,
    pub skipped: u32,
    pub errors: Vec<String>,
    pub warnings: Vec<String>,
    pub metrics: std::collections::HashMap<String, f64>,
}

impl ValidationResult {
    pub fn new() -> Self {
        Self {
            passed: 0,
            failed: 0,
            skipped: 0,
            errors: Vec::new(),
            warnings: Vec::new(),
            metrics: std::collections::HashMap::new(),
        }
    }
    
    pub fn merge(&mut self, other: ValidationResult) {
        self.passed += other.passed;
        self.failed += other.failed;
        self.skipped += other.skipped;
        self.errors.extend(other.errors);
        self.warnings.extend(other.warnings);
        self.metrics.extend(other.metrics);
    }
    
    pub fn success_rate(&self) -> f64 {
        let total = self.passed + self.failed;
        if total == 0 {
            0.0
        } else {
            (self.passed as f64) / (total as f64) * 100.0
        }
    }
    
    pub fn is_passing(&self) -> bool {
        self.success_rate() >= 95.0 && self.failed == 0
    }
}</pre>

        <p><strong>æ­¥éª¤ 2: æ€§èƒ½å‹åŠ›æµ‹è¯•</strong></p>
        <pre># src/validation/performance_tests.rs
//! æ€§èƒ½å‹åŠ›æµ‹è¯•å¥—ä»¶

use std::time::{Duration, Instant};
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, AtomicU32, Ordering};
use tokio::sync::Semaphore;
use futures::future::join_all;
use serde_json::json;

use crate::utils::{TestClient, LoadGenerator};
use crate::reporting::TestReporter;
use super::ValidationResult;

/// æ€§èƒ½æµ‹è¯•é…ç½®
#[derive(Debug, Clone)]
pub struct PerformanceTestConfig {
    pub max_connections: u32,
    pub messages_per_second_target: u32,
    pub test_duration_seconds: u64,
    pub latency_p99_threshold_ms: u64,
    pub memory_limit_mb: u64,
    pub cpu_limit_percent: f64,
}

impl Default for PerformanceTestConfig {
    fn default() -> Self {
        Self {
            max_connections: 10000,
            messages_per_second_target: 50000,
            test_duration_seconds: 300, // 5åˆ†é’Ÿ
            latency_p99_threshold_ms: 100,
            memory_limit_mb: 4096,
            cpu_limit_percent: 80.0,
        }
    }
}

/// æ€§èƒ½æµ‹è¯•å¥—ä»¶
pub struct PerformanceTestSuite {
    config: PerformanceTestConfig,
    reporter: TestReporter,
    load_generator: LoadGenerator,
}

impl PerformanceTestSuite {
    pub async fn new(config: PerformanceTestConfig) -> Self {
        Self {
            config,
            reporter: TestReporter::new("performance_validation").await,
            load_generator: LoadGenerator::new().await,
        }
    }
    
    /// æ‰§è¡Œå®Œæ•´çš„æ€§èƒ½æµ‹è¯•
    pub async fn run_performance_validation(&mut self) -> ValidationResult {
        self.reporter.start_test_suite("WebSocket æ€§èƒ½å‹åŠ›æµ‹è¯•").await;
        
        let mut results = ValidationResult::new();
        
        // 1. è¿æ¥å®¹é‡æµ‹è¯•
        results.merge(self.test_connection_capacity().await);
        
        // 2. æ¶ˆæ¯ååé‡æµ‹è¯•
        results.merge(self.test_message_throughput().await);
        
        // 3. å»¶è¿Ÿæµ‹è¯•
        results.merge(self.test_latency_performance().await);
        
        // 4. å¹¶å‘å‹åŠ›æµ‹è¯•
        results.merge(self.test_concurrent_load().await);
        
        // 5. å†…å­˜ä½¿ç”¨æµ‹è¯•
        results.merge(self.test_memory_usage().await);
        
        // 6. é•¿æœŸç¨³å®šæ€§æµ‹è¯•
        results.merge(self.test_endurance().await);
        
        self.reporter.finish_test_suite(results.clone()).await;
        results
    }
    
    /// æµ‹è¯•è¿æ¥å®¹é‡
    async fn test_connection_capacity(&mut self) -> ValidationResult {
        self.reporter.start_test("è¿æ¥å®¹é‡æµ‹è¯•").await;
        let mut result = ValidationResult::new();
        
        let target_connections = self.config.max_connections.min(5000); // é™åˆ¶æµ‹è¯•è§„æ¨¡
        let batch_size = 100;
        let mut successful_connections = 0u32;
        
        self.reporter.log_info(&format!(
            "å¼€å§‹è¿æ¥å®¹é‡æµ‹è¯•ï¼Œç›®æ ‡è¿æ¥æ•°: {}", target_connections
        )).await;
        
        let start_time = Instant::now();
        let semaphore = Arc::new(Semaphore::new(batch_size));
        let connection_counter = Arc::new(AtomicU32::new(0));
        
        let mut connection_tasks = Vec::new();
        
        for i in 0..target_connections {
            let permit = semaphore.clone().acquire_owned().await.unwrap();
            let counter = connection_counter.clone();
            
            let task = tokio::spawn(async move {
                let _permit = permit; // ä¿æŒ permit ç›´åˆ°ä»»åŠ¡å®Œæˆ
                
                let client_id = format!("capacity_test_client_{}", i);
                match TestClient::connect_with_user_token(&client_id).await {
                    Ok(client) => {
                        counter.fetch_add(1, Ordering::Relaxed);
                        
                        // ä¿æŒè¿æ¥ä¸€æ®µæ—¶é—´
                        tokio::time::sleep(Duration::from_secs(30)).await;
                        
                        client.close().await;
                        true
                    }
                    Err(_) => false,
                }
            });
            
            connection_tasks.push(task);
            
            // æ§åˆ¶è¿æ¥å»ºç«‹é€Ÿç‡
            if i % batch_size == 0 {
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
        }
        
        // ç­‰å¾…æ‰€æœ‰è¿æ¥ä»»åŠ¡å®Œæˆ
        let results = join_all(connection_tasks).await;
        let establishment_time = start_time.elapsed();
        
        successful_connections = results.iter()
            .filter_map(|r| r.as_ref().ok())
            .filter(|&&success| success)
            .count() as u32;
        
        let success_rate = (successful_connections as f64) / (target_connections as f64) * 100.0;
        let connections_per_second = successful_connections as f64 / establishment_time.as_secs_f64();
        
        result.metrics.insert("max_connections".to_string(), successful_connections as f64);
        result.metrics.insert("connection_success_rate".to_string(), success_rate);
        result.metrics.insert("connections_per_second".to_string(), connections_per_second);
        result.metrics.insert("establishment_time_seconds".to_string(), establishment_time.as_secs_f64());
        
        if success_rate >= 95.0 {
            result.passed += 1;
            self.reporter.log_success(&format!(
                "è¿æ¥å®¹é‡æµ‹è¯•é€šè¿‡: {}/{} è¿æ¥æˆåŠŸ ({:.1}%), å»ºç«‹é€Ÿç‡: {:.1} conn/s",
                successful_connections, target_connections, success_rate, connections_per_second
            )).await;
        } else {
            result.failed += 1;
            self.reporter.log_error(&format!(
                "è¿æ¥å®¹é‡æµ‹è¯•å¤±è´¥: æˆåŠŸç‡ {:.1}% ä½äº 95%", success_rate
            )).await;
        }
        
        result
    }
    
    /// æµ‹è¯•æ¶ˆæ¯ååé‡
    async fn test_message_throughput(&mut self) -> ValidationResult {
        self.reporter.start_test("æ¶ˆæ¯ååé‡æµ‹è¯•").await;
        let mut result = ValidationResult::new();
        
        let client_count = 100;
        let messages_per_client = 1000;
        let test_duration = Duration::from_secs(60);
        
        self.reporter.log_info(&format!(
            "å¼€å§‹ååé‡æµ‹è¯•: {} å®¢æˆ·ç«¯ï¼Œæ¯å®¢æˆ·ç«¯ {} æ¶ˆæ¯ï¼ŒæŒç»­ {} ç§’",
            client_count, messages_per_client, test_duration.as_secs()
        )).await;
        
        let start_time = Instant::now();
        let message_counter = Arc::new(AtomicU64::new(0));
        let error_counter = Arc::new(AtomicU64::new(0));
        
        let mut client_tasks = Vec::new();
        
        for i in 0..client_count {
            let msg_counter = message_counter.clone();
            let err_counter = error_counter.clone();
            
            let task = tokio::spawn(async move {
                let client_id = format!("throughput_client_{}", i);
                let client = match TestClient::connect_with_user_token(&client_id).await {
                    Ok(c) => c,
                    Err(_) => {
                        err_counter.fetch_add(messages_per_client as u64, Ordering::Relaxed);
                        return;
                    }
                };
                
                let client_start = Instant::now();
                let mut sent_count = 0u64;
                
                while client_start.elapsed() < test_duration && sent_count < messages_per_client as u64 {
                    let message = json!({
                        "type": "throughput_test",
                        "client_id": i,
                        "message_id": sent_count,
                        "timestamp": chrono::Utc::now().timestamp_millis()
                    });
                    
                    match client.send_message(message.to_string()).await {
                        Ok(_) => {
                            msg_counter.fetch_add(1, Ordering::Relaxed);
                            sent_count += 1;
                        }
                        Err(_) => {
                            err_counter.fetch_add(1, Ordering::Relaxed);
                        }
                    }
                    
                    // æ§åˆ¶å‘é€é€Ÿç‡
                    tokio::time::sleep(Duration::from_micros(100)).await;
                }
                
                client.close().await;
            });
            
            client_tasks.push(task);
        }
        
        // ç­‰å¾…æ‰€æœ‰å®¢æˆ·ç«¯å®Œæˆ
        join_all(client_tasks).await;
        
        let test_time = start_time.elapsed();
        let total_messages = message_counter.load(Ordering::Relaxed);
        let total_errors = error_counter.load(Ordering::Relaxed);
        let messages_per_second = total_messages as f64 / test_time.as_secs_f64();
        let error_rate = (total_errors as f64) / (total_messages + total_errors) as f64 * 100.0;
        
        result.metrics.insert("total_messages".to_string(), total_messages as f64);
        result.metrics.insert("messages_per_second".to_string(), messages_per_second);
        result.metrics.insert("error_rate_percent".to_string(), error_rate);
        result.metrics.insert("test_duration_seconds".to_string(), test_time.as_secs_f64());
        
        if messages_per_second >= self.config.messages_per_second_target as f64 * 0.8 && error_rate < 1.0 {
            result.passed += 1;
            self.reporter.log_success(&format!(
                "ååé‡æµ‹è¯•é€šè¿‡: {:.0} msg/s (ç›®æ ‡: {}), é”™è¯¯ç‡: {:.2}%",
                messages_per_second, self.config.messages_per_second_target, error_rate
            )).await;
        } else {
            result.failed += 1;
            self.reporter.log_error(&format!(
                "ååé‡æµ‹è¯•å¤±è´¥: {:.0} msg/s ä½äºç›®æ ‡ {} çš„ 80%ï¼Œæˆ–é”™è¯¯ç‡ {:.2}% è¿‡é«˜",
                messages_per_second, self.config.messages_per_second_target, error_rate
            )).await;
        }
        
        result
    }
    
    /// æµ‹è¯•å»¶è¿Ÿæ€§èƒ½
    async fn test_latency_performance(&mut self) -> ValidationResult {
        self.reporter.start_test("å»¶è¿Ÿæ€§èƒ½æµ‹è¯•").await;
        let mut result = ValidationResult::new();
        
        let client1 = TestClient::connect_with_user_token("latency_client1").await.unwrap();
        let client2 = TestClient::connect_with_user_token("latency_client2").await.unwrap();
        
        let test_count = 1000;
        let mut latencies = Vec::with_capacity(test_count);
        
        self.reporter.log_info(&format!("å¼€å§‹å»¶è¿Ÿæµ‹è¯•ï¼Œæ ·æœ¬æ•°: {}", test_count)).await;
        
        for i in 0..test_count {
            let send_time = Instant::now();
            let message_id = format!("latency_test_{}", i);
            
            let message = json!({
                "type": "echo_request",
                "message_id": message_id,
                "timestamp": chrono::Utc::now().timestamp_millis()
            });
            
            client1.send_message(message.to_string()).await;
            
            // ç­‰å¾…å›æ˜¾å“åº”
            if let Ok(response) = tokio::time::timeout(Duration::from_secs(5), client1.receive_message()).await {
                if let Ok(response_str) = response {
                    let latency = send_time.elapsed();
                    latencies.push(latency.as_millis() as u64);
                    
                    let response_json: serde_json::Value = serde_json::from_str(&response_str).unwrap();
                    if response_json["message_id"] != message_id {
                        result.warnings.push(format!("æ¶ˆæ¯ ID ä¸åŒ¹é…: {}", i));
                    }
                } else {
                    result.warnings.push(format!("æ¶ˆæ¯ {} æ¥æ”¶å¤±è´¥", i));
                }
            } else {
                result.warnings.push(format!("æ¶ˆæ¯ {} è¶…æ—¶", i));
            }
            
            // æ§åˆ¶æµ‹è¯•é¢‘ç‡
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
        
        client1.close().await;
        client2.close().await;
        
        if latencies.is_empty() {
            result.failed += 1;
            self.reporter.log_error("å»¶è¿Ÿæµ‹è¯•å¤±è´¥ï¼šæ²¡æœ‰æœ‰æ•ˆçš„å»¶è¿Ÿæ ·æœ¬").await;
            return result;
        }
        
        // è®¡ç®—å»¶è¿Ÿç»Ÿè®¡
        latencies.sort();
        let p50 = latencies[latencies.len() * 50 / 100];
        let p95 = latencies[latencies.len() * 95 / 100];
        let p99 = latencies[latencies.len() * 99 / 100];
        let avg = latencies.iter().sum::<u64>() as f64 / latencies.len() as f64;
        let max = *latencies.last().unwrap();
        let min = *latencies.first().unwrap();
        
        result.metrics.insert("latency_p50_ms".to_string(), p50 as f64);
        result.metrics.insert("latency_p95_ms".to_string(), p95 as f64);
        result.metrics.insert("latency_p99_ms".to_string(), p99 as f64);
        result.metrics.insert("latency_avg_ms".to_string(), avg);
        result.metrics.insert("latency_max_ms".to_string(), max as f64);
        result.metrics.insert("latency_min_ms".to_string(), min as f64);
        
        if p99 <= self.config.latency_p99_threshold_ms {
            result.passed += 1;
            self.reporter.log_success(&format!(
                "å»¶è¿Ÿæµ‹è¯•é€šè¿‡: P99={} ms (é˜ˆå€¼: {} ms), P95={} ms, P50={} ms, å¹³å‡={:.1} ms",
                p99, self.config.latency_p99_threshold_ms, p95, p50, avg
            )).await;
        } else {
            result.failed += 1;
            self.reporter.log_error(&format!(
                "å»¶è¿Ÿæµ‹è¯•å¤±è´¥: P99={} ms è¶…è¿‡é˜ˆå€¼ {} ms",
                p99, self.config.latency_p99_threshold_ms
            )).await;
        }
        
        result
    }
}</pre>

        <p><strong>æ­¥éª¤ 3: æœ€ç»ˆç”Ÿäº§éƒ¨ç½²</strong></p>
        <pre># scripts/deployment/final-deploy.sh
#!/bin/bash
# æœ€ç»ˆç”Ÿäº§éƒ¨ç½²è„šæœ¬

set -euo pipefail

# é…ç½®å˜é‡
NAMESPACE="websocket-production"
RELEASE_NAME="websocket-final"
IMAGE_TAG=${1:-$(git rev-parse --short HEAD)}
ENVIRONMENT="production"

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_step() {
    echo -e "${BLUE}[STEP]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_success() {
    echo -e "${PURPLE}[SUCCESS]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

# æœ€ç»ˆéƒ¨ç½²å‰æ£€æŸ¥
pre_deployment_validation() {
    log_step "æ‰§è¡Œæœ€ç»ˆéƒ¨ç½²å‰éªŒè¯..."
    
    # æ£€æŸ¥æ‰€æœ‰å¿…éœ€çš„å¯†é’¥å’Œé…ç½®
    local required_secrets=("JWT_SECRET" "REDIS_PASSWORD" "TLS_CERT" "TLS_KEY" "GRAFANA_ADMIN_PASSWORD")
    for secret in "${required_secrets[@]}"; do
        if [ -z "${!secret:-}" ]; then
            log_error "ç¼ºå°‘å¿…éœ€çš„ç¯å¢ƒå˜é‡: $secret"
            exit 1
        fi
    done
    
    # æ£€æŸ¥é•œåƒå¯ç”¨æ€§
    if ! docker manifest inspect "websocket-server:$IMAGE_TAG" &> /dev/null; then
        log_error "é•œåƒ websocket-server:$IMAGE_TAG ä¸å­˜åœ¨æˆ–æ— æ³•è®¿é—®"
        exit 1
    fi
    
    # æ£€æŸ¥ Kubernetes é›†ç¾¤çŠ¶æ€
    local ready_nodes=$(kubectl get nodes --no-headers | grep Ready | wc -l)
    if [ "$ready_nodes" -lt 3 ]; then
        log_error "é›†ç¾¤èŠ‚ç‚¹æ•°é‡ä¸è¶³ï¼Œè‡³å°‘éœ€è¦3ä¸ªèŠ‚ç‚¹ï¼Œå½“å‰: $ready_nodes"
        exit 1
    fi
    
    # æ£€æŸ¥é›†ç¾¤èµ„æº
    local total_cpu=$(kubectl top nodes --no-headers | awk '{sum+=$2} END {print sum}' | sed 's/m$//')
    local total_memory=$(kubectl top nodes --no-headers | awk '{sum+=$4} END {print sum}' | sed 's/Mi$//')
    
    log_info "é›†ç¾¤èµ„æºçŠ¶æ€: CPU=${total_cpu}m, Memory=${total_memory}Mi"
    
    if [ "${total_cpu:-0}" -lt 8000 ]; then
        log_warn "é›†ç¾¤ CPU èµ„æºå¯èƒ½ä¸è¶³"
    fi
    
    if [ "${total_memory:-0}" -lt 16384 ]; then
        log_warn "é›†ç¾¤å†…å­˜èµ„æºå¯èƒ½ä¸è¶³"
    fi
    
    log_info "éƒ¨ç½²å‰éªŒè¯å®Œæˆ"
}

# åˆ›å»ºç”Ÿäº§å‘½åç©ºé—´
create_production_namespace() {
    log_step "åˆ›å»ºç”Ÿäº§ç¯å¢ƒå‘½åç©ºé—´..."
    
    # åˆ›å»ºå‘½åç©ºé—´å¹¶è®¾ç½®æ ‡ç­¾
    kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | \
    kubectl label --local -f - \
        environment=production \
        tier=critical \
        monitoring=enabled \
        backup=enabled \
        -o yaml | \
    kubectl apply -f -
    
    # è®¾ç½®ç”Ÿäº§çº§èµ„æºé…é¢
    kubectl apply -f - <<EOF
apiVersion: v1
kind: ResourceQuota
metadata:
  name: production-quota
  namespace: $NAMESPACE
spec:
  hard:
    requests.cpu: "20"
    requests.memory: 40Gi
    limits.cpu: "40"
    limits.memory: 80Gi
    persistentvolumeclaims: "20"
    services: "10"
    secrets: "20"
    configmaps: "20"
    count/pods: "50"
---
apiVersion: v1
kind: LimitRange
metadata:
  name: production-limits
  namespace: $NAMESPACE
spec:
  limits:
  - default:
      cpu: "2"
      memory: "4Gi"
    defaultRequest:
      cpu: "500m"
      memory: "1Gi"
    type: Container
  - max:
      cpu: "8"
      memory: "16Gi"
    min:
      cpu: "100m"
      memory: "128Mi"
    type: Container
EOF
    
    log_info "ç”Ÿäº§å‘½åç©ºé—´åˆ›å»ºå®Œæˆ"
}

# éƒ¨ç½²ç”Ÿäº§çº§å¯†é’¥ç®¡ç†
deploy_production_secrets() {
    log_step "éƒ¨ç½²ç”Ÿäº§çº§å¯†é’¥..."
    
    # åˆ›å»º TLS å¯†é’¥
    kubectl create secret tls websocket-tls-prod \
        --cert=<(echo "$TLS_CERT" | base64 -d) \
        --key=<(echo "$TLS_KEY" | base64 -d) \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | \
    kubectl label --local -f - \
        environment=production \
        component=security \
        -o yaml | \
    kubectl apply -f -
    
    # åˆ›å»ºåº”ç”¨å¯†é’¥
    kubectl create secret generic websocket-app-secrets \
        --from-literal=jwt-secret="$JWT_SECRET" \
        --from-literal=redis-password="$REDIS_PASSWORD" \
        --from-literal=grafana-admin-password="$GRAFANA_ADMIN_PASSWORD" \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | \
    kubectl label --local -f - \
        environment=production \
        component=application \
        -o yaml | \
    kubectl apply -f -
    
    # åˆ›å»ºç›‘æ§å¯†é’¥
    kubectl create secret generic monitoring-secrets \
        --from-literal=prometheus-admin-password="$(openssl rand -base64 32)" \
        --from-literal=alertmanager-webhook-token="$(openssl rand -base64 32)" \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | \
    kubectl label --local -f - \
        environment=production \
        component=monitoring \
        -o yaml | \
    kubectl apply -f -
    
    log_info "ç”Ÿäº§å¯†é’¥éƒ¨ç½²å®Œæˆ"
}

# éƒ¨ç½²ç”Ÿäº§çº§åŸºç¡€è®¾æ–½
deploy_production_infrastructure() {
    log_step "éƒ¨ç½²ç”Ÿäº§çº§åŸºç¡€è®¾æ–½..."
    
    # éƒ¨ç½² Redis é«˜å¯ç”¨é›†ç¾¤
    helm repo add bitnami https://charts.bitnami.com/bitnami
    helm repo update
    
    helm upgrade --install redis-ha bitnami/redis \
        --namespace="$NAMESPACE" \
        --version="17.11.3" \
        --set architecture=replication \
        --set auth.enabled=true \
        --set auth.password="$REDIS_PASSWORD" \
        --set master.persistence.enabled=true \
        --set master.persistence.size=50Gi \
        --set master.persistence.storageClass=fast-ssd \
        --set replica.replicaCount=3 \
        --set replica.persistence.enabled=true \
        --set replica.persistence.size=50Gi \
        --set replica.persistence.storageClass=fast-ssd \
        --set master.resources.requests.memory=2Gi \
        --set master.resources.requests.cpu=1000m \
        --set master.resources.limits.memory=4Gi \
        --set master.resources.limits.cpu=2000m \
        --set replica.resources.requests.memory=1Gi \
        --set replica.resources.requests.cpu=500m \
        --set replica.resources.limits.memory=2Gi \
        --set replica.resources.limits.cpu=1000m \
        --set sentinel.enabled=true \
        --set sentinel.masterSet=websocket-redis \
        --set metrics.enabled=true \
        --set metrics.serviceMonitor.enabled=true \
        --wait --timeout=900s
    
    # éƒ¨ç½²ç”Ÿäº§çº§ç›‘æ§æ ˆ
    helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
    helm repo update
    
    # åˆ›å»ºç›‘æ§é…ç½®
    kubectl create configmap prometheus-config \
        --from-file=configs/monitoring/prometheus-production.yml \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    kubectl create configmap grafana-dashboards \
        --from-file=configs/monitoring/dashboards/ \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
        --namespace="$NAMESPACE" \
        --version="48.3.1" \
        --set prometheus.prometheusSpec.retention=90d \
        --set prometheus.prometheusSpec.storageSpec.volumeClaimTemplate.spec.resources.requests.storage=200Gi \
        --set prometheus.prometheusSpec.storageSpec.volumeClaimTemplate.spec.storageClassName=fast-ssd \
        --set prometheus.prometheusSpec.resources.requests.memory=4Gi \
        --set prometheus.prometheusSpec.resources.requests.cpu=2000m \
        --set prometheus.prometheusSpec.resources.limits.memory=8Gi \
        --set prometheus.prometheusSpec.resources.limits.cpu=4000m \
        --set grafana.adminPassword="$GRAFANA_ADMIN_PASSWORD" \
        --set grafana.persistence.enabled=true \
        --set grafana.persistence.size=20Gi \
        --set grafana.persistence.storageClassName=fast-ssd \
        --set grafana.resources.requests.memory=1Gi \
        --set grafana.resources.requests.cpu=500m \
        --set grafana.resources.limits.memory=2Gi \
        --set grafana.resources.limits.cpu=1000m \
        --set grafana.sidecar.dashboards.enabled=true \
        --set grafana.sidecar.datasources.enabled=true \
        --set alertmanager.alertmanagerSpec.storage.volumeClaimTemplate.spec.resources.requests.storage=10Gi \
        --set alertmanager.alertmanagerSpec.storage.volumeClaimTemplate.spec.storageClassName=fast-ssd \
        --wait --timeout=900s
    
    log_info "ç”Ÿäº§åŸºç¡€è®¾æ–½éƒ¨ç½²å®Œæˆ"
}

# éƒ¨ç½²ä¸»åº”ç”¨æœåŠ¡
deploy_websocket_application() {
    log_step "éƒ¨ç½² WebSocket ä¸»åº”ç”¨..."
    
    # åˆ›å»ºç”Ÿäº§çº§é…ç½®
    cat > /tmp/production-final-values.yaml <<EOF
# ç”Ÿäº§çº§é…ç½®
global:
  environment: production
  imageRegistry: docker.io
  storageClass: fast-ssd

image:
  repository: websocket-server
  tag: "$IMAGE_TAG"
  pullPolicy: Always

replicaCount: 5

strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 2

resources:
  requests:
    cpu: 1500m
    memory: 2Gi
  limits:
    cpu: 3000m
    memory: 8Gi

autoscaling:
  enabled: true
  minReplicas: 5
  maxReplicas: 20
  targetCPUUtilizationPercentage: 60
  targetMemoryUtilizationPercentage: 70
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60

service:
  type: ClusterIP
  port: 8080
  targetPort: 8080

ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/websocket-services: "websocket-server"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"
    nginx.ingress.kubernetes.io/upstream-hash-by: "\$remote_addr"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "1000"
    nginx.ingress.kubernetes.io/rate-limit-burst: "2000"
  hosts:
    - host: websocket.production.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: websocket-tls-prod
      hosts:
        - websocket.production.com

config:
  environment: production
  server:
    host: "0.0.0.0"
    port: 8080
    maxConnections: 50000
    connectionTimeout: 300
    heartbeatInterval: 30
    tlsEnabled: true
    workerThreads: 8
  monitoring:
    metricsEnabled: true
    tracingEnabled: true
    healthCheckEnabled: true
    tracingEndpoint: "http://jaeger-collector:14268/api/traces"
    tracingSampleRate: 0.1
  security:
    jwtExpirationHours: 24
    rateLimitEnabled: true
    rateLimitRequestsPerMinute: 1000

secrets:
  existingSecret: "websocket-app-secrets"
  jwtSecretKey: "jwt-secret"
  redisPasswordKey: "redis-password"

redis:
  enabled: false
  external:
    enabled: true
    host: "redis-ha"
    port: 6379
    auth: true
    passwordSecret: "websocket-app-secrets"
    passwordKey: "redis-password"
    sentinel:
      enabled: true
      masterSet: "websocket-redis"

monitoring:
  serviceMonitor:
    enabled: true
    interval: 15s
    scrapeTimeout: 10s
  prometheusRule:
    enabled: true

podDisruptionBudget:
  enabled: true
  minAvailable: 3

networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx
      ports:
      - protocol: TCP
        port: 8080
    - from:
      - namespaceSelector:
          matchLabels:
            name: monitoring
      ports:
      - protocol: TCP
        port: 9090
  egress:
    - to:
      - namespaceSelector:
          matchLabels:
            name: $NAMESPACE
      ports:
      - protocol: TCP
        port: 6379
    - to: []
      ports:
      - protocol: TCP
        port: 53
      - protocol: UDP
        port: 53

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

podSecurityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
    add:
    - NET_BIND_SERVICE
  readOnlyRootFilesystem: true

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - websocket-server
        topologyKey: kubernetes.io/hostname

tolerations:
- key: "dedicated"
  operator: "Equal"
  value: "websocket"
  effect: "NoSchedule"

nodeSelector:
  node-type: "compute-optimized"

persistence:
  enabled: true
  storageClass: "fast-ssd"
  size: 10Gi
  logs:
    enabled: true
    size: 20Gi

backup:
  enabled: true
  schedule: "0 2 * * *"
  retention: "30d"
EOF

    # éƒ¨ç½²åº”ç”¨
    helm upgrade --install "$RELEASE_NAME" helm/websocket-server/ \
        --namespace="$NAMESPACE" \
        --values=/tmp/production-final-values.yaml \
        --wait --timeout=900s \
        --atomic
    
    log_info "WebSocket åº”ç”¨éƒ¨ç½²å®Œæˆ"
}

# éƒ¨ç½²åå®Œæ•´éªŒè¯
post_deployment_comprehensive_validation() {
    log_step "æ‰§è¡Œéƒ¨ç½²åç»¼åˆéªŒè¯..."
    
    # ç­‰å¾…æ‰€æœ‰ Pods å°±ç»ª
    log_info "ç­‰å¾… Pods å°±ç»ª..."
    kubectl wait --for=condition=ready pod \
        -l app.kubernetes.io/name=websocket-server \
        --namespace="$NAMESPACE" \
        --timeout=600s
    
    # æ£€æŸ¥æœåŠ¡çŠ¶æ€
    local ready_pods=$(kubectl get pods -l app.kubernetes.io/name=websocket-server \
        --namespace="$NAMESPACE" --no-headers | grep Running | wc -l)
    log_info "å°±ç»ªçš„ WebSocket Pods: $ready_pods"
    
    if [ "$ready_pods" -lt 3 ]; then
        log_error "å°±ç»ªçš„ Pods æ•°é‡ä¸è¶³: $ready_pods"
        exit 1
    fi
    
    # å¥åº·æ£€æŸ¥
    local service_ip=$(kubectl get service "$RELEASE_NAME" \
        --namespace="$NAMESPACE" -o jsonpath='{.spec.clusterIP}')
    
    log_info "æ‰§è¡Œå¥åº·æ£€æŸ¥..."
    kubectl run health-check-final --rm -i --restart=Never \
        --image=curlimages/curl:7.87.0 \
        --namespace="$NAMESPACE" -- \
        curl -f --max-time 30 "http://$service_ip:8080/health" || {
        log_error "å¥åº·æ£€æŸ¥å¤±è´¥"
        kubectl logs -l app.kubernetes.io/name=websocket-server --namespace="$NAMESPACE" --tail=100
        exit 1
    }
    
    # æŒ‡æ ‡æ£€æŸ¥
    log_info "éªŒè¯æŒ‡æ ‡ç«¯ç‚¹..."
    kubectl run metrics-check-final --rm -i --restart=Never \
        --image=curlimages/curl:7.87.0 \
        --namespace="$NAMESPACE" -- \
        curl -f --max-time 30 "http://$service_ip:9090/metrics" || {
        log_warn "æŒ‡æ ‡ç«¯ç‚¹æ£€æŸ¥å¤±è´¥"
    }
    
    # WebSocket è¿æ¥æµ‹è¯•
    log_info "æ‰§è¡Œ WebSocket è¿æ¥æµ‹è¯•..."
    kubectl run websocket-test --rm -i --restart=Never \
        --image=alpine/wscat:v5.2.0 \
        --namespace="$NAMESPACE" -- \
        wscat -c "ws://$service_ip:8080" -x '{"type":"ping"}' || {
        log_warn "WebSocket è¿æ¥æµ‹è¯•å¤±è´¥"
    }
    
    # æ£€æŸ¥ç›‘æ§ç³»ç»Ÿ
    log_info "éªŒè¯ç›‘æ§ç³»ç»Ÿ..."
    kubectl get pods -l app=prometheus --namespace="$NAMESPACE" | grep Running || {
        log_warn "Prometheus æœªæ­£å¸¸è¿è¡Œ"
    }
    
    kubectl get pods -l app.kubernetes.io/name=grafana --namespace="$NAMESPACE" | grep Running || {
        log_warn "Grafana æœªæ­£å¸¸è¿è¡Œ"
    }
    
    # æ£€æŸ¥å­˜å‚¨
    log_info "éªŒè¯å­˜å‚¨é…ç½®..."
    kubectl get pvc --namespace="$NAMESPACE" | grep Bound || {
        log_warn "å­˜å‚¨å·ç»‘å®šå¼‚å¸¸"
    }
    
    log_success "éƒ¨ç½²åéªŒè¯å®Œæˆ"
}

# ç”Ÿæˆéƒ¨ç½²æŠ¥å‘Š
generate_deployment_report() {
    log_step "ç”Ÿæˆéƒ¨ç½²æŠ¥å‘Š..."
    
    local report_file="deployment-report-$(date +%Y%m%d-%H%M%S).md"
    
    cat > "$report_file" <<EOF
# WebSocket æœåŠ¡ç”Ÿäº§éƒ¨ç½²æŠ¥å‘Š

## éƒ¨ç½²ä¿¡æ¯
- **éƒ¨ç½²æ—¶é—´**: $(date)
- **é•œåƒç‰ˆæœ¬**: $IMAGE_TAG
- **å‘½åç©ºé—´**: $NAMESPACE
- **å‘å¸ƒåç§°**: $RELEASE_NAME
- **ç¯å¢ƒ**: $ENVIRONMENT

## æœåŠ¡çŠ¶æ€
\`\`\`
$(kubectl get all -n "$NAMESPACE")
\`\`\`

## Pod è¯¦æƒ…
\`\`\`
$(kubectl get pods -l app.kubernetes.io/name=websocket-server -n "$NAMESPACE" -o wide)
\`\`\`

## èµ„æºä½¿ç”¨
\`\`\`
$(kubectl top pods -n "$NAMESPACE" --no-headers | head -10)
\`\`\`

## æœåŠ¡ç«¯ç‚¹
- **WebSocket æœåŠ¡**: ws://websocket.production.com
- **å¥åº·æ£€æŸ¥**: https://websocket.production.com/health
- **æŒ‡æ ‡**: https://websocket.production.com/metrics
- **Grafana ç›‘æ§**: https://grafana.production.com
- **Prometheus**: https://prometheus.production.com

## é…ç½®æ‘˜è¦
- **å‰¯æœ¬æ•°**: 5 (è‡ªåŠ¨æ‰©å±•: 5-20)
- **èµ„æºé™åˆ¶**: CPU 3000m, Memory 8Gi
- **å­˜å‚¨**: 10Gi (fast-ssd)
- **ç½‘ç»œç­–ç•¥**: å·²å¯ç”¨
- **å®‰å…¨ä¸Šä¸‹æ–‡**: é root ç”¨æˆ·

## éªŒè¯ç»“æœ
- âœ… Pod å°±ç»ªæ£€æŸ¥
- âœ… å¥åº·æ£€æŸ¥
- âœ… æŒ‡æ ‡ç«¯ç‚¹
- âœ… WebSocket è¿æ¥
- âœ… ç›‘æ§ç³»ç»Ÿ
- âœ… å­˜å‚¨é…ç½®

## ä¸‹ä¸€æ­¥
1. é…ç½®å¤–éƒ¨ DNS æŒ‡å‘ç”Ÿäº§åŸŸå
2. è®¾ç½®å¤‡ä»½å’Œæ¢å¤æµç¨‹
3. é…ç½®å‘Šè­¦é€šçŸ¥
4. æ‰§è¡Œè´Ÿè½½æµ‹è¯•éªŒè¯
5. åˆ¶å®šè¿ç»´å€¼ç­è®¡åˆ’

---
æŠ¥å‘Šç”Ÿæˆæ—¶é—´: $(date)
EOF
    
    log_success "éƒ¨ç½²æŠ¥å‘Šå·²ç”Ÿæˆ: $report_file"
}

# æ¸…ç†ä¸´æ—¶æ–‡ä»¶
cleanup_deployment() {
    log_step "æ¸…ç†éƒ¨ç½²ä¸´æ—¶æ–‡ä»¶..."
    
    rm -f /tmp/production-final-values.yaml
    
    log_info "æ¸…ç†å®Œæˆ"
}

# ä¸»éƒ¨ç½²æµç¨‹
main() {
    log_info "å¼€å§‹æœ€ç»ˆç”Ÿäº§éƒ¨ç½² - ç‰ˆæœ¬: $IMAGE_TAG"
    
    # è®¾ç½®é”™è¯¯å¤„ç†
    trap cleanup_deployment EXIT
    
    pre_deployment_validation
    create_production_namespace
    deploy_production_secrets
    deploy_production_infrastructure
    deploy_websocket_application
    post_deployment_comprehensive_validation
    generate_deployment_report
    
    log_success "ğŸ‰ ç”Ÿäº§éƒ¨ç½²æˆåŠŸå®Œæˆï¼"
    echo
    echo "========================================"
    echo "ğŸš€ WebSocket æœåŠ¡å·²æˆåŠŸéƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ"
    echo "ğŸ“Š è®¿é—®åœ°å€: https://websocket.production.com"
    echo "ğŸ“ˆ ç›‘æ§é¢æ¿: https://grafana.production.com"
    echo "ğŸ” æŒ‡æ ‡æŸ¥è¯¢: https://prometheus.production.com"
    echo "========================================"
    echo
    log_info "éƒ¨ç½²çŠ¶æ€æ¦‚è§ˆ:"
    kubectl get all -n "$NAMESPACE"
}

# æ‰§è¡Œä¸»æµç¨‹
main "$@"</pre>

        <p><strong>æ­¥éª¤ 4: éªŒæ”¶æŠ¥å‘Šç”Ÿæˆ</strong></p>
        <pre># src/reporting/test_reporter.rs
//! æµ‹è¯•æŠ¥å‘Šç”Ÿæˆå™¨

use std::collections::HashMap;
use std::fs::{self, File};
use std::io::Write;
use std::path::Path;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use serde_json;

use super::ValidationResult;

/// æµ‹è¯•æŠ¥å‘Šå™¨
pub struct TestReporter {
    suite_name: String,
    start_time: DateTime<Utc>,
    logs: Vec<LogEntry>,
    test_results: Vec<TestResult>,
    metrics: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogEntry {
    timestamp: DateTime<Utc>,
    level: LogLevel,
    message: String,
    context: Option<HashMap<String, String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogLevel {
    Info,
    Success,
    Warning,
    Error,
    Debug,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResult {
    name: String,
    status: TestStatus,
    duration: f64,
    error_message: Option<String>,
    metrics: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TestStatus {
    Passed,
    Failed,
    Skipped,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ValidationReport {
    metadata: ReportMetadata,
    summary: TestSummary,
    test_results: Vec<TestResult>,
    performance_metrics: HashMap<String, f64>,
    security_findings: Vec<SecurityFinding>,
    recommendations: Vec<Recommendation>,
    logs: Vec<LogEntry>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ReportMetadata {
    suite_name: String,
    generated_at: DateTime<Utc>,
    version: String,
    environment: String,
    test_duration_seconds: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TestSummary {
    total_tests: u32,
    passed: u32,
    failed: u32,
    skipped: u32,
    success_rate: f64,
    total_duration: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityFinding {
    severity: String,
    category: String,
    description: String,
    recommendation: String,
    status: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Recommendation {
    priority: String,
    category: String,
    title: String,
    description: String,
    implementation_effort: String,
    expected_impact: String,
}

impl TestReporter {
    pub async fn new(suite_name: &str) -> Self {
        Self {
            suite_name: suite_name.to_string(),
            start_time: Utc::now(),
            logs: Vec::new(),
            test_results: Vec::new(),
            metrics: HashMap::new(),
        }
    }
    
    pub async fn start_test_suite(&mut self, description: &str) {
        self.log_info(&format!("å¼€å§‹æµ‹è¯•å¥—ä»¶: {}", description)).await;
    }
    
    pub async fn start_test(&mut self, test_name: &str) {
        self.log_info(&format!("å¼€å§‹æµ‹è¯•: {}", test_name)).await;
    }
    
    pub async fn log_info(&mut self, message: &str) {
        self.add_log(LogLevel::Info, message, None).await;
    }
    
    pub async fn log_success(&mut self, message: &str) {
        self.add_log(LogLevel::Success, message, None).await;
    }
    
    pub async fn log_warning(&mut self, message: &str) {
        self.add_log(LogLevel::Warning, message, None).await;
    }
    
    pub async fn log_error(&mut self, message: &str) {
        self.add_log(LogLevel::Error, message, None).await;
    }
    
    async fn add_log(&mut self, level: LogLevel, message: &str, context: Option<HashMap<String, String>>) {
        let entry = LogEntry {
            timestamp: Utc::now(),
            level,
            message: message.to_string(),
            context,
        };
        
        self.logs.push(entry);
        
        // å®æ—¶è¾“å‡ºåˆ°æ§åˆ¶å°
        let level_str = match &self.logs.last().unwrap().level {
            LogLevel::Info => "INFO",
            LogLevel::Success => "SUCCESS",
            LogLevel::Warning => "WARN",
            LogLevel::Error => "ERROR",
            LogLevel::Debug => "DEBUG",
        };
        
        println!("[{}] {}: {}", 
                 self.logs.last().unwrap().timestamp.format("%H:%M:%S"),
                 level_str, 
                 message);
    }
    
    pub async fn finish_test_suite(&mut self, results: ValidationResult) {
        let duration = Utc::now().signed_duration_since(self.start_time);
        self.log_info(&format!(
            "æµ‹è¯•å¥—ä»¶å®Œæˆ: é€šè¿‡ {}, å¤±è´¥ {}, è·³è¿‡ {}, æˆåŠŸç‡ {:.1}%, è€—æ—¶ {:.1}s",
            results.passed, results.failed, results.skipped, 
            results.success_rate(), duration.num_milliseconds() as f64 / 1000.0
        )).await;
        
        self.metrics.extend(results.metrics);
    }
    
    /// ç”Ÿæˆå®Œæ•´éªŒæ”¶æŠ¥å‘Š
    pub async fn generate_validation_report(&self) -> std::io::Result<ValidationReport> {
        let total_duration = Utc::now().signed_duration_since(self.start_time);
        
        let summary = self.calculate_summary();
        let security_findings = self.generate_security_findings();
        let recommendations = self.generate_recommendations();
        
        let report = ValidationReport {
            metadata: ReportMetadata {
                suite_name: self.suite_name.clone(),
                generated_at: Utc::now(),
                version: env!("CARGO_PKG_VERSION").to_string(),
                environment: std::env::var("ENVIRONMENT").unwrap_or("test".to_string()),
                test_duration_seconds: total_duration.num_milliseconds() as f64 / 1000.0,
            },
            summary,
            test_results: self.test_results.clone(),
            performance_metrics: self.metrics.clone(),
            security_findings,
            recommendations,
            logs: self.logs.clone(),
        };
        
        Ok(report)
    }
    
    /// ç”Ÿæˆ HTML æ ¼å¼æŠ¥å‘Š
    pub async fn generate_html_report(&self, output_path: &str) -> std::io::Result<()> {
        let report = self.generate_validation_report().await?;
        
        let html_content = format!(r#"
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket æœåŠ¡éªŒæ”¶æŠ¥å‘Š</title>
    <style>
        body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 8px 8px 0 0; }}
        .content {{ padding: 30px; }}
        .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }}
        .metric-card {{ background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #667eea; }}
        .metric-value {{ font-size: 2em; font-weight: bold; color: #333; }}
        .metric-label {{ color: #666; margin-top: 5px; }}
        .section {{ margin: 30px 0; }}
        .section h2 {{ color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px; }}
        .test-result {{ background: #f8f9fa; margin: 10px 0; padding: 15px; border-radius: 5px; border-left: 4px solid #28a745; }}
        .test-result.failed {{ border-left-color: #dc3545; }}
        .test-result.skipped {{ border-left-color: #ffc107; }}
        .log-entry {{ font-family: monospace; margin: 5px 0; padding: 8px; background: #f8f9fa; border-radius: 4px; }}
        .log-info {{ border-left: 3px solid #17a2b8; }}
        .log-success {{ border-left: 3px solid #28a745; }}
        .log-warning {{ border-left: 3px solid #ffc107; }}
        .log-error {{ border-left: 3px solid #dc3545; }}
        .chart {{ background: white; padding: 20px; border-radius: 8px; margin: 20px 0; }}
        table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background-color: #f8f9fa; font-weight: bold; }}
        .status-passed {{ color: #28a745; font-weight: bold; }}
        .status-failed {{ color: #dc3545; font-weight: bold; }}
        .status-skipped {{ color: #ffc107; font-weight: bold; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ WebSocket æœåŠ¡éªŒæ”¶æŠ¥å‘Š</h1>
            <p>æµ‹è¯•å¥—ä»¶: {suite_name}</p>
            <p>ç”Ÿæˆæ—¶é—´: {generated_at}</p>
            <p>æµ‹è¯•ç¯å¢ƒ: {environment}</p>
        </div>
        
        <div class="content">
            <div class="section">
                <h2>ğŸ“Š æµ‹è¯•æ¦‚è§ˆ</h2>
                <div class="summary">
                    <div class="metric-card">
                        <div class="metric-value">{total_tests}</div>
                        <div class="metric-label">æ€»æµ‹è¯•æ•°</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">{passed}</div>
                        <div class="metric-label">é€šè¿‡</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">{failed}</div>
                        <div class="metric-label">å¤±è´¥</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">{success_rate:.1}%</div>
                        <div class="metric-label">æˆåŠŸç‡</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">{duration:.1}s</div>
                        <div class="metric-label">æµ‹è¯•æ—¶é•¿</div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2>ğŸ§ª æµ‹è¯•ç»“æœè¯¦æƒ…</h2>
                {test_results_html}
            </div>
            
            <div class="section">
                <h2>ğŸ“ˆ æ€§èƒ½æŒ‡æ ‡</h2>
                <table>
                    <thead>
                        <tr><th>æŒ‡æ ‡åç§°</th><th>å€¼</th><th>å•ä½</th></tr>
                    </thead>
                    <tbody>
                        {performance_metrics_html}
                    </tbody>
                </table>
            </div>
            
            <div class="section">
                <h2>ğŸ”’ å®‰å…¨æ£€æŸ¥</h2>
                {security_findings_html}
            </div>
            
            <div class="section">
                <h2>ğŸ’¡ ä¼˜åŒ–å»ºè®®</h2>
                {recommendations_html}
            </div>
            
            <div class="section">
                <h2>ğŸ“ è¯¦ç»†æ—¥å¿—</h2>
                <div style="max-height: 400px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 5px;">
                    {logs_html}
                </div>
            </div>
        </div>
    </div>
</body>
</html>
"#,
            suite_name = report.metadata.suite_name,
            generated_at = report.metadata.generated_at.format("%Y-%m-%d %H:%M:%S UTC"),
            environment = report.metadata.environment,
            total_tests = report.summary.total_tests,
            passed = report.summary.passed,
            failed = report.summary.failed,
            success_rate = report.summary.success_rate,
            duration = report.summary.total_duration,
            test_results_html = self.generate_test_results_html(&report.test_results),
            performance_metrics_html = self.generate_metrics_html(&report.performance_metrics),
            security_findings_html = self.generate_security_html(&report.security_findings),
            recommendations_html = self.generate_recommendations_html(&report.recommendations),
            logs_html = self.generate_logs_html(&report.logs),
        );
        
        fs::write(output_path, html_content)?;
        Ok(())
    }
    
    fn calculate_summary(&self) -> TestSummary {
        let total = self.test_results.len() as u32;
        let passed = self.test_results.iter().filter(|r| matches!(r.status, TestStatus::Passed)).count() as u32;
        let failed = self.test_results.iter().filter(|r| matches!(r.status, TestStatus::Failed)).count() as u32;
        let skipped = self.test_results.iter().filter(|r| matches!(r.status, TestStatus::Skipped)).count() as u32;
        
        let success_rate = if total > 0 { (passed as f64 / total as f64) * 100.0 } else { 0.0 };
        let total_duration = self.test_results.iter().map(|r| r.duration).sum();
        
        TestSummary {
            total_tests: total,
            passed,
            failed,
            skipped,
            success_rate,
            total_duration,
        }
    }
    
    fn generate_security_findings(&self) -> Vec<SecurityFinding> {
        vec![
            SecurityFinding {
                severity: "High".to_string(),
                category: "Authentication".to_string(),
                description: "JWT token éªŒè¯æœºåˆ¶å·²å®æ–½".to_string(),
                recommendation: "å»ºè®®å®šæœŸè½®æ¢ JWT å¯†é’¥".to_string(),
                status: "Resolved".to_string(),
            },
            SecurityFinding {
                severity: "Medium".to_string(),
                category: "Network".to_string(),
                description: "TLS åŠ å¯†å·²å¯ç”¨".to_string(),
                recommendation: "ç¡®ä¿ä½¿ç”¨æœ€æ–°çš„ TLS ç‰ˆæœ¬".to_string(),
                status: "Resolved".to_string(),
            },
            SecurityFinding {
                severity: "Low".to_string(),
                category: "Logging".to_string(),
                description: "æ—¥å¿—ä¸­å¯èƒ½åŒ…å«æ•æ„Ÿä¿¡æ¯".to_string(),
                recommendation: "å®æ–½æ—¥å¿—è„±æ•å¤„ç†".to_string(),
                status: "Open".to_string(),
            },
        ]
    }
    
    fn generate_recommendations(&self) -> Vec<Recommendation> {
        vec![
            Recommendation {
                priority: "High".to_string(),
                category: "Performance".to_string(),
                title: "å®æ–½è¿æ¥æ± ç®¡ç†".to_string(),
                description: "æ·»åŠ è¿æ¥æ± ç®¡ç†ä»¥ä¼˜åŒ–èµ„æºä½¿ç”¨å’Œæ€§èƒ½".to_string(),
                implementation_effort: "Medium".to_string(),
                expected_impact: "æå‡ 20% æ€§èƒ½ï¼Œå‡å°‘èµ„æºä½¿ç”¨".to_string(),
            },
            Recommendation {
                priority: "Medium".to_string(),
                category: "Monitoring".to_string(),
                title: "å¢å¼ºç›‘æ§æŒ‡æ ‡".to_string(),
                description: "æ·»åŠ æ›´è¯¦ç»†çš„ä¸šåŠ¡æŒ‡æ ‡å’Œç”¨æˆ·è¡Œä¸ºåˆ†æ".to_string(),
                implementation_effort: "Low".to_string(),
                expected_impact: "æ”¹å–„è¿ç»´å¯è§†æ€§å’Œé—®é¢˜è¯Šæ–­èƒ½åŠ›".to_string(),
            },
            Recommendation {
                priority: "Low".to_string(),
                category: "Feature".to_string(),
                title: "å®æ–½æ¶ˆæ¯æŒä¹…åŒ–".to_string(),
                description: "ä¸ºå…³é”®æ¶ˆæ¯æ·»åŠ æŒä¹…åŒ–å­˜å‚¨æœºåˆ¶".to_string(),
                implementation_effort: "High".to_string(),
                expected_impact: "æé«˜æ•°æ®å¯é æ€§å’Œç”¨æˆ·ä½“éªŒ".to_string(),
            },
        ]
    }
    
    // å…¶ä»– HTML ç”Ÿæˆæ–¹æ³•...
    fn generate_test_results_html(&self, results: &[TestResult]) -> String {
        results.iter().map(|result| {
            let status_class = match result.status {
                TestStatus::Passed => "passed",
                TestStatus::Failed => "failed",
                TestStatus::Skipped => "skipped",
            };
            let status_text = match result.status {
                TestStatus::Passed => "âœ… é€šè¿‡",
                TestStatus::Failed => "âŒ å¤±è´¥",
                TestStatus::Skipped => "â­ï¸ è·³è¿‡",
            };
            
            format!(r#"
                <div class="test-result {}">
                    <strong>{}</strong> - {} ({:.2}s)
                    {}
                </div>
            "#, 
                status_class, 
                result.name, 
                status_text, 
                result.duration,
                result.error_message.as_ref().map(|e| format!("<br><em>é”™è¯¯: {}</em>", e)).unwrap_or_default()
            )
        }).collect()
    }
    
    fn generate_metrics_html(&self, metrics: &HashMap<String, f64>) -> String {
        metrics.iter().map(|(name, value)| {
            let (unit, formatted_value) = self.format_metric_value(name, *value);
            format!("<tr><td>{}</td><td>{}</td><td>{}</td></tr>", name, formatted_value, unit)
        }).collect()
    }
    
    fn format_metric_value(&self, name: &str, value: f64) -> (String, String) {
        if name.contains("latency") || name.contains("duration") {
            if name.contains("_ms") {
                ("ms".to_string(), format!("{:.2}", value))
            } else {
                ("s".to_string(), format!("{:.2}", value))
            }
        } else if name.contains("rate") || name.contains("per_second") {
            ("/s".to_string(), format!("{:.0}", value))
        } else if name.contains("percent") {
            ("%".to_string(), format!("{:.1}", value))
        } else if name.contains("memory") && name.contains("mb") {
            ("MB".to_string(), format!("{:.0}", value))
        } else if name.contains("connections") {
            ("count".to_string(), format!("{:.0}", value))
        } else {
            ("".to_string(), format!("{:.2}", value))
        }
    }
    
    fn generate_security_html(&self, findings: &[SecurityFinding]) -> String {
        findings.iter().map(|finding| {
            let severity_class = match finding.severity.as_str() {
                "High" => "status-failed",
                "Medium" => "status-skipped", 
                "Low" => "status-passed",
                _ => "",
            };
            
            format!(r#"
                <div class="test-result">
                    <strong class="{}">{} - {}</strong><br>
                    <em>{}</em><br>
                    <small>å»ºè®®: {}</small>
                </div>
            "#, severity_class, finding.severity, finding.category, finding.description, finding.recommendation)
        }).collect()
    }
    
    fn generate_recommendations_html(&self, recommendations: &[Recommendation]) -> String {
        recommendations.iter().map(|rec| {
            format!(r#"
                <div class="test-result">
                    <strong>{} ({})</strong><br>
                    <em>{}</em><br>
                    <small>å®æ–½éš¾åº¦: {} | é¢„æœŸå½±å“: {}</small>
                </div>
            "#, rec.title, rec.priority, rec.description, rec.implementation_effort, rec.expected_impact)
        }).collect()
    }
    
    fn generate_logs_html(&self, logs: &[LogEntry]) -> String {
        logs.iter().map(|log| {
            let level_class = match log.level {
                LogLevel::Info => "log-info",
                LogLevel::Success => "log-success",
                LogLevel::Warning => "log-warning",
                LogLevel::Error => "log-error",
                LogLevel::Debug => "log-info",
            };
            
            format!(r#"
                <div class="log-entry {}">
                    [{}] {}
                </div>
            "#, level_class, log.timestamp.format("%H:%M:%S"), log.message)
        }).collect()
    }
}</pre>

        <p><strong>å®è·µç»ƒä¹ ï¼š</strong></p>
        <ol>
            <li><strong>æ‰§è¡Œå…¨é¢éªŒæ”¶æµ‹è¯•</strong>
                <pre>cd day31_project_validation
./scripts/validation/run-all-tests.sh
cargo test --release --all</pre>
            </li>
            <li><strong>ç”ŸæˆéªŒæ”¶æŠ¥å‘Š</strong>
                <pre>./scripts/reporting/generate-report.sh
open reports/validation-report.html</pre>
            </li>
            <li><strong>æ‰§è¡Œæœ€ç»ˆç”Ÿäº§éƒ¨ç½²</strong>
                <pre>./scripts/deployment/final-deploy.sh v1.0.0
kubectl get all -n websocket-production</pre>
            </li>
            <li><strong>éªŒè¯ç”Ÿäº§ç¯å¢ƒ</strong>
                <pre>./scripts/deployment/smoke-test.sh
curl -f https://websocket.production.com/health</pre>
            </li>
            <li><strong>ç›‘æ§ç³»ç»Ÿæ£€æŸ¥</strong>
                <pre>kubectl port-forward svc/grafana 3000:80 -n websocket-production
open http://localhost:3000</pre>
            </li>
        </ol>

        <p><strong>é¡¹ç›®éªŒæ”¶æ ‡å‡†ï¼š</strong></p>
        <ul>
            <li>âœ… <strong>åŠŸèƒ½å®Œæ•´æ€§</strong>: æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½æ­£å¸¸å·¥ä½œï¼Œæµ‹è¯•é€šè¿‡ç‡ â‰¥ 95%</li>
            <li>âœ… <strong>æ€§èƒ½æŒ‡æ ‡</strong>: æ”¯æŒ 10K+ å¹¶å‘è¿æ¥ï¼Œæ¶ˆæ¯å»¶è¿Ÿ P99 â‰¤ 100ms</li>
            <li>âœ… <strong>å¯é æ€§</strong>: æœåŠ¡å¯ç”¨æ€§ â‰¥ 99.9%ï¼Œæ•…éšœæ¢å¤æ—¶é—´ â‰¤ 30s</li>
            <li>âœ… <strong>å®‰å…¨åˆè§„</strong>: é€šè¿‡å®‰å…¨æ‰«æï¼Œæ— é«˜å±æ¼æ´</li>
            <li>âœ… <strong>è¿ç»´å°±ç»ª</strong>: ç›‘æ§å‘Šè­¦å®Œå¤‡ï¼Œæ—¥å¿—ç»“æ„åŒ–ï¼Œæ–‡æ¡£å®Œæ•´</li>
            <li>âœ… <strong>æ‰©å±•èƒ½åŠ›</strong>: æ”¯æŒæ°´å¹³æ‰©å±•ï¼Œèµ„æºå¼¹æ€§è°ƒæ•´</li>
            <li>âœ… <strong>éƒ¨ç½²è‡ªåŠ¨åŒ–</strong>: CI/CD æµæ°´çº¿å®Œæ•´ï¼Œä¸€é”®éƒ¨ç½²</li>
            <li>âœ… <strong>ä»£ç è´¨é‡</strong>: ä»£ç è¦†ç›–ç‡ â‰¥ 90%ï¼Œç¬¦åˆæœ€ä½³å®è·µ</li>
        </ul>

        <p><strong>é•¿æœŸè¿ç»´è®¡åˆ’ï¼š</strong></p>
        <ul>
            <li>ğŸ”„ <strong>æŒç»­ç›‘æ§</strong>: 7x24 ç›‘æ§å‘Šè­¦ï¼Œæ€§èƒ½è¶‹åŠ¿åˆ†æ</li>
            <li>ğŸ›¡ï¸ <strong>å®‰å…¨ç»´æŠ¤</strong>: å®šæœŸå®‰å…¨æ‰«æï¼Œä¾èµ–æ›´æ–°ç®¡ç†</li>
            <li>ğŸ“Š <strong>æ€§èƒ½ä¼˜åŒ–</strong>: æœˆåº¦æ€§èƒ½è¯„ä¼°ï¼Œç“¶é¢ˆè¯†åˆ«ä¼˜åŒ–</li>
            <li>ğŸ”§ <strong>åŠŸèƒ½è¿­ä»£</strong>: éœ€æ±‚æ”¶é›†è¯„ä¼°ï¼Œç‰ˆæœ¬å‘å¸ƒç®¡ç†</li>
            <li>ğŸ’¾ <strong>æ•°æ®å¤‡ä»½</strong>: è‡ªåŠ¨åŒ–å¤‡ä»½ç­–ç•¥ï¼Œç¾éš¾æ¢å¤æ¼”ç»ƒ</li>
            <li>ğŸ“š <strong>çŸ¥è¯†ä¼ æ‰¿</strong>: è¿ç»´æ–‡æ¡£æ›´æ–°ï¼Œå›¢é˜ŸåŸ¹è®­è®¡åˆ’</li>
        </ul>

    <h2 style="margin-top: 3em;">âœ… ç¬¬ 31 å¤©é¡¹ç›®éªŒæ”¶ç›®æ ‡</h2>
    <pre>
ğŸ¯ é¡¹ç›®éªŒæ”¶ç›®æ ‡ï¼ˆ8 æœˆ 31 æ—¥ï¼‰ï¼š

ä½ å°†å®Œæˆä¸€ä¸ªå®Œæ•´çš„å¼‚æ­¥ WebSocket æœåŠ¡ï¼Œå…·å¤‡ä»¥ä¸‹èƒ½åŠ›ï¼š

- æ”¯æŒå®¢æˆ·ç«¯é€šè¿‡æµè§ˆå™¨æˆ– CLI å·¥å…·è¿æ¥å¹¶å‘é€æ¶ˆæ¯
- æ”¯æŒå¤šå®¢æˆ·ç«¯å¹¿æ’­ï¼Œæ„å»ºèŠå¤©å®¤åŸå‹
- æ¯ä¸ªå®¢æˆ·ç«¯è¿æ¥å‰è¿›è¡Œ token é‰´æƒ
- æ—¥å¿—ç³»ç»Ÿé‡‡ç”¨ tracingï¼Œè¾“å‡ºç»“æ„åŒ–æ—¥å¿—
- æ‰€æœ‰é…ç½®æ”¯æŒé€šè¿‡ ConfigMap æ³¨å…¥
- å·²å®¹å™¨åŒ–ä¸º docker é•œåƒï¼Œèƒ½éƒ¨ç½²åœ¨ Kubernetes ä¸­
- æä¾› Helm chartï¼ˆå¯é€‰ï¼‰è¿›è¡Œæ¨¡æ¿åŒ–éƒ¨ç½²
- é¡¹ç›®å·²ä¸Šä¼ è‡³ GitHubï¼Œå¸¦ README å’Œéƒ¨ç½²è¯´æ˜
</pre>

    <footer style="margin-top: 3em; font-size: 0.9em; color: #999;">
        æœ¬é¡µé¢ç”± ChatGPT Rust é¡¹ç›®åŸ¹è®­ä¸“å®¶ç”Ÿæˆï¼Œé€‚ç”¨äºä¸ªäººè®­ç»ƒã€è‡ªå­¦è®¡åˆ’ä¸å›¢é˜ŸåŸ¹è®­ã€‚
    </footer>
</body>
<a href="#" id="back-to-top">Back to Top</a>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        const toc = document.querySelector("#toc ul");
        const headings = document.querySelectorAll("h2");
        headings.forEach((heading, index) => {
            const id = "day-" + (index + 1);
            heading.id = id;
            const li = document.createElement("li");
            const a = document.createElement("a");
            a.href = "#" + id;
            a.textContent = heading.textContent;
            li.appendChild(a);
            toc.appendChild(li);
        });
        const backToTopButton = document.getElementById("back-to-top");
        window.addEventListener("scroll", () => {
            if (window.pageYOffset > 300) {
                backToTopButton.style.display = "block";
            } else {
                backToTopButton.style.display = "none";
            }
        });
    });
</script>
</html>