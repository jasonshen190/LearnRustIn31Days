
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Rust 训练营完整计划（31天 + 项目验收）</title>
    <style>
        body { font-family: sans-serif; padding: 2rem; background: #fdfdfd; line-height: 1.6; }
        h1 { color: #a00000; }
        h2 { margin-top: 2em; color: #333; }
        p.date { color: #888; margin-bottom: 0.3em; }
        pre { background: #f4f4f4; padding: 1em; border-left: 3px solid #ccc; }
        a { color: #007acc; }
        #toc {
            background: #f9f9f9;
            border: 1px solid #aaa;
            padding: 1em;
            margin-bottom: 2em;
        }
        #toc h2 {
            margin-top: 0;
        }
        #toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        #toc ul li a {
            text-decoration: none;
        }
        #back-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #007acc;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            text-decoration: none;
            display: none;
        }
    </style>
</head>
<body>
    <h1>Rust WebSocket 项目训练营：每日任务 + 结构模板 + 最终验收</h1>
    <div id="toc">
        <h2>Table of Contents</h2>
        <ul></ul>
    </div>
    
        <p class="date"><strong>🗓️ 2025-08-01</strong></p>
        <h2>Day 1 - 安装 Rust 和本地开发环境</h2>
        <p>你将在本地安装 Rust 工具链（含 rustc, cargo, rustup），验证版本，并成功创建和运行第一个 Rust 程序。</p>
        <p>🔗 <a href="https://www.rust-lang.org/tools/install" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 安装 Rust</strong></p>
        <pre># macOS 和 Linux
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Windows (在 PowerShell 中运行)
# 访问 https://rustup.rs/ 下载 rustup-init.exe</pre>

        <p><strong>步骤 2: 配置环境变量</strong></p>
        <pre># 添加到 shell 配置文件 (~/.bashrc, ~/.zshrc 等)
source ~/.cargo/env

# 验证安装
rustc --version
cargo --version
rustup --version</pre>

        <p><strong>步骤 3: 创建第一个项目</strong></p>
        <pre># 创建新项目
cargo new day01_hello_rust
cd day01_hello_rust

# 查看项目结构
tree . # 或使用 ls -la</pre>

        <p><strong>步骤 4: 编写和运行代码</strong></p>
        <pre>📁 项目结构：
day01_hello_rust/
├── src/
│   └── main.rs     # 主要源代码文件
├── Cargo.toml      # 项目配置和依赖管理
└── .gitignore      # Git 忽略文件</pre>

        <p><strong>main.rs 示例代码：</strong></p>
        <pre>fn main() {
    println!("Hello, Rust World!");
    println!("Welcome to the 31-day Rust WebSocket journey!");
    
    // 显示一些系统信息
    println!("Rust version: {}", env!("RUSTC_VERSION"));
    println!("Build target: {}", env!("TARGET"));
}</pre>

        <p><strong>Cargo.toml 配置：</strong></p>
        <pre>[package]
name = "day01_hello_rust"
version = "0.1.0"
edition = "2021"

[dependencies]
# 今天不需要外部依赖</pre>

        <p><strong>步骤 5: 编译和运行</strong></p>
        <pre># 运行项目（自动编译）
cargo run

# 仅编译（不运行）
cargo build

# 发布模式编译（优化）
cargo build --release

# 检查代码（快速语法检查）
cargo check</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>修改 main.rs，添加你的名字和学习目标</li>
            <li>尝试使用 `cargo run --verbose` 查看详细编译过程</li>
            <li>创建一个计算器函数，进行简单的加减乘除运算</li>
        </ul>

        <p><strong>扩展练习代码：</strong></p>
        <pre>fn main() {
    println!("=== Day 1: Rust Environment Setup ===");
    
    // 基本计算器
    let a = 10;
    let b = 3;
    
    println!("数字 {} 和 {} 的运算结果：", a, b);
    println!("加法: {} + {} = {}", a, b, add(a, b));
    println!("减法: {} - {} = {}", a, b, subtract(a, b));
    println!("乘法: {} × {} = {}", a, b, multiply(a, b));
    println!("除法: {} ÷ {} = {:.2}", a, b, divide(a, b));
}

fn add(x: i32, y: i32) -> i32 {
    x + y
}

fn subtract(x: i32, y: i32) -> i32 {
    x - y
}

fn multiply(x: i32, y: i32) -> i32 {
    x * y
}

fn divide(x: i32, y: i32) -> f64 {
    x as f64 / y as f64
}</pre>
    
        <p class="date"><strong>🗓️ 2025-08-02</strong></p>
        <h2>Day 2 - 变量、类型与基本函数</h2>
        <p>你将学会使用 `let`、`mut` 声明变量，区分基本数据类型（整数、浮点、布尔、字符串等），并写出带参数和返回值的函数。</p>
        <p>🔗 <a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目</strong></p>
        <pre>cargo new day02_variables_types
cd day02_variables_types</pre>

        <p><strong>步骤 2: 理解变量声明</strong></p>
        <pre>fn main() {
    // 不可变变量（默认）
    let x = 5;
    println!("x 的值是: {}", x);
    
    // x = 6; // 这行会编译错误！
    
    // 可变变量
    let mut y = 10;
    println!("y 的初始值: {}", y);
    y = 15; // 可以修改
    println!("y 的新值: {}", y);
    
    // 变量遮蔽（shadowing）
    let z = 5;
    let z = z + 1; // 创建新变量，遮蔽旧的
    let z = z * 2;
    println!("z 的最终值: {}", z); // 输出 12
}</pre>

        <p><strong>步骤 3: 基本数据类型实践</strong></p>
        <pre>fn main() {
    println!("=== Rust 基本数据类型 ===");
    
    // 整数类型
    let small_int: i8 = 127;           // 8位有符号整数
    let big_int: i64 = 9223372036854775807; // 64位有符号整数
    let unsigned: u32 = 4294967295;    // 32位无符号整数
    
    println!("小整数: {}, 大整数: {}, 无符号: {}", small_int, big_int, unsigned);
    
    // 浮点类型
    let float32: f32 = 3.14159;
    let float64: f64 = 2.718281828459045;
    
    println!("32位浮点: {:.3}, 64位浮点: {:.6}", float32, float64);
    
    // 布尔类型
    let is_rust_awesome: bool = true;
    let is_learning_hard: bool = false;
    
    println!("Rust很棒吗? {}, 学习困难吗? {}", is_rust_awesome, is_learning_hard);
    
    // 字符类型（注意单引号）
    let heart_emoji: char = '❤';
    let letter: char = 'R';
    
    println!("字符: {} {}", heart_emoji, letter);
    
    // 字符串类型
    let greeting: &str = "Hello, Rust!";      // 字符串切片
    let owned_string: String = String::from("我在学习 Rust"); // 拥有所有权的字符串
    
    println!("字符串切片: {}", greeting);
    println!("String 类型: {}", owned_string);
}</pre>

        <p><strong>步骤 4: 函数定义与调用</strong></p>
        <pre>fn main() {
    println!("=== 函数练习 ===");
    
    // 调用无参数函数
    say_hello();
    
    // 调用带参数函数
    greet_user("张三");
    greet_user_with_age("李四", 25);
    
    // 调用有返回值的函数
    let sum = add_numbers(10, 20);
    println!("10 + 20 = {}", sum);
    
    let area = calculate_circle_area(5.0);
    println!("半径为5的圆面积: {:.2}", area);
    
    // 使用表达式返回值的函数
    let max = find_maximum(15, 8);
    println!("15 和 8 的最大值: {}", max);
}

// 无参数，无返回值
fn say_hello() {
    println!("你好，世界！");
}

// 带参数，无返回值
fn greet_user(name: &str) {
    println!("欢迎你，{}！", name);
}

fn greet_user_with_age(name: &str, age: u32) {
    println!("你好 {}，你今年 {} 岁了", name, age);
}

// 带参数，有返回值
fn add_numbers(a: i32, b: i32) -> i32 {
    return a + b; // 显式返回
}

fn calculate_circle_area(radius: f64) -> f64 {
    3.14159 * radius * radius // 表达式返回（无分号）
}

// 更复杂的函数示例
fn find_maximum(a: i32, b: i32) -> i32 {
    if a > b {
        a // 返回 a
    } else {
        b // 返回 b
    }
}</pre>

        <p><strong>步骤 5: 类型推断与显式标注</strong></p>
        <pre>fn main() {
    // Rust 的类型推断很强大
    let auto_int = 42;          // 自动推断为 i32
    let auto_float = 3.14;      // 自动推断为 f64
    let auto_string = "hello";  // 自动推断为 &str
    
    // 有时需要显式标注
    let parsed_number: i32 = "42".parse().expect("不是有效数字");
    let bytes: Vec<u8> = vec![1, 2, 3, 4, 5];
    
    println!("解析的数字: {}", parsed_number);
    println!("字节数组: {:?}", bytes);
    
    // 类型别名
    type UserId = u64;
    type UserName = String;
    
    let user_id: UserId = 12345;
    let user_name: UserName = String::from("Rust学习者");
    
    println!("用户ID: {}, 用户名: {}", user_id, user_name);
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>创建一个函数，计算两个数的平均值</li>
            <li>编写一个函数，判断一个数是否为偶数</li>
            <li>实现一个简单的BMI计算器函数</li>
            <li>尝试不同的数值类型转换</li>
        </ul>

        <p><strong>综合练习代码：</strong></p>
        <pre>fn main() {
    println!("=== Day 2 综合练习 ===");
    
    // BMI 计算器
    let height = 1.75; // 米
    let weight = 70.0; // 公斤
    let bmi = calculate_bmi(weight, height);
    println!("身高 {}m，体重 {}kg，BMI: {:.1}", height, weight, bmi);
    
    // 偶数检查
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    for num in numbers {
        if is_even(num) {
            println!("{} 是偶数", num);
        } else {
            println!("{} 是奇数", num);
        }
    }
    
    // 平均值计算
    let avg = average(85.5, 92.0);
    println!("两次考试成绩的平均分: {:.1}", avg);
    
    // 类型转换示例
    let int_val = 42i32;
    let float_val = int_val as f64;
    let back_to_int = float_val as i32;
    
    println!("整数: {} -> 浮点: {} -> 整数: {}", int_val, float_val, back_to_int);
}

fn calculate_bmi(weight: f64, height: f64) -> f64 {
    weight / (height * height)
}

fn is_even(number: i32) -> bool {
    number % 2 == 0
}

fn average(a: f64, b: f64) -> f64 {
    (a + b) / 2.0
}

// 温度转换函数
fn celsius_to_fahrenheit(celsius: f64) -> f64 {
    celsius * 9.0 / 5.0 + 32.0
}

fn fahrenheit_to_celsius(fahrenheit: f64) -> f64 {
    (fahrenheit - 32.0) * 5.0 / 9.0
}</pre>

        <pre>📁 项目结构：
day02_variables_types/
├── src/
│   └── main.rs
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-03</strong></p>
        <h2>Day 3 - 控制流：if、loop 与 match</h2>
        <p>你将能根据条件执行不同代码，用 loop/while 重复执行任务，并使用 `match` 替代嵌套的 if 判断。</p>
        <p>🔗 <a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目</strong></p>
        <pre>cargo new day03_control_flow
cd day03_control_flow</pre>

        <p><strong>步骤 2: if 条件语句</strong></p>
        <pre>fn main() {
    println!("=== if 条件语句练习 ===");
    
    let number = 42;
    
    // 基本 if 语句
    if number > 0 {
        println!("{} 是正数", number);
    }
    
    // if-else 语句
    if number % 2 == 0 {
        println!("{} 是偶数", number);
    } else {
        println!("{} 是奇数", number);
    }
    
    // if-else if-else 链
    let temperature = 25;
    if temperature > 30 {
        println!("天气很热！");
    } else if temperature > 20 {
        println!("天气刚好");
    } else if temperature > 10 {
        println!("有点凉");
    } else {
        println!("很冷！");
    }
    
    // if 表达式（可以返回值）
    let condition = true;
    let result = if condition {
        "条件为真"
    } else {
        "条件为假"
    };
    println!("结果: {}", result);
    
    // 更复杂的条件判断
    let age = 18;
    let has_license = true;
    
    if age >= 18 && has_license {
        println!("可以开车");
    } else if age >= 18 {
        println!("已成年但没有驾照");
    } else {
        println!("未成年，不能开车");
    }
}</pre>

        <p><strong>步骤 3: 循环语句 - loop, while, for</strong></p>
        <pre>fn main() {
    println!("=== 循环语句练习 ===");
    
    // 1. loop 无限循环（需要手动 break）
    println!("--- loop 循环 ---");
    let mut counter = 0;
    loop {
        counter += 1;
        println!("循环第 {} 次", counter);
        
        if counter == 3 {
            break; // 跳出循环
        }
    }
    
    // loop 可以返回值
    let mut multiply = 1;
    let result = loop {
        multiply *= 2;
        if multiply > 10 {
            break multiply; // 返回 multiply 的值
        }
    };
    println!("loop 返回值: {}", result);
    
    // 2. while 条件循环
    println!("--- while 循环 ---");
    let mut number = 3;
    while number != 0 {
        println!("倒计时: {}", number);
        number -= 1;
    }
    println!("发射！");
    
    // 3. for 循环
    println!("--- for 循环 ---");
    
    // 遍历数组
    let numbers = [1, 2, 3, 4, 5];
    for num in numbers {
        println!("数字: {}", num);
    }
    
    // 使用范围
    for i in 1..=5 {  // 1 到 5（包含5）
        println!("范围循环: {}", i);
    }
    
    // 倒序循环
    for i in (1..4).rev() {
        println!("倒序: {}", i);
    }
    
    // 带索引的循环
    let fruits = ["苹果", "香蕉", "橙子"];
    for (index, fruit) in fruits.iter().enumerate() {
        println!("第{}个水果: {}", index + 1, fruit);
    }
}</pre>

        <p><strong>步骤 4: match 模式匹配</strong></p>
        <pre>fn main() {
    println!("=== match 模式匹配练习 ===");
    
    // 基本 match 用法
    let number = 3;
    match number {
        1 => println!("一"),
        2 => println!("二"),
        3 => println!("三"),
        4 => println!("四"),
        5 => println!("五"),
        _ => println!("其他数字"), // _ 是通配符，匹配所有其他情况
    }
    
    // match 匹配范围
    let score = 85;
    match score {
        90..=100 => println!("优秀"),
        80..=89 => println!("良好"),
        70..=79 => println!("一般"),
        60..=69 => println!("及格"),
        _ => println!("不及格"),
    }
    
    // match 表达式（返回值）
    let grade = match score {
        90..=100 => 'A',
        80..=89 => 'B',
        70..=79 => 'C',
        60..=69 => 'D',
        _ => 'F',
    };
    println!("成绩等级: {}", grade);
    
    // 匹配多个值
    let day = 3;
    match day {
        1 | 2 | 3 | 4 | 5 => println!("工作日"),
        6 | 7 => println!("周末"),
        _ => println!("无效的日期"),
    }
    
    // 匹配条件（守卫）
    let number = Some(4);
    match number {
        Some(x) if x < 5 => println!("小于5的数: {}", x),
        Some(x) => println!("大于等于5的数: {}", x),
        None => println!("没有数字"),
    }
}</pre>

        <p><strong>步骤 5: 嵌套循环和标签</strong></p>
        <pre>fn main() {
    println!("=== 嵌套循环和标签 ===");
    
    // 嵌套循环
    for i in 1..=3 {
        for j in 1..=3 {
            println!("i={}, j={}", i, j);
        }
    }
    
    // 使用标签控制外层循环
    'outer: for i in 1..=3 {
        for j in 1..=3 {
            if i == 2 && j == 2 {
                println!("在 i={}, j={} 时跳出外层循环", i, j);
                break 'outer; // 跳出外层循环
            }
            println!("i={}, j={}", i, j);
        }
    }
    
    // continue 跳过本次循环
    println!("跳过偶数:");
    for i in 1..=10 {
        if i % 2 == 0 {
            continue; // 跳过偶数
        }
        println!("奇数: {}", i);
    }
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>编写一个猜数字游戏（使用 loop 和 match）</li>
            <li>实现一个简单的计算器，根据操作符执行不同运算</li>
            <li>创建一个九九乘法表</li>
            <li>编写一个函数判断年份是否为闰年</li>
        </ul>

        <p><strong>综合练习代码：</strong></p>
        <pre>fn main() {
    println!("=== Day 3 综合练习 ===");
    
    // 1. 简单计算器
    let a = 10;
    let b = 3;
    let operator = '+';
    
    let result = calculate(a, b, operator);
    println!("{} {} {} = {}", a, operator, b, result);
    
    // 2. 年份判断
    let years = [2020, 2021, 2022, 2023, 2024];
    for year in years {
        if is_leap_year(year) {
            println!("{} 是闰年", year);
        } else {
            println!("{} 不是闰年", year);
        }
    }
    
    // 3. 九九乘法表
    println!("九九乘法表:");
    print_multiplication_table();
    
    // 4. 数字分类
    let numbers = [1, 4, 9, 16, 25, 30, 36, 49, 64, 81, 100];
    for num in numbers {
        classify_number(num);
    }
}

fn calculate(a: i32, b: i32, op: char) -> i32 {
    match op {
        '+' => a + b,
        '-' => a - b,
        '*' => a * b,
        '/' => {
            if b != 0 {
                a / b
            } else {
                println!("错误：除零操作");
                0
            }
        }
        _ => {
            println!("不支持的操作符: {}", op);
            0
        }
    }
}

fn is_leap_year(year: i32) -> bool {
    if year % 400 == 0 {
        true
    } else if year % 100 == 0 {
        false
    } else if year % 4 == 0 {
        true
    } else {
        false
    }
}

fn print_multiplication_table() {
    for i in 1..=9 {
        for j in 1..=i {
            print!("{}×{}={:2} ", j, i, i * j);
        }
        println!(); // 换行
    }
}

fn classify_number(num: i32) {
    let sqrt_num = (num as f64).sqrt() as i32;
    
    match num {
        n if n < 0 => println!("{} 是负数", n),
        0 => println!("0 是零"),
        n if sqrt_num * sqrt_num == n => println!("{} 是完全平方数", n),
        n if n % 2 == 0 => println!("{} 是偶数", n),
        n => println!("{} 是奇数", n),
    }
}</pre>

        <p><strong>高级练习：简单猜数字游戏</strong></p>
        <pre>use std::io;

fn main() {
    println!("=== 猜数字游戏 ===");
    
    let secret_number = 42; // 在实际项目中可以用随机数
    let mut attempts = 0;
    let max_attempts = 5;
    
    println!("我想了一个1到100之间的数字，你有{}次机会猜对它！", max_attempts);
    
    loop {
        attempts += 1;
        println!("第{}次尝试，请输入你的猜测:", attempts);
        
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("读取输入失败");
        
        let guess: i32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("请输入有效的数字！");
                attempts -= 1; // 不算作有效尝试
                continue;
            }
        };
        
        match guess {
            n if n < 1 || n > 100 => {
                println!("请输入1到100之间的数字！");
                attempts -= 1;
            }
            n if n < secret_number => println!("太小了！"),
            n if n > secret_number => println!("太大了！"),
            _ => {
                println!("恭喜你！猜对了！答案就是 {}", secret_number);
                println!("你用了 {} 次尝试", attempts);
                break;
            }
        }
        
        if attempts >= max_attempts {
            println!("很遗憾，你用完了所有机会。答案是 {}", secret_number);
            break;
        }
    }
}</pre>

        <pre>📁 项目结构：
day03_control_flow/
├── src/
│   └── main.rs
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-04</strong></p>
        <h2>Day 4 - 所有权与引用：为什么 Rust 不崩溃</h2>
        <p>你将编写一个函数处理字符串参数，观察所有权移动和借用规则，并能解释为何编译器禁止重复可变借用。</p>
        <p>🔗 <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目</strong></p>
        <pre>cargo new day04_ownership
cd day04_ownership</pre>

        <p><strong>步骤 2: 理解所有权基本概念</strong></p>
        <pre>fn main() {
    println!("=== 所有权基本概念 ===");
    
    // 1. 栈上的数据（Copy 类型）
    let x = 5;
    let y = x; // 复制，x 仍然有效
    println!("x: {}, y: {}", x, y); // 都可以使用
    
    // 2. 堆上的数据（非 Copy 类型）
    let s1 = String::from("hello");
    let s2 = s1; // 移动（move），s1 不再有效
    // println!("{}", s1); // 这行会编译错误！
    println!("s2: {}", s2);
    
    // 3. 克隆数据
    let s3 = String::from("world");
    let s4 = s3.clone(); // 深拷贝
    println!("s3: {}, s4: {}", s3, s4); // 都可以使用
    
    // 4. 函数调用中的所有权
    let msg = String::from("Hello, Rust!");
    take_ownership(msg); // msg 的所有权被移动
    // println!("{}", msg); // 这行会编译错误！
    
    let num = 42;
    makes_copy(num); // 数字类型会被复制
    println!("num 仍然有效: {}", num); // 仍然可以使用
}

fn take_ownership(some_string: String) {
    println!("接收到字符串: {}", some_string);
} // some_string 离开作用域，内存被释放

fn makes_copy(some_integer: i32) {
    println!("接收到数字: {}", some_integer);
} // some_integer 离开作用域，但因为是 Copy 类型，没有特殊处理</pre>

        <p><strong>步骤 3: 引用和借用</strong></p>
        <pre>fn main() {
    println!("=== 引用和借用 ===");
    
    let s1 = String::from("hello");
    
    // 不可变引用
    let len = calculate_length(&s1); // 借用 s1
    println!("'{}' 的长度是 {}", s1, len); // s1 仍然有效
    
    // 可变引用
    let mut s2 = String::from("hello");
    change(&mut s2);
    println!("修改后: {}", s2);
    
    // 引用规则演示
    let mut s3 = String::from("hello");
    
    // 可以有多个不可变引用
    let r1 = &s3;
    let r2 = &s3;
    println!("r1: {}, r2: {}", r1, r2);
    // r1 和 r2 作用域结束
    
    // 然后可以有一个可变引用
    let r3 = &mut s3;
    r3.push_str(", world!");
    println!("r3: {}", r3);
    // 不能同时有可变和不可变引用
    
    // 悬垂引用预防
    // let reference_to_nothing = dangle(); // 这会编译错误
    let valid_string = no_dangle();
    println!("有效的字符串: {}", valid_string);
}

fn calculate_length(s: &String) -> usize {
    s.len()
} // s 离开作用域，但因为它只是引用，不会释放内存

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}

// 这个函数会产生悬垂引用，编译器会阻止
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s // 返回对即将被释放内存的引用
// }

fn no_dangle() -> String {
    let s = String::from("hello");
    s // 直接返回所有权
}</pre>

        <p><strong>步骤 4: 切片（slice）</strong></p>
        <pre>fn main() {
    println!("=== 切片练习 ===");
    
    let s = String::from("hello world");
    
    // 字符串切片
    let hello = &s[0..5];   // 或 &s[..5]
    let world = &s[6..11];  // 或 &s[6..]
    let whole = &s[..];     // 整个字符串的切片
    
    println!("原字符串: {}", s);
    println!("hello: {}, world: {}", hello, world);
    println!("整个字符串: {}", whole);
    
    // 使用切片的函数
    let first_word = first_word(&s);
    println!("第一个单词: {}", first_word);
    
    // 字符串字面量就是切片
    let s_literal = "Hello, world!"; // 类型是 &str
    let first = first_word(s_literal);
    println!("字面量的第一个单词: {}", first);
    
    // 数组切片
    let arr = [1, 2, 3, 4, 5];
    let slice = &arr[1..4];
    println!("数组切片: {:?}", slice);
    
    // 切片作为参数的优势
    let my_string = String::from("hello world");
    let word1 = first_word(&my_string[0..6]); // String 的切片
    let word2 = first_word(&my_string[..]);    // 整个 String 的切片
    let word3 = first_word("hello world");     // 字符串字面量
    
    println!("word1: {}, word2: {}, word3: {}", 
             first_word(&word1), first_word(&word2), word3);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..] // 没有空格，返回整个字符串
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>编写函数计算字符串中单词的数量（使用借用）</li>
            <li>实现一个函数交换两个字符串的内容（使用可变引用）</li>
            <li>创建一个函数返回字符串的最后一个单词</li>
            <li>编写代码演示所有权规则的各种场景</li>
        </ul>

        <p><strong>综合练习代码：</strong></p>
        <pre>fn main() {
    println!("=== Day 4 综合练习 ===");
    
    // 1. 单词计数
    let sentence = "Rust is a systems programming language";
    let word_count = count_words(sentence);
    println!("句子 '{}' 有 {} 个单词", sentence, word_count);
    
    // 2. 字符串交换
    let mut str1 = String::from("Hello");
    let mut str2 = String::from("World");
    println!("交换前: str1='{}', str2='{}'", str1, str2);
    swap_strings(&mut str1, &mut str2);
    println!("交换后: str1='{}', str2='{}'", str1, str2);
    
    // 3. 最后一个单词
    let text = "Learn Rust programming language";
    let last = last_word(text);
    println!("'{}' 的最后一个单词是: '{}'", text, last);
    
    // 4. 所有权转移演示
    let original = String::from("Original string");
    let processed = process_and_return(original);
    // println!("{}", original); // 编译错误：original 已被移动
    println!("处理后的字符串: {}", processed);
    
    // 5. 借用vs拥有所有权的对比
    let data = String::from("Some data");
    
    // 使用借用，data 仍然有效
    let length = get_length(&data);
    println!("数据 '{}' 的长度是 {}", data, length);
    
    // data 仍然可以使用
    println!("data 仍然有效: {}", data);
}

fn count_words(text: &str) -> usize {
    if text.trim().is_empty() {
        return 0;
    }
    
    text.split_whitespace().count()
}

fn swap_strings(str1: &mut String, str2: &mut String) {
    std::mem::swap(str1, str2);
}

fn last_word(text: &str) -> &str {
    let words: Vec<&str> = text.split_whitespace().collect();
    if words.is_empty() {
        ""
    } else {
        words[words.len() - 1]
    }
}

fn process_and_return(mut input: String) -> String {
    input.push_str(" - processed");
    input.to_uppercase()
}

fn get_length(s: &String) -> usize {
    s.len()
}

// 更高级的借用示例
fn advanced_borrowing_example() {
    let mut data = vec![1, 2, 3, 4, 5];
    
    // 不可变借用
    let sum = calculate_sum(&data);
    println!("数组 {:?} 的和是 {}", data, sum);
    
    // 可变借用
    modify_vec(&mut data);
    println!("修改后的数组: {:?}", data);
    
    // 切片
    let slice = &data[1..4];
    println!("切片 [1..4]: {:?}", slice);
}

fn calculate_sum(numbers: &Vec<i32>) -> i32 {
    numbers.iter().sum()
}

fn modify_vec(numbers: &mut Vec<i32>) {
    for num in numbers.iter_mut() {
        *num *= 2;
    }
}</pre>

        <pre>📁 项目结构：
day04_ownership/
├── src/
│   └── main.rs
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-05</strong></p>
        <h2>Day 5 - 结构体定义与方法添加</h2>
        <p>你将定义一个 `User` 结构体，包含用户名和登录次数，并为其添加方法如 `login()` 与 `describe()`。</p>
        <p>🔗 <a href="https://doc.rust-lang.org/book/ch05-00-structs.html" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目</strong></p>
        <pre>cargo new day05_structs
cd day05_structs</pre>

        <p><strong>步骤 2: 定义和使用结构体</strong></p>
        <pre>// 定义 User 结构体
#[derive(Debug)] // 自动实现 Debug trait，便于打印
struct User {
    username: String,
    email: String,
    login_count: u32,
    active: bool,
}

fn main() {
    println!("=== 结构体基础使用 ===");
    
    // 创建结构体实例
    let user1 = User {
        username: String::from("张三"),
        email: String::from("zhangsan@example.com"),
        login_count: 0,
        active: true,
    };
    
    println!("用户信息: {:?}", user1);
    println!("用户名: {}", user1.username);
    println!("邮箱: {}", user1.email);
    
    // 可变结构体实例
    let mut user2 = User {
        username: String::from("李四"),
        email: String::from("lisi@example.com"),
        login_count: 5,
        active: true,
    };
    
    user2.login_count += 1; // 修改字段
    println!("李四登录次数更新为: {}", user2.login_count);
    
    // 使用函数创建结构体
    let user3 = build_user(
        String::from("王五"), 
        String::from("wangwu@example.com")
    );
    println!("通过函数创建的用户: {:?}", user3);
    
    // 结构体更新语法
    let user4 = User {
        username: String::from("赵六"),
        email: String::from("zhaoliu@example.com"),
        ..user1 // 使用 user1 的其他字段值
    };
    println!("使用更新语法创建的用户: {:?}", user4);
}

fn build_user(username: String, email: String) -> User {
    User {
        username, // 字段初始化简写
        email,    // 等同于 email: email
        login_count: 0,
        active: true,
    }
}</pre>

        <p><strong>步骤 3: 为结构体添加方法</strong></p>
        <pre>#[derive(Debug)]
struct User {
    username: String,
    email: String,
    login_count: u32,
    active: bool,
}

// 实现块（impl block）
impl User {
    // 关联函数（类似静态方法）
    fn new(username: String, email: String) -> User {
        User {
            username,
            email,
            login_count: 0,
            active: true,
        }
    }
    
    // 方法（需要 self 参数）
    fn login(&mut self) {
        self.login_count += 1;
        println!("用户 {} 登录，总登录次数: {}", self.username, self.login_count);
    }
    
    fn describe(&self) -> String {
        format!("用户: {}, 邮箱: {}, 登录次数: {}, 状态: {}",
                self.username, 
                self.email, 
                self.login_count,
                if self.active { "活跃" } else { "非活跃" })
    }
    
    fn deactivate(&mut self) {
        self.active = false;
        println!("用户 {} 已被停用", self.username);
    }
    
    fn is_frequent_user(&self) -> bool {
        self.login_count > 10
    }
    
    // 消费 self 的方法
    fn delete_account(self) -> String {
        format!("用户 {} 的账户已被删除", self.username)
    }
}

fn main() {
    println!("=== 结构体方法练习 ===");
    
    // 使用关联函数创建实例
    let mut user = User::new(
        String::from("Alice"),
        String::from("alice@example.com")
    );
    
    println!("新用户: {}", user.describe());
    
    // 调用方法
    user.login();
    user.login();
    user.login();
    
    println!("用户描述: {}", user.describe());
    println!("是否为频繁用户: {}", user.is_frequent_user());
    
    // 多次登录后再检查
    for _ in 0..10 {
        user.login();
    }
    
    println!("多次登录后是否为频繁用户: {}", user.is_frequent_user());
    
    user.deactivate();
    println!("停用后的用户: {}", user.describe());
    
    // 删除账户（消费 self）
    let deletion_message = user.delete_account();
    println!("{}", deletion_message);
    // println!("{:?}", user); // 编译错误：user 已被移动
}</pre>

        <p><strong>步骤 4: 元组结构体和单元结构体</strong></p>
        <pre>fn main() {
    println!("=== 特殊类型的结构体 ===");
    
    // 元组结构体
    #[derive(Debug)]
    struct Color(i32, i32, i32); // RGB
    
    #[derive(Debug)]
    struct Point(i32, i32, i32); // 3D坐标
    
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
    
    println!("黑色: {:?}", black);
    println!("原点: {:?}", origin);
    println!("黑色的红色分量: {}", black.0);
    
    // 单元结构体（没有字段）
    #[derive(Debug)]
    struct AlwaysEqual;
    
    let subject = AlwaysEqual;
    println!("单元结构体: {:?}", subject);
    
    // 使用结构体的实际例子
    let rectangle = Rectangle { width: 30, height: 50 };
    println!("矩形: {:?}", rectangle);
    println!("矩形面积: {}", rectangle.area());
    println!("矩形周长: {}", rectangle.perimeter());
    
    let square = Rectangle::square(25);
    println!("正方形: {:?}, 面积: {}", square, square.area());
    
    // 比较矩形
    let rect1 = Rectangle { width: 10, height: 20 };
    let rect2 = Rectangle { width: 20, height: 10 };
    
    println!("rect1 能容纳 rect2 吗? {}", rect1.can_hold(rect2));
}

#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    fn perimeter(&self) -> u32 {
        2 * (self.width + self.height)
    }
    
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
    
    fn can_hold(&self, other: Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>创建一个 `Book` 结构体，包含标题、作者、页数、是否可借阅</li>
            <li>为 `Book` 添加借阅、归还、获取信息等方法</li>
            <li>实现一个 `Library` 结构体，管理多本书籍</li>
            <li>创建一个 `BankAccount` 结构体，实现存款、取款功能</li>
        </ul>

        <p><strong>综合练习代码：</strong></p>
        <pre>#[derive(Debug, Clone)]
struct Book {
    title: String,
    author: String,
    pages: u32,
    available: bool,
}

impl Book {
    fn new(title: String, author: String, pages: u32) -> Book {
        Book {
            title,
            author,
            pages,
            available: true,
        }
    }
    
    fn borrow_book(&mut self) -> Result<String, String> {
        if self.available {
            self.available = false;
            Ok(format!("成功借阅《{}》", self.title))
        } else {
            Err(format!("《{}》已被借出", self.title))
        }
    }
    
    fn return_book(&mut self) -> String {
        self.available = true;
        format!("《{}》已归还", self.title)
    }
    
    fn info(&self) -> String {
        format!("《{}》- 作者: {}, 页数: {}, 状态: {}",
                self.title,
                self.author,
                self.pages,
                if self.available { "可借" } else { "已借出" })
    }
}

#[derive(Debug)]
struct BankAccount {
    account_number: String,
    holder_name: String,
    balance: f64,
}

impl BankAccount {
    fn new(account_number: String, holder_name: String) -> BankAccount {
        BankAccount {
            account_number,
            holder_name,
            balance: 0.0,
        }
    }
    
    fn deposit(&mut self, amount: f64) -> Result<String, String> {
        if amount > 0.0 {
            self.balance += amount;
            Ok(format!("存款 {:.2} 元成功，余额: {:.2} 元", amount, self.balance))
        } else {
            Err("存款金额必须大于0".to_string())
        }
    }
    
    fn withdraw(&mut self, amount: f64) -> Result<String, String> {
        if amount <= 0.0 {
            return Err("取款金额必须大于0".to_string());
        }
        
        if amount > self.balance {
            return Err("余额不足".to_string());
        }
        
        self.balance -= amount;
        Ok(format!("取款 {:.2} 元成功，余额: {:.2} 元", amount, self.balance))
    }
    
    fn get_balance(&self) -> f64 {
        self.balance
    }
    
    fn account_info(&self) -> String {
        format!("账户: {}, 户主: {}, 余额: {:.2} 元",
                self.account_number,
                self.holder_name,
                self.balance)
    }
}

fn main() {
    println!("=== Day 5 综合练习 ===");
    
    // 图书管理系统
    println!("--- 图书管理 ---");
    let mut book1 = Book::new(
        "Rust编程语言".to_string(),
        "Steve Klabnik".to_string(),
        500
    );
    
    let mut book2 = Book::new(
        "深入理解计算机系统".to_string(),
        "Randal E. Bryant".to_string(),
        800
    );
    
    println!("{}", book1.info());
    println!("{}", book2.info());
    
    // 借阅操作
    match book1.borrow_book() {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("错误: {}", err),
    }
    
    // 再次借阅同一本书
    match book1.borrow_book() {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("错误: {}", err),
    }
    
    // 归还书籍
    println!("{}", book1.return_book());
    
    // 银行账户系统
    println!("\n--- 银行账户 ---");
    let mut account = BankAccount::new(
        "6228480000000000000".to_string(),
        "张三".to_string()
    );
    
    println!("{}", account.account_info());
    
    // 存款
    match account.deposit(1000.0) {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("错误: {}", err),
    }
    
    match account.deposit(500.0) {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("错误: {}", err),
    }
    
    // 取款
    match account.withdraw(200.0) {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("错误: {}", err),
    }
    
    // 尝试取款超过余额
    match account.withdraw(2000.0) {
        Ok(msg) => println!("{}", msg),
        Err(err) => println!("错误: {}", err),
    }
    
    println!("\n最终账户信息: {}", account.account_info());
}</pre>

        <pre>📁 项目结构：
day05_structs/
├── src/
│   └── main.rs
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-06</strong></p>
        <h2>Day 6 - 枚举与 match：处理状态或命令</h2>
        <p>你将写一个 `UserMessage` 枚举类型，用于表示文本消息、心跳、关闭连接等，并使用 `match` 分别处理这些变体。你将理解如何替代字符串类型匹配，并将代码写得更安全。</p>
        <p>🔗 <a href="https://doc.rust-lang.org/book/ch06-00-enums.html" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目</strong></p>
        <pre>cargo new day06_enums
cd day06_enums</pre>

        <p><strong>步骤 2: 基本枚举定义和使用</strong></p>
        <pre>#[derive(Debug)]
enum IpAddrKind {
    V4,
    V6,
}

#[derive(Debug)]
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

fn main() {
    println!("=== 枚举基础 ===");
    
    // 简单枚举
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
    
    println!("IPv4 类型: {:?}", four);
    println!("IPv6 类型: {:?}", six);
    
    // 带数据的枚举
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));
    
    println!("本地地址: {:?}", home);
    println!("回环地址: {:?}", loopback);
    
    // 使用函数处理枚举
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
    
    process_ip_address(home);
    process_ip_address(loopback);
}

fn route(ip_kind: IpAddrKind) {
    match ip_kind {
        IpAddrKind::V4 => println!("路由到 IPv4 地址"),
        IpAddrKind::V6 => println!("路由到 IPv6 地址"),
    }
}

fn process_ip_address(ip: IpAddr) {
    match ip {
        IpAddr::V4(a, b, c, d) => {
            println!("处理 IPv4 地址: {}.{}.{}.{}", a, b, c, d);
        }
        IpAddr::V6(addr) => {
            println!("处理 IPv6 地址: {}", addr);
        }
    }
}</pre>

        <p><strong>步骤 3: WebSocket 消息类型枚举</strong></p>
        <pre>#[derive(Debug, Clone)]
enum UserMessage {
    Text(String),
    Heartbeat,
    Close { code: u16, reason: String },
    Binary(Vec<u8>),
    Join { room: String, username: String },
    Leave { room: String },
}

#[derive(Debug)]
enum ConnectionStatus {
    Connected,
    Connecting,
    Disconnected,
    Error(String),
}

fn main() {
    println!("=== WebSocket 消息处理 ===");
    
    // 创建不同类型的消息
    let messages = vec![
        UserMessage::Text("Hello, WebSocket!".to_string()),
        UserMessage::Heartbeat,
        UserMessage::Join {
            room: "general".to_string(),
            username: "Alice".to_string(),
        },
        UserMessage::Binary(vec![0x48, 0x65, 0x6c, 0x6c, 0x6f]), // "Hello" in bytes
        UserMessage::Leave { room: "general".to_string() },
        UserMessage::Close {
            code: 1000,
            reason: "Normal closure".to_string(),
        },
    ];
    
    for message in messages {
        handle_message(message);
    }
    
    // 连接状态处理
    println!("\n=== 连接状态处理 ===");
    let statuses = vec![
        ConnectionStatus::Connecting,
        ConnectionStatus::Connected,
        ConnectionStatus::Error("Network timeout".to_string()),
        ConnectionStatus::Disconnected,
    ];
    
    for status in statuses {
        handle_connection_status(status);
    }
}

fn handle_message(msg: UserMessage) {
    match msg {
        UserMessage::Text(content) => {
            println!("📝 收到文本消息: {}", content);
            // 这里可以添加文本消息的处理逻辑
        }
        UserMessage::Heartbeat => {
            println!("💓 收到心跳包");
            // 发送心跳响应
        }
        UserMessage::Close { code, reason } => {
            println!("🔌 连接关闭 - 代码: {}, 原因: {}", code, reason);
            // 清理资源
        }
        UserMessage::Binary(data) => {
            println!("📦 收到二进制数据: {} 字节", data.len());
            // 处理二进制数据
            if let Ok(text) = String::from_utf8(data) {
                println!("    转换为文本: {}", text);
            }
        }
        UserMessage::Join { room, username } => {
            println!("🚪 用户 {} 加入房间 {}", username, room);
            // 将用户添加到房间
        }
        UserMessage::Leave { room } => {
            println!("🚪 用户离开房间 {}", room);
            // 从房间移除用户
        }
    }
}

fn handle_connection_status(status: ConnectionStatus) {
    match status {
        ConnectionStatus::Connecting => {
            println!("🔄 正在连接...");
        }
        ConnectionStatus::Connected => {
            println!("✅ 连接已建立");
        }
        ConnectionStatus::Disconnected => {
            println!("❌ 连接已断开");
        }
        ConnectionStatus::Error(err_msg) => {
            println!("⚠️ 连接错误: {}", err_msg);
            // 这里可以添加错误处理逻辑
        }
    }
}</pre>

        <p><strong>步骤 4: Option 和 Result 深入理解</strong></p>
        <pre>fn main() {
    println!("=== Option 和 Result 使用 ===");
    
    // Option 处理可能为空的值
    let numbers = vec![1, 2, 3, 4, 5];
    
    match find_number(&numbers, 3) {
        Some(index) => println!("找到数字 3 在索引 {}", index),
        None => println!("没有找到数字 3"),
    }
    
    match find_number(&numbers, 10) {
        Some(index) => println!("找到数字 10 在索引 {}", index),
        None => println!("没有找到数字 10"),
    }
    
    // Result 处理可能失败的操作
    match divide(10.0, 2.0) {
        Ok(result) => println!("10 ÷ 2 = {}", result),
        Err(err) => println!("除法错误: {}", err),
    }
    
    match divide(10.0, 0.0) {
        Ok(result) => println!("10 ÷ 0 = {}", result),
        Err(err) => println!("除法错误: {}", err),
    }
    
    // 链式调用和 ? 操作符的替代
    println!("\n=== 处理多个可能失败的操作 ===");
    
    match parse_and_double("42") {
        Ok(result) => println!("解析并翻倍结果: {}", result),
        Err(err) => println!("操作失败: {}", err),
    }
    
    match parse_and_double("abc") {
        Ok(result) => println!("解析并翻倍结果: {}", result),
        Err(err) => println!("操作失败: {}", err),
    }
    
    // Option 的常用方法
    println!("\n=== Option 的常用方法 ===");
    
    let some_value = Some(42);
    let none_value: Option<i32> = None;
    
    println!("some_value.is_some(): {}", some_value.is_some());
    println!("none_value.is_none(): {}", none_value.is_none());
    
    // unwrap_or 提供默认值
    println!("some_value.unwrap_or(0): {}", some_value.unwrap_or(0));
    println!("none_value.unwrap_or(0): {}", none_value.unwrap_or(0));
    
    // map 转换 Option 中的值
    let doubled = some_value.map(|x| x * 2);
    println!("some_value 翻倍: {:?}", doubled);
}

fn find_number(numbers: &[i32], target: i32) -> Option<usize> {
    for (index, &number) in numbers.iter().enumerate() {
        if number == target {
            return Some(index);
        }
    }
    None
}

fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("除数不能为零".to_string())
    } else {
        Ok(a / b)
    }
}

fn parse_and_double(s: &str) -> Result<i32, String> {
    match s.parse::<i32>() {
        Ok(num) => Ok(num * 2),
        Err(_) => Err(format!("无法解析 '{}' 为数字", s)),
    }
}</pre>

        <p><strong>步骤 5: 枚举的方法实现</strong></p>
        <pre>#[derive(Debug, Clone)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn process(&self) {
        match self {
            Message::Quit => {
                println!("退出应用程序");
            }
            Message::Move { x, y } => {
                println!("移动到坐标 ({}, {})", x, y);
            }
            Message::Write(text) => {
                println!("显示文本: {}", text);
            }
            Message::ChangeColor(r, g, b) => {
                println!("改变颜色为 RGB({}, {}, {})", r, g, b);
            }
        }
    }
    
    fn is_quit(&self) -> bool {
        matches!(self, Message::Quit)
    }
    
    fn get_description(&self) -> String {
        match self {
            Message::Quit => "退出消息".to_string(),
            Message::Move { .. } => "移动消息".to_string(),
            Message::Write(_) => "文本消息".to_string(),
            Message::ChangeColor(_, _, _) => "颜色变更消息".to_string(),
        }
    }
}

fn main() {
    println!("=== 枚举方法演示 ===");
    
    let messages = vec![
        Message::Move { x: 10, y: 20 },
        Message::Write("Hello, Rust!".to_string()),
        Message::ChangeColor(255, 0, 0),
        Message::Quit,
    ];
    
    for msg in &messages {
        println!("消息类型: {}", msg.get_description());
        msg.process();
        println!("是否为退出消息: {}", msg.is_quit());
        println!();
    }
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>创建一个 `OrderStatus` 枚举，表示订单的不同状态</li>
            <li>实现一个 `HttpResponse` 枚举，处理不同的HTTP响应</li>
            <li>设计一个游戏状态枚举，包含开始、游戏中、暂停、结束等状态</li>
            <li>创建一个表示不同几何形状的枚举，并计算面积</li>
        </ul>

        <p><strong>综合练习代码：</strong></p>
        <pre>#[derive(Debug, Clone)]
enum OrderStatus {
    Pending,
    Processing { estimated_time: u32 }, // 分钟
    Shipped { tracking_number: String },
    Delivered { delivery_time: String },
    Cancelled { reason: String },
}

#[derive(Debug)]
enum HttpResponse {
    Ok { body: String },
    NotFound,
    InternalServerError { message: String },
    BadRequest { error: String },
}

#[derive(Debug)]
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
    Triangle { base: f64, height: f64 },
}

impl OrderStatus {
    fn description(&self) -> String {
        match self {
            OrderStatus::Pending => "订单待处理".to_string(),
            OrderStatus::Processing { estimated_time } => {
                format!("订单处理中，预计 {} 分钟完成", estimated_time)
            }
            OrderStatus::Shipped { tracking_number } => {
                format!("订单已发货，快递单号: {}", tracking_number)
            }
            OrderStatus::Delivered { delivery_time } => {
                format!("订单已送达，送达时间: {}", delivery_time)
            }
            OrderStatus::Cancelled { reason } => {
                format!("订单已取消，原因: {}", reason)
            }
        }
    }
    
    fn is_completed(&self) -> bool {
        matches!(self, OrderStatus::Delivered { .. } | OrderStatus::Cancelled { .. })
    }
}

impl HttpResponse {
    fn status_code(&self) -> u16 {
        match self {
            HttpResponse::Ok { .. } => 200,
            HttpResponse::NotFound => 404,
            HttpResponse::InternalServerError { .. } => 500,
            HttpResponse::BadRequest { .. } => 400,
        }
    }
    
    fn handle(&self) {
        match self {
            HttpResponse::Ok { body } => {
                println!("✅ 请求成功 (200): {}", body);
            }
            HttpResponse::NotFound => {
                println!("❌ 页面未找到 (404)");
            }
            HttpResponse::InternalServerError { message } => {
                println!("💥 服务器内部错误 (500): {}", message);
            }
            HttpResponse::BadRequest { error } => {
                println!("⚠️ 请求错误 (400): {}", error);
            }
        }
    }
}

impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Circle { radius } => std::f64::consts::PI * radius * radius,
            Shape::Rectangle { width, height } => width * height,
            Shape::Triangle { base, height } => 0.5 * base * height,
        }
    }
    
    fn perimeter(&self) -> f64 {
        match self {
            Shape::Circle { radius } => 2.0 * std::f64::consts::PI * radius,
            Shape::Rectangle { width, height } => 2.0 * (width + height),
            Shape::Triangle { base, height } => {
                // 假设是等腰三角形，计算近似周长
                let side = (height * height + (base / 2.0) * (base / 2.0)).sqrt();
                base + 2.0 * side
            }
        }
    }
}

fn main() {
    println!("=== Day 6 综合练习 ===");
    
    // 订单状态管理
    println!("--- 订单状态管理 ---");
    let order_statuses = vec![
        OrderStatus::Pending,
        OrderStatus::Processing { estimated_time: 30 },
        OrderStatus::Shipped { tracking_number: "SF1234567890".to_string() },
        OrderStatus::Delivered { delivery_time: "2025-08-06 14:30".to_string() },
        OrderStatus::Cancelled { reason: "用户取消".to_string() },
    ];
    
    for status in &order_statuses {
        println!("{}", status.description());
        println!("订单是否完成: {}", status.is_completed());
        println!();
    }
    
    // HTTP 响应处理
    println!("--- HTTP 响应处理 ---");
    let responses = vec![
        HttpResponse::Ok { body: "用户数据获取成功".to_string() },
        HttpResponse::NotFound,
        HttpResponse::BadRequest { error: "缺少必要参数".to_string() },
        HttpResponse::InternalServerError { message: "数据库连接失败".to_string() },
    ];
    
    for response in &responses {
        println!("状态码: {}", response.status_code());
        response.handle();
        println!();
    }
    
    // 几何形状计算
    println!("--- 几何形状计算 ---");
    let shapes = vec![
        Shape::Circle { radius: 5.0 },
        Shape::Rectangle { width: 10.0, height: 8.0 },
        Shape::Triangle { base: 12.0, height: 9.0 },
    ];
    
    for shape in &shapes {
        println!("形状: {:?}", shape);
        println!("面积: {:.2}", shape.area());
        println!("周长: {:.2}", shape.perimeter());
        println!();
    }
}</pre>

        <pre>📁 项目结构：
day06_enums/
├── src/
│   └── main.rs
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-07</strong></p>
        <h2>Day 7 - Option 与 Result：构建安全返回值</h2>
        <p>你将写一个函数，它根据用户名返回用户结构体（使用 Option），以及一个可能失败的注册流程（返回 Result）。你将知道什么时候使用哪种类型，以及如何用 `?` 优雅地传播错误。</p>
        <p>🔗 <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目</strong></p>
        <pre>cargo new day07_option_result
cd day07_option_result</pre>

        <p><strong>步骤 2: Option 深入理解</strong></p>
        <pre>#[derive(Debug, Clone)]
struct User {
    id: u32,
    username: String,
    email: String,
    age: Option<u8>, // 年龄可能不提供
}

fn main() {
    println!("=== Option 深入使用 ===");
    
    // 创建用户数据库
    let users = vec![
        User {
            id: 1,
            username: "alice".to_string(),
            email: "alice@example.com".to_string(),
            age: Some(25),
        },
        User {
            id: 2,
            username: "bob".to_string(),
            email: "bob@example.com".to_string(),
            age: None, // 没有提供年龄
        },
        User {
            id: 3,
            username: "charlie".to_string(),
            email: "charlie@example.com".to_string(),
            age: Some(30),
        },
    ];
    
    // 根据用户名查找用户
    match find_user_by_username(&users, "alice") {
        Some(user) => {
            println!("找到用户: {:?}", user);
            display_user_age(&user);
        }
        None => println!("用户不存在"),
    }
    
    match find_user_by_username(&users, "david") {
        Some(user) => println!("找到用户: {:?}", user),
        None => println!("用户 david 不存在"),
    }
    
    // Option 的常用方法演示
    demonstrate_option_methods(&users);
}

fn find_user_by_username(users: &[User], username: &str) -> Option<&User> {
    for user in users {
        if user.username == username {
            return Some(user);
        }
    }
    None
}

fn display_user_age(user: &User) {
    match user.age {
        Some(age) => println!("用户 {} 的年龄是 {}", user.username, age),
        None => println!("用户 {} 没有提供年龄信息", user.username),
    }
}

fn demonstrate_option_methods(users: &[User]) {
    println!("\n=== Option 方法演示 ===");
    
    for user in users {
        // unwrap_or 提供默认值
        let age = user.age.unwrap_or(0);
        println!("{} 的年龄（默认0）: {}", user.username, age);
        
        // map 转换 Option 中的值
        let age_next_year = user.age.map(|a| a + 1);
        match age_next_year {
            Some(age) => println!("{} 明年 {} 岁", user.username, age),
            None => println!("{} 年龄未知，无法计算明年年龄", user.username),
        }
        
        // and_then 链式调用
        let age_category = user.age.and_then(|age| {
            if age < 18 {
                Some("未成年")
            } else if age < 60 {
                Some("成年人")
            } else {
                Some("老年人")
            }
        });
        
        if let Some(category) = age_category {
            println!("{} 属于: {}", user.username, category);
        }
        
        println!();
    }
}</pre>

        <p><strong>步骤 3: Result 错误处理</strong></p>
        <pre>#[derive(Debug)]
enum RegistrationError {
    UsernameAlreadyExists,
    InvalidEmail,
    PasswordTooShort,
    InvalidAge,
}

impl std::fmt::Display for RegistrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            RegistrationError::UsernameAlreadyExists => write!(f, "用户名已存在"),
            RegistrationError::InvalidEmail => write!(f, "邮箱格式无效"),
            RegistrationError::PasswordTooShort => write!(f, "密码长度不足"),
            RegistrationError::InvalidAge => write!(f, "年龄无效"),
        }
    }
}

#[derive(Debug)]
struct NewUser {
    username: String,
    email: String,
    password: String,
    age: u8,
}

fn main() {
    println!("=== Result 错误处理 ===");
    
    let mut existing_users = vec![
        "alice".to_string(),
        "bob".to_string(),
    ];
    
    // 成功注册
    match register_user(
        &existing_users,
        "charlie",
        "charlie@example.com",
        "secure123",
        25,
    ) {
        Ok(user) => {
            println!("注册成功: {:?}", user);
            existing_users.push(user.username);
        }
        Err(err) => println!("注册失败: {}", err),
    }
    
    // 各种失败情况
    let test_cases = vec![
        ("alice", "alice@example.com", "password123", 25), // 用户名已存在
        ("david", "invalid-email", "password123", 25),     // 邮箱无效
        ("eve", "eve@example.com", "123", 25),             // 密码太短
        ("frank", "frank@example.com", "password123", 200), // 年龄无效
    ];
    
    for (username, email, password, age) in test_cases {
        match register_user(&existing_users, username, email, password, age) {
            Ok(user) => println!("注册成功: {:?}", user),
            Err(err) => println!("注册失败 {}: {}", username, err),
        }
    }
    
    // 演示 Result 的方法
    demonstrate_result_methods();
}

fn register_user(
    existing_users: &[String],
    username: &str,
    email: &str,
    password: &str,
    age: u8,
) -> Result<NewUser, RegistrationError> {
    // 检查用户名是否已存在
    if existing_users.contains(&username.to_string()) {
        return Err(RegistrationError::UsernameAlreadyExists);
    }
    
    // 验证邮箱格式
    if !email.contains('@') || !email.contains('.') {
        return Err(RegistrationError::InvalidEmail);
    }
    
    // 验证密码长度
    if password.len() < 6 {
        return Err(RegistrationError::PasswordTooShort);
    }
    
    // 验证年龄
    if age > 150 {
        return Err(RegistrationError::InvalidAge);
    }
    
    Ok(NewUser {
        username: username.to_string(),
        email: email.to_string(),
        password: password.to_string(),
        age,
    })
}

fn demonstrate_result_methods() {
    println!("\n=== Result 方法演示 ===");
    
    let result1: Result<i32, &str> = Ok(42);
    let result2: Result<i32, &str> = Err("出错了");
    
    // unwrap_or 提供默认值
    println!("result1.unwrap_or(0): {}", result1.unwrap_or(0));
    println!("result2.unwrap_or(0): {}", result2.unwrap_or(0));
    
    // map 转换成功值
    let doubled = result1.map(|x| x * 2);
    println!("result1 翻倍: {:?}", doubled);
    
    // map_err 转换错误值
    let mapped_error = result2.map_err(|e| format!("错误: {}", e));
    println!("映射错误: {:?}", mapped_error);
}</pre>

        <p><strong>步骤 4: ? 操作符的使用</strong></p>
        <pre>use std::fs;
use std::io;

fn main() {
    println!("=== ? 操作符演示 ===");
    
    // 传统错误处理方式
    match read_file_traditional("config.txt") {
        Ok(content) => println!("文件内容（传统方式）: {}", content),
        Err(err) => println!("读取失败: {}", err),
    }
    
    // 使用 ? 操作符
    match read_file_with_question_mark("config.txt") {
        Ok(content) => println!("文件内容（? 操作符）: {}", content),
        Err(err) => println!("读取失败: {}", err),
    }
    
    // 创建一个测试文件再试试
    let _ = fs::write("test.txt", "Hello, Rust!");
    
    match read_file_with_question_mark("test.txt") {
        Ok(content) => println!("成功读取 test.txt: {}", content),
        Err(err) => println!("读取 test.txt 失败: {}", err),
    }
    
    // 演示复杂的错误传播
    match process_user_data("123", "john@example.com") {
        Ok(result) => println!("处理结果: {}", result),
        Err(err) => println!("处理失败: {}", err),
    }
    
    match process_user_data("abc", "john@example.com") {
        Ok(result) => println!("处理结果: {}", result),
        Err(err) => println!("处理失败: {}", err),
    }
}

// 传统错误处理方式
fn read_file_traditional(filename: &str) -> Result<String, io::Error> {
    match fs::read_to_string(filename) {
        Ok(content) => Ok(content),
        Err(err) => Err(err),
    }
}

// 使用 ? 操作符
fn read_file_with_question_mark(filename: &str) -> Result<String, io::Error> {
    let content = fs::read_to_string(filename)?; // 如果出错，直接返回错误
    Ok(content)
}

#[derive(Debug)]
enum ProcessError {
    ParseError(std::num::ParseIntError),
    InvalidEmail(String),
    IoError(io::Error),
}

impl From<std::num::ParseIntError> for ProcessError {
    fn from(err: std::num::ParseIntError) -> ProcessError {
        ProcessError::ParseError(err)
    }
}

impl From<io::Error> for ProcessError {
    fn from(err: io::Error) -> ProcessError {
        ProcessError::IoError(err)
    }
}

impl std::fmt::Display for ProcessError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ProcessError::ParseError(err) => write!(f, "解析错误: {}", err),
            ProcessError::InvalidEmail(email) => write!(f, "无效邮箱: {}", email),
            ProcessError::IoError(err) => write!(f, "IO错误: {}", err),
        }
    }
}

fn process_user_data(id_str: &str, email: &str) -> Result<String, ProcessError> {
    // 解析 ID
    let id: u32 = id_str.parse()?; // 使用 ? 自动转换 ParseIntError
    
    // 验证邮箱
    if !email.contains('@') {
        return Err(ProcessError::InvalidEmail(email.to_string()));
    }
    
    // 尝试读取用户配置文件
    let config = match fs::read_to_string("user_config.txt") {
        Ok(content) => content,
        Err(_) => "default config".to_string(), // 提供默认配置
    };
    
    Ok(format!("用户ID: {}, 邮箱: {}, 配置: {}", id, email, config))
}</pre>

        <p><strong>步骤 5: 组合 Option 和 Result</strong></p>
        <pre>use std::collections::HashMap;

#[derive(Debug, Clone)]
struct UserProfile {
    id: u32,
    username: String,
    email: String,
    preferences: HashMap<String, String>,
}

#[derive(Debug)]
enum UserError {
    NotFound,
    InvalidPreference(String),
    DatabaseError(String),
}

impl std::fmt::Display for UserError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            UserError::NotFound => write!(f, "用户未找到"),
            UserError::InvalidPreference(key) => write!(f, "无效的偏好设置: {}", key),
            UserError::DatabaseError(msg) => write!(f, "数据库错误: {}", msg),
        }
    }
}

struct UserService {
    users: HashMap<u32, UserProfile>,
}

impl UserService {
    fn new() -> Self {
        let mut users = HashMap::new();
        
        let mut alice_prefs = HashMap::new();
        alice_prefs.insert("theme".to_string(), "dark".to_string());
        alice_prefs.insert("language".to_string(), "zh".to_string());
        
        users.insert(1, UserProfile {
            id: 1,
            username: "alice".to_string(),
            email: "alice@example.com".to_string(),
            preferences: alice_prefs,
        });
        
        let mut bob_prefs = HashMap::new();
        bob_prefs.insert("theme".to_string(), "light".to_string());
        
        users.insert(2, UserProfile {
            id: 2,
            username: "bob".to_string(),
            email: "bob@example.com".to_string(),
            preferences: bob_prefs,
        });
        
        UserService { users }
    }
    
    // 返回 Option
    fn find_user(&self, id: u32) -> Option<&UserProfile> {
        self.users.get(&id)
    }
    
    // 返回 Result
    fn get_user(&self, id: u32) -> Result<&UserProfile, UserError> {
        self.users.get(&id).ok_or(UserError::NotFound)
    }
    
    // 组合使用：先查找用户，再获取偏好设置
    fn get_user_preference(&self, id: u32, key: &str) -> Result<String, UserError> {
        let user = self.get_user(id)?; // 如果用户不存在，直接返回错误
        
        user.preferences
            .get(key)
            .cloned()
            .ok_or_else(|| UserError::InvalidPreference(key.to_string()))
    }
    
    // 可选的偏好设置，返回 Option
    fn get_optional_preference(&self, id: u32, key: &str) -> Option<String> {
        self.find_user(id)
            .and_then(|user| user.preferences.get(key))
            .cloned()
    }
    
    // 批量获取用户偏好
    fn get_multiple_preferences(&self, id: u32, keys: &[&str]) -> Result<HashMap<String, Option<String>>, UserError> {
        let user = self.get_user(id)?;
        
        let mut result = HashMap::new();
        for &key in keys {
            let value = user.preferences.get(key).cloned();
            result.insert(key.to_string(), value);
        }
        
        Ok(result)
    }
}

fn main() {
    println!("=== Option 和 Result 组合使用 ===");
    
    let service = UserService::new();
    
    // 使用 Option 查找
    match service.find_user(1) {
        Some(user) => println!("找到用户（Option）: {}", user.username),
        None => println!("用户不存在"),
    }
    
    // 使用 Result 查找
    match service.get_user(1) {
        Ok(user) => println!("获取用户（Result）: {}", user.username),
        Err(err) => println!("获取失败: {}", err),
    }
    
    // 获取偏好设置
    match service.get_user_preference(1, "theme") {
        Ok(theme) => println!("Alice 的主题设置: {}", theme),
        Err(err) => println!("获取偏好失败: {}", err),
    }
    
    match service.get_user_preference(1, "font-size") {
        Ok(font_size) => println!("Alice 的字体大小: {}", font_size),
        Err(err) => println!("获取偏好失败: {}", err),
    }
    
    // 获取不存在用户的偏好
    match service.get_user_preference(999, "theme") {
        Ok(theme) => println!("用户999的主题: {}", theme),
        Err(err) => println!("获取失败: {}", err),
    }
    
    // 获取可选偏好设置
    if let Some(lang) = service.get_optional_preference(1, "language") {
        println!("Alice 的语言设置: {}", lang);
    } else {
        println!("Alice 没有设置语言偏好");
    }
    
    // 批量获取偏好设置
    match service.get_multiple_preferences(1, &["theme", "language", "font-size"]) {
        Ok(prefs) => {
            println!("Alice 的偏好设置:");
            for (key, value) in prefs {
                match value {
                    Some(v) => println!("  {}: {}", key, v),
                    None => println!("  {}: 未设置", key),
                }
            }
        }
        Err(err) => println!("获取偏好设置失败: {}", err),
    }
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>实现一个配置文件读取器，使用 Result 处理文件不存在、格式错误等情况</li>
            <li>创建一个用户认证系统，使用 Option 表示可选的用户信息</li>
            <li>编写一个数据验证器，组合使用多个 Result 返回的函数</li>
            <li>实现一个缓存系统，使用 Option 表示缓存命中/未命中</li>
        </ul>

        <p><strong>综合练习代码：</strong></p>
        <pre>use std::collections::HashMap;
use std::fs;

#[derive(Debug)]
enum ConfigError {
    FileNotFound,
    InvalidFormat(String),
    MissingKey(String),
}

impl std::fmt::Display for ConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ConfigError::FileNotFound => write!(f, "配置文件未找到"),
            ConfigError::InvalidFormat(msg) => write!(f, "配置格式错误: {}", msg),
            ConfigError::MissingKey(key) => write!(f, "缺少必需的配置项: {}", key),
        }
    }
}

#[derive(Debug)]
struct AppConfig {
    server_host: String,
    server_port: Option<u16>,
    database_url: String,
    debug_mode: bool,
    max_connections: Option<u32>,
}

struct ConfigLoader;

impl ConfigLoader {
    fn load_config(filename: &str) -> Result<AppConfig, ConfigError> {
        // 读取文件
        let content = fs::read_to_string(filename)
            .map_err(|_| ConfigError::FileNotFound)?;
        
        // 解析配置
        let mut config_map = HashMap::new();
        
        for line in content.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue; // 跳过空行和注释
            }
            
            let parts: Vec<&str> = line.split('=').collect();
            if parts.len() != 2 {
                return Err(ConfigError::InvalidFormat(
                    format!("无效的配置行: {}", line)
                ));
            }
            
            config_map.insert(parts[0].trim().to_string(), parts[1].trim().to_string());
        }
        
        // 构建配置对象
        let server_host = config_map
            .get("server_host")
            .ok_or_else(|| ConfigError::MissingKey("server_host".to_string()))?
            .clone();
        
        let database_url = config_map
            .get("database_url")
            .ok_or_else(|| ConfigError::MissingKey("database_url".to_string()))?
            .clone();
        
        // 可选配置项
        let server_port = config_map
            .get("server_port")
            .and_then(|s| s.parse().ok());
        
        let debug_mode = config_map
            .get("debug_mode")
            .map(|s| s.to_lowercase() == "true")
            .unwrap_or(false);
        
        let max_connections = config_map
            .get("max_connections")
            .and_then(|s| s.parse().ok());
        
        Ok(AppConfig {
            server_host,
            server_port,
            database_url,
            debug_mode,
            max_connections,
        })
    }
    
    fn get_effective_port(config: &AppConfig) -> u16 {
        config.server_port.unwrap_or(8080) // 默认端口
    }
    
    fn get_effective_max_connections(config: &AppConfig) -> u32 {
        config.max_connections.unwrap_or(100) // 默认连接数
    }
}

// 缓存系统示例
struct Cache<K, V> {
    data: HashMap<K, V>,
}

impl<K: std::hash::Hash + Eq + Clone, V: Clone> Cache<K, V> {
    fn new() -> Self {
        Cache {
            data: HashMap::new(),
        }
    }
    
    fn get(&self, key: &K) -> Option<V> {
        self.data.get(key).cloned()
    }
    
    fn set(&mut self, key: K, value: V) {
        self.data.insert(key, value);
    }
    
    fn get_or_compute<F>(&mut self, key: K, compute: F) -> V
    where
        F: FnOnce() -> V,
    {
        match self.get(&key) {
            Some(value) => {
                println!("缓存命中: {:?}", key);
                value
            }
            None => {
                println!("缓存未命中，计算新值: {:?}", key);
                let value = compute();
                self.set(key, value.clone());
                value
            }
        }
    }
}

fn main() {
    println!("=== Day 7 综合练习 ===");
    
    // 创建测试配置文件
    let config_content = r#"
# 服务器配置
server_host=localhost
server_port=3000
database_url=postgresql://localhost/myapp
debug_mode=true
max_connections=200
"#;
    
    let _ = fs::write("app.config", config_content);
    
    // 加载配置
    match ConfigLoader::load_config("app.config") {
        Ok(config) => {
            println!("配置加载成功: {:?}", config);
            println!("有效端口: {}", ConfigLoader::get_effective_port(&config));
            println!("最大连接数: {}", ConfigLoader::get_effective_max_connections(&config));
        }
        Err(err) => println!("配置加载失败: {}", err),
    }
    
    // 测试缓存系统
    println!("\n=== 缓存系统测试 ===");
    let mut cache = Cache::new();
    
    // 模拟耗时计算
    let expensive_computation = || {
        println!("执行复杂计算...");
        std::thread::sleep(std::time::Duration::from_millis(100));
        42
    };
    
    // 第一次访问 - 缓存未命中
    let result1 = cache.get_or_compute("key1", expensive_computation);
    println!("结果1: {}", result1);
    
    // 第二次访问 - 缓存命中
    let result2 = cache.get_or_compute("key1", expensive_computation);
    println!("结果2: {}", result2);
    
    // 直接获取缓存
    match cache.get(&"key1") {
        Some(value) => println!("直接从缓存获取 key1: {}", value),
        None => println!("key1 不在缓存中"),
    }
    
    match cache.get(&"nonexistent") {
        Some(value) => println!("获取到值: {}", value),
        None => println!("nonexistent 不在缓存中"),
    }
    
    // 清理测试文件
    let _ = fs::remove_file("app.config");
    let _ = fs::remove_file("test.txt");
}</pre>

        <pre>📁 项目结构：
day07_option_result/
├── src/
│   └── main.rs
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-08</strong></p>
        <h2>Day 8 - 项目模块拆分与 mod 语法</h2>
        <p>你将把程序拆分成多个文件：`main.rs`, `handlers.rs`, `models.rs`，通过 `mod`, `pub` 管理项目结构，建立模块化思维，方便后续扩展与测试。</p>
        <p>🔗 <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目</strong></p>
        <pre>cargo new day08_modules
cd day08_modules</pre>

        <p><strong>步骤 2: 理解模块系统基础</strong></p>
        <p><strong>src/main.rs - 主文件</strong></p>
        <pre>// 声明模块
mod math_utils;     // 对应 math_utils.rs 文件
mod models;         // 对应 models.rs 文件
mod handlers;       // 对应 handlers.rs 文件

// 使用模块中的项
use math_utils::{add, multiply};
use models::User;
use handlers::user_handler;

fn main() {
    println!("=== 模块系统演示 ===");
    
    // 使用数学工具模块
    let sum = add(5, 3);
    let product = multiply(4, 6);
    println!("5 + 3 = {}", sum);
    println!("4 × 6 = {}", product);
    
    // 使用模型
    let user = User::new("Alice".to_string(), "alice@example.com".to_string());
    println!("创建用户: {:?}", user);
    
    // 使用处理器
    user_handler::process_user(&user);
    user_handler::validate_user(&user);
    
    // 演示不同的导入方式
    demonstrate_import_styles();
}

fn demonstrate_import_styles() {
    println!("\n=== 不同的导入方式 ===");
    
    // 完整路径调用
    let result1 = math_utils::subtract(10, 3);
    println!("完整路径调用: 10 - 3 = {}", result1);
    
    // 使用 use 语句简化
    use math_utils::divide;
    let result2 = divide(15.0, 3.0);
    println!("use 语句简化: 15 ÷ 3 = {}", result2);
    
    // 使用别名
    use math_utils::power as pow;
    let result3 = pow(2, 8);
    println!("使用别名: 2^8 = {}", result3);
}</pre>

        <p><strong>步骤 3: 创建数学工具模块</strong></p>
        <p><strong>src/math_utils.rs</strong></p>
        <pre>// 公共函数，可以被其他模块使用
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}

pub fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

pub fn divide(a: f64, b: f64) -> f64 {
    if b != 0.0 {
        a / b
    } else {
        panic!("除数不能为零")
    }
}

pub fn power(base: i32, exp: u32) -> i32 {
    base.pow(exp)
}

// 私有函数，只能在当前模块内使用
fn private_helper() -> &'static str {
    "这是一个私有函数"
}

// 嵌套模块
pub mod advanced {
    pub fn factorial(n: u32) -> u32 {
        if n <= 1 {
            1
        } else {
            n * factorial(n - 1)
        }
    }
    
    pub fn fibonacci(n: u32) -> u32 {
        match n {
            0 => 0,
            1 => 1,
            _ => fibonacci(n - 1) + fibonacci(n - 2),
        }
    }
    
    // 使用父模块的私有函数
    pub fn test_private() -> &'static str {
        super::private_helper() // 使用 super 访问父模块
    }
}

// 公共常量
pub const PI: f64 = 3.14159265359;
pub const E: f64 = 2.71828182846;

// 公共结构体
#[derive(Debug)]
pub struct Calculator {
    pub name: String,
    version: f32, // 私有字段
}

impl Calculator {
    pub fn new(name: String) -> Self {
        Calculator {
            name,
            version: 1.0,
        }
    }
    
    pub fn get_version(&self) -> f32 {
        self.version
    }
    
    pub fn calculate(&self, op: &str, a: f64, b: f64) -> Result<f64, String> {
        match op {
            "+" => Ok(a + b),
            "-" => Ok(a - b),
            "*" => Ok(a * b),
            "/" => {
                if b != 0.0 {
                    Ok(a / b)
                } else {
                    Err("除数不能为零".to_string())
                }
            }
            _ => Err(format!("不支持的操作符: {}", op)),
        }
    }
}</pre>

        <p><strong>步骤 4: 创建数据模型模块</strong></p>
        <p><strong>src/models.rs</strong></p>
        <pre>// 导入标准库模块
use std::collections::HashMap;

// 用户模型
#[derive(Debug, Clone)]
pub struct User {
    pub id: Option<u32>,
    pub username: String,
    pub email: String,
    pub active: bool,
    metadata: HashMap<String, String>, // 私有字段
}

impl User {
    pub fn new(username: String, email: String) -> Self {
        User {
            id: None,
            username,
            email,
            active: true,
            metadata: HashMap::new(),
        }
    }
    
    pub fn with_id(mut self, id: u32) -> Self {
        self.id = Some(id);
        self
    }
    
    pub fn add_metadata(&mut self, key: String, value: String) {
        self.metadata.insert(key, value);
    }
    
    pub fn get_metadata(&self, key: &str) -> Option<&String> {
        self.metadata.get(key)
    }
    
    pub fn deactivate(&mut self) {
        self.active = false;
    }
}

// 消息模型
#[derive(Debug, Clone)]
pub struct Message {
    pub id: u32,
    pub sender_id: u32,
    pub recipient_id: Option<u32>, // None 表示广播消息
    pub content: String,
    pub timestamp: u64,
    pub message_type: MessageType,
}

#[derive(Debug, Clone)]
pub enum MessageType {
    Text,
    Image { url: String },
    File { name: String, size: u64 },
    System,
}

impl Message {
    pub fn new_text(sender_id: u32, content: String) -> Self {
        Message {
            id: generate_id(),
            sender_id,
            recipient_id: None,
            content,
            timestamp: current_timestamp(),
            message_type: MessageType::Text,
        }
    }
    
    pub fn new_private(sender_id: u32, recipient_id: u32, content: String) -> Self {
        Message {
            id: generate_id(),
            sender_id,
            recipient_id: Some(recipient_id),
            content,
            timestamp: current_timestamp(),
            message_type: MessageType::Text,
        }
    }
    
    pub fn is_private(&self) -> bool {
        self.recipient_id.is_some()
    }
}

// 聊天室模型
#[derive(Debug)]
pub struct ChatRoom {
    pub id: u32,
    pub name: String,
    pub users: Vec<User>,
    pub messages: Vec<Message>,
    pub max_users: usize,
}

impl ChatRoom {
    pub fn new(id: u32, name: String, max_users: usize) -> Self {
        ChatRoom {
            id,
            name,
            users: Vec::new(),
            messages: Vec::new(),
            max_users,
        }
    }
    
    pub fn add_user(&mut self, user: User) -> Result<(), String> {
        if self.users.len() >= self.max_users {
            return Err("聊天室已满".to_string());
        }
        
        if self.users.iter().any(|u| u.username == user.username) {
            return Err("用户名已存在".to_string());
        }
        
        self.users.push(user);
        Ok(())
    }
    
    pub fn remove_user(&mut self, username: &str) -> Option<User> {
        if let Some(pos) = self.users.iter().position(|u| u.username == username) {
            Some(self.users.remove(pos))
        } else {
            None
        }
    }
    
    pub fn add_message(&mut self, message: Message) {
        self.messages.push(message);
    }
    
    pub fn get_recent_messages(&self, count: usize) -> &[Message] {
        let start = if self.messages.len() > count {
            self.messages.len() - count
        } else {
            0
        };
        &self.messages[start..]
    }
}

// 工具函数
fn generate_id() -> u32 {
    use std::sync::atomic::{AtomicU32, Ordering};
    static COUNTER: AtomicU32 = AtomicU32::new(1);
    COUNTER.fetch_add(1, Ordering::SeqCst)
}

fn current_timestamp() -> u64 {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs()
}

// 公共枚举
#[derive(Debug, Clone)]
pub enum UserRole {
    Admin,
    Moderator,
    User,
    Guest,
}

impl UserRole {
    pub fn has_permission(&self, permission: &str) -> bool {
        match (self, permission) {
            (UserRole::Admin, _) => true,
            (UserRole::Moderator, "kick") | (UserRole::Moderator, "mute") => true,
            (UserRole::User, "send_message") => true,
            (UserRole::Guest, "read_only") => true,
            _ => false,
        }
    }
}</pre>

        <p><strong>步骤 5: 创建处理器模块</strong></p>
        <p><strong>src/handlers.rs</strong></p>
        <pre>// 导入其他模块
use crate::models::{User, Message, ChatRoom, UserRole};

// 用户处理器子模块
pub mod user_handler {
    use super::*;
    
    pub fn process_user(user: &User) {
        println!("处理用户: {}", user.username);
        
        match &user.id {
            Some(id) => println!("  用户ID: {}", id),
            None => println!("  用户ID: 未分配"),
        }
        
        println!("  邮箱: {}", user.email);
        println!("  状态: {}", if user.active { "活跃" } else { "非活跃" });
    }
    
    pub fn validate_user(user: &User) -> Result<(), String> {
        if user.username.len() < 3 {
            return Err("用户名长度不能少于3个字符".to_string());
        }
        
        if !user.email.contains('@') {
            return Err("邮箱格式无效".to_string());
        }
        
        if !user.active {
            return Err("用户账户已停用".to_string());
        }
        
        println!("✅ 用户 {} 验证通过", user.username);
        Ok(())
    }
    
    pub fn format_user_info(user: &User) -> String {
        format!(
            "用户: {} ({}), 状态: {}",
            user.username,
            user.email,
            if user.active { "活跃" } else { "非活跃" }
        )
    }
}

// 消息处理器子模块
pub mod message_handler {
    use super::*;
    
    pub fn process_message(message: &Message) {
        println!("处理消息 ID: {}", message.id);
        println!("  发送者: {}", message.sender_id);
        
        match message.recipient_id {
            Some(recipient) => println!("  接收者: {} (私信)", recipient),
            None => println!("  类型: 公开消息"),
        }
        
        println!("  内容: {}", message.content);
        println!("  时间戳: {}", message.timestamp);
    }
    
    pub fn validate_message(message: &Message) -> Result<(), String> {
        if message.content.trim().is_empty() {
            return Err("消息内容不能为空".to_string());
        }
        
        if message.content.len() > 1000 {
            return Err("消息长度不能超过1000个字符".to_string());
        }
        
        // 简单的内容过滤
        let forbidden_words = ["spam", "广告", "违规"];
        for word in &forbidden_words {
            if message.content.contains(word) {
                return Err(format!("消息包含禁止词汇: {}", word));
            }
        }
        
        Ok(())
    }
    
    pub fn format_message(message: &Message) -> String {
        let time = format_timestamp(message.timestamp);
        match message.recipient_id {
            Some(_) => format!("[{}] 私信: {}", time, message.content),
            None => format!("[{}] 公开: {}", time, message.content),
        }
    }
    
    fn format_timestamp(timestamp: u64) -> String {
        // 简化的时间格式化
        format!("时间戳:{}", timestamp)
    }
}

// 聊天室处理器子模块
pub mod room_handler {
    use super::*;
    
    pub fn setup_room(name: &str, max_users: usize) -> ChatRoom {
        let room = ChatRoom::new(generate_room_id(), name.to_string(), max_users);
        println!("创建聊天室: {} (最大用户数: {})", name, max_users);
        room
    }
    
    pub fn join_room(room: &mut ChatRoom, user: User) -> Result<(), String> {
        match room.add_user(user.clone()) {
            Ok(()) => {
                println!("用户 {} 加入聊天室 {}", user.username, room.name);
                
                // 发送系统消息
                let system_message = Message {
                    id: crate::models::generate_id(),
                    sender_id: 0, // 系统消息使用ID 0
                    recipient_id: None,
                    content: format!("{} 加入了聊天室", user.username),
                    timestamp: crate::models::current_timestamp(),
                    message_type: crate::models::MessageType::System,
                };
                room.add_message(system_message);
                
                Ok(())
            }
            Err(e) => Err(e),
        }
    }
    
    pub fn leave_room(room: &mut ChatRoom, username: &str) -> Result<(), String> {
        match room.remove_user(username) {
            Some(user) => {
                println!("用户 {} 离开聊天室 {}", user.username, room.name);
                
                // 发送系统消息
                let system_message = Message {
                    id: crate::models::generate_id(),
                    sender_id: 0,
                    recipient_id: None,
                    content: format!("{} 离开了聊天室", user.username),
                    timestamp: crate::models::current_timestamp(),
                    message_type: crate::models::MessageType::System,
                };
                room.add_message(system_message);
                
                Ok(())
            }
            None => Err(format!("用户 {} 不在聊天室中", username)),
        }
    }
    
    pub fn send_message(room: &mut ChatRoom, sender_id: u32, content: String) -> Result<(), String> {
        // 验证发送者是否在房间中
        if !room.users.iter().any(|u| u.id == Some(sender_id)) {
            return Err("发送者不在聊天室中".to_string());
        }
        
        let message = Message::new_text(sender_id, content);
        
        // 验证消息
        message_handler::validate_message(&message)?;
        
        room.add_message(message);
        println!("消息已发送到聊天室 {}", room.name);
        
        Ok(())
    }
    
    pub fn get_room_stats(room: &ChatRoom) -> String {
        format!(
            "聊天室 {}: {} 用户在线, {} 条消息, 容量 {}/{}",
            room.name,
            room.users.len(),
            room.messages.len(),
            room.users.len(),
            room.max_users
        )
    }
    
    fn generate_room_id() -> u32 {
        use std::sync::atomic::{AtomicU32, Ordering};
        static ROOM_COUNTER: AtomicU32 = AtomicU32::new(1000);
        ROOM_COUNTER.fetch_add(1, Ordering::SeqCst)
    }
}

// 权限处理器
pub mod permission_handler {
    use super::*;
    
    pub fn check_permission(role: &UserRole, action: &str) -> bool {
        let has_perm = role.has_permission(action);
        println!(
            "权限检查: {:?} 尝试执行 '{}' - {}",
            role,
            action,
            if has_perm { "允许" } else { "拒绝" }
        );
        has_perm
    }
    
    pub fn execute_with_permission<F>(
        role: &UserRole,
        action: &str,
        operation: F,
    ) -> Result<(), String>
    where
        F: FnOnce() -> Result<(), String>,
    {
        if check_permission(role, action) {
            operation()
        } else {
            Err(format!("权限不足，无法执行: {}", action))
        }
    }
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>创建一个 `config` 模块，管理应用程序配置</li>
            <li>实现一个 `database` 模块，模拟数据库操作</li>
            <li>设计一个 `utils` 模块，包含常用工具函数</li>
            <li>构建一个多层级的模块结构，体验深度嵌套模块</li>
        </ul>

        <p><strong>综合练习代码：</strong></p>
        <p><strong>更新后的 src/main.rs</strong></p>
        <pre>mod math_utils;
mod models;
mod handlers;

use math_utils::{Calculator, advanced};
use models::{User, Message, ChatRoom, UserRole};
use handlers::{user_handler, message_handler, room_handler, permission_handler};

fn main() {
    println!("=== Day 8 综合练习：模块化聊天应用 ===");
    
    // 创建用户
    let mut alice = User::new("Alice".to_string(), "alice@example.com".to_string())
        .with_id(1);
    alice.add_metadata("location".to_string(), "Beijing".to_string());
    
    let bob = User::new("Bob".to_string(), "bob@example.com".to_string())
        .with_id(2);
    
    let charlie = User::new("Charlie".to_string(), "charlie@example.com".to_string())
        .with_id(3);
    
    // 用户验证
    match user_handler::validate_user(&alice) {
        Ok(()) => println!("Alice 验证成功"),
        Err(e) => println!("Alice 验证失败: {}", e),
    }
    
    // 创建聊天室
    let mut general_room = room_handler::setup_room("General", 10);
    
    // 用户加入聊天室
    let _ = room_handler::join_room(&mut general_room, alice.clone());
    let _ = room_handler::join_room(&mut general_room, bob.clone());
    let _ = room_handler::join_room(&mut general_room, charlie.clone());
    
    println!("\n{}", room_handler::get_room_stats(&general_room));
    
    // 发送消息
    let _ = room_handler::send_message(
        &mut general_room,
        1,
        "Hello everyone!".to_string(),
    );
    
    let _ = room_handler::send_message(
        &mut general_room,
        2,
        "Hi Alice! How are you?".to_string(),
    );
    
    // 显示最近消息
    println!("\n=== 最近消息 ===");
    for message in general_room.get_recent_messages(5) {
        println!("{}", message_handler::format_message(message));
    }
    
    // 权限系统演示
    println!("\n=== 权限系统演示 ===");
    let admin = UserRole::Admin;
    let user = UserRole::User;
    let guest = UserRole::Guest;
    
    // 测试不同权限
    let permissions = ["send_message", "kick", "mute", "read_only"];
    let roles = [&admin, &user, &guest];
    
    for role in &roles {
        for permission in &permissions {
            permission_handler::check_permission(role, permission);
        }
        println!();
    }
    
    // 使用数学工具模块
    println!("=== 数学工具演示 ===");
    let calc = Calculator::new("ChatRoom Calculator".to_string());
    println!("计算器: {} v{}", calc.name, calc.get_version());
    
    match calc.calculate("+", 10.0, 5.0) {
        Ok(result) => println!("10 + 5 = {}", result),
        Err(e) => println!("计算错误: {}", e),
    }
    
    // 使用嵌套模块
    println!("\n=== 高级数学函数 ===");
    println!("5! = {}", advanced::factorial(5));
    println!("fibonacci(10) = {}", advanced::fibonacci(10));
    println!("测试私有函数: {}", advanced::test_private());
    
    // 用户离开聊天室
    let _ = room_handler::leave_room(&mut general_room, "Charlie");
    
    println!("\n{}", room_handler::get_room_stats(&general_room));
}</pre>

        <pre>📁 项目结构：
day08_modules/
├── src/
│   ├── main.rs          # 主程序入口
│   ├── math_utils.rs    # 数学工具模块
│   ├── models.rs        # 数据模型模块  
│   └── handlers.rs      # 业务处理模块
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-09</strong></p>
        <h2>Day 9 - 使用 Cargo crate：引入外部库</h2>
        <p>你将通过 `Cargo.toml` 添加 `chrono`, `rand`, `serde` 等库，并写出一个读取配置、随机生成用户 ID 的例子，理解 Rust 的构建系统和依赖管理。</p>
        <p>🔗 <a href="https://doc.rust-lang.org/cargo/" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目</strong></p>
        <pre>cargo new day09_external_crates
cd day09_external_crates</pre>

        <p><strong>步骤 2: 配置依赖项</strong></p>
        <p><strong>Cargo.toml 配置</strong></p>
        <pre>[package]
name = "day09_external_crates"
version = "0.1.0"
edition = "2021"

[dependencies]
# 时间处理库
chrono = { version = "0.4", features = ["serde"] }

# 随机数生成库
rand = "0.8"

# 序列化/反序列化库
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# 配置文件处理
toml = "0.8"

# 命令行参数解析
clap = { version = "4.0", features = ["derive"] }

# UUID 生成
uuid = { version = "1.0", features = ["v4", "serde"] }

# 颜色输出
colored = "2.0"

# 错误处理
anyhow = "1.0"
thiserror = "1.0"</pre>

        <p><strong>步骤 3: 时间处理 - Chrono</strong></p>
        <pre>use chrono::{DateTime, Local, Utc, NaiveDate, Duration};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct EventLog {
    id: String,
    message: String,
    timestamp: DateTime<Utc>,
    local_time: DateTime<Local>,
}

fn main() {
    println!("=== Chrono 时间处理演示 ===");
    
    // 获取当前时间
    let now_utc = Utc::now();
    let now_local = Local::now();
    
    println!("UTC 时间: {}", now_utc.format("%Y-%m-%d %H:%M:%S"));
    println!("本地时间: {}", now_local.format("%Y-%m-%d %H:%M:%S %Z"));
    
    // 解析时间字符串
    let date_str = "2025-08-09 14:30:00";
    match NaiveDate::parse_from_str("2025-08-09", "%Y-%m-%d") {
        Ok(date) => println!("解析日期成功: {}", date),
        Err(e) => println!("解析日期失败: {}", e),
    }
    
    // 时间计算
    let future = now_utc + Duration::days(7);
    let past = now_utc - Duration::hours(24);
    
    println!("一周后: {}", future.format("%Y-%m-%d %H:%M:%S"));
    println!("24小时前: {}", past.format("%Y-%m-%d %H:%M:%S"));
    
    // 创建事件日志
    let event = EventLog {
        id: uuid::Uuid::new_v4().to_string(),
        message: "系统启动".to_string(),
        timestamp: now_utc,
        local_time: now_local,
    };
    
    // 序列化为 JSON
    match serde_json::to_string_pretty(&event) {
        Ok(json) => println!("事件日志 JSON:\n{}", json),
        Err(e) => println!("序列化失败: {}", e),
    }
    
    // 时间格式化示例
    demonstrate_time_formatting();
}</pre>

        <p><strong>步骤 4: 随机数生成 - Rand</strong></p>
        <pre>use rand::{Rng, thread_rng, seq::SliceRandom};
use rand::distributions::{Alphanumeric, Standard};
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct User {
    id: String,
    username: String,
    email: String,
    age: u8,
    balance: f64,
    preferences: HashMap<String, String>,
}

fn main() {
    println!("=== Rand 随机数生成演示 ===");
    
    let mut rng = thread_rng();
    
    // 基本随机数生成
    println!("随机整数 (1-100): {}", rng.gen_range(1..=100));
    println!("随机浮点数: {:.2}", rng.gen::<f64>());
    println!("随机布尔值: {}", rng.gen::<bool>());
    
    // 生成随机字符串
    let random_string: String = thread_rng()
        .sample_iter(&Alphanumeric)
        .take(10)
        .map(char::from)
        .collect();
    println!("随机字符串: {}", random_string);
    
    // 从数组中随机选择
    let names = ["Alice", "Bob", "Charlie", "Diana", "Eve"];
    let random_name = names.choose(&mut rng).unwrap();
    println!("随机名字: {}", random_name);
    
    // 打乱数组
    let mut numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    numbers.shuffle(&mut rng);
    println!("打乱后的数字: {:?}", numbers);
    
    // 生成随机用户
    let users = generate_random_users(5);
    println!("\n=== 生成的随机用户 ===");
    for (i, user) in users.iter().enumerate() {
        println!("用户 {}: {:?}", i + 1, user);
    }
    
    // 随机选择权重
    demonstrate_weighted_selection();
}

fn generate_random_users(count: usize) -> Vec<User> {
    let mut rng = thread_rng();
    let mut users = Vec::new();
    
    let first_names = ["Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Henry"];
    let last_names = ["Smith", "Johnson", "Brown", "Davis", "Wilson", "Miller", "Taylor"];
    let domains = ["gmail.com", "yahoo.com", "hotmail.com", "example.com"];
    
    for _ in 0..count {
        let first_name = first_names.choose(&mut rng).unwrap();
        let last_name = last_names.choose(&mut rng).unwrap();
        let domain = domains.choose(&mut rng).unwrap();
        
        let username = format!("{}{}", first_name.to_lowercase(), rng.gen_range(1..999));
        let email = format!("{}@{}", username, domain);
        
        let mut preferences = HashMap::new();
        preferences.insert("theme".to_string(), 
            if rng.gen::<bool>() { "dark" } else { "light" }.to_string());
        preferences.insert("language".to_string(),
            ["en", "zh", "es", "fr"].choose(&mut rng).unwrap().to_string());
        
        let user = User {
            id: uuid::Uuid::new_v4().to_string(),
            username,
            email,
            age: rng.gen_range(18..80),
            balance: rng.gen_range(0.0..10000.0),
            preferences,
        };
        
        users.push(user);
    }
    
    users
}

fn demonstrate_weighted_selection() {
    use rand::distributions::WeightedIndex;
    use rand::prelude::*;
    
    println!("\n=== 权重随机选择演示 ===");
    
    let choices = ["常见", "不常见", "稀有", "史诗", "传说"];
    let weights = [50, 30, 15, 4, 1]; // 权重：常见最高，传说最低
    
    let dist = WeightedIndex::new(&weights).unwrap();
    let mut rng = thread_rng();
    
    let mut results = HashMap::new();
    
    // 模拟1000次抽取
    for _ in 0..1000 {
        let choice = choices[dist.sample(&mut rng)];
        *results.entry(choice).or_insert(0) += 1;
    }
    
    println!("1000次随机抽取结果:");
    for (item, count) in &results {
        println!("  {}: {} 次 ({:.1}%)", item, count, *count as f64 / 10.0);
    }
}</pre>

        <p><strong>步骤 5: 序列化/反序列化 - Serde</strong></p>
        <pre>use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;

#[derive(Debug, Serialize, Deserialize, Clone)]
struct ServerConfig {
    host: String,
    port: u16,
    max_connections: u32,
    ssl_enabled: bool,
    database: DatabaseConfig,
    features: Vec<String>,
    settings: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct DatabaseConfig {
    url: String,
    pool_size: u32,
    timeout: u64,
}

fn main() {
    println!("=== Serde 序列化演示 ===");
    
    // 创建配置对象
    let mut settings = HashMap::new();
    settings.insert("debug".to_string(), serde_json::Value::Bool(true));
    settings.insert("log_level".to_string(), serde_json::Value::String("info".to_string()));
    settings.insert("max_file_size".to_string(), serde_json::Value::Number(serde_json::Number::from(1024)));
    
    let config = ServerConfig {
        host: "localhost".to_string(),
        port: 8080,
        max_connections: 100,
        ssl_enabled: false,
        database: DatabaseConfig {
            url: "postgresql://localhost/myapp".to_string(),
            pool_size: 10,
            timeout: 30,
        },
        features: vec![
            "websocket".to_string(),
            "cors".to_string(),
            "rate_limiting".to_string(),
        ],
        settings,
    };
    
    // 序列化为 JSON
    match serde_json::to_string_pretty(&config) {
        Ok(json) => {
            println!("配置 JSON:\n{}", json);
            
            // 保存到文件
            if let Err(e) = fs::write("server_config.json", &json) {
                println!("保存文件失败: {}", e);
            } else {
                println!("\n配置已保存到 server_config.json");
            }
        }
        Err(e) => println!("JSON 序列化失败: {}", e),
    }
    
    // 从 JSON 字符串反序列化
    let json_str = r#"{
        "host": "0.0.0.0",
        "port": 3000,
        "max_connections": 200,
        "ssl_enabled": true,
        "database": {
            "url": "postgresql://localhost/production",
            "pool_size": 20,
            "timeout": 60
        },
        "features": ["websocket", "auth", "logging"],
        "settings": {
            "debug": false,
            "log_level": "warn"
        }
    }"#;
    
    match serde_json::from_str::<ServerConfig>(json_str) {
        Ok(loaded_config) => {
            println!("\n从 JSON 加载的配置:");
            println!("{:#?}", loaded_config);
        }
        Err(e) => println!("JSON 反序列化失败: {}", e),
    }
    
    // TOML 格式演示
    demonstrate_toml_serialization(&config);
    
    // 从文件加载配置
    load_config_from_file();
}

fn demonstrate_toml_serialization(config: &ServerConfig) {
    println!("\n=== TOML 序列化演示 ===");
    
    match toml::to_string_pretty(config) {
        Ok(toml_str) => {
            println!("配置 TOML:\n{}", toml_str);
            
            // 保存 TOML 文件
            if let Err(e) = fs::write("server_config.toml", &toml_str) {
                println!("保存 TOML 文件失败: {}", e);
            }
        }
        Err(e) => println!("TOML 序列化失败: {}", e),
    }
}

fn load_config_from_file() {
    println!("\n=== 从文件加载配置 ===");
    
    // 尝试从 JSON 文件加载
    if let Ok(content) = fs::read_to_string("server_config.json") {
        match serde_json::from_str::<ServerConfig>(&content) {
            Ok(config) => {
                println!("从 JSON 文件加载成功:");
                println!("服务器: {}:{}", config.host, config.port);
                println!("数据库: {}", config.database.url);
                println!("功能: {:?}", config.features);
            }
            Err(e) => println!("JSON 文件解析失败: {}", e),
        }
    }
    
    // 尝试从 TOML 文件加载
    if let Ok(content) = fs::read_to_string("server_config.toml") {
        match toml::from_str::<ServerConfig>(&content) {
            Ok(config) => {
                println!("\n从 TOML 文件加载成功:");
                println!("最大连接数: {}", config.max_connections);
                println!("SSL 启用: {}", config.ssl_enabled);
            }
            Err(e) => println!("TOML 文件解析失败: {}", e),
        }
    }
}</pre>

        <p><strong>步骤 6: 命令行参数 - Clap</strong></p>
        <pre>use clap::{Parser, Subcommand};
use colored::*;
use anyhow::{Result, Context};

#[derive(Parser)]
#[command(name = "chatroom")]
#[command(about = "一个简单的聊天室服务器")]
#[command(version = "1.0.0")]
struct Cli {
    /// 服务器监听地址
    #[arg(short, long, default_value = "127.0.0.1")]
    host: String,
    
    /// 服务器监听端口
    #[arg(short, long, default_value_t = 8080)]
    port: u16,
    
    /// 启用调试模式
    #[arg(short, long)]
    debug: bool,
    
    /// 配置文件路径
    #[arg(short, long)]
    config: Option<String>,
    
    /// 子命令
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// 启动服务器
    Start {
        /// 最大连接数
        #[arg(long, default_value_t = 100)]
        max_connections: u32,
        
        /// 启用 SSL
        #[arg(long)]
        ssl: bool,
    },
    /// 生成配置文件
    Config {
        /// 输出文件名
        #[arg(short, long, default_value = "config.json")]
        output: String,
        
        /// 配置格式
        #[arg(short, long, default_value = "json")]
        format: String,
    },
    /// 用户管理
    User {
        /// 用户操作
        #[command(subcommand)]
        action: UserCommands,
    },
}

#[derive(Subcommand)]
enum UserCommands {
    /// 创建用户
    Create {
        /// 用户名
        username: String,
        /// 邮箱
        email: String,
    },
    /// 列出所有用户
    List,
    /// 删除用户
    Delete {
        /// 用户ID
        id: String,
    },
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    
    println!("{}", "🚀 聊天室服务器".bright_blue().bold());
    println!("主机: {}", cli.host.bright_green());
    println!("端口: {}", cli.port.to_string().bright_green());
    
    if cli.debug {
        println!("{}", "调试模式已启用".yellow());
    }
    
    if let Some(config_path) = &cli.config {
        println!("配置文件: {}", config_path.bright_cyan());
        load_custom_config(config_path)?;
    }
    
    match cli.command {
        Some(Commands::Start { max_connections, ssl }) => {
            start_server(&cli.host, cli.port, max_connections, ssl)?;
        }
        Some(Commands::Config { output, format }) => {
            generate_config_file(&output, &format)?;
        }
        Some(Commands::User { action }) => {
            handle_user_command(action)?;
        }
        None => {
            println!("{}", "使用 --help 查看可用命令".bright_yellow());
        }
    }
    
    Ok(())
}

fn start_server(host: &str, port: u16, max_connections: u32, ssl: bool) -> Result<()> {
    println!("{}", "\n🎯 启动服务器...".bright_green().bold());
    println!("地址: {}:{}", host, port);
    println!("最大连接数: {}", max_connections);
    println!("SSL: {}", if ssl { "启用".green() } else { "禁用".red() });
    
    // 模拟服务器启动
    use std::thread;
    use std::time::Duration;
    
    println!("{}", "正在初始化...".bright_blue());
    thread::sleep(Duration::from_millis(500));
    
    println!("{}", "✅ 服务器启动成功!".bright_green().bold());
    println!("监听地址: http://{}:{}", host, port);
    
    Ok(())
}

fn generate_config_file(output: &str, format: &str) -> Result<()> {
    println!("{}", "📝 生成配置文件...".bright_blue().bold());
    
    let config = ServerConfig {
        host: "0.0.0.0".to_string(),
        port: 8080,
        max_connections: 100,
        ssl_enabled: false,
        database: DatabaseConfig {
            url: "postgresql://localhost/chatroom".to_string(),
            pool_size: 10,
            timeout: 30,
        },
        features: vec!["websocket".to_string(), "cors".to_string()],
        settings: std::collections::HashMap::new(),
    };
    
    let content = match format {
        "json" => serde_json::to_string_pretty(&config)
            .context("JSON 序列化失败")?,
        "toml" => toml::to_string_pretty(&config)
            .context("TOML 序列化失败")?,
        _ => return Err(anyhow::anyhow!("不支持的格式: {}", format)),
    };
    
    std::fs::write(output, content)
        .context(format!("写入文件失败: {}", output))?;
    
    println!("{} {}", "✅ 配置文件已生成:".bright_green(), output.bright_cyan());
    
    Ok(())
}

fn handle_user_command(action: UserCommands) -> Result<()> {
    match action {
        UserCommands::Create { username, email } => {
            println!("{}", "👤 创建用户...".bright_blue().bold());
            let user_id = uuid::Uuid::new_v4().to_string();
            println!("用户名: {}", username.bright_green());
            println!("邮箱: {}", email.bright_green());
            println!("用户ID: {}", user_id.bright_cyan());
            println!("{}", "✅ 用户创建成功!".bright_green());
        }
        UserCommands::List => {
            println!("{}", "📋 用户列表:".bright_blue().bold());
            // 模拟用户列表
            let users = [
                ("alice123", "alice@example.com"),
                ("bob_smith", "bob@example.com"),
                ("charlie_dev", "charlie@example.com"),
            ];
            
            for (i, (username, email)) in users.iter().enumerate() {
                println!("{}. {} ({})", 
                    (i + 1).to_string().bright_cyan(),
                    username.bright_green(),
                    email.bright_yellow()
                );
            }
        }
        UserCommands::Delete { id } => {
            println!("{}", "🗑️  删除用户...".bright_red().bold());
            println!("用户ID: {}", id.bright_cyan());
            println!("{}", "✅ 用户已删除!".bright_green());
        }
    }
    
    Ok(())
}

fn load_custom_config(config_path: &str) -> Result<()> {
    println!("{} {}", "📖 加载配置文件:".bright_blue(), config_path.bright_cyan());
    
    let content = std::fs::read_to_string(config_path)
        .context(format!("读取配置文件失败: {}", config_path))?;
    
    // 根据文件扩展名判断格式
    if config_path.ends_with(".json") {
        let config: ServerConfig = serde_json::from_str(&content)
            .context("JSON 配置文件解析失败")?;
        println!("{}", "✅ JSON 配置加载成功!".bright_green());
        println!("数据库: {}", config.database.url.bright_cyan());
    } else if config_path.ends_with(".toml") {
        let config: ServerConfig = toml::from_str(&content)
            .context("TOML 配置文件解析失败")?;
        println!("{}", "✅ TOML 配置加载成功!".bright_green());
        println!("功能: {:?}", config.features);
    } else {
        return Err(anyhow::anyhow!("不支持的配置文件格式"));
    }
    
    Ok(())
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>创建一个日志管理系统，使用 chrono 记录时间戳</li>
            <li>实现一个数据生成器，使用 rand 生成测试数据</li>
            <li>构建一个配置管理器，支持 JSON 和 TOML 格式</li>
            <li>开发一个命令行工具，使用 clap 处理用户输入</li>
        </ul>

        <p><strong>综合练习：完整的用户管理系统</strong></p>
        <pre>// 运行示例:
// cargo run -- --host 0.0.0.0 --port 3000 start --max-connections 200 --ssl
// cargo run -- config --output my_config.toml --format toml
// cargo run -- user create "alice" "alice@example.com"
// cargo run -- user list
// cargo run -- --debug --config my_config.toml start</pre>

        <pre>📁 项目结构：
day09_external_crates/
├── src/
│   └── main.rs
├── Cargo.toml
├── server_config.json    # 生成的配置文件
├── server_config.toml    # 生成的配置文件
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-10</strong></p>
        <h2>Day 10 - 测试基础：验证代码正确性</h2>
        <p>你将为之前的结构体方法编写单元测试，学习使用 `#[test]` 和 `assert_eq!`，并使用 `cargo test` 运行测试。你还将了解如何组织集成测试。</p>
        <p>🔗 <a href="https://doc.rust-lang.org/book/ch11-00-testing.html" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目和基础代码</strong></p>
        <pre>cargo new day10_testing
cd day10_testing</pre>

        <p><strong>src/lib.rs - 创建库文件</strong></p>
        <pre>pub mod calculator;
pub mod user;
pub mod message;

// 公共库接口
pub use calculator::Calculator;
pub use user::User;
pub use message::{Message, MessageType};</pre>

        <p><strong>src/calculator.rs</strong></p>
        <pre>#[derive(Debug, PartialEq)]
pub struct Calculator {
    pub name: String,
    pub version: String,
}

impl Calculator {
    pub fn new(name: String) -> Self {
        Calculator {
            name,
            version: "1.0.0".to_string(),
        }
    }
    
    pub fn add(&self, a: f64, b: f64) -> f64 {
        a + b
    }
    
    pub fn subtract(&self, a: f64, b: f64) -> f64 {
        a - b
    }
    
    pub fn multiply(&self, a: f64, b: f64) -> f64 {
        a * b
    }
    
    pub fn divide(&self, a: f64, b: f64) -> Result<f64, String> {
        if b == 0.0 {
            Err("除数不能为零".to_string())
        } else {
            Ok(a / b)
        }
    }
    
    pub fn power(&self, base: f64, exp: f64) -> f64 {
        base.powf(exp)
    }
    
    pub fn sqrt(&self, x: f64) -> Result<f64, String> {
        if x < 0.0 {
            Err("不能计算负数的平方根".to_string())
        } else {
            Ok(x.sqrt())
        }
    }
}

// 在模块内部的测试
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_calculator_creation() {
        let calc = Calculator::new("Test Calc".to_string());
        assert_eq!(calc.name, "Test Calc");
        assert_eq!(calc.version, "1.0.0");
    }
    
    #[test]
    fn test_addition() {
        let calc = Calculator::new("Test".to_string());
        assert_eq!(calc.add(2.0, 3.0), 5.0);
        assert_eq!(calc.add(-1.0, 1.0), 0.0);
        assert_eq!(calc.add(0.0, 0.0), 0.0);
    }
    
    #[test]
    fn test_subtraction() {
        let calc = Calculator::new("Test".to_string());
        assert_eq!(calc.subtract(5.0, 3.0), 2.0);
        assert_eq!(calc.subtract(1.0, 1.0), 0.0);
        assert_eq!(calc.subtract(-2.0, -3.0), 1.0);
    }
    
    #[test]
    fn test_multiplication() {
        let calc = Calculator::new("Test".to_string());
        assert_eq!(calc.multiply(4.0, 5.0), 20.0);
        assert_eq!(calc.multiply(-2.0, 3.0), -6.0);
        assert_eq!(calc.multiply(0.0, 100.0), 0.0);
    }
    
    #[test]
    fn test_division() {
        let calc = Calculator::new("Test".to_string());
        
        // 正常除法
        assert_eq!(calc.divide(10.0, 2.0), Ok(5.0));
        assert_eq!(calc.divide(-6.0, 3.0), Ok(-2.0));
        
        // 除以零的情况
        assert!(calc.divide(5.0, 0.0).is_err());
        assert_eq!(calc.divide(5.0, 0.0), Err("除数不能为零".to_string()));
    }
    
    #[test]
    fn test_power() {
        let calc = Calculator::new("Test".to_string());
        assert_eq!(calc.power(2.0, 3.0), 8.0);
        assert_eq!(calc.power(5.0, 0.0), 1.0);
        assert!((calc.power(2.0, 0.5) - 1.4142135623730951).abs() < f64::EPSILON);
    }
    
    #[test]
    fn test_sqrt() {
        let calc = Calculator::new("Test".to_string());
        
        // 正常平方根
        assert_eq!(calc.sqrt(4.0), Ok(2.0));
        assert_eq!(calc.sqrt(9.0), Ok(3.0));
        assert_eq!(calc.sqrt(0.0), Ok(0.0));
        
        // 负数平方根
        assert!(calc.sqrt(-1.0).is_err());
        assert_eq!(calc.sqrt(-1.0), Err("不能计算负数的平方根".to_string()));
    }
    
    #[test]
    #[should_panic(expected = "assertion failed")]
    fn test_should_panic_example() {
        // 这个测试应该 panic
        assert_eq!(1, 2);
    }
    
    #[test]
    #[ignore]
    fn test_ignored() {
        // 这个测试默认会被忽略
        assert_eq!(1, 1);
    }
}</pre>

        <p><strong>src/user.rs</strong></p>
        <pre>use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub struct User {
    pub id: u32,
    pub username: String,
    pub email: String,
    pub active: bool,
    pub metadata: HashMap<String, String>,
}

impl User {
    pub fn new(id: u32, username: String, email: String) -> Result<Self, String> {
        if username.len() < 3 {
            return Err("用户名长度不能少于3个字符".to_string());
        }
        
        if !email.contains('@') {
            return Err("邮箱格式不正确".to_string());
        }
        
        Ok(User {
            id,
            username,
            email,
            active: true,
            metadata: HashMap::new(),
        })
    }
    
    pub fn deactivate(&mut self) {
        self.active = false;
    }
    
    pub fn activate(&mut self) {
        self.active = true;
    }
    
    pub fn add_metadata(&mut self, key: String, value: String) {
        self.metadata.insert(key, value);
    }
    
    pub fn get_metadata(&self, key: &str) -> Option<&String> {
        self.metadata.get(key)
    }
    
    pub fn remove_metadata(&mut self, key: &str) -> Option<String> {
        self.metadata.remove(key)
    }
    
    pub fn is_valid_email(email: &str) -> bool {
        email.contains('@') && email.contains('.') && email.len() > 5
    }
    
    pub fn update_email(&mut self, new_email: String) -> Result<(), String> {
        if !Self::is_valid_email(&new_email) {
            return Err("邮箱格式不正确".to_string());
        }
        
        self.email = new_email;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_user_creation_success() {
        let user = User::new(1, "alice".to_string(), "alice@example.com".to_string());
        assert!(user.is_ok());
        
        let user = user.unwrap();
        assert_eq!(user.id, 1);
        assert_eq!(user.username, "alice");
        assert_eq!(user.email, "alice@example.com");
        assert!(user.active);
        assert!(user.metadata.is_empty());
    }
    
    #[test]
    fn test_user_creation_invalid_username() {
        let user = User::new(1, "ab".to_string(), "test@example.com".to_string());
        assert!(user.is_err());
        assert_eq!(user.unwrap_err(), "用户名长度不能少于3个字符");
    }
    
    #[test]
    fn test_user_creation_invalid_email() {
        let user = User::new(1, "alice".to_string(), "invalid-email".to_string());
        assert!(user.is_err());
        assert_eq!(user.unwrap_err(), "邮箱格式不正确");
    }
    
    #[test]
    fn test_user_activation() {
        let mut user = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
        
        assert!(user.active);
        
        user.deactivate();
        assert!(!user.active);
        
        user.activate();
        assert!(user.active);
    }
    
    #[test]
    fn test_user_metadata() {
        let mut user = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
        
        // 添加参数
        user.add_metadata("theme".to_string(), "dark".to_string());
        user.add_metadata("language".to_string(), "zh".to_string());
        
        // 获取参数
        assert_eq!(user.get_metadata("theme"), Some(&"dark".to_string()));
        assert_eq!(user.get_metadata("language"), Some(&"zh".to_string()));
        assert_eq!(user.get_metadata("nonexistent"), None);
        
        // 删除参数
        let removed = user.remove_metadata("theme");
        assert_eq!(removed, Some("dark".to_string()));
        assert_eq!(user.get_metadata("theme"), None);
    }
    
    #[test]
    fn test_email_validation() {
        assert!(User::is_valid_email("test@example.com"));
        assert!(User::is_valid_email("user.name+tag@domain.co.uk"));
        
        assert!(!User::is_valid_email("invalid"));
        assert!(!User::is_valid_email("test@"));
        assert!(!User::is_valid_email("@example.com"));
        assert!(!User::is_valid_email("test.com"));
        assert!(!User::is_valid_email("a@b"));
    }
    
    #[test]
    fn test_email_update() {
        let mut user = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
        
        // 正常更新
        let result = user.update_email("alice.new@example.com".to_string());
        assert!(result.is_ok());
        assert_eq!(user.email, "alice.new@example.com");
        
        // 无效邮箱更新
        let result = user.update_email("invalid-email".to_string());
        assert!(result.is_err());
        assert_eq!(user.email, "alice.new@example.com"); // 邮箱不应该变化
    }
}</pre>

        <p><strong>src/message.rs</strong></p>
        <pre>use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Clone, PartialEq)]
pub enum MessageType {
    Text,
    Image { url: String },
    File { name: String, size: u64 },
    System,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Message {
    pub id: u64,
    pub sender_id: u32,
    pub content: String,
    pub message_type: MessageType,
    pub timestamp: u64,
    pub edited: bool,
}

impl Message {
    pub fn new_text(sender_id: u32, content: String) -> Result<Self, String> {
        if content.trim().is_empty() {
            return Err("消息内容不能为空".to_string());
        }
        
        if content.len() > 1000 {
            return Err("消息长度不能超过1000个字符".to_string());
        }
        
        Ok(Message {
            id: Self::generate_id(),
            sender_id,
            content,
            message_type: MessageType::Text,
            timestamp: Self::current_timestamp(),
            edited: false,
        })
    }
    
    pub fn new_image(sender_id: u32, url: String, caption: Option<String>) -> Result<Self, String> {
        if url.trim().is_empty() {
            return Err("图片URL不能为空".to_string());
        }
        
        let content = caption.unwrap_or_else(|| "[图片]".to_string());
        
        Ok(Message {
            id: Self::generate_id(),
            sender_id,
            content,
            message_type: MessageType::Image { url },
            timestamp: Self::current_timestamp(),
            edited: false,
        })
    }
    
    pub fn new_system(content: String) -> Self {
        Message {
            id: Self::generate_id(),
            sender_id: 0, // 系统消息使用ID 0
            content,
            message_type: MessageType::System,
            timestamp: Self::current_timestamp(),
            edited: false,
        }
    }
    
    pub fn edit_content(&mut self, new_content: String) -> Result<(), String> {
        if new_content.trim().is_empty() {
            return Err("消息内容不能为空".to_string());
        }
        
        if new_content.len() > 1000 {
            return Err("消息长度不能超过1000个字符".to_string());
        }
        
        self.content = new_content;
        self.edited = true;
        Ok(())
    }
    
    pub fn is_system_message(&self) -> bool {
        matches!(self.message_type, MessageType::System)
    }
    
    pub fn format_timestamp(&self) -> String {
        // 简单的时间格式化
        format!("时间戳: {}", self.timestamp)
    }
    
    fn generate_id() -> u64 {
        use std::sync::atomic::{AtomicU64, Ordering};
        static COUNTER: AtomicU64 = AtomicU64::new(1);
        COUNTER.fetch_add(1, Ordering::SeqCst)
    }
    
    fn current_timestamp() -> u64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_text_message_creation() {
        let message = Message::new_text(1, "Hello, world!".to_string());
        assert!(message.is_ok());
        
        let message = message.unwrap();
        assert_eq!(message.sender_id, 1);
        assert_eq!(message.content, "Hello, world!");
        assert_eq!(message.message_type, MessageType::Text);
        assert!(!message.edited);
        assert!(!message.is_system_message());
    }
    
    #[test]
    fn test_text_message_empty_content() {
        let message = Message::new_text(1, "".to_string());
        assert!(message.is_err());
        assert_eq!(message.unwrap_err(), "消息内容不能为空");
        
        let message = Message::new_text(1, "   ".to_string());
        assert!(message.is_err());
    }
    
    #[test]
    fn test_text_message_too_long() {
        let long_content = "a".repeat(1001);
        let message = Message::new_text(1, long_content);
        assert!(message.is_err());
        assert_eq!(message.unwrap_err(), "消息长度不能超过1000个字符");
    }
    
    #[test]
    fn test_image_message_creation() {
        let message = Message::new_image(
            1, 
            "https://example.com/image.jpg".to_string(),
            Some("美丽的风景".to_string())
        );
        assert!(message.is_ok());
        
        let message = message.unwrap();
        assert_eq!(message.content, "美丽的风景");
        assert_eq!(message.message_type, MessageType::Image { 
            url: "https://example.com/image.jpg".to_string() 
        });
    }
    
    #[test]
    fn test_image_message_without_caption() {
        let message = Message::new_image(
            1, 
            "https://example.com/image.jpg".to_string(),
            None
        );
        assert!(message.is_ok());
        
        let message = message.unwrap();
        assert_eq!(message.content, "[图片]");
    }
    
    #[test]
    fn test_image_message_empty_url() {
        let message = Message::new_image(1, "".to_string(), None);
        assert!(message.is_err());
        assert_eq!(message.unwrap_err(), "图片URL不能为空");
    }
    
    #[test]
    fn test_system_message() {
        let message = Message::new_system("用户 Alice 加入了聊天室".to_string());
        
        assert_eq!(message.sender_id, 0);
        assert_eq!(message.content, "用户 Alice 加入了聊天室");
        assert_eq!(message.message_type, MessageType::System);
        assert!(message.is_system_message());
    }
    
    #[test]
    fn test_message_editing() {
        let mut message = Message::new_text(1, "Original content".to_string()).unwrap();
        assert!(!message.edited);
        
        let result = message.edit_content("Edited content".to_string());
        assert!(result.is_ok());
        assert_eq!(message.content, "Edited content");
        assert!(message.edited);
    }
    
    #[test]
    fn test_message_editing_invalid() {
        let mut message = Message::new_text(1, "Original content".to_string()).unwrap();
        
        // 空内容
        let result = message.edit_content("".to_string());
        assert!(result.is_err());
        assert_eq!(message.content, "Original content"); // 内容不应该变化
        assert!(!message.edited);
        
        // 过长内容
        let long_content = "a".repeat(1001);
        let result = message.edit_content(long_content);
        assert!(result.is_err());
        assert_eq!(message.content, "Original content");
    }
    
    #[test]
    fn test_message_id_uniqueness() {
        let msg1 = Message::new_text(1, "Message 1".to_string()).unwrap();
        let msg2 = Message::new_text(1, "Message 2".to_string()).unwrap();
        
        assert_ne!(msg1.id, msg2.id);
    }
    
    #[test]
    fn test_message_timestamp() {
        let msg = Message::new_text(1, "Test message".to_string()).unwrap();
        
        // 时间戳应该是合理的（在当前时间附近）
        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        assert!(msg.timestamp <= current_time);
        assert!(msg.timestamp > current_time - 10); // 在10秒内
    }
}</pre>

        <p><strong>步骤 2: 集成测试</strong></p>
        <p><strong>tests/integration_test.rs</strong></p>
        <pre>use day10_testing::{Calculator, User, Message, MessageType};
use std::collections::HashMap;

#[test]
fn test_calculator_user_integration() {
    // 创建用户和计算器
    let mut user = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
    let calc = Calculator::new("Alice's Calculator".to_string());
    
    // 用户添加计算器信息到元数据
    user.add_metadata("calculator_name".to_string(), calc.name.clone());
    user.add_metadata("calculator_version".to_string(), calc.version.clone());
    
    // 验证集成
    assert_eq!(user.get_metadata("calculator_name"), Some(&calc.name));
    assert_eq!(user.get_metadata("calculator_version"), Some(&calc.version));
    
    // 模拟计算操作
    let result = calc.add(10.0, 5.0);
    assert_eq!(result, 15.0);
}

#[test]
fn test_message_system_integration() {
    // 创建用户
    let user1 = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
    let user2 = User::new(2, "bob".to_string(), "bob@example.com".to_string()).unwrap();
    
    // 创建消息
    let mut messages = Vec::new();
    
    // 系统消息
    messages.push(Message::new_system(format!("{} 加入了聊天室", user1.username)));
    messages.push(Message::new_system(format!("{} 加入了聊天室", user2.username)));
    
    // 用户消息
    messages.push(Message::new_text(user1.id, "Hello everyone!".to_string()).unwrap());
    messages.push(Message::new_text(user2.id, "Hi Alice!".to_string()).unwrap());
    
    // 验证消息系统
    assert_eq!(messages.len(), 4);
    assert!(messages[0].is_system_message());
    assert!(messages[1].is_system_message());
    assert!(!messages[2].is_system_message());
    assert!(!messages[3].is_system_message());
    
    // 验证消息内容
    assert_eq!(messages[2].sender_id, user1.id);
    assert_eq!(messages[3].sender_id, user2.id);
}

#[test]
fn test_full_chat_scenario() {
    // 完整的聊天场景测试
    let mut users = HashMap::new();
    let mut messages = Vec::new();
    
    // 创建多个用户
    let alice = User::new(1, "alice".to_string(), "alice@example.com".to_string()).unwrap();
    let bob = User::new(2, "bob".to_string(), "bob@example.com".to_string()).unwrap();
    let charlie = User::new(3, "charlie".to_string(), "charlie@example.com".to_string()).unwrap();
    
    users.insert(alice.id, alice);
    users.insert(bob.id, bob);
    users.insert(charlie.id, charlie);
    
    // 模拟聊天流程
    // 1. 用户加入
    for user in users.values() {
        messages.push(Message::new_system(format!("{} 加入了聊天室", user.username)));
    }
    
    // 2. 用户发送消息
    messages.push(Message::new_text(1, "Hello everyone!".to_string()).unwrap());
    messages.push(Message::new_text(2, "Hi Alice! How are you?".to_string()).unwrap());
    messages.push(Message::new_text(3, "Good morning!".to_string()).unwrap());
    
    // 3. 用户发送图片
    messages.push(Message::new_image(
        1, 
        "https://example.com/vacation.jpg".to_string(),
        Some("我的度假照片".to_string())
    ).unwrap());
    
    // 4. 编辑消息
    if let Some(last_text_msg) = messages.iter_mut().find(|m| m.message_type == MessageType::Text && m.sender_id == 3) {
        last_text_msg.edit_content("Good morning everyone! 🌅".to_string()).unwrap();
    }
    
    // 验证整个流程
    assert_eq!(users.len(), 3);
    assert_eq!(messages.len(), 7); // 3个系统消息 + 3个文本消息 + 1个图片消息
    
    // 验证最后一条文本消息被编辑
    let edited_msg = messages.iter().find(|m| m.edited).unwrap();
    assert_eq!(edited_msg.content, "Good morning everyone! 🌅");
    assert_eq!(edited_msg.sender_id, 3);
    
    // 验证消息类型分布
    let system_count = messages.iter().filter(|m| m.is_system_message()).count();
    let text_count = messages.iter().filter(|m| matches!(m.message_type, MessageType::Text)).count();
    let image_count = messages.iter().filter(|m| matches!(m.message_type, MessageType::Image { .. })).count();
    
    assert_eq!(system_count, 3);
    assert_eq!(text_count, 3);
    assert_eq!(image_count, 1);
}</pre>

        <p><strong>步骤 3: 性能测试和数据驱动测试</strong></p>
        <p><strong>tests/benchmark_test.rs</strong></p>
        <pre>#[cfg(test)]
mod performance_tests {
    use day10_testing::*;
    use std::time::Instant;
    
    #[test]
    fn test_calculator_performance() {
        let calc = Calculator::new("Perf Test".to_string());
        let start = Instant::now();
        
        // 执行大量计算
        for i in 0..10000 {
            let _ = calc.add(i as f64, (i + 1) as f64);
            let _ = calc.multiply(i as f64, 2.0);
        }
        
        let duration = start.elapsed();
        println!("🕰️  10000次计算操作耗时: {:?}", duration);
        
        // 确保性能在合理范围内（小于100ms）
        assert!(duration.as_millis() < 100);
    }
    
    #[test]
    fn test_message_creation_performance() {
        let start = Instant::now();
        let mut messages = Vec::new();
        
        // 创建大量消息
        for i in 0..1000 {
            let msg = Message::new_text(1, format!("消息 {}", i)).unwrap();
            messages.push(msg);
        }
        
        let duration = start.elapsed();
        println!("🕰️  1000条消息创建耗时: {:?}", duration);
        
        assert_eq!(messages.len(), 1000);
        assert!(duration.as_millis() < 100);
    }
}

// 数据驱动测试
#[cfg(test)]
mod data_driven_tests {
    use day10_testing::*;
    
    #[test]
    fn test_calculator_operations_data_driven() {
        let calc = Calculator::new("Data Test".to_string());
        
        // 测试数据集
        let test_cases = vec![
            // (a, b, expected_add, expected_multiply)
            (1.0, 2.0, 3.0, 2.0),
            (0.0, 5.0, 5.0, 0.0),
            (-3.0, 4.0, 1.0, -12.0),
            (2.5, 1.5, 4.0, 3.75),
            (100.0, -50.0, 50.0, -5000.0),
        ];
        
        for (i, (a, b, expected_add, expected_multiply)) in test_cases.iter().enumerate() {
            let add_result = calc.add(*a, *b);
            let multiply_result = calc.multiply(*a, *b);
            
            assert_eq!(add_result, *expected_add, "测试用例 {} 加法失败", i);
            assert_eq!(multiply_result, *expected_multiply, "测试用例 {} 乘法失败", i);
        }
    }
    
    #[test]
    fn test_user_validation_data_driven() {
        let test_cases = vec![
            // (id, username, email, should_succeed)
            (1, "alice", "alice@example.com", true),
            (2, "bob123", "bob@test.org", true),
            (3, "charlie_dev", "charlie.dev@company.co.uk", true),
            (4, "ab", "valid@email.com", false), // 用户名太短
            (5, "validuser", "invalid-email", false), // 邮箱无效
            (6, "u", "bad", false), // 都无效
        ];
        
        for (i, (id, username, email, should_succeed)) in test_cases.iter().enumerate() {
            let result = User::new(*id, username.to_string(), email.to_string());
            
            if *should_succeed {
                assert!(result.is_ok(), "测试用例 {} 应该成功但失败了: {:?}", i, result.err());
                let user = result.unwrap();
                assert_eq!(user.username, *username);
                assert_eq!(user.email, *email);
            } else {
                assert!(result.is_err(), "测试用例 {} 应该失败但成功了", i);
            }
        }
    }
}</pre>

        <p><strong>步骤 4: 测试工具和命令</strong></p>
        <pre># 运行所有测试
cargo test

# 运行特定测试
cargo test test_calculator

# 运行忽略的测试
cargo test -- --ignored

# 运行单个线程测试
cargo test -- --test-threads=1

# 显示测试输出
cargo test -- --nocapture

# 生成测试覆盖率报告
cargo install cargo-tarpaulin
cargo tarpaulin --out Html

# 运行性能测试
cargo test performance -- --nocapture</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>为之前的模块代码编写完整的单元测试</li>
            <li>创建集成测试验证模块间的交互</li>
            <li>编写性能测试确保代码效率</li>
            <li>使用数据驱动方法测试多种场景</li>
        </ul>

        <pre>📁 项目结构：
day10_testing/
├── src/
│   ├── lib.rs           # 库入口文件
│   ├── calculator.rs    # 计算器模块及测试
│   ├── user.rs          # 用户模块及测试
│   └── message.rs       # 消息模块及测试
├── tests/
│   ├── integration_test.rs  # 集成测试
│   └── benchmark_test.rs    # 性能测试
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-11</strong></p>
        <h2>Day 11 - 引入 tokio 并运行第一个 async 函数</h2>
        <p>你将安装 `tokio` 并写一个 `async fn` 延迟 1 秒后打印信息的例子，并了解 `.await` 的调用方式以及 `#[tokio::main]` 的作用。</p>
        <p>🔗 <a href="https://tokio.rs/tokio/tutorial" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目和配置依赖</strong></p>
        <pre>cargo new day11_async_basics
cd day11_async_basics</pre>

        <p><strong>Cargo.toml</strong></p>
        <pre>[package]
name = "day11_async_basics"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
futures = "0.3"
chrono = { version = "0.4", features = ["serde"] }
rand = "0.8"</pre>

        <p><strong>步骤 2: 基本 async/await 使用</strong></p>
        <pre>use tokio::time::{sleep, Duration, Instant};
use chrono::{DateTime, Utc};

#[tokio::main]
async fn main() {
    println!("=== Tokio Async 基础演示 ===");
    
    // 基本延迟操作
    println!("🕰️  开始时间: {}", Utc::now().format("%H:%M:%S"));
    
    simple_delay().await;
    
    println!("🕰️  结束时间: {}", Utc::now().format("%H:%M:%S"));
    
    // 演示不同的 async 函数
    demonstrate_async_functions().await;
    
    // 演示并发执行
    demonstrate_concurrency().await;
    
    // 演示错误处理
    demonstrate_error_handling().await;
}

// 简单的延迟函数
async fn simple_delay() {
    println!("😴 开始睡眠 1 秒...");
    sleep(Duration::from_secs(1)).await;
    println!("😊 睡醒了！");
}

// 返回值的 async 函数
async fn fetch_data(id: u32) -> String {
    println!("📀 正在获取数据 ID: {}", id);
    
    // 模拟网络请求延迟
    let delay = Duration::from_millis(500 + (id * 100) as u64);
    sleep(delay).await;
    
    format!("数据包 {} 的内容", id)
}

// 可能失败的 async 函数
async fn risky_operation(should_fail: bool) -> Result<String, String> {
    println!("⚠️  执行风险操作...");
    
    sleep(Duration::from_millis(300)).await;
    
    if should_fail {
        Err("操作失败！".to_string())
    } else {
        Ok("操作成功！".to_string())
    }
}

async fn demonstrate_async_functions() {
    println!("\n=== Async 函数演示 ===");
    
    // 调用带返回值的 async 函数
    let data = fetch_data(1).await;
    println!("获取到数据: {}", data);
    
    // 调用多个 async 函数（串行）
    let start = Instant::now();
    let data1 = fetch_data(2).await;
    let data2 = fetch_data(3).await;
    let duration = start.elapsed();
    
    println!("串行获取数据:");
    println!("  {}", data1);
    println!("  {}", data2);
    println!("  总耗时: {:?}", duration);
}

async fn demonstrate_concurrency() {
    println!("\n=== 并发执行演示 ===");
    
    // 使用 tokio::join! 并发执行
    let start = Instant::now();
    let (data1, data2, data3) = tokio::join!(
        fetch_data(4),
        fetch_data(5),
        fetch_data(6)
    );
    let duration = start.elapsed();
    
    println!("并发获取数据:");
    println!("  {}", data1);
    println!("  {}", data2);
    println!("  {}", data3);
    println!("  总耗时: {:?}", duration);
    
    // 使用 tokio::select! 等待第一个完成的任务
    println!("\n使用 select! 等待第一个完成的任务:");
    
    tokio::select! {
        result = fetch_data(7) => {
            println!("第一个完成的任务: {}", result);
        }
        result = fetch_data(8) => {
            println!("第一个完成的任务: {}", result);
        }
        _ = sleep(Duration::from_millis(200)) => {
            println!("超时！所有任务都太慢了");
        }
    }
}

async fn demonstrate_error_handling() {
    println!("\n=== 异步错误处理演示 ===");
    
    // 处理成功的情况
    match risky_operation(false).await {
        Ok(result) => println!("✅ {}", result),
        Err(error) => println!("❌ {}", error),
    }
    
    // 处理失败的情况
    match risky_operation(true).await {
        Ok(result) => println!("✅ {}", result),
        Err(error) => println!("❌ {}", error),
    }
    
    // 使用 ? 操作符
    if let Err(e) = handle_multiple_operations().await {
        println!("多个操作失败: {}", e);
    }
}

async fn handle_multiple_operations() -> Result<(), String> {
    // 模拟多个可能失败的操作
    let _result1 = risky_operation(false).await?;
    let _result2 = risky_operation(false).await?;
    
    println!("✅ 所有操作都成功了！");
    Ok(())
}</pre>

        <p><strong>步骤 3: 任务生成和管理</strong></p>
        <pre>use tokio::task;
use rand::Rng;

#[tokio::main]
async fn main() {
    println!("=== Tokio 任务管理演示 ===");
    
    // 生成单个任务
    demonstrate_single_task().await;
    
    // 生成多个任务
    demonstrate_multiple_tasks().await;
    
    // 任务取消
    demonstrate_task_cancellation().await;
    
    // 任务结果收集
    demonstrate_task_results().await;
}

async fn worker_task(id: u32, work_duration: u64) -> String {
    println!("👷 工作者 {} 开始工作", id);
    
    let mut rng = rand::thread_rng();
    
    // 模拟工作进度
    for i in 1..=5 {
        let step_duration = Duration::from_millis(work_duration / 5);
        sleep(step_duration).await;
        
        if rng.gen_bool(0.1) { // 10% 的几率打印进度
            println!("👷 工作者 {} 进度: {}/5", id, i);
        }
    }
    
    let result = format!("工作者 {} 完成了任务（耗时 {}ms）", id, work_duration);
    println!("✅ {}", result);
    result
}

async fn demonstrate_single_task() {
    println!("\n--- 单个任务演示 ---");
    
    // 生成一个任务
    let handle = task::spawn(worker_task(1, 1000));
    
    // 在任务运行时做其他事情
    for i in 1..=3 {
        println!("💭 主线程正在思考... {}", i);
        sleep(Duration::from_millis(300)).await;
    }
    
    // 等待任务完成
    match handle.await {
        Ok(result) => println!("任务结果: {}", result),
        Err(e) => println!("任务失败: {}", e),
    }
}

async fn demonstrate_multiple_tasks() {
    println!("\n--- 多个任务演示 ---");
    
    let start = Instant::now();
    
    // 创建多个任务
    let mut handles = Vec::new();
    
    for i in 1..=5 {
        let duration = (i * 200) as u64;
        let handle = task::spawn(worker_task(i, duration));
        handles.push(handle);
    }
    
    println!("🚀 启动了 {} 个并发任务", handles.len());
    
    // 等待所有任务完成
    let mut results = Vec::new();
    for handle in handles {
        match handle.await {
            Ok(result) => results.push(result),
            Err(e) => println!("任务失败: {}", e),
        }
    }
    
    let total_duration = start.elapsed();
    println!("\n✅ 所有任务完成，总耗时: {:?}", total_duration);
    println!("结果数量: {}", results.len());
}

async fn long_running_task(id: u32) -> Result<String, String> {
    for i in 1..=10 {
        // 检查是否被取消
        tokio::task::yield_now().await; // 让出 CPU 时间片
        
        println!("🔄 任务 {} 步骤 {}/10", id, i);
        sleep(Duration::from_millis(500)).await;
    }
    
    Ok(format!("任务 {} 正常完成", id))
}

async fn demonstrate_task_cancellation() {
    println!("\n--- 任务取消演示 ---");
    
    let handle = task::spawn(long_running_task(99));
    
    // 让任务运行一段时间
    sleep(Duration::from_millis(2000)).await;
    
    println!("⚠️  准备取消任务...");
    handle.abort();
    
    match handle.await {
        Ok(result) => println!("任务结果: {:?}", result),
        Err(e) if e.is_cancelled() => println!("✅ 任务已被成功取消"),
        Err(e) => println!("任务出错: {}", e),
    }
}

async fn demonstrate_task_results() {
    println!("\n--- 任务结果收集演示 ---");
    
    // 使用 futures::future::join_all 收集结果
    let tasks: Vec<_> = (1..=3)
        .map(|i| task::spawn(worker_task(i + 10, (i * 300) as u64)))
        .collect();
    
    // 等待所有任务完成并收集结果
    let results = futures::future::join_all(tasks).await;
    
    println!("\n收集的任务结果:");
    for (i, result) in results.into_iter().enumerate() {
        match result {
            Ok(task_result) => println!("  任务 {}: {}", i + 1, task_result),
            Err(e) => println!("  任务 {} 失败: {}", i + 1, e),
        }
    }
}</pre>

        <p><strong>步骤 4: 定时器和间隔执行</strong></p>
        <pre>use tokio::time::{interval, timeout};

#[tokio::main]
async fn main() {
    println!("=== Tokio 定时器和超时演示 ===");
    
    // 定时执行任务
    demonstrate_intervals().await;
    
    // 超时处理
    demonstrate_timeouts().await;
    
    // 组合定时器和任务
    demonstrate_timed_tasks().await;
}

async fn demonstrate_intervals() {
    println!("\n--- 间隔执行演示 ---");
    
    let mut interval = interval(Duration::from_millis(500));
    let mut counter = 0;
    
    println!("🕰️  每 500ms 执行一次，共执行 5 次:");
    
    for _ in 0..5 {
        interval.tick().await;
        counter += 1;
        println!("  • Tick {}: {}", counter, Utc::now().format("%H:%M:%S%.3f"));
    }
}

async fn slow_operation(duration_ms: u64) -> Result<String, String> {
    println!("🐌 慢操作开始（需要 {}ms）", duration_ms);
    sleep(Duration::from_millis(duration_ms)).await;
    Ok(format!("慢操作完成（耗时 {}ms）", duration_ms))
}

async fn demonstrate_timeouts() {
    println!("\n--- 超时处理演示 ---");
    
    // 成功的情况（在超时时间内完成）
    match timeout(Duration::from_millis(1000), slow_operation(500)).await {
        Ok(Ok(result)) => println!("✅ 操作成功: {}", result),
        Ok(Err(e)) => println!("❌ 操作失败: {}", e),
        Err(_) => println!("⏰ 操作超时"),
    }
    
    // 超时的情况
    match timeout(Duration::from_millis(800), slow_operation(1500)).await {
        Ok(Ok(result)) => println!("✅ 操作成功: {}", result),
        Ok(Err(e)) => println!("❌ 操作失败: {}", e),
        Err(_) => println!("⏰ 操作超时（800ms 超时限制）"),
    }
}

async fn heartbeat_task(id: u32, interval_ms: u64, max_beats: u32) {
    let mut interval = interval(Duration::from_millis(interval_ms));
    let mut count = 0;
    
    println!("💓 心跳任务 {} 开始（间隔 {}ms）", id, interval_ms);
    
    while count < max_beats {
        interval.tick().await;
        count += 1;
        println!("  💓 任务 {} 心跳 #{}", id, count);
    }
    
    println!("❤️  心跳任务 {} 完成（共 {} 次心跳）", id, count);
}

async fn demonstrate_timed_tasks() {
    println!("\n--- 定时任务组合演示 ---");
    
    // 启动多个不同间隔的心跳任务
    let heartbeat1 = task::spawn(heartbeat_task(1, 300, 8));
    let heartbeat2 = task::spawn(heartbeat_task(2, 500, 5));
    let heartbeat3 = task::spawn(heartbeat_task(3, 700, 4));
    
    // 等待所有心跳任务完成
    let _ = tokio::join!(heartbeat1, heartbeat2, heartbeat3);
    
    println!("✅ 所有心跳任务完成！");
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>创建一个异步文件下载器，模拟下载进度</li>
            <li>实现一个定时任务调度器，支持不同间隔</li>
            <li>构建一个并发网络请求处理器</li>
            <li>设计一个异步消息队列系统</li>
        </ul>

        <p><strong>综合练习：异步任务管理器</strong></p>
        <pre>use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct TaskStatus {
    id: u32,
    name: String,
    status: String,
    progress: u32,
    start_time: DateTime<Utc>,
}

struct TaskManager {
    tasks: Arc<Mutex<HashMap<u32, TaskStatus>>>,
    next_id: Arc<Mutex<u32>>,
}

impl TaskManager {
    fn new() -> Self {
        TaskManager {
            tasks: Arc::new(Mutex::new(HashMap::new())),
            next_id: Arc::new(Mutex::new(1)),
        }
    }
    
    async fn spawn_task<F, Fut>(&self, name: String, task_fn: F) -> u32 
    where
        F: FnOnce(u32) -> Fut + Send + 'static,
        Fut: std::future::Future<Output = ()> + Send,
    {
        let id = {
            let mut next_id = self.next_id.lock().await;
            let current_id = *next_id;
            *next_id += 1;
            current_id
        };
        
        let task_status = TaskStatus {
            id,
            name: name.clone(),
            status: "Running".to_string(),
            progress: 0,
            start_time: Utc::now(),
        };
        
        {
            let mut tasks = self.tasks.lock().await;
            tasks.insert(id, task_status);
        }
        
        let tasks_clone = Arc::clone(&self.tasks);
        
        tokio::spawn(async move {
            task_fn(id).await;
            
            // 更新任务状态为完成
            let mut tasks = tasks_clone.lock().await;
            if let Some(task) = tasks.get_mut(&id) {
                task.status = "Completed".to_string();
                task.progress = 100;
            }
        });
        
        id
    }
    
    async fn get_task_status(&self, id: u32) -> Option<TaskStatus> {
        let tasks = self.tasks.lock().await;
        tasks.get(&id).cloned()
    }
    
    async fn list_all_tasks(&self) -> Vec<TaskStatus> {
        let tasks = self.tasks.lock().await;
        tasks.values().cloned().collect()
    }
    
    async fn update_progress(&self, id: u32, progress: u32) {
        let mut tasks = self.tasks.lock().await;
        if let Some(task) = tasks.get_mut(&id) {
            task.progress = progress;
        }
    }
}

#[tokio::main]
async fn main() {
    println!("=== Day 11 综合练习：异步任务管理器 ===");
    
    let manager = TaskManager::new();
    
    // 启动多个任务
    let task1_id = manager.spawn_task(
        "数据处理".to_string(),
        |id| async move {
            simulate_data_processing(id).await;
        }
    ).await;
    
    let task2_id = manager.spawn_task(
        "文件下载".to_string(),
        |id| async move {
            simulate_file_download(id).await;
        }
    ).await;
    
    let task3_id = manager.spawn_task(
        "邮件发送".to_string(),
        |id| async move {
            simulate_email_sending(id).await;
        }
    ).await;
    
    println!("启动了 3 个任务: {}, {}, {}", task1_id, task2_id, task3_id);
    
    // 定期检查任务状态
    let status_checker = task::spawn(async move {
        let mut interval = interval(Duration::from_millis(1000));
        
        for _ in 0..8 {
            interval.tick().await;
            
            let tasks = manager.list_all_tasks().await;
            println!("\n✨ 任务状态更新:");
            
            for task in tasks {
                let duration = Utc::now().signed_duration_since(task.start_time);
                println!("  • 任务 {}: {} - {}% - 运行时间: {}s", 
                    task.id, 
                    task.name, 
                    task.progress,
                    duration.num_seconds()
                );
            }
        }
    });
    
    status_checker.await.unwrap();
    
    println!("\n✅ 任务管理器演示完成！");
}

async fn simulate_data_processing(task_id: u32) {
    for i in 1..=10 {
        sleep(Duration::from_millis(400)).await;
        println!("📀 任务 {} 数据处理进度: {}%", task_id, i * 10);
    }
}

async fn simulate_file_download(task_id: u32) {
    for i in 1..=5 {
        sleep(Duration::from_millis(800)).await;
        println!("📁 任务 {} 文件下载进度: {}%", task_id, i * 20);
    }
}

async fn simulate_email_sending(task_id: u32) {
    for i in 1..=6 {
        sleep(Duration::from_millis(600)).await;
        println!("📧 任务 {} 邮件发送进度: {}%", task_id, (i * 100) / 6);
    }
}</pre>

        <pre>📁 项目结构：
day11_async_basics/
├── src/
│   └── main.rs
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-12</strong></p>
        <h2>Day 12 - 异步任务与共享状态</h2>
        <p>你将学习如何使用 `tokio::spawn` 启动异步任务，如何使用 `Arc<Mutex<>>`来共享状态（如连接列表或在线人数），并避免竞态条件。</p>
        <p>🔗 <a href="https://tokio.rs/tokio/tutorial/spawn" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目和配置依赖</strong></p>
        <pre>cargo new day12_shared_state
cd day12_shared_state</pre>

        <p><strong>Cargo.toml</strong></p>
        <pre>[package]
name = "day12_shared_state"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
rand = "0.8"
chrono = { version = "0.4", features = ["serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"</pre>

        <p><strong>步骤 2: Arc 和 Mutex 基础使用</strong></p>
        <pre>use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use std::collections::HashMap;
use rand::Rng;

#[tokio::main]
async fn main() {
    println!("=== 共享状态基础演示 ===");
    
    // 演示基本共享计数器
    demonstrate_shared_counter().await;
    
    // 演示多任务访问共享数据
    demonstrate_shared_data().await;
    
    // 演示复杂共享状态
    demonstrate_user_connections().await;
}

// 简单的共享计数器
async fn demonstrate_shared_counter() {
    println!("\n--- 共享计数器演示 ---");
    
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    // 创建 5 个任务，每个任务递增计数器 10 次
    for i in 1..=5 {
        let counter_clone = Arc::clone(&counter);
        
        let handle = tokio::spawn(async move {
            for j in 1..=10 {
                // 获取锁并更新计数器
                {
                    let mut count = counter_clone.lock().unwrap();
                    *count += 1;
                    println!("🔢 任务 {} 第 {} 次递增，当前值: {}", i, j, *count);
                } // 锁在这里被释放
                
                // 模拟一些工作
                sleep(Duration::from_millis(100)).await;
            }
        });
        
        handles.push(handle);
    }
    
    // 等待所有任务完成
    for handle in handles {
        handle.await.unwrap();
    }
    
    let final_count = *counter.lock().unwrap();
    println!("✅ 最终计数器值: {}", final_count);
}

// 共享复杂数据结构
async fn demonstrate_shared_data() {
    println!("\n--- 共享数据结构演示 ---");
    
    let shared_map = Arc::new(Mutex::new(HashMap::<String, i32>::new()));
    let mut handles = vec![];
    
    // 创建多个任务来操作共享 HashMap
    for i in 1..=3 {
        let map_clone = Arc::clone(&shared_map);
        
        let handle = tokio::spawn(async move {
            let mut rng = rand::thread_rng();
            
            for j in 1..=5 {
                let key = format!("task_{}_item_{}", i, j);
                let value = rng.gen_range(1..100);
                
                // 插入数据
                {
                    let mut map = map_clone.lock().unwrap();
                    map.insert(key.clone(), value);
                    println!("📝 任务 {} 插入: {} = {}", i, key, value);
                }
                
                sleep(Duration::from_millis(200)).await;
            }
        });
        
        handles.push(handle);
    }
    
    // 读取任务
    let reader_handle = {
        let map_clone = Arc::clone(&shared_map);
        tokio::spawn(async move {
            for _ in 1..=8 {
                sleep(Duration::from_millis(500)).await;
                
                let map = map_clone.lock().unwrap();
                println!("🔍 当前 map 大小: {} 个元素", map.len());
                
                if !map.is_empty() {
                    let sample_key = map.keys().next().unwrap();
                    let sample_value = map.get(sample_key).unwrap();
                    println!("  示例数据: {} = {}", sample_key, sample_value);
                }
            }
        })
    };
    
    // 等待所有任务完成
    for handle in handles {
        handle.await.unwrap();
    }
    reader_handle.await.unwrap();
    
    let final_map = shared_map.lock().unwrap();
    println!("✅ 最终 map 包含 {} 个元素", final_map.len());
}

// 用户连接管理示例
#[derive(Debug, Clone)]
struct UserConnection {
    id: u32,
    username: String,
    connected_at: chrono::DateTime<chrono::Utc>,
    last_activity: chrono::DateTime<chrono::Utc>,
}

impl UserConnection {
    fn new(id: u32, username: String) -> Self {
        let now = chrono::Utc::now();
        UserConnection {
            id,
            username,
            connected_at: now,
            last_activity: now,
        }
    }
    
    fn update_activity(&mut self) {
        self.last_activity = chrono::Utc::now();
    }
}

async fn demonstrate_user_connections() {
    println!("\n--- 用户连接管理演示 ---");
    
    let connections = Arc::new(Mutex::new(HashMap::<u32, UserConnection>::new()));
    let mut handles = vec![];
    
    // 模拟用户连接
    for i in 1..=5 {
        let connections_clone = Arc::clone(&connections);
        
        let handle = tokio::spawn(async move {
            let username = format!("user_{}", i);
            let user_conn = UserConnection::new(i, username.clone());
            
            // 用户连接
            {
                let mut conns = connections_clone.lock().unwrap();
                conns.insert(i, user_conn);
                println!("👤 用户 {} 已连接", username);
            }
            
            // 模拟用户活动
            for j in 1..=rand::thread_rng().gen_range(3..8) {
                sleep(Duration::from_millis(rand::thread_rng().gen_range(300..800))).await;
                
                {
                    let mut conns = connections_clone.lock().unwrap();
                    if let Some(conn) = conns.get_mut(&i) {
                        conn.update_activity();
                        println!("📱 用户 {} 活动 #{}", username, j);
                    }
                }
            }
            
            // 用户断开连接
            {
                let mut conns = connections_clone.lock().unwrap();
                conns.remove(&i);
                println!("🚪 用户 {} 已断开连接", username);
            }
        });
        
        handles.push(handle);
    }
    
    // 连接状态监控任务
    let monitor_handle = {
        let connections_clone = Arc::clone(&connections);
        tokio::spawn(async move {
            for i in 1..=15 {
                sleep(Duration::from_millis(400)).await;
                
                let conns = connections_clone.lock().unwrap();
                let active_count = conns.len();
                
                if active_count > 0 {
                    println!("📊 第 {} 次检查: {} 个活跃连接", i, active_count);
                    
                    for conn in conns.values() {
                        let duration = chrono::Utc::now().signed_duration_since(conn.last_activity);
                        println!("  • {}: 最后活动 {}s 前", 
                               conn.username, 
                               duration.num_seconds());
                    }
                } else {
                    println!("📊 第 {} 次检查: 没有活跃连接", i);
                }
            }
        })
    };
    
    // 等待所有任务完成
    for handle in handles {
        handle.await.unwrap();
    }
    monitor_handle.await.unwrap();
    
    println!("✅ 用户连接管理演示完成");
}</pre>

        <p><strong>步骤 3: Tokio 同步原语</strong></p>
        <pre>use tokio::sync::{RwLock, Semaphore, broadcast, mpsc};
use std::sync::Arc;

#[tokio::main]
async fn main() {
    println!("=== Tokio 同步原语演示 ===");
    
    // RwLock 演示
    demonstrate_rwlock().await;
    
    // Semaphore 演示
    demonstrate_semaphore().await;
    
    // Broadcast channel 演示
    demonstrate_broadcast().await;
    
    // MPSC channel 演示
    demonstrate_mpsc().await;
}

async fn demonstrate_rwlock() {
    println!("\n--- RwLock 演示 ---");
    
    let data = Arc::new(RwLock::new(HashMap::<String, i32>::new()));
    let mut handles = vec![];
    
    // 写入任务（少数）
    for i in 1..=2 {
        let data_clone = Arc::clone(&data);
        
        let handle = tokio::spawn(async move {
            for j in 1..=3 {
                {
                    let mut write_guard = data_clone.write().await;
                    let key = format!("writer_{}_item_{}", i, j);
                    write_guard.insert(key.clone(), j * 10);
                    println!("✏️  写入者 {} 添加: {}", i, key);
                }
                sleep(Duration::from_millis(300)).await;
            }
        });
        
        handles.push(handle);
    }
    
    // 读取任务（多数）
    for i in 1..=5 {
        let data_clone = Arc::clone(&data);
        
        let handle = tokio::spawn(async move {
            for _ in 1..=4 {
                {
                    let read_guard = data_clone.read().await;
                    let count = read_guard.len();
                    println!("🔍 读取者 {} 看到 {} 个元素", i, count);
                    
                    if !read_guard.is_empty() {
                        let first_key = read_guard.keys().next().unwrap();
                        println!("    示例数据: {}", first_key);
                    }
                }
                sleep(Duration::from_millis(200)).await;
            }
        });
        
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    let final_data = data.read().await;
    println!("✅ RwLock 演示完成，最终数据数量: {}", final_data.len());
}

async fn demonstrate_semaphore() {
    println!("\n--- Semaphore 演示 ---");
    
    // 创建一个允许最多 3 个并发访问的信号量
    let semaphore = Arc::new(Semaphore::new(3));
    let mut handles = vec![];
    
    // 创建 8 个任务，但只允许 3 个同时访问资源
    for i in 1..=8 {
        let semaphore_clone = Arc::clone(&semaphore);
        
        let handle = tokio::spawn(async move {
            println!("🔄 任务 {} 等待获取许可...", i);
            
            let _permit = semaphore_clone.acquire().await.unwrap();
            println!("✅ 任务 {} 获得许可，开始执行", i);
            
            // 模拟资源密集型操作
            sleep(Duration::from_millis(1000)).await;
            
            println!("🏁 任务 {} 完成，释放许可", i);
            // _permit 在这里被自动释放
        });
        
        handles.push(handle);
        
        // 稍微延迟启动，以便观察效果
        sleep(Duration::from_millis(100)).await;
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("✅ Semaphore 演示完成");
}

async fn demonstrate_broadcast() {
    println!("\n--- Broadcast Channel 演示 ---");
    
    let (tx, _rx) = broadcast::channel::<String>(10);
    let mut handles = vec![];
    
    // 创建多个接收者
    for i in 1..=4 {
        let mut rx = tx.subscribe();
        
        let handle = tokio::spawn(async move {
            println!("📡 接收者 {} 开始监听", i);
            
            while let Ok(message) = rx.recv().await {
                println!("📨 接收者 {} 收到: {}", i, message);
                
                if message == "exit" {
                    break;
                }
            }
            
            println!("🚪 接收者 {} 退出", i);
        });
        
        handles.push(handle);
    }
    
    // 发送者任务
    let sender_handle = tokio::spawn(async move {
        sleep(Duration::from_millis(500)).await;
        
        let messages = vec![
            "欢迎来到广播频道！",
            "这是第一条消息",
            "这是第二条消息",
            "这是最后一条消息",
            "exit"
        ];
        
        for (i, message) in messages.iter().enumerate() {
            println!("📢 发送消息 {}: {}", i + 1, message);
            
            if let Err(e) = tx.send(message.to_string()) {
                println!("发送失败: {}", e);
            }
            
            sleep(Duration::from_millis(800)).await;
        }
    });
    
    sender_handle.await.unwrap();
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("✅ Broadcast 演示完成");
}

async fn demonstrate_mpsc() {
    println!("\n--- MPSC Channel 演示 ---");
    
    let (tx, mut rx) = mpsc::channel::<String>(32);
    
    // 多个发送者
    let mut sender_handles = vec![];
    
    for i in 1..=4 {
        let tx_clone = tx.clone();
        
        let handle = tokio::spawn(async move {
            for j in 1..=3 {
                let message = format!("发送者 {} 的消息 {}", i, j);
                
                if let Err(e) = tx_clone.send(message.clone()).await {
                    println!("发送失败: {}", e);
                } else {
                    println!("📤 已发送: {}", message);
                }
                
                sleep(Duration::from_millis(300)).await;
            }
            
            println!("🏁 发送者 {} 完成", i);
        });
        
        sender_handles.push(handle);
    }
    
    // 单个接收者
    let receiver_handle = tokio::spawn(async move {
        let mut count = 0;
        
        while let Some(message) = rx.recv().await {
            count += 1;
            println!("📥 接收到第 {} 条消息: {}", count, message);
        }
        
        println!("🏁 接收者完成，共处理 {} 条消息", count);
    });
    
    // 等待所有发送者完成
    for handle in sender_handles {
        handle.await.unwrap();
    }
    
    // 关闭发送端
    drop(tx);
    
    // 等待接收者完成
    receiver_handle.await.unwrap();
    
    println!("✅ MPSC 演示完成");
}</pre>

        <p><strong>步骤 4: 死锁防范和性能优化</strong></p>
        <pre>use tokio::sync::{Mutex as TokioMutex, RwLock};
use std::sync::Arc;
use std::time::Instant;

#[tokio::main]
async fn main() {
    println!("=== 死锁防范和性能优化 ===");
    
    // 死锁防范演示
    demonstrate_deadlock_prevention().await;
    
    // 性能比较：std::sync::Mutex vs tokio::sync::Mutex
    compare_mutex_performance().await;
    
    // RwLock 性能演示
    demonstrate_rwlock_performance().await;
}

async fn demonstrate_deadlock_prevention() {
    println!("\n--- 死锁防范演示 ---");
    
    let resource_a = Arc::new(TokioMutex::new(0));
    let resource_b = Arc::new(TokioMutex::new(0));
    
    let mut handles = vec![];
    
    // 任务 1：先锁 A 再锁 B
    {
        let resource_a = Arc::clone(&resource_a);
        let resource_b = Arc::clone(&resource_b);
        
        let handle = tokio::spawn(async move {
            for i in 1..=3 {
                println!("🔒 任务 1 第 {} 次尝试获取资源 A", i);
                let _guard_a = resource_a.lock().await;
                println!("✅ 任务 1 获得资源 A");
                
                sleep(Duration::from_millis(100)).await;
                
                println!("🔒 任务 1 尝试获取资源 B");
                let _guard_b = resource_b.lock().await;
                println!("✅ 任务 1 获得资源 A 和 B");
                
                sleep(Duration::from_millis(200)).await;
                
                println!("🔓 任务 1 释放所有资源");
            }
        });
        
        handles.push(handle);
    }
    
    // 任务 2：也是先锁 A 再锁 B（防止死锁）
    {
        let resource_a = Arc::clone(&resource_a);
        let resource_b = Arc::clone(&resource_b);
        
        let handle = tokio::spawn(async move {
            for i in 1..=3 {
                println!("🔒 任务 2 第 {} 次尝试获取资源 A", i);
                let _guard_a = resource_a.lock().await;
                println!("✅ 任务 2 获得资源 A");
                
                sleep(Duration::from_millis(150)).await;
                
                println!("🔒 任务 2 尝试获取资源 B");
                let _guard_b = resource_b.lock().await;
                println!("✅ 任务 2 获得资源 A 和 B");
                
                sleep(Duration::from_millis(200)).await;
                
                println!("🔓 任务 2 释放所有资源");
            }
        });
        
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("✅ 死锁防范演示完成（没有发生死锁）");
}

async fn compare_mutex_performance() {
    println!("\n--- Mutex 性能比较 ---");
    
    const ITERATIONS: usize = 1000;
    const TASKS: usize = 10;
    
    // 测试 tokio::sync::Mutex
    let tokio_mutex = Arc::new(TokioMutex::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..TASKS {
        let mutex = Arc::clone(&tokio_mutex);
        let handle = tokio::spawn(async move {
            for _ in 0..ITERATIONS {
                let mut guard = mutex.lock().await;
                *guard += 1;
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    let tokio_duration = start.elapsed();
    let tokio_result = *tokio_mutex.lock().await;
    
    println!("🏁 Tokio Mutex 结果: {}, 耗时: {:?}", tokio_result, tokio_duration);
    
    // 测试 std::sync::Mutex 在 spawn_blocking 中
    let std_mutex = Arc::new(std::sync::Mutex::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..TASKS {
        let mutex = Arc::clone(&std_mutex);
        let handle = tokio::task::spawn_blocking(move || {
            for _ in 0..ITERATIONS {
                let mut guard = mutex.lock().unwrap();
                *guard += 1;
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    let std_duration = start.elapsed();
    let std_result = *std_mutex.lock().unwrap();
    
    println!("🏁 Std Mutex 结果: {}, 耗时: {:?}", std_result, std_duration);
    
    println!("ℹ️  性能比较: Tokio Mutex 适合 async 环境，Std Mutex 适合 CPU 密集型任务");
}

async fn demonstrate_rwlock_performance() {
    println!("\n--- RwLock 性能演示 ---");
    
    let data = Arc::new(RwLock::new(HashMap::<String, i32>::new()));
    
    // 初始化数据
    {
        let mut write_guard = data.write().await;
        for i in 0..100 {
            write_guard.insert(format!("key_{}", i), i);
        }
    }
    
    let start = Instant::now();
    let mut handles = vec![];
    
    // 大量读取任务
    for i in 0..50 {
        let data = Arc::clone(&data);
        let handle = tokio::spawn(async move {
            for j in 0..10 {
                let read_guard = data.read().await;
                let key = format!("key_{}", (i + j) % 100);
                let _value = read_guard.get(&key);
            }
        });
        handles.push(handle);
    }
    
    // 少量写入任务
    for i in 0..5 {
        let data = Arc::clone(&data);
        let handle = tokio::spawn(async move {
            let mut write_guard = data.write().await;
            let key = format!("new_key_{}", i);
            write_guard.insert(key, i * 1000);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    let duration = start.elapsed();
    let final_size = data.read().await.len();
    
    println!("✅ RwLock 性能测试完成");
    println!("  最终数据大小: {} 个元素", final_size);
    println!("  总耗时: {:?}", duration);
    println!("ℹ️  RwLock 允许多个并发读取，但写入是排他的");
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>实现一个线程安全的计数器服务</li>
            <li>构建一个多用户聊天室原型</li>
            <li>创建一个并发任务调度器</li>
            <li>设计一个分布式缓存系统</li>
        </ul>

        <pre>📁 项目结构：
day12_shared_state/
├── src/
│   └── main.rs
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-13</strong></p>
        <h2>Day 13 - 创建 axum 项目并运行 HTTP 路由</h2>
        <p>你将初始化 `axum` 项目，添加 `/ping` 路由，返回 JSON 响应，并配置 `Router`，理解提取器的工作机制。</p>
        <p>🔗 <a href="https://docs.rs/axum/latest/axum/" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目和配置依赖</strong></p>
        <pre>cargo new day13_axum_server
cd day13_axum_server</pre>

        <p><strong>Cargo.toml</strong></p>
        <pre>[package]
name = "day13_axum_server"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.7"
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
tracing = "0.1"
tracing-subscriber = "0.3"
thiserror = "1.0"
anyhow = "1.0"</pre>

        <p><strong>步骤 2: 基本 Axum 服务器</strong></p>
        <pre>use axum::{
    extract::{Path, Query},
    http::StatusCode,
    response::{Html, Json},
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tower_http::cors::CorsLayer;
use tracing::{info, warn};

#[tokio::main]
async fn main() {
    // 初始化日志
    tracing_subscriber::init();
    
    info!("🚀 启动 Axum 服务器...");
    
    // 构建路由
    let app = create_router();
    
    // 启动服务器
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    
    info!("🎧 服务器已启动，监听地址: http://0.0.0.0:3000");
    
    axum::serve(listener, app).await.unwrap();
}

fn create_router() -> Router {
    Router::new()
        // 基本路由
        .route("/", get(root_handler))
        .route("/ping", get(ping_handler))
        .route("/health", get(health_check))
        
        // 路径参数
        .route("/user/:id", get(get_user))
        .route("/user/:id/profile", get(get_user_profile))
        
        // 查询参数
        .route("/search", get(search_handler))
        .route("/items", get(list_items))
        
        // POST 路由
        .route("/users", post(create_user))
        .route("/echo", post(echo_handler))
        
        // 添加 CORS 支持
        .layer(CorsLayer::permissive())
        
        // 全局错误处理
        .fallback(not_found_handler)
}

// 响应结构体
#[derive(Serialize)]
struct ApiResponse<T> {
    success: bool,
    message: String,
    data: Option<T>,
    timestamp: String,
}

impl<T> ApiResponse<T> {
    fn success(data: T, message: &str) -> Self {
        Self {
            success: true,
            message: message.to_string(),
            data: Some(data),
            timestamp: chrono::Utc::now().to_rfc3339(),
        }
    }
    
    fn error(message: &str) -> ApiResponse<()> {
        ApiResponse {
            success: false,
            message: message.to_string(),
            data: None,
            timestamp: chrono::Utc::now().to_rfc3339(),
        }
    }
}

// 路由处理器

async fn root_handler() -> Html<&'static str> {
    info!("🏠 访问根路径");
    Html(r#"
    <html>
        <head><title>Axum 服务器</title></head>
        <body>
            <h1>🚀 欢迎来到 Axum 服务器！</h1>
            <p>这是一个使用 Rust Axum 构建的 Web 服务器。</p>
            <ul>
                <li><a href="/ping">/ping</a> - 健康检查</li>
                <li><a href="/health">/health</a> - 详细健康状态</li>
                <li><a href="/user/123">/user/123</a> - 获取用户信息</li>
                <li><a href="/search?q=rust&limit=10">/search?q=rust&limit=10</a> - 搜索</li>
            </ul>
        </body>
    </html>
    "#)
}

async fn ping_handler() -> Json<ApiResponse<&'static str>> {
    info!("🏓 Ping 请求");
    Json(ApiResponse::success("pong", "服务器运行正常"))
}

#[derive(Debug, Serialize)]
struct HealthStatus {
    status: String,
    uptime: String,
    version: String,
    server_time: String,
}

async fn health_check() -> Json<ApiResponse<HealthStatus>> {
    info!("❤️  健康检查请求");
    
    let health = HealthStatus {
        status: "healthy".to_string(),
        uptime: "running".to_string(),
        version: env!("CARGO_PKG_VERSION").to_string(),
        server_time: chrono::Utc::now().to_rfc3339(),
    };
    
    Json(ApiResponse::success(health, "服务器状态良好"))
}

#[derive(Debug, Serialize)]
struct User {
    id: u32,
    username: String,
    email: String,
    created_at: String,
}

async fn get_user(Path(user_id): Path<u32>) -> Json<ApiResponse<User>> {
    info!("👤 获取用户信息: ID = {}", user_id);
    
    // 模拟数据库查询
    let user = User {
        id: user_id,
        username: format!("user_{}", user_id),
        email: format!("user_{}@example.com", user_id),
        created_at: chrono::Utc::now().to_rfc3339(),
    };
    
    Json(ApiResponse::success(user, "用户信息获取成功"))
}

#[derive(Debug, Serialize)]
struct UserProfile {
    user_id: u32,
    display_name: String,
    bio: String,
    followers: u32,
    following: u32,
}

async fn get_user_profile(Path(user_id): Path<u32>) -> Json<ApiResponse<UserProfile>> {
    info!("📋 获取用户资料: ID = {}", user_id);
    
    let profile = UserProfile {
        user_id,
        display_name: format!("User {}的显示名", user_id),
        bio: "这是一个示例用户的个人简介。".to_string(),
        followers: user_id * 10,
        following: user_id * 5,
    };
    
    Json(ApiResponse::success(profile, "用户资料获取成功"))
}

#[derive(Debug, Deserialize)]
struct SearchParams {
    q: Option<String>,
    limit: Option<usize>,
    offset: Option<usize>,
}

#[derive(Debug, Serialize)]
struct SearchResult {
    query: String,
    results: Vec<SearchItem>,
    total: usize,
    limit: usize,
    offset: usize,
}

#[derive(Debug, Serialize)]
struct SearchItem {
    id: String,
    title: String,
    description: String,
    score: f64,
}

async fn search_handler(Query(params): Query<SearchParams>) -> Json<ApiResponse<SearchResult>> {
    let query = params.q.unwrap_or_else(|| "default".to_string());
    let limit = params.limit.unwrap_or(10).min(100); // 最大 100 个结果
    let offset = params.offset.unwrap_or(0);
    
    info!("🔍 搜索请求: query='{}', limit={}, offset={}", query, limit, offset);
    
    // 模拟搜索结果
    let items: Vec<SearchItem> = (0..limit)
        .map(|i| SearchItem {
            id: uuid::Uuid::new_v4().to_string(),
            title: format!("{} 结果 {}", query, i + 1),
            description: format!("这是关于 '{}' 的第 {} 个搜索结果。", query, i + 1),
            score: 1.0 - (i as f64 * 0.1),
        })
        .collect();
    
    let result = SearchResult {
        query: query.clone(),
        total: 1000, // 模拟总数
        results: items,
        limit,
        offset,
    };
    
    Json(ApiResponse::success(result, &format!("搜索 '{}' 完成", query)))
}

#[derive(Debug, Deserialize)]
struct ListParams {
    page: Option<usize>,
    per_page: Option<usize>,
    category: Option<String>,
}

#[derive(Debug, Serialize)]
struct ItemList {
    items: Vec<Item>,
    pagination: Pagination,
}

#[derive(Debug, Serialize)]
struct Item {
    id: String,
    name: String,
    category: String,
    price: f64,
    in_stock: bool,
}

#[derive(Debug, Serialize)]
struct Pagination {
    page: usize,
    per_page: usize,
    total_pages: usize,
    total_items: usize,
}

async fn list_items(Query(params): Query<ListParams>) -> Json<ApiResponse<ItemList>> {
    let page = params.page.unwrap_or(1).max(1);
    let per_page = params.per_page.unwrap_or(20).min(100).max(1);
    let category = params.category.unwrap_or_else(|| "all".to_string());
    
    info!("📎 列表请求: page={}, per_page={}, category='{}'", page, per_page, category);
    
    // 模拟数据
    let items: Vec<Item> = (0..per_page)
        .map(|i| {
            let item_id = (page - 1) * per_page + i + 1;
            Item {
                id: format!("item_{}", item_id),
                name: format!("商品 {}", item_id),
                category: category.clone(),
                price: (item_id as f64) * 9.99,
                in_stock: item_id % 3 != 0, // 模拟库存状态
            }
        })
        .collect();
    
    let total_items = 500; // 模拟总数
    let total_pages = (total_items + per_page - 1) / per_page;
    
    let item_list = ItemList {
        items,
        pagination: Pagination {
            page,
            per_page,
            total_pages,
            total_items,
        },
    };
    
    Json(ApiResponse::success(item_list, "商品列表获取成功"))
}

#[derive(Debug, Deserialize)]
struct CreateUserRequest {
    username: String,
    email: String,
    full_name: Option<String>,
}

#[derive(Debug, Serialize)]
struct CreateUserResponse {
    id: String,
    username: String,
    email: String,
    full_name: Option<String>,
    created_at: String,
}

async fn create_user(Json(payload): Json<CreateUserRequest>) -> Result<Json<ApiResponse<CreateUserResponse>>, StatusCode> {
    info!("🆕 创建用户请求: {:?}", payload);
    
    // 验证输入
    if payload.username.is_empty() {
        warn!("用户名不能为空");
        return Err(StatusCode::BAD_REQUEST);
    }
    
    if !payload.email.contains('@') {
        warn!("邮箱格式不正确");
        return Err(StatusCode::BAD_REQUEST);
    }
    
    // 模拟创建用户逻辑
    let user = CreateUserResponse {
        id: uuid::Uuid::new_v4().to_string(),
        username: payload.username,
        email: payload.email,
        full_name: payload.full_name,
        created_at: chrono::Utc::now().to_rfc3339(),
    };
    
    Ok(Json(ApiResponse::success(user, "用户创建成功")))
}

#[derive(Debug, Deserialize, Serialize)]
struct EchoMessage {
    message: String,
    timestamp: Option<String>,
}

async fn echo_handler(Json(payload): Json<EchoMessage>) -> Json<ApiResponse<EchoMessage>> {
    info!("🔊 Echo 请求: {:?}", payload);
    
    let mut response = payload;
    response.timestamp = Some(chrono::Utc::now().to_rfc3339());
    
    Json(ApiResponse::success(response, "Echo 成功"))
}

async fn not_found_handler() -> (StatusCode, Json<ApiResponse<()>>) {
    warn!("🚫 404 - 路径未找到");
    (
        StatusCode::NOT_FOUND,
        Json(ApiResponse::error("请求的资源未找到")),
    )
}</pre>

        <p><strong>步骤 3: 中间件和错误处理</strong></p>
        <pre>use axum::{
    extract::Request,
    middleware::{self, Next},
    response::Response,
};
use tower::ServiceBuilder;
use tower_http::{
    trace::TraceLayer,
    timeout::TimeoutLayer,
    compression::CompressionLayer,
};
use std::time::Duration;

// 更新 create_router 函数
fn create_router() -> Router {
    Router::new()
        // API 路由
        .route("/", get(root_handler))
        .route("/ping", get(ping_handler))
        .route("/health", get(health_check))
        .route("/user/:id", get(get_user))
        .route("/user/:id/profile", get(get_user_profile))
        .route("/search", get(search_handler))
        .route("/items", get(list_items))
        .route("/users", post(create_user))
        .route("/echo", post(echo_handler))
        
        // 受保护的路由
        .route("/protected", get(protected_handler))
        .route_layer(middleware::from_fn(auth_middleware))
        
        // 全局中间件
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CompressionLayer::new())
                .layer(TimeoutLayer::new(Duration::from_secs(30)))
                .layer(middleware::from_fn(request_logging_middleware))
                .layer(CorsLayer::permissive())
        )
        
        .fallback(not_found_handler)
}

// 请求日忕中间件
async fn request_logging_middleware(
    request: Request,
    next: Next,
) -> Response {
    let method = request.method().clone();
    let uri = request.uri().clone();
    let start = std::time::Instant::now();
    
    let response = next.run(request).await;
    
    let duration = start.elapsed();
    let status = response.status();
    
    info!(
        "📋 {} {} - {} ({:?})",
        method,
        uri,
        status.as_u16(),
        duration
    );
    
    response
}

// 简单认证中间件
async fn auth_middleware(
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    // 检查 Authorization header
    let auth_header = request
        .headers()
        .get("authorization")
        .and_then(|value| value.to_str().ok());
    
    match auth_header {
        Some(token) if token.starts_with("Bearer ") => {
            let token = &token[7..]; // 移除 "Bearer " 前缀
            
            if token == "valid-token-123" {
                info!("✅ 认证成功");
                Ok(next.run(request).await)
            } else {
                warn!("❌ 无效的 token");
                Err(StatusCode::UNAUTHORIZED)
            }
        }
        _ => {
            warn!("❌ 缺少 Authorization header");
            Err(StatusCode::UNAUTHORIZED)
        }
    }
}

#[derive(Serialize)]
struct ProtectedData {
    message: String,
    user_id: String,
    access_level: String,
}

async fn protected_handler() -> Json<ApiResponse<ProtectedData>> {
    info!("🔒 访问受保护的资源");
    
    let data = ProtectedData {
        message: "这是受保护的数据".to_string(),
        user_id: "user_123".to_string(),
        access_level: "admin".to_string(),
    };
    
    Json(ApiResponse::success(data, "受保护资源访问成功"))
}</pre>

        <p><strong>步骤 4: 状态管理</strong></p>
        <pre>use axum::extract::State;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

// 应用状态
#[derive(Clone)]
struct AppState {
    users: Arc<Mutex<HashMap<String, StoredUser>>>,
    visit_count: Arc<Mutex<u64>>,
    server_start_time: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize)]
struct StoredUser {
    id: String,
    username: String,
    email: String,
    created_at: String,
}

impl AppState {
    fn new() -> Self {
        Self {
            users: Arc::new(Mutex::new(HashMap::new())),
            visit_count: Arc::new(Mutex::new(0)),
            server_start_time: chrono::Utc::now(),
        }
    }
}

// 更新 main 函数
#[tokio::main]
async fn main() {
    tracing_subscriber::init();
    
    info!("🚀 启动 Axum 服务器...");
    
    // 创建应用状态
    let state = AppState::new();
    
    // 构建路由
    let app = create_stateful_router().with_state(state);
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    
    info!("🎧 服务器已启动，监听地址: http://0.0.0.0:3000");
    
    axum::serve(listener, app).await.unwrap();
}

fn create_stateful_router() -> Router<AppState> {
    Router::new()
        .route("/", get(stateful_root_handler))
        .route("/stats", get(get_stats))
        .route("/users", post(create_stateful_user))
        .route("/users/:id", get(get_stateful_user))
        .route("/users", get(list_all_users))
        
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(middleware::from_fn(visit_counter_middleware))
                .layer(CorsLayer::permissive())
        )
        
        .fallback(not_found_handler)
}

// 访问计数中间件
async fn visit_counter_middleware(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    // 增加访问计数
    {
        let mut count = state.visit_count.lock().unwrap();
        *count += 1;
    }
    
    next.run(request).await
}

async fn stateful_root_handler(State(state): State<AppState>) -> Html<String> {
    let visit_count = *state.visit_count.lock().unwrap();
    let user_count = state.users.lock().unwrap().len();
    
    let html = format!(r#"
    <html>
        <head><title>Axum 状态管理服务器</title></head>
        <body>
            <h1>🚀 Axum 服务器状态</h1>
            <ul>
                <li>📊 访问次数: {}</li>
                <li>👥 用户数量: {}</li>
                <li><a href="/stats">/stats</a> - 查看统计信息</li>
                <li><a href="/users">/users</a> - 查看所有用户</li>
            </ul>
        </body>
    </html>
    "#, visit_count, user_count);
    
    Html(html)
}

#[derive(Serialize)]
struct ServerStats {
    visit_count: u64,
    user_count: usize,
    uptime_seconds: i64,
    server_start_time: String,
}

async fn get_stats(State(state): State<AppState>) -> Json<ApiResponse<ServerStats>> {
    let visit_count = *state.visit_count.lock().unwrap();
    let user_count = state.users.lock().unwrap().len();
    let uptime = chrono::Utc::now().signed_duration_since(state.server_start_time);
    
    let stats = ServerStats {
        visit_count,
        user_count,
        uptime_seconds: uptime.num_seconds(),
        server_start_time: state.server_start_time.to_rfc3339(),
    };
    
    Json(ApiResponse::success(stats, "服务器统计信息"))
}

async fn create_stateful_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<ApiResponse<StoredUser>>, StatusCode> {
    if payload.username.is_empty() || !payload.email.contains('@') {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    let user_id = uuid::Uuid::new_v4().to_string();
    let user = StoredUser {
        id: user_id.clone(),
        username: payload.username,
        email: payload.email,
        created_at: chrono::Utc::now().to_rfc3339(),
    };
    
    // 存储用户
    {
        let mut users = state.users.lock().unwrap();
        users.insert(user_id, user.clone());
    }
    
    info!("🆕 用户已创建: {}", user.username);
    
    Ok(Json(ApiResponse::success(user, "用户创建成功")))
}

async fn get_stateful_user(
    State(state): State<AppState>,
    Path(user_id): Path<String>,
) -> Result<Json<ApiResponse<StoredUser>>, StatusCode> {
    let users = state.users.lock().unwrap();
    
    match users.get(&user_id) {
        Some(user) => Ok(Json(ApiResponse::success(user.clone(), "用户信息获取成功"))),
        None => Err(StatusCode::NOT_FOUND),
    }
}

async fn list_all_users(
    State(state): State<AppState>,
) -> Json<ApiResponse<Vec<StoredUser>>> {
    let users = state.users.lock().unwrap();
    let user_list: Vec<StoredUser> = users.values().cloned().collect();
    
    Json(ApiResponse::success(user_list, "用户列表获取成功"))
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>添加更多 REST API 端点（PUT, DELETE）</li>
            <li>实现用户认证和授权系统</li>
            <li>添加请求限速中间件</li>
            <li>实现文件上传和下载功能</li>
        </ul>

        <p><strong>测试命令：</strong></p>
        <pre># 启动服务器
cargo run

# 测试 API 端点
curl http://localhost:3000/ping
curl http://localhost:3000/health
curl http://localhost:3000/user/123
curl "http://localhost:3000/search?q=rust&limit=5"

# POST 请求
curl -X POST http://localhost:3000/users \
  -H "Content-Type: application/json" \
  -d '{"username":"alice","email":"alice@example.com"}'

# 受保护的资源
curl http://localhost:3000/protected \
  -H "Authorization: Bearer valid-token-123"</pre>

        <pre>📁 项目结构：
day13_axum_server/
├── src/
│   └── main.rs
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-14</strong></p>
        <h2>Day 14 - 定义 JSON 请求与响应类型</h2>
        <p>你将定义结构体，使用 `serde::{Serialize, Deserialize}` 将其转换为 JSON，并编写支持 POST 请求的接口（如 `/login`）。</p>
        <p>🔗 <a href="https://docs.rs/serde/latest/serde/" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目和配置依赖</strong></p>
        <pre>cargo new day14_json_api
cd day14_json_api</pre>

        <p><strong>Cargo.toml</strong></p>
        <pre>[package]
name = "day14_json_api"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.7"
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace", "validate-request"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
tracing = "0.1"
tracing-subscriber = "0.3"
validator = { version = "0.18", features = ["derive"] }
bcrypt = "0.15"
jsonwebtoken = "9.2"
thiserror = "1.0"
anyhow = "1.0"</pre>

        <p><strong>步骤 2: 定义 JSON 数据结构</strong></p>
        <pre>use axum::{
    extract::{Json, Path, State},
    http::StatusCode,
    response::Json as ResponseJson,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use validator::Validate;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use uuid::Uuid;
use chrono::{DateTime, Utc};

// ===== 通用响应结构 =====

#[derive(Debug, Serialize)]
struct ApiResponse<T> {
    success: bool,
    message: String,
    data: Option<T>,
    timestamp: DateTime<Utc>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error_code: Option<String>,
}

impl<T> ApiResponse<T> {
    fn success(data: T, message: &str) -> Self {
        Self {
            success: true,
            message: message.to_string(),
            data: Some(data),
            timestamp: Utc::now(),
            error_code: None,
        }
    }
    
    fn error(message: &str, error_code: Option<&str>) -> ApiResponse<()> {
        ApiResponse {
            success: false,
            message: message.to_string(),
            data: None,
            timestamp: Utc::now(),
            error_code: error_code.map(|s| s.to_string()),
        }
    }
}

// ===== 用户相关数据结构 =====

#[derive(Debug, Clone, Serialize, Deserialize)]
struct User {
    id: String,
    username: String,
    email: String,
    full_name: Option<String>,
    avatar_url: Option<String>,
    is_active: bool,
    role: UserRole,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
    #[serde(skip_serializing)] // 不在 JSON 中返回密码哈希
    password_hash: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
enum UserRole {
    Admin,
    Moderator,
    User,
    Guest,
}

#[derive(Debug, Deserialize, Validate)]
struct CreateUserRequest {
    #[validate(length(min = 3, max = 30))]
    username: String,
    
    #[validate(email)]
    email: String,
    
    #[validate(length(min = 6))]
    password: String,
    
    #[validate(length(min = 1, max = 100))]
    full_name: Option<String>,
    
    #[validate(url)]
    avatar_url: Option<String>,
}

#[derive(Debug, Deserialize, Validate)]
struct UpdateUserRequest {
    #[validate(length(min = 1, max = 100))]
    full_name: Option<String>,
    
    #[validate(url)]
    avatar_url: Option<String>,
    
    #[validate(email)]
    email: Option<String>,
}

#[derive(Debug, Deserialize, Validate)]
struct LoginRequest {
    #[validate(length(min = 1))]
    username: String,
    
    #[validate(length(min = 1))]
    password: String,
}

#[derive(Debug, Serialize)]
struct LoginResponse {
    user: UserInfo,
    token: String,
    expires_at: DateTime<Utc>,
}

#[derive(Debug, Serialize)]
struct UserInfo {
    id: String,
    username: String,
    email: String,
    full_name: Option<String>,
    avatar_url: Option<String>,
    role: UserRole,
}

impl From<User> for UserInfo {
    fn from(user: User) -> Self {
        Self {
            id: user.id,
            username: user.username,
            email: user.email,
            full_name: user.full_name,
            avatar_url: user.avatar_url,
            role: user.role,
        }
    }
}

// ===== 文章相关数据结构 =====

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Article {
    id: String,
    title: String,
    content: String,
    summary: Option<String>,
    author_id: String,
    category: ArticleCategory,
    tags: Vec<String>,
    status: ArticleStatus,
    view_count: u64,
    like_count: u64,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
    published_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
enum ArticleCategory {
    Technology,
    Science,
    Business,
    Entertainment,
    Sports,
    Health,
    Other,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
enum ArticleStatus {
    Draft,
    Published,
    Archived,
}

#[derive(Debug, Deserialize, Validate)]
struct CreateArticleRequest {
    #[validate(length(min = 1, max = 200))]
    title: String,
    
    #[validate(length(min = 10))]
    content: String,
    
    #[validate(length(max = 500))]
    summary: Option<String>,
    
    category: ArticleCategory,
    tags: Vec<String>,
}

#[derive(Debug, Deserialize, Validate)]
struct UpdateArticleRequest {
    #[validate(length(min = 1, max = 200))]
    title: Option<String>,
    
    #[validate(length(min = 10))]
    content: Option<String>,
    
    #[validate(length(max = 500))]
    summary: Option<String>,
    
    category: Option<ArticleCategory>,
    tags: Option<Vec<String>>,
    status: Option<ArticleStatus>,
}

#[derive(Debug, Serialize)]
struct ArticleListItem {
    id: String,
    title: String,
    summary: Option<String>,
    author: UserInfo,
    category: ArticleCategory,
    tags: Vec<String>,
    status: ArticleStatus,
    view_count: u64,
    like_count: u64,
    created_at: DateTime<Utc>,
    published_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize)]
struct ArticleQueryParams {
    page: Option<u32>,
    per_page: Option<u32>,
    category: Option<ArticleCategory>,
    author_id: Option<String>,
    status: Option<ArticleStatus>,
    search: Option<String>,
}

#[derive(Debug, Serialize)]
struct PaginatedResponse<T> {
    items: Vec<T>,
    pagination: PaginationInfo,
}

#[derive(Debug, Serialize)]
struct PaginationInfo {
    page: u32,
    per_page: u32,
    total_items: u64,
    total_pages: u32,
    has_next: bool,
    has_prev: bool,
}

// ===== 评论相关数据结构 =====

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Comment {
    id: String,
    article_id: String,
    author_id: String,
    content: String,
    parent_id: Option<String>, // 支持回复评论
    like_count: u64,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize, Validate)]
struct CreateCommentRequest {
    #[validate(length(min = 1, max = 1000))]
    content: String,
    
    parent_id: Option<String>,
}

#[derive(Debug, Serialize)]
struct CommentWithAuthor {
    id: String,
    content: String,
    author: UserInfo,
    parent_id: Option<String>,
    replies: Vec<CommentWithAuthor>,
    like_count: u64,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}

// ===== 应用状态 =====

#[derive(Clone)]
struct AppState {
    users: Arc<Mutex<HashMap<String, User>>>,
    articles: Arc<Mutex<HashMap<String, Article>>>,
    comments: Arc<Mutex<HashMap<String, Comment>>>,
    jwt_secret: String,
}

impl AppState {
    fn new() -> Self {
        Self {
            users: Arc::new(Mutex::new(HashMap::new())),
            articles: Arc::new(Mutex::new(HashMap::new())),
            comments: Arc::new(Mutex::new(HashMap::new())),
            jwt_secret: "your-secret-key".to_string(),
        }
    }
}</pre>

        <p><strong>步骤 3: 用户管理 API</strong></p>
        <pre>use tower_http::cors::CorsLayer;
use tracing::{info, warn, error};

#[tokio::main]
async fn main() {
    tracing_subscriber::init();
    
    info!("🚀 启动 JSON API 服务器...");
    
    let state = AppState::new();
    let app = create_api_router().with_state(state);
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    
    info!("🎧 服务器已启动，监听地址: http://0.0.0.0:3000");
    
    axum::serve(listener, app).await.unwrap();
}

fn create_api_router() -> Router<AppState> {
    Router::new()
        // 身份验证
        .route("/api/auth/register", post(register_user))
        .route("/api/auth/login", post(login_user))
        
        // 用户管理
        .route("/api/users", get(list_users))
        .route("/api/users/:id", get(get_user))
        .route("/api/users/:id", put(update_user))
        .route("/api/users/:id", delete(delete_user))
        
        // 文章管理
        .route("/api/articles", get(list_articles))
        .route("/api/articles", post(create_article))
        .route("/api/articles/:id", get(get_article))
        .route("/api/articles/:id", put(update_article))
        .route("/api/articles/:id", delete(delete_article))
        .route("/api/articles/:id/like", post(like_article))
        
        // 评论管理
        .route("/api/articles/:article_id/comments", get(list_comments))
        .route("/api/articles/:article_id/comments", post(create_comment))
        .route("/api/comments/:id", put(update_comment))
        .route("/api/comments/:id", delete(delete_comment))
        
        .layer(CorsLayer::permissive())
        .fallback(api_not_found)
}

// ===== 身份验证 API =====

async fn register_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<ResponseJson<ApiResponse<UserInfo>>, StatusCode> {
    // 验证输入
    if let Err(errors) = payload.validate() {
        warn!("用户注册验证失败: {:?}", errors);
        return Err(StatusCode::BAD_REQUEST);
    }
    
    info!("🆕 用户注册请求: {}", payload.username);
    
    let mut users = state.users.lock().unwrap();
    
    // 检查用户名是否已存在
    if users.values().any(|u| u.username == payload.username) {
        warn!("用户名已存在: {}", payload.username);
        return Err(StatusCode::CONFLICT);
    }
    
    // 检查邮箱是否已存在
    if users.values().any(|u| u.email == payload.email) {
        warn!("邮箱已存在: {}", payload.email);
        return Err(StatusCode::CONFLICT);
    }
    
    // 创建用户
    let user_id = Uuid::new_v4().to_string();
    let password_hash = bcrypt::hash(&payload.password, bcrypt::DEFAULT_COST)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    let user = User {
        id: user_id.clone(),
        username: payload.username,
        email: payload.email,
        full_name: payload.full_name,
        avatar_url: payload.avatar_url,
        is_active: true,
        role: UserRole::User,
        created_at: Utc::now(),
        updated_at: Utc::now(),
        password_hash,
    };
    
    let user_info = UserInfo::from(user.clone());
    users.insert(user_id, user);
    
    info!("✅ 用户注册成功: {}", user_info.username);
    
    Ok(ResponseJson(ApiResponse::success(
        user_info,
        "用户注册成功",
    )))
}

async fn login_user(
    State(state): State<AppState>,
    Json(payload): Json<LoginRequest>,
) -> Result<ResponseJson<ApiResponse<LoginResponse>>, StatusCode> {
    if let Err(_) = payload.validate() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    info!("🔑 用户登录请求: {}", payload.username);
    
    let users = state.users.lock().unwrap();
    
    // 查找用户
    let user = users
        .values()
        .find(|u| u.username == payload.username)
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    // 验证密码
    if !bcrypt::verify(&payload.password, &user.password_hash)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
    {
        warn!("密码错误: {}", payload.username);
        return Err(StatusCode::UNAUTHORIZED);
    }
    
    // 生成 JWT token
    let token = generate_jwt_token(&user.id, &state.jwt_secret)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    let expires_at = Utc::now() + chrono::Duration::hours(24);
    
    let response = LoginResponse {
        user: UserInfo::from(user.clone()),
        token,
        expires_at,
    };
    
    info!("✅ 用户登录成功: {}", user.username);
    
    Ok(ResponseJson(ApiResponse::success(
        response,
        "登录成功",
    )))
}

fn generate_jwt_token(user_id: &str, secret: &str) -> Result<String, jsonwebtoken::errors::Error> {
    use jsonwebtoken::{encode, Header, EncodingKey};
    use serde::{Serialize};
    
    #[derive(Serialize)]
    struct Claims {
        sub: String,
        exp: usize,
    }
    
    let expiration = Utc::now()
        .checked_add_signed(chrono::Duration::hours(24))
        .expect("无效的时间戳")
        .timestamp() as usize;
    
    let claims = Claims {
        sub: user_id.to_string(),
        exp: expiration,
    };
    
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_ref()))
}

// ===== 用户管理 API =====

async fn list_users(
    State(state): State<AppState>,
) -> ResponseJson<ApiResponse<Vec<UserInfo>>> {
    let users = state.users.lock().unwrap();
    let user_list: Vec<UserInfo> = users
        .values()
        .filter(|u| u.is_active)
        .map(|u| UserInfo::from(u.clone()))
        .collect();
    
    ResponseJson(ApiResponse::success(
        user_list,
        "用户列表获取成功",
    ))
}

async fn get_user(
    State(state): State<AppState>,
    Path(user_id): Path<String>,
) -> Result<ResponseJson<ApiResponse<UserInfo>>, StatusCode> {
    let users = state.users.lock().unwrap();
    
    let user = users
        .get(&user_id)
        .filter(|u| u.is_active)
        .ok_or(StatusCode::NOT_FOUND)?;
    
    Ok(ResponseJson(ApiResponse::success(
        UserInfo::from(user.clone()),
        "用户信息获取成功",
    )))
}

async fn update_user(
    State(state): State<AppState>,
    Path(user_id): Path<String>,
    Json(payload): Json<UpdateUserRequest>,
) -> Result<ResponseJson<ApiResponse<UserInfo>>, StatusCode> {
    if let Err(_) = payload.validate() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    let mut users = state.users.lock().unwrap();
    
    let user = users.get_mut(&user_id).ok_or(StatusCode::NOT_FOUND)?;
    
    // 更新字段
    if let Some(full_name) = payload.full_name {
        user.full_name = Some(full_name);
    }
    
    if let Some(avatar_url) = payload.avatar_url {
        user.avatar_url = Some(avatar_url);
    }
    
    if let Some(email) = payload.email {
        // 检查邮箱是否已被其他用户使用
        if users.values().any(|u| u.id != user_id && u.email == email) {
            return Err(StatusCode::CONFLICT);
        }
        user.email = email;
    }
    
    user.updated_at = Utc::now();
    
    info!("✅ 用户信息更新成功: {}", user.username);
    
    Ok(ResponseJson(ApiResponse::success(
        UserInfo::from(user.clone()),
        "用户信息更新成功",
    )))
}

async fn delete_user(
    State(state): State<AppState>,
    Path(user_id): Path<String>,
) -> Result<ResponseJson<ApiResponse<()>>, StatusCode> {
    let mut users = state.users.lock().unwrap();
    
    let user = users.get_mut(&user_id).ok_or(StatusCode::NOT_FOUND)?;
    
    // 软删除：标记为非活跃状态
    user.is_active = false;
    user.updated_at = Utc::now();
    
    info!("✅ 用户已禁用: {}", user.username);
    
    Ok(ResponseJson(ApiResponse::success(
        (),
        "用户已删除",
    )))
}</pre>

        <p><strong>步骤 4: 文章管理 API</strong></p>
        <pre>use axum::extract::Query;

// ===== 文章管理 API =====

async fn create_article(
    State(state): State<AppState>,
    Json(payload): Json<CreateArticleRequest>,
) -> Result<ResponseJson<ApiResponse<Article>>, StatusCode> {
    if let Err(_) = payload.validate() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    info!("📝 创建文章: {}", payload.title);
    
    let article_id = Uuid::new_v4().to_string();
    let now = Utc::now();
    
    let article = Article {
        id: article_id.clone(),
        title: payload.title,
        content: payload.content,
        summary: payload.summary,
        author_id: "system".to_string(), // 在实际应用中从 JWT 中获取
        category: payload.category,
        tags: payload.tags,
        status: ArticleStatus::Draft,
        view_count: 0,
        like_count: 0,
        created_at: now,
        updated_at: now,
        published_at: None,
    };
    
    let mut articles = state.articles.lock().unwrap();
    articles.insert(article_id, article.clone());
    
    Ok(ResponseJson(ApiResponse::success(
        article,
        "文章创建成功",
    )))
}

async fn list_articles(
    State(state): State<AppState>,
    Query(params): Query<ArticleQueryParams>,
) -> ResponseJson<ApiResponse<PaginatedResponse<ArticleListItem>>> {
    let page = params.page.unwrap_or(1).max(1);
    let per_page = params.per_page.unwrap_or(10).min(50).max(1);
    
    info!("📎 获取文章列表: page={}, per_page={}", page, per_page);
    
    let articles = state.articles.lock().unwrap();
    let users = state.users.lock().unwrap();
    
    let mut filtered_articles: Vec<&Article> = articles
        .values()
        .filter(|article| {
            // 按类别过滤
            if let Some(ref category) = params.category {
                if article.category != *category {
                    return false;
                }
            }
            
            // 按作者过滤
            if let Some(ref author_id) = params.author_id {
                if article.author_id != *author_id {
                    return false;
                }
            }
            
            // 按状态过滤
            if let Some(ref status) = params.status {
                if article.status != *status {
                    return false;
                }
            }
            
            // 搜索过滤
            if let Some(ref search) = params.search {
                let search_lower = search.to_lowercase();
                if !article.title.to_lowercase().contains(&search_lower)
                    && !article.content.to_lowercase().contains(&search_lower)
                {
                    return false;
                }
            }
            
            true
        })
        .collect();
    
    // 按创建时间排序（最新的在前）
    filtered_articles.sort_by(|a, b| b.created_at.cmp(&a.created_at));
    
    let total_items = filtered_articles.len() as u64;
    let total_pages = ((total_items as f64) / (per_page as f64)).ceil() as u32;
    
    // 分页
    let start = ((page - 1) * per_page) as usize;
    let end = (start + per_page as usize).min(filtered_articles.len());
    let page_articles = if start < filtered_articles.len() {
        &filtered_articles[start..end]
    } else {
        &[]
    };
    
    // 转换为列表项格式
    let items: Vec<ArticleListItem> = page_articles
        .iter()
        .filter_map(|article| {
            users.get(&article.author_id).map(|author| ArticleListItem {
                id: article.id.clone(),
                title: article.title.clone(),
                summary: article.summary.clone(),
                author: UserInfo::from(author.clone()),
                category: article.category.clone(),
                tags: article.tags.clone(),
                status: article.status.clone(),
                view_count: article.view_count,
                like_count: article.like_count,
                created_at: article.created_at,
                published_at: article.published_at,
            })
        })
        .collect();
    
    let response = PaginatedResponse {
        items,
        pagination: PaginationInfo {
            page,
            per_page,
            total_items,
            total_pages,
            has_next: page < total_pages,
            has_prev: page > 1,
        },
    };
    
    ResponseJson(ApiResponse::success(
        response,
        "文章列表获取成功",
    ))
}

async fn get_article(
    State(state): State<AppState>,
    Path(article_id): Path<String>,
) -> Result<ResponseJson<ApiResponse<Article>>, StatusCode> {
    let mut articles = state.articles.lock().unwrap();
    
    let article = articles.get_mut(&article_id).ok_or(StatusCode::NOT_FOUND)?;
    
    // 增加阅读数
    article.view_count += 1;
    
    info!("👁️  文章被查看: {} (ID: {})", article.title, article_id);
    
    Ok(ResponseJson(ApiResponse::success(
        article.clone(),
        "文章获取成功",
    )))
}

async fn update_article(
    State(state): State<AppState>,
    Path(article_id): Path<String>,
    Json(payload): Json<UpdateArticleRequest>,
) -> Result<ResponseJson<ApiResponse<Article>>, StatusCode> {
    if let Err(_) = payload.validate() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    let mut articles = state.articles.lock().unwrap();
    let article = articles.get_mut(&article_id).ok_or(StatusCode::NOT_FOUND)?;
    
    // 更新字段
    if let Some(title) = payload.title {
        article.title = title;
    }
    
    if let Some(content) = payload.content {
        article.content = content;
    }
    
    if let Some(summary) = payload.summary {
        article.summary = Some(summary);
    }
    
    if let Some(category) = payload.category {
        article.category = category;
    }
    
    if let Some(tags) = payload.tags {
        article.tags = tags;
    }
    
    if let Some(status) = payload.status {
        if status == ArticleStatus::Published && article.published_at.is_none() {
            article.published_at = Some(Utc::now());
        }
        article.status = status;
    }
    
    article.updated_at = Utc::now();
    
    info!("✅ 文章更新成功: {}", article.title);
    
    Ok(ResponseJson(ApiResponse::success(
        article.clone(),
        "文章更新成功",
    )))
}

async fn delete_article(
    State(state): State<AppState>,
    Path(article_id): Path<String>,
) -> Result<ResponseJson<ApiResponse<()>>, StatusCode> {
    let mut articles = state.articles.lock().unwrap();
    
    let article = articles.remove(&article_id).ok_or(StatusCode::NOT_FOUND)?;
    
    info!("✅ 文章已删除: {}", article.title);
    
    Ok(ResponseJson(ApiResponse::success(
        (),
        "文章删除成功",
    )))
}

async fn like_article(
    State(state): State<AppState>,
    Path(article_id): Path<String>,
) -> Result<ResponseJson<ApiResponse<Article>>, StatusCode> {
    let mut articles = state.articles.lock().unwrap();
    
    let article = articles.get_mut(&article_id).ok_or(StatusCode::NOT_FOUND)?;
    
    article.like_count += 1;
    
    info!("👍 文章被点赞: {} (ID: {})", article.title, article_id);
    
    Ok(ResponseJson(ApiResponse::success(
        article.clone(),
        "点赞成功",
    )))
}

// ===== 通用错误处理 =====

async fn api_not_found() -> (StatusCode, ResponseJson<ApiResponse<()>>) {
    (
        StatusCode::NOT_FOUND,
        ResponseJson(ApiResponse::error("请求的 API 端点不存在", Some("API_NOT_FOUND"))),
    )
}</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>实现评论系统 API</li>
            <li>添加文件上传和图片处理功能</li>
            <li>创建通知系统 API</li>
            <li>实现数据导出功能（CSV/JSON）</li>
        </ul>

        <p><strong>测试命令：</strong></p>
        <pre># 用户注册
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "alice",
    "email": "alice@example.com",
    "password": "password123",
    "full_name": "Alice Smith"
  }'

# 用户登录
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "alice",
    "password": "password123"
  }'

# 创建文章
curl -X POST http://localhost:3000/api/articles \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Rust 学习指南",
    "content": "这是一篇关于 Rust 编程语言的文章...",
    "summary": "介绍 Rust 基础知识",
    "category": "technology",
    "tags": ["rust", "programming", "tutorial"]
  }'

# 获取文章列表
curl "http://localhost:3000/api/articles?page=1&per_page=5&category=technology"

# 获取单个文章
curl http://localhost:3000/api/articles/{article_id}

# 搜索文章
curl "http://localhost:3000/api/articles?search=rust&page=1&per_page=10"</pre>

        <pre>📁 项目结构：
day14_json_api/
├── src/
│   └── main.rs
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-15</strong></p>
        <h2>Day 15 - WebSocket 接入与升级握手</h2>
        <p>你将通过 `axum::extract::ws` 实现 `/ws` 路由，完成客户端连接升级，并使用 `WebSocket::send`, `WebSocket::recv` 与客户端通信。</p>
        <p>🔗 <a href="https://docs.rs/axum/latest/axum/extract/ws/" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目并配置依赖</strong></p>
        <pre>cargo new day15_websocket_basic
cd day15_websocket_basic</pre>

        <p><strong>配置 Cargo.toml：</strong></p>
        <pre>[package]
name = "day15_websocket_basic"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.20"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"</pre>

        <p><strong>步骤 2: 实现基础 WebSocket 服务器</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade},
    response::Html,
    routing::get,
    Router,
};
use std::net::SocketAddr;
use tokio::net::TcpListener;
use tower_http::cors::CorsLayer;
use tracing::{info, warn, error};

#[tokio::main]
async fn main() {
    // 初始化日志
    tracing_subscriber::init();
    
    // 构建应用路由
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .layer(CorsLayer::permissive());
    
    // 启动服务器
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!("WebSocket 服务器启动在 http://{}", addr);
    info!("WebSocket 端点: ws://{}/ws", addr);
    
    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// 提供简单的测试页面
async fn index_handler() -> Html<&'static str> {
    Html(include_str!("../static/index.html"))
}

// WebSocket 升级处理器
async fn websocket_handler(ws: WebSocketUpgrade) -> axum::response::Response {
    info!("收到 WebSocket 升级请求");
    ws.on_upgrade(handle_websocket)
}

// 处理 WebSocket 连接
async fn handle_websocket(mut socket: WebSocket) {
    info!("WebSocket 连接已建立");
    
    // 发送欢迎消息
    if socket.send(axum::extract::ws::Message::Text(
        "欢迎连接 WebSocket 服务器！".to_string()
    )).await.is_err() {
        error!("发送欢迎消息失败");
        return;
    }
    
    // 持续处理消息
    while let Some(msg) = socket.recv().await {
        match msg {
            Ok(axum::extract::ws::Message::Text(text)) => {
                info!("收到文本消息: {}", text);
                
                // 处理不同类型的消息
                let response = handle_text_message(&text);
                
                if socket.send(axum::extract::ws::Message::Text(response)).await.is_err() {
                    error!("发送响应消息失败");
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Binary(data)) => {
                info!("收到二进制消息，长度: {} 字节", data.len());
                
                // 回显二进制数据
                if socket.send(axum::extract::ws::Message::Binary(data)).await.is_err() {
                    error!("发送二进制响应失败");
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Close(_)) => {
                info!("客户端主动关闭连接");
                break;
            }
            Ok(axum::extract::ws::Message::Ping(data)) => {
                info!("收到 Ping 消息");
                if socket.send(axum::extract::ws::Message::Pong(data)).await.is_err() {
                    error!("发送 Pong 响应失败");
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Pong(_)) => {
                info!("收到 Pong 消息");
            }
            Err(e) => {
                error!("WebSocket 错误: {}", e);
                break;
            }
        }
    }
    
    info!("WebSocket 连接已关闭");
}

// 处理文本消息的业务逻辑
fn handle_text_message(text: &str) -> String {
    match text.trim().to_lowercase().as_str() {
        "hello" | "hi" => "你好！我是 WebSocket 服务器".to_string(),
        "time" => {
            use std::time::{SystemTime, UNIX_EPOCH};
            let timestamp = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();
            format!("当前时间戳: {}", timestamp)
        }
        "ping" => "pong".to_string(),
        "help" => {
            "可用命令:\n- hello: 问候\n- time: 获取时间\n- ping: 测试连接\n- help: 显示帮助".to_string()
        }
        _ => format!("收到消息: {} (长度: {} 字符)", text, text.len()),
    }
}</pre>

        <p><strong>步骤 3: 创建测试页面</strong></p>
        <p><strong>创建 static/index.html：</strong></p>
        <pre>mkdir static</pre>
        
        <p><strong>static/index.html 内容：</strong></p>
        <pre>&lt;!DOCTYPE html>
&lt;html lang="zh-CN">
&lt;head>
    &lt;meta charset="UTF-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
    &lt;title>WebSocket 测试页面&lt;/title>
    &lt;style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .connected { background-color: #d4edda; color: #155724; }
        .disconnected { background-color: #f8d7da; color: #721c24; }
        .connecting { background-color: #fff3cd; color: #856404; }
        #messages {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            background-color: #fafafa;
            font-family: monospace;
        }
        .message {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        .sent { background-color: #e3f2fd; text-align: right; }
        .received { background-color: #f1f8e9; }
        .system { background-color: #fff3e0; font-style: italic; }
        input[type="text"] {
            width: 70%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .connect-btn { background-color: #28a745; color: white; }
        .disconnect-btn { background-color: #dc3545; color: white; }
        .send-btn { background-color: #007bff; color: white; }
        .clear-btn { background-color: #6c757d; color: white; }
    &lt;/style>
&lt;/head>
&lt;body>
    &lt;div class="container">
        &lt;h1>WebSocket 测试页面&lt;/h1>
        
        &lt;div class="controls">
            &lt;div id="status" class="status disconnected">未连接&lt;/div>
            
            &lt;div>
                &lt;input type="text" id="wsUrl" value="ws://localhost:3000/ws" placeholder="WebSocket URL">
                &lt;button id="connectBtn" class="connect-btn">连接&lt;/button>
                &lt;button id="disconnectBtn" class="disconnect-btn" disabled>断开&lt;/button>
            &lt;/div>
        &lt;/div>
        
        &lt;div id="messages">&lt;/div>
        
        &lt;div class="input-area">
            &lt;input type="text" id="messageInput" placeholder="输入消息..." disabled>
            &lt;button id="sendBtn" class="send-btn" disabled>发送&lt;/button>
            &lt;button id="clearBtn" class="clear-btn">清空&lt;/button>
        &lt;/div>
        
        &lt;div class="quick-commands">
            &lt;h3>快速命令：&lt;/h3>
            &lt;button class="send-btn" onclick="sendQuickMessage('hello')">Hello&lt;/button>
            &lt;button class="send-btn" onclick="sendQuickMessage('time')">获取时间&lt;/button>
            &lt;button class="send-btn" onclick="sendQuickMessage('ping')">Ping&lt;/button>
            &lt;button class="send-btn" onclick="sendQuickMessage('help')">帮助&lt;/button>
        &lt;/div>
    &lt;/div>

    &lt;script>
        let ws = null;
        const status = document.getElementById('status');
        const messages = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const wsUrl = document.getElementById('wsUrl');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const sendBtn = document.getElementById('sendBtn');
        const clearBtn = document.getElementById('clearBtn');

        function addMessage(content, type = 'system') {
            const div = document.createElement('div');
            div.className = `message ${type}`;
            div.innerHTML = `&lt;span class="time">[${new Date().toLocaleTimeString()}]&lt;/span> ${content}`;
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
        }

        function updateStatus(text, className) {
            status.textContent = text;
            status.className = `status ${className}`;
        }

        function connect() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                addMessage('已经连接了！', 'system');
                return;
            }

            const url = wsUrl.value.trim();
            if (!url) {
                addMessage('请输入 WebSocket URL', 'system');
                return;
            }

            updateStatus('连接中...', 'connecting');
            addMessage(`正在连接 ${url}...`, 'system');

            ws = new WebSocket(url);

            ws.onopen = function(event) {
                updateStatus('已连接', 'connected');
                addMessage('WebSocket 连接成功！', 'system');
                
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                messageInput.disabled = false;
                sendBtn.disabled = false;
            };

            ws.onmessage = function(event) {
                addMessage(event.data, 'received');
            };

            ws.onclose = function(event) {
                updateStatus('未连接', 'disconnected');
                addMessage(`连接已关闭 (代码: ${event.code})`, 'system');
                
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                messageInput.disabled = true;
                sendBtn.disabled = true;
            };

            ws.onerror = function(error) {
                updateStatus('连接错误', 'disconnected');
                addMessage('WebSocket 连接出错', 'system');
                console.error('WebSocket错误:', error);
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
            }
        }

        function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(message);
                addMessage(message, 'sent');
                messageInput.value = '';
            } else {
                addMessage('未连接到服务器', 'system');
            }
        }

        function sendQuickMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(message);
                addMessage(message, 'sent');
            } else {
                addMessage('未连接到服务器', 'system');
            }
        }

        function clearMessages() {
            messages.innerHTML = '';
        }

        // 事件监听
        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);
        sendBtn.addEventListener('click', sendMessage);
        clearBtn.addEventListener('click', clearMessages);

        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // 页面加载完成后的提示
        addMessage('页面加载完成，点击"连接"按钮开始测试', 'system');
    &lt;/script>
&lt;/body>
&lt;/html></pre>

        <p><strong>步骤 4: 改进版 main.rs（支持静态文件服务）</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade},
    http::StatusCode,
    response::Html,
    routing::get,
    Router,
};
use std::net::SocketAddr;
use tokio::net::TcpListener;
use tower::ServiceBuilder;
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{info, warn, error};

#[tokio::main]
async fn main() {
    // 初始化日志
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .init();
    
    // 构建应用路由
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .nest_service("/static", ServeDir::new("static"))
        .layer(
            ServiceBuilder::new()
                .layer(CorsLayer::permissive())
        );
    
    // 启动服务器
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!("🚀 WebSocket 服务器启动在 http://{}", addr);
    info!("📡 WebSocket 端点: ws://{}/ws", addr);
    info!("🌐 测试页面: http://{}/", addr);
    
    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// 主页处理器
async fn index_handler() -> Result<Html<String>, StatusCode> {
    match tokio::fs::read_to_string("static/index.html").await {
        Ok(content) => Ok(Html(content)),
        Err(_) => Ok(Html(r#"
&lt;h1>WebSocket 服务器&lt;/h1>
&lt;p>请在浏览器中访问 ws://localhost:3000/ws&lt;/p>
&lt;script>
const ws = new WebSocket('ws://localhost:3000/ws');
ws.onopen = () => console.log('连接成功');
ws.onmessage = (e) => console.log('收到消息:', e.data);
ws.onclose = () => console.log('连接关闭');
&lt;/script>
        "#.to_string())),
    }
}

// WebSocket 升级处理器
async fn websocket_handler(ws: WebSocketUpgrade) -> axum::response::Response {
    info!("🔗 收到 WebSocket 升级请求");
    ws.on_upgrade(handle_websocket)
}

// 处理 WebSocket 连接
async fn handle_websocket(mut socket: WebSocket) {
    let client_id = uuid::Uuid::new_v4().to_string()[..8].to_string();
    info!("✅ WebSocket 连接已建立，客户端 ID: {}", client_id);
    
    // 发送欢迎消息
    let welcome_msg = format!("🎉 欢迎连接 WebSocket 服务器！\n客户端 ID: {}\n输入 'help' 查看可用命令", client_id);
    if socket.send(axum::extract::ws::Message::Text(welcome_msg)).await.is_err() {
        error!("❌ 发送欢迎消息失败，客户端: {}", client_id);
        return;
    }
    
    // 消息计数器
    let mut message_count = 0;
    
    // 持续处理消息
    while let Some(msg) = socket.recv().await {
        message_count += 1;
        
        match msg {
            Ok(axum::extract::ws::Message::Text(text)) => {
                info!("📩 客户端 {} 发送消息 (#{}) : {}", client_id, message_count, text);
                
                // 处理不同类型的消息
                let response = handle_text_message(&text, &client_id, message_count);
                
                if socket.send(axum::extract::ws::Message::Text(response)).await.is_err() {
                    error!("❌ 发送响应消息失败，客户端: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Binary(data)) => {
                info!("📦 客户端 {} 发送二进制消息，长度: {} 字节", client_id, data.len());
                
                // 创建响应消息
                let response = format!("✅ 收到 {} 字节的二进制数据", data.len());
                if socket.send(axum::extract::ws::Message::Text(response)).await.is_err() {
                    error!("❌ 发送二进制响应失败，客户端: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Close(close_frame)) => {
                info!("👋 客户端 {} 主动关闭连接: {:?}", client_id, close_frame);
                break;
            }
            Ok(axum::extract::ws::Message::Ping(data)) => {
                info!("🏓 收到客户端 {} 的 Ping 消息", client_id);
                if socket.send(axum::extract::ws::Message::Pong(data)).await.is_err() {
                    error!("❌ 发送 Pong 响应失败，客户端: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Pong(_)) => {
                info!("🏓 收到客户端 {} 的 Pong 消息", client_id);
            }
            Err(e) => {
                error!("💥 WebSocket 错误，客户端 {}: {}", client_id, e);
                break;
            }
        }
    }
    
    info!("🔌 WebSocket 连接已关闭，客户端: {} (共处理 {} 条消息)", client_id, message_count);
}

// 处理文本消息的业务逻辑
fn handle_text_message(text: &str, client_id: &str, message_count: usize) -> String {
    let command = text.trim().to_lowercase();
    
    match command.as_str() {
        "hello" | "hi" | "你好" => {
            format!("👋 你好！我是 WebSocket 服务器\n客户端 ID: {}\n这是你发送的第 {} 条消息", client_id, message_count)
        }
        "time" | "时间" => {
            use chrono::{Local, Utc};
            format!("🕒 当前时间信息:\n本地时间: {}\nUTC 时间: {}\n时间戳: {}", 
                Local::now().format("%Y-%m-%d %H:%M:%S"),
                Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
                std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_secs()
            )
        }
        "ping" => "🏓 pong".to_string(),
        "status" | "状态" => {
            format!("📊 连接状态:\n✅ 连接正常\n📨 已处理消息: {} 条\n🆔 客户端 ID: {}", message_count, client_id)
        }
        "help" | "帮助" => {
            "📚 可用命令:\n\
            • hello/hi/你好 - 问候服务器\n\
            • time/时间 - 获取当前时间\n\
            • ping - 测试连接\n\
            • status/状态 - 查看连接状态\n\
            • help/帮助 - 显示此帮助信息\n\
            • echo <消息> - 回显消息\n\
            • count - 显示消息计数\n\
            \n💡 你也可以发送任意文本，服务器会回复确认信息".to_string()
        }
        _ if command.starts_with("echo ") => {
            let echo_text = &text[5..];
            format!("🔊 回显: {}", echo_text)
        }
        "count" | "计数" => {
            format!("🔢 消息计数: 这是你发送的第 {} 条消息", message_count)
        }
        _ => {
            format!("📝 收到消息: \"{}\"\n📏 消息长度: {} 字符\n🔢 消息编号: #{}\n\n💡 输入 'help' 查看可用命令", 
                text, text.len(), message_count)
        }
    }
}

// 添加 UUID 依赖以生成客户端 ID
// 在 Cargo.toml 中添加: uuid = { version = "1.0", features = ["v4"] }
// chrono = { version = "0.4", features = ["serde"] }</pre>

        <p><strong>步骤 5: 更新依赖并测试</strong></p>
        <pre># 更新 Cargo.toml 添加新依赖
[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.20"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }</pre>

        <p><strong>运行测试：</strong></p>
        <pre># 启动服务器
cargo run

# 在另一个终端使用 websocat 测试（如果已安装）
websocat ws://localhost:3000/ws

# 或者在浏览器中访问 http://localhost:3000</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>实现一个简单的命令系统，支持多种指令响应</li>
            <li>添加连接计数功能，显示当前活跃连接数</li>
            <li>实现消息历史记录功能</li>
            <li>添加心跳检测机制</li>
            <li>创建一个简单的 Web 测试界面</li>
        </ul>

        <p><strong>步骤 6: 命令行客户端测试工具</strong></p>
        <p><strong>创建 client.rs：</strong></p>
        <pre>// src/client.rs
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};
use futures_util::{SinkExt, StreamExt};
use std::io::{self, Write};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 WebSocket 客户端启动");
    
    let url = "ws://127.0.0.1:3000/ws";
    println!("🔗 连接到: {}", url);
    
    let (ws_stream, _) = connect_async(url).await?;
    println!("✅ WebSocket 连接成功！");
    
    let (mut write, mut read) = ws_stream.split();
    
    // 启动接收消息的任务
    let read_handle = tokio::spawn(async move {
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    println!("📩 服务器: {}", text);
                }
                Ok(Message::Binary(data)) => {
                    println!("📦 收到二进制数据: {} 字节", data.len());
                }
                Ok(Message::Close(_)) => {
                    println!("👋 服务器关闭了连接");
                    break;
                }
                Err(e) => {
                    println!("❌ 接收消息错误: {}", e);
                    break;
                }
                _ => {}
            }
        }
    });
    
    // 主线程处理用户输入
    println!("\n💡 输入消息并按回车发送，输入 'quit' 退出");
    println!("📚 可用命令: hello, time, ping, status, help, echo <消息>");
    
    loop {
        print!("👤 你: ");
        io::stdout().flush().unwrap();
        
        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();
        
        if input == "quit" || input == "exit" {
            break;
        }
        
        if !input.is_empty() {
            if write.send(Message::Text(input.to_string())).await.is_err() {
                println!("❌ 发送消息失败");
                break;
            }
        }
    }
    
    println!("👋 正在关闭连接...");
    let _ = write.send(Message::Close(None)).await;
    read_handle.abort();
    
    Ok(())
}</pre>

        <p><strong>编译并运行客户端：</strong></p>
        <pre># 编译客户端
rustc --edition 2021 src/client.rs -o client \
  --extern tokio_tungstenite \
  --extern tokio \
  --extern futures_util

# 或者添加到 Cargo.toml 的 [[bin]] 部分
[[bin]]
name = "client"
path = "src/client.rs"

# 然后运行
cargo run --bin client</pre>

        <pre>📁 项目结构：
day15_websocket_basic/
├── src/
│   ├── main.rs
│   └── client.rs
├── static/
│   └── index.html
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-16</strong></p>
        <h2>Day 16 - WebSocket Echo 实现</h2>
        <p>你将写一个完整的 Echo 服务：客户端发什么，服务端返回什么，并支持持续通信，直到客户端断开连接。</p>
        <p>🔗 <a href="https://github.com/tokio-rs/axum/blob/main/examples/websockets/chat.rs" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目并配置依赖</strong></p>
        <pre>cargo new day16_websocket_echo
cd day16_websocket_echo</pre>

        <p><strong>配置 Cargo.toml：</strong></p>
        <pre>[package]
name = "day16_websocket_echo"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.20"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
futures-util = "0.3"

[[bin]]
name = "server"
path = "src/main.rs"

[[bin]]
name = "client"
path = "src/client.rs"</pre>

        <p><strong>步骤 2: 实现 Echo WebSocket 服务器</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade},
    http::StatusCode,
    response::Html,
    routing::get,
    Router,
};
use futures_util::{SinkExt, StreamExt};
use std::{net::SocketAddr, sync::atomic::{AtomicUsize, Ordering}};
use tokio::net::TcpListener;
use tower::ServiceBuilder;
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{info, warn, error, debug};

// 全局连接计数器
static CONNECTED_USERS: AtomicUsize = AtomicUsize::new(0);

#[tokio::main]
async fn main() {
    // 初始化日志
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .with_level(true)
        .init();
    
    // 构建应用路由
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .route("/stats", get(stats_handler))
        .nest_service("/static", ServeDir::new("static"))
        .layer(
            ServiceBuilder::new()
                .layer(CorsLayer::permissive())
        );
    
    // 启动服务器
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!("🚀 WebSocket Echo 服务器启动在 http://{}", addr);
    info!("📡 WebSocket 端点: ws://{}/ws", addr);
    info!("🌐 测试页面: http://{}/", addr);
    info!("📊 统计页面: http://{}/stats", addr);
    
    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// 主页处理器
async fn index_handler() -> Html<&'static str> {
    Html(include_str!("../templates/echo.html"))
}

// 统计页面处理器
async fn stats_handler() -> Result<axum::Json<serde_json::Value>, StatusCode> {
    let stats = serde_json::json!({
        "connected_users": CONNECTED_USERS.load(Ordering::Relaxed),
        "server_uptime": chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC").to_string(),
        "service_type": "WebSocket Echo Server"
    });
    Ok(axum::Json(stats))
}

// WebSocket 升级处理器
async fn websocket_handler(ws: WebSocketUpgrade) -> axum::response::Response {
    let current_connections = CONNECTED_USERS.fetch_add(1, Ordering::Relaxed) + 1;
    info!("🔗 收到 WebSocket 升级请求 (当前连接数: {})", current_connections);
    ws.on_upgrade(handle_websocket)
}

// 处理 WebSocket 连接 - Echo 实现
async fn handle_websocket(socket: WebSocket) {
    let client_id = uuid::Uuid::new_v4().to_string()[..8].to_string();
    let connected_time = chrono::Utc::now();
    info!("✅ Echo 连接已建立，客户端 ID: {} (连接时间: {})", 
          client_id, connected_time.format("%H:%M:%S"));
    
    // 分离 socket 为发送和接收部分
    let (mut sender, mut receiver) = socket.split();
    
    // 发送欢迎消息
    let welcome_msg = serde_json::json!({
        "type": "welcome",
        "client_id": client_id,
        "message": "🎉 欢迎连接 WebSocket Echo 服务器！",
        "server_time": chrono::Utc::now().to_rfc3339(),
        "instructions": "发送任何消息，服务器将原样返回。发送 JSON 可获得结构化响应。"
    });
    
    if sender.send(axum::extract::ws::Message::Text(
        serde_json::to_string(&welcome_msg).unwrap()
    )).await.is_err() {
        error!("❌ 发送欢迎消息失败，客户端: {}", client_id);
        CONNECTED_USERS.fetch_sub(1, Ordering::Relaxed);
        return;
    }
    
    // 消息统计
    let mut messages_echoed = 0;
    let mut bytes_processed = 0;
    
    // Echo 消息循环
    while let Some(msg) = receiver.next().await {
        match msg {
            Ok(axum::extract::ws::Message::Text(text)) => {
                debug!("📩 客户端 {} 发送文本: {}", client_id, text);
                messages_echoed += 1;
                bytes_processed += text.len();
                
                // 尝试解析为 JSON，如果是 JSON 则增强响应
                let echo_response = if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(&text) {
                    // JSON 消息的增强回显
                    let enhanced_response = serde_json::json!({
                        "type": "json_echo",
                        "client_id": client_id,
                        "echo_count": messages_echoed,
                        "original_message": json_value,
                        "message_size": text.len(),
                        "server_time": chrono::Utc::now().to_rfc3339(),
                        "processing_info": {
                            "is_json": true,
                            "json_valid": true
                        }
                    });
                    serde_json::to_string(&enhanced_response).unwrap()
                } else {
                    // 普通文本消息的简单回显
                    let simple_response = serde_json::json!({
                        "type": "text_echo", 
                        "client_id": client_id,
                        "echo_count": messages_echoed,
                        "original_message": text,
                        "message_size": text.len(),
                        "server_time": chrono::Utc::now().to_rfc3339(),
                        "processing_info": {
                            "is_json": false,
                            "message_type": "plain_text"
                        }
                    });
                    serde_json::to_string(&simple_response).unwrap()
                };
                
                if sender.send(axum::extract::ws::Message::Text(echo_response)).await.is_err() {
                    error!("❌ Echo 响应发送失败，客户端: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Binary(data)) => {
                debug!("📦 客户端 {} 发送二进制数据: {} 字节", client_id, data.len());
                messages_echoed += 1;
                bytes_processed += data.len();
                
                // 二进制数据的 Echo 响应（包含元数据）
                let binary_info = serde_json::json!({
                    "type": "binary_echo_info",
                    "client_id": client_id,
                    "echo_count": messages_echoed,
                    "data_size": data.len(),
                    "server_time": chrono::Utc::now().to_rfc3339(),
                    "note": "二进制数据已原样返回"
                });
                
                // 先发送信息，再发送原始二进制数据
                if sender.send(axum::extract::ws::Message::Text(
                    serde_json::to_string(&binary_info).unwrap()
                )).await.is_err() {
                    error!("❌ 二进制信息发送失败，客户端: {}", client_id);
                    break;
                }
                
                if sender.send(axum::extract::ws::Message::Binary(data)).await.is_err() {
                    error!("❌ 二进制数据 Echo 失败，客户端: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Close(close_frame)) => {
                info!("👋 客户端 {} 主动关闭连接: {:?}", client_id, close_frame);
                break;
            }
            Ok(axum::extract::ws::Message::Ping(data)) => {
                debug!("🏓 收到客户端 {} 的 Ping", client_id);
                if sender.send(axum::extract::ws::Message::Pong(data)).await.is_err() {
                    error!("❌ Pong 响应失败，客户端: {}", client_id);
                    break;
                }
            }
            Ok(axum::extract::ws::Message::Pong(_)) => {
                debug!("🏓 收到客户端 {} 的 Pong", client_id);
            }
            Err(e) => {
                error!("💥 WebSocket 错误，客户端 {}: {}", client_id, e);
                break;
            }
        }
    }
    
    // 连接结束统计
    let session_duration = chrono::Utc::now() - connected_time;
    let remaining_connections = CONNECTED_USERS.fetch_sub(1, Ordering::Relaxed) - 1;
    
    info!("🔌 Echo 连接已关闭，客户端: {} | 会话时长: {}秒 | 消息数: {} | 处理字节: {} | 剩余连接: {}", 
          client_id, 
          session_duration.num_seconds(),
          messages_echoed,
          bytes_processed,
          remaining_connections
    );
}</pre>

        <p><strong>步骤 3: 创建测试页面</strong></p>
        <p><strong>创建 templates/echo.html：</strong></p>
        <pre>mkdir templates</pre>
        
        <p><strong>templates/echo.html 内容：</strong></p>
        <pre>&lt;!DOCTYPE html>
&lt;html lang="zh-CN">
&lt;head>
    &lt;meta charset="UTF-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
    &lt;title>WebSocket Echo 测试&lt;/title>
    &lt;style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
        }
        .status {
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
        }
        .connected { background: linear-gradient(135deg, #4CAF50, #45a049); color: white; }
        .disconnected { background: linear-gradient(135deg, #f44336, #da190b); color: white; }
        .connecting { background: linear-gradient(135deg, #ff9800, #f57c00); color: white; }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
            align-items: center;
        }
        input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .connect-btn { background: linear-gradient(135deg, #28a745, #20c997); color: white; }
        .disconnect-btn { background: linear-gradient(135deg, #dc3545, #c82333); color: white; }
        .send-btn { background: linear-gradient(135deg, #007bff, #0056b3); color: white; }
        .clear-btn { background: linear-gradient(135deg, #6c757d, #545b62); color: white; }
        .json-btn { background: linear-gradient(135deg, #17a2b8, #138496); color: white; }
        #messages {
            height: 400px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
            padding: 15px;
            margin: 20px 0;
            background: #f8f9fa;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            border-radius: 8px;
        }
        .message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 6px;
            word-wrap: break-word;
        }
        .sent { 
            background: linear-gradient(135deg, #e3f2fd, #bbdefb); 
            text-align: right; 
            border-left: 4px solid #2196F3;
        }
        .received { 
            background: linear-gradient(135deg, #f1f8e9, #c8e6c9); 
            border-left: 4px solid #4CAF50;
        }
        .system { 
            background: linear-gradient(135deg, #fff3e0, #ffe0b2); 
            font-style: italic; 
            border-left: 4px solid #FF9800;
        }
        .json-display {
            background: #2d3748;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 6px;
            margin: 5px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            white-space: pre-wrap;
            font-size: 12px;
        }
        .quick-commands {
            margin: 20px 0;
        }
        .quick-commands h3 {
            color: #495057;
            margin-bottom: 15px;
        }
        .command-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
    &lt;/style>
&lt;/head>
&lt;body>
    &lt;div class="container">
        &lt;h1>🔄 WebSocket Echo 服务器测试&lt;/h1>
        
        &lt;div class="stats">
            &lt;div class="stat-item">
                &lt;div class="stat-value" id="messageCount">0&lt;/div>
                &lt;div class="stat-label">消息数量&lt;/div>
            &lt;/div>
            &lt;div class="stat-item">
                &lt;div class="stat-value" id="byteCount">0&lt;/div>
                &lt;div class="stat-label">字节传输&lt;/div>
            &lt;/div>
            &lt;div class="stat-item">
                &lt;div class="stat-value" id="connectionTime">00:00&lt;/div>
                &lt;div class="stat-label">连接时长&lt;/div>
            &lt;/div>
        &lt;/div>
        
        &lt;div id="status" class="status disconnected">未连接到服务器&lt;/div>
        
        &lt;div class="controls">
            &lt;input type="text" id="wsUrl" value="ws://localhost:3000/ws" placeholder="WebSocket URL">
            &lt;button id="connectBtn" class="connect-btn">🔗 连接&lt;/button>
            &lt;button id="disconnectBtn" class="disconnect-btn" disabled>🔌 断开&lt;/button>
        &lt;/div>
        
        &lt;div id="messages">&lt;/div>
        
        &lt;div class="controls">
            &lt;input type="text" id="messageInput" placeholder="输入要回显的消息..." disabled>
            &lt;button id="sendBtn" class="send-btn" disabled>📤 发送&lt;/button>
            &lt;button id="clearBtn" class="clear-btn">🗑️ 清空&lt;/button>
        &lt;/div>
        
        &lt;div class="quick-commands">
            &lt;h3>🚀 快速测试命令&lt;/h3>
            &lt;div class="command-grid">
                &lt;button class="json-btn" onclick="sendPredefined('simple')">📝 简单文本&lt;/button>
                &lt;button class="json-btn" onclick="sendPredefined('json')">📊 JSON 消息&lt;/button>
                &lt;button class="json-btn" onclick="sendPredefined('large')">📦 大消息&lt;/button>
                &lt;button class="json-btn" onclick="sendPredefined('unicode')">🌍 Unicode&lt;/button>
                &lt;button class="json-btn" onclick="sendPredefined('structured')">🏗️ 结构化数据&lt;/button>
                &lt;button class="json-btn" onclick="sendBinary()">🔢 二进制数据&lt;/button>
            &lt;/div>
        &lt;/div>
    &lt;/div>

    &lt;script>
        let ws = null;
        let messageCount = 0;
        let byteCount = 0;
        let connectionStartTime = null;
        let timerInterval = null;

        const elements = {
            status: document.getElementById('status'),
            messages: document.getElementById('messages'),
            messageInput: document.getElementById('messageInput'),
            wsUrl: document.getElementById('wsUrl'),
            connectBtn: document.getElementById('connectBtn'),
            disconnectBtn: document.getElementById('disconnectBtn'),
            sendBtn: document.getElementById('sendBtn'),
            clearBtn: document.getElementById('clearBtn'),
            messageCountEl: document.getElementById('messageCount'),
            byteCountEl: document.getElementById('byteCount'),
            connectionTimeEl: document.getElementById('connectionTime')
        };

        function addMessage(content, type = 'system') {
            const div = document.createElement('div');
            div.className = `message ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            let displayContent = content;
            
            // 尝试格式化 JSON
            if (type === 'received' && typeof content === 'string') {
                try {
                    const jsonObj = JSON.parse(content);
                    displayContent = `&lt;div class="json-display">${JSON.stringify(jsonObj, null, 2)}&lt;/div>`;
                } catch (e) {
                    // 不是 JSON，保持原样
                }
            }
            
            div.innerHTML = `&lt;span style="opacity: 0.7; font-size: 11px;">[${timestamp}]&lt;/span> ${displayContent}`;
            elements.messages.appendChild(div);
            elements.messages.scrollTop = elements.messages.scrollHeight;
        }

        function updateStatus(text, className) {
            elements.status.textContent = text;
            elements.status.className = `status ${className}`;
        }

        function updateStats() {
            elements.messageCountEl.textContent = messageCount;
            elements.byteCountEl.textContent = byteCount.toLocaleString();
            
            if (connectionStartTime) {
                const elapsed = Math.floor((Date.now() - connectionStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                elements.connectionTimeEl.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function connect() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                addMessage('已经连接了！', 'system');
                return;
            }

            const url = elements.wsUrl.value.trim();
            if (!url) {
                addMessage('请输入 WebSocket URL', 'system');
                return;
            }

            updateStatus('连接中...', 'connecting');
            addMessage(`🔗 正在连接 ${url}...`, 'system');

            ws = new WebSocket(url);

            ws.onopen = function(event) {
                updateStatus('✅ 已连接 - Echo 模式', 'connected');
                addMessage('🎉 WebSocket Echo 连接成功！服务器将回显所有消息', 'system');
                
                elements.connectBtn.disabled = true;
                elements.disconnectBtn.disabled = false;
                elements.messageInput.disabled = false;
                elements.sendBtn.disabled = false;
                
                connectionStartTime = Date.now();
                timerInterval = setInterval(updateStats, 1000);
            };

            ws.onmessage = function(event) {
                addMessage(event.data, 'received');
                messageCount++;
                byteCount += event.data.length;
                updateStats();
            };

            ws.onclose = function(event) {
                updateStatus('❌ 未连接', 'disconnected');
                addMessage(`🔌 连接已关闭 (代码: ${event.code})`, 'system');
                
                elements.connectBtn.disabled = false;
                elements.disconnectBtn.disabled = true;
                elements.messageInput.disabled = true;
                elements.sendBtn.disabled = true;
                
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
            };

            ws.onerror = function(error) {
                updateStatus('❌ 连接错误', 'disconnected');
                addMessage('💥 WebSocket 连接出错', 'system');
                console.error('WebSocket错误:', error);
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
            }
        }

        function sendMessage() {
            const message = elements.messageInput.value.trim();
            if (!message) return;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(message);
                addMessage(message, 'sent');
                elements.messageInput.value = '';
            } else {
                addMessage('❌ 未连接到服务器', 'system');
            }
        }

        function sendPredefined(type) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('❌ 未连接到服务器', 'system');
                return;
            }

            let message;
            switch (type) {
                case 'simple':
                    message = 'Hello, WebSocket Echo Server! 🌟';
                    break;
                case 'json':
                    message = JSON.stringify({
                        type: 'test_message',
                        timestamp: new Date().toISOString(),
                        data: { hello: 'world', numbers: [1, 2, 3] }
                    });
                    break;
                case 'large':
                    message = 'A'.repeat(1000) + ' - This is a large message for testing!';
                    break;
                case 'unicode':
                    message = '🌟 Hello 世界 🚀 Привет мир 🎉 مرحبا بالعالم 🌈';
                    break;
                case 'structured':
                    message = JSON.stringify({
                        user: 'test_user',
                        action: 'echo_test',
                        timestamp: Date.now(),
                        metadata: {
                            client: 'web_browser',
                            version: '1.0.0'
                        },
                        payload: {
                            message: 'This is a structured test message',
                            tags: ['test', 'echo', 'websocket']
                        }
                    }, null, 2);
                    break;
            }

            ws.send(message);
            addMessage(message, 'sent');
        }

        function sendBinary() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('❌ 未连接到服务器', 'system');
                return;
            }

            // 创建一些二进制数据
            const data = new Uint8Array([1, 2, 3, 4, 5, 255, 254, 253]);
            ws.send(data);
            addMessage(`📦 发送二进制数据: [${Array.from(data).join(', ')}]`, 'sent');
        }

        function clearMessages() {
            elements.messages.innerHTML = '';
            messageCount = 0;
            byteCount = 0;
            updateStats();
        }

        // 事件监听
        elements.connectBtn.addEventListener('click', connect);
        elements.disconnectBtn.addEventListener('click', disconnect);
        elements.sendBtn.addEventListener('click', sendMessage);
        elements.clearBtn.addEventListener('click', clearMessages);

        elements.messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // 页面加载完成后的提示
        addMessage('🚀 Echo 测试页面加载完成，点击"连接"按钮开始测试', 'system');
        addMessage('💡 Echo 模式：服务器将原样返回你发送的所有消息', 'system');
    &lt;/script>
&lt;/body>
&lt;/html></pre>

        <p><strong>步骤 4: 创建命令行测试客户端</strong></p>
        <p><strong>创建 src/client.rs：</strong></p>
        <pre>use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};
use futures_util::{SinkExt, StreamExt};
use std::io::{self, Write};
use serde_json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🔄 WebSocket Echo 客户端启动");
    println!("=====================================");
    
    let url = "ws://127.0.0.1:3000/ws";
    println!("🔗 连接到: {}", url);
    
    let (ws_stream, _) = connect_async(url).await?;
    println!("✅ WebSocket Echo 连接成功！");
    println!("📝 服务器将回显你发送的所有消息");
    
    let (mut write, mut read) = ws_stream.split();
    
    // 启动接收消息的任务
    let read_handle = tokio::spawn(async move {
        let mut message_count = 0;
        
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    message_count += 1;
                    println!("\n📩 服务器回显 (#{}):", message_count);
                    
                    // 尝试格式化 JSON 响应
                    if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(&text) {
                        println!("{}", serde_json::to_string_pretty(&json_value).unwrap());
                    } else {
                        println!("{}", text);
                    }
                    print!("\n👤 你: ");
                    io::stdout().flush().unwrap();
                }
                Ok(Message::Binary(data)) => {
                    message_count += 1;
                    println!("\n📦 服务器回显二进制数据 (#{}): {} 字节", message_count, data.len());
                    println!("数据内容: {:?}", data);
                    print!("\n👤 你: ");
                    io::stdout().flush().unwrap();
                }
                Ok(Message::Close(close_frame)) => {
                    println!("\n👋 服务器关闭了连接: {:?}", close_frame);
                    break;
                }
                Ok(Message::Ping(_)) => {
                    println!("\n🏓 收到服务器 Ping");
                }
                Ok(Message::Pong(_)) => {
                    println!("\n🏓 收到服务器 Pong");
                }
                Err(e) => {
                    println!("\n❌ 接收消息错误: {}", e);
                    break;
                }
            }
        }
    });
    
    // 主线程处理用户输入
    println!("\n💡 使用说明:");
    println!("- 输入任何文本，服务器将原样回显");
    println!("- 输入 JSON 格式数据将获得增强的结构化响应");
    println!("- 输入 'quit' 或 'exit' 退出");
    println!("- 输入 'binary' 发送测试二进制数据");
    println!("- 输入 'json' 发送测试 JSON 数据");
    println!("\n开始测试:");
    
    loop {
        print!("👤 你: ");
        io::stdout().flush().unwrap();
        
        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();
        
        if input == "quit" || input == "exit" {
            break;
        }
        
        if input.is_empty() {
            continue;
        }
        
        // 特殊命令处理
        match input {
            "binary" => {
                let test_data = vec![1u8, 2, 3, 4, 5, 255, 254, 253, 252];
                println!("📤 发送二进制测试数据: {:?}", test_data);
                if write.send(Message::Binary(test_data)).await.is_err() {
                    println!("❌ 发送二进制数据失败");
                    break;
                }
            }
            "json" => {
                let test_json = serde_json::json!({
                    "type": "test_message",
                    "timestamp": chrono::Utc::now().to_rfc3339(),
                    "client": "rust_cli",
                    "data": {
                        "message": "这是一个测试 JSON 消息",
                        "number": 42,
                        "array": [1, 2, 3, "hello", true],
                        "nested": {
                            "key": "value"
                        }
                    }
                });
                let json_string = serde_json::to_string(&test_json).unwrap();
                println!("📤 发送 JSON 测试数据");
                if write.send(Message::Text(json_string)).await.is_err() {
                    println!("❌ 发送 JSON 数据失败");
                    break;
                }
            }
            _ => {
                // 普通文本消息
                if write.send(Message::Text(input.to_string())).await.is_err() {
                    println!("❌ 发送消息失败");
                    break;
                }
            }
        }
    }
    
    println!("👋 正在关闭 Echo 连接...");
    let _ = write.send(Message::Close(None)).await;
    read_handle.abort();
    
    Ok(())
}</pre>

        <p><strong>更新 Cargo.toml 添加客户端依赖：</strong></p>
        <pre>[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.20"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
futures-util = "0.3"</pre>

        <p><strong>步骤 5: 高级 Echo 服务功能</strong></p>
        <p><strong>创建 src/advanced_echo.rs 展示更多功能：</strong></p>
        <pre>// src/advanced_echo.rs - 高级 Echo 功能演示
use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade, Query},
    response::Html,
    routing::get,
    Router,
};
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    sync::{atomic::{AtomicUsize, Ordering}, Arc},
    time::{SystemTime, UNIX_EPOCH},
};
use tokio::sync::RwLock;
use uuid::Uuid;

// Echo 服务器状态
#[derive(Debug, Clone)]
pub struct EchoStats {
    total_connections: usize,
    total_messages: usize,
    total_bytes: usize,
    start_time: u64,
}

// 连接查询参数
#[derive(Debug, Deserialize)]
pub struct ConnectParams {
    #[serde(default)]
    echo_format: String,  // "simple", "enhanced", "json"
    #[serde(default)]
    client_name: String,
}

// Echo 响应格式
#[derive(Debug, Serialize)]
pub struct EchoResponse {
    echo_id: String,
    client_id: String,
    echo_format: String,
    original_message: serde_json::Value,
    echo_time: String,
    message_stats: MessageStats,
    server_info: ServerInfo,
}

#[derive(Debug, Serialize)]
pub struct MessageStats {
    message_length: usize,
    message_type: String,
    is_json: bool,
    word_count: usize,
}

#[derive(Debug, Serialize)]
pub struct ServerInfo {
    server_uptime: String,
    total_connections: usize,
    current_connections: usize,
}

// 全局状态
pub struct EchoServer {
    stats: Arc<RwLock<EchoStats>>,
    active_connections: Arc<AtomicUsize>,
}

impl EchoServer {
    pub fn new() -> Self {
        Self {
            stats: Arc::new(RwLock::new(EchoStats {
                total_connections: 0,
                total_messages: 0,
                total_bytes: 0,
                start_time: SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_secs(),
            })),
            active_connections: Arc::new(AtomicUsize::new(0)),
        }
    }

    // 高级 Echo 处理器
    pub async fn handle_advanced_websocket(
        &self,
        ws: WebSocketUpgrade,
        params: Query<ConnectParams>,
    ) -> axum::response::Response {
        let echo_format = if params.echo_format.is_empty() {
            "enhanced".to_string()
        } else {
            params.echo_format.clone()
        };

        let client_name = if params.client_name.is_empty() {
            format!("client_{}", Uuid::new_v4().to_string()[..6].to_string())
        } else {
            params.client_name.clone()
        };

        let stats = self.stats.clone();
        let active_connections = self.active_connections.clone();

        // 更新连接统计
        {
            let mut stats_guard = stats.write().await;
            stats_guard.total_connections += 1;
        }
        active_connections.fetch_add(1, Ordering::Relaxed);

        ws.on_upgrade(move |socket| {
            Self::handle_echo_connection(
                socket,
                client_name,
                echo_format,
                stats,
                active_connections,
            )
        })
    }

    async fn handle_echo_connection(
        socket: WebSocket,
        client_name: String,
        echo_format: String,
        stats: Arc<RwLock<EchoStats>>,
        active_connections: Arc<AtomicUsize>,
    ) {
        let client_id = Uuid::new_v4().to_string()[..8].to_string();
        tracing::info!("🔗 高级 Echo 连接: {} ({})", client_name, client_id);

        let (mut sender, mut receiver) = socket.split();

        // 发送连接确认
        let welcome = serde_json::json!({
            "type": "connection_established",
            "client_id": client_id,
            "client_name": client_name,
            "echo_format": echo_format,
            "server_time": chrono::Utc::now().to_rfc3339(),
            "instructions": format!("Echo 格式: {}。发送消息进行测试。", echo_format)
        });

        if sender
            .send(axum::extract::ws::Message::Text(
                serde_json::to_string(&welcome).unwrap(),
            ))
            .await
            .is_err()
        {
            tracing::error!("发送欢迎消息失败: {}", client_id);
            active_connections.fetch_sub(1, Ordering::Relaxed);
            return;
        }

        // 消息处理循环
        while let Some(msg) = receiver.next().await {
            match msg {
                Ok(axum::extract::ws::Message::Text(text)) => {
                    // 更新统计
                    {
                        let mut stats_guard = stats.write().await;
                        stats_guard.total_messages += 1;
                        stats_guard.total_bytes += text.len();
                    }

                    // 生成 Echo 响应
                    let echo_response = Self::create_echo_response(
                        &text,
                        &client_id,
                        &echo_format,
                        &stats,
                        active_connections.load(Ordering::Relaxed),
                    )
                    .await;

                    let response_text = match echo_format.as_str() {
                        "simple" => text, // 简单回显
                        "json" => serde_json::to_string(&echo_response).unwrap(),
                        _ => serde_json::to_string_pretty(&echo_response).unwrap(), // enhanced
                    };

                    if sender
                        .send(axum::extract::ws::Message::Text(response_text))
                        .await
                        .is_err()
                    {
                        tracing::error!("Echo 响应发送失败: {}", client_id);
                        break;
                    }
                }
                Ok(axum::extract::ws::Message::Binary(data)) => {
                    // 二进制数据 Echo
                    {
                        let mut stats_guard = stats.write().await;
                        stats_guard.total_messages += 1;
                        stats_guard.total_bytes += data.len();
                    }

                    if sender
                        .send(axum::extract::ws::Message::Binary(data))
                        .await
                        .is_err()
                    {
                        tracing::error!("二进制 Echo 失败: {}", client_id);
                        break;
                    }
                }
                Ok(axum::extract::ws::Message::Close(_)) => {
                    tracing::info!("客户端关闭连接: {}", client_id);
                    break;
                }
                Err(e) => {
                    tracing::error!("WebSocket 错误: {} - {}", client_id, e);
                    break;
                }
                _ => {}
            }
        }

        active_connections.fetch_sub(1, Ordering::Relaxed);
        tracing::info!("Echo 连接结束: {}", client_id);
    }

    async fn create_echo_response(
        message: &str,
        client_id: &str,
        echo_format: &str,
        stats: &Arc<RwLock<EchoStats>>,
        current_connections: usize,
    ) -> EchoResponse {
        let stats_guard = stats.read().await;

        // 消息分析
        let is_json = serde_json::from_str::<serde_json::Value>(message).is_ok();
        let original_value = if is_json {
            serde_json::from_str(message).unwrap()
        } else {
            serde_json::Value::String(message.to_string())
        };

        let word_count = message.split_whitespace().count();
        let message_type = if is_json {
            "json"
        } else if message.chars().all(|c| c.is_numeric()) {
            "numeric"
        } else if message.chars().all(|c| c.is_alphabetic() || c.is_whitespace()) {
            "text"
        } else {
            "mixed"
        };

        let uptime = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs()
            - stats_guard.start_time;

        EchoResponse {
            echo_id: Uuid::new_v4().to_string(),
            client_id: client_id.to_string(),
            echo_format: echo_format.to_string(),
            original_message: original_value,
            echo_time: chrono::Utc::now().to_rfc3339(),
            message_stats: MessageStats {
                message_length: message.len(),
                message_type: message_type.to_string(),
                is_json,
                word_count,
            },
            server_info: ServerInfo {
                server_uptime: format!("{}秒", uptime),
                total_connections: stats_guard.total_connections,
                current_connections,
            },
        }
    }
}</pre>

        <p><strong>运行和测试：</strong></p>
        <pre># 运行服务器
cargo run --bin server

# 在另一个终端运行客户端
cargo run --bin client

# 或者在浏览器中测试
# http://localhost:3000</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>实现消息延迟回显功能（延迟指定秒数后回显）</li>
            <li>添加消息过滤功能（过滤敏感词汇）</li>
            <li>实现消息转换功能（大小写转换、加密等）</li>
            <li>添加连接限流功能（限制单个 IP 的连接数）</li>
            <li>实现消息持久化（将消息保存到文件或数据库）</li>
            <li>创建性能测试工具，测试并发连接和消息吞吐量</li>
        </ul>

        <pre>📁 项目结构：
day16_websocket_echo/
├── src/
│   ├── main.rs
│   ├── client.rs
│   └── advanced_echo.rs
├── templates/
│   └── echo.html
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-17</strong></p>
        <h2>Day 17 - 广播多个连接：构建聊天室模型</h2>
        <p>你将使用 `tokio::sync::broadcast` 构建一个最小聊天室，支持多个客户端连接并接收所有广播消息。</p>
        <p>🔗 <a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目并配置依赖</strong></p>
        <pre>cargo new day17_websocket_chat
cd day17_websocket_chat</pre>

        <p><strong>配置 Cargo.toml：</strong></p>
        <pre>[package]
name = "day17_websocket_chat"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
futures-util = "0.3"
tokio-tungstenite = "0.20"

[[bin]]
name = "server"
path = "src/main.rs"

[[bin]]
name = "client"
path = "src/client.rs"</pre>

        <p><strong>步骤 2: 实现广播聊天室服务器</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade, State},
    response::Html,
    routing::get,
    Router,
};
use futures_util::{SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    net::SocketAddr,
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc,
    },
};
use tokio::{
    net::TcpListener,
    sync::{broadcast, RwLock},
};
use tower::ServiceBuilder;
use tower_http::cors::CorsLayer;
use tracing::{debug, error, info, warn};
use uuid::Uuid;

// 聊天消息结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    pub msg_type: String,
    pub user_id: String,
    pub username: String,
    pub content: String,
    pub timestamp: String,
    pub room: String,
}

// 用户信息
#[derive(Debug, Clone)]
pub struct User {
    pub id: String,
    pub username: String,
    pub join_time: chrono::DateTime<chrono::Utc>,
    pub room: String,
}

// 应用状态
#[derive(Clone)]
pub struct AppState {
    pub users: Arc<RwLock<HashMap<String, User>>>,
    pub tx: broadcast::Sender<ChatMessage>,
    pub active_connections: Arc<AtomicUsize>,
}

impl AppState {
    pub fn new() -> Self {
        let (tx, _rx) = broadcast::channel(1000); // 支持1000条消息缓冲
        Self {
            users: Arc::new(RwLock::new(HashMap::new())),
            tx,
            active_connections: Arc::new(AtomicUsize::new(0)),
        }
    }
}

#[tokio::main]
async fn main() {
    // 初始化日志
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .with_level(true)
        .init();

    // 创建应用状态
    let state = AppState::new();

    // 构建应用路由
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .route("/api/users", get(get_users))
        .route("/api/stats", get(get_stats))
        .layer(ServiceBuilder::new().layer(CorsLayer::permissive()))
        .with_state(state);

    // 启动服务器
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!("🚀 WebSocket 聊天室服务器启动在 http://{}", addr);
    info!("💬 WebSocket 端点: ws://{}/ws", addr);
    info!("🌐 测试页面: http://{}/", addr);

    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// 主页处理器
async fn index_handler() -> Html<&'static str> {
    Html(include_str!("../templates/chat.html"))
}

// 获取在线用户列表
async fn get_users(State(state): State<AppState>) -> axum::Json<Vec<User>> {
    let users = state.users.read().await;
    let user_list: Vec<User> = users.values().cloned().collect();
    axum::Json(user_list)
}

// 获取服务器统计信息
async fn get_stats(State(state): State<AppState>) -> axum::Json<serde_json::Value> {
    let users = state.users.read().await;
    let stats = serde_json::json!({
        "active_connections": state.active_connections.load(Ordering::Relaxed),
        "registered_users": users.len(),
        "server_time": chrono::Utc::now().to_rfc3339(),
        "uptime": "运行中"
    });
    axum::Json(stats)
}

// WebSocket 升级处理器
async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<AppState>,
) -> axum::response::Response {
    let current_connections = state.active_connections.fetch_add(1, Ordering::Relaxed) + 1;
    info!("🔗 新的 WebSocket 连接 (当前连接数: {})", current_connections);
    ws.on_upgrade(move |socket| handle_websocket(socket, state))
}

// 处理 WebSocket 连接
async fn handle_websocket(socket: WebSocket, state: AppState) {
    let user_id = Uuid::new_v4().to_string();
    let (mut sender, mut receiver) = socket.split();

    // 订阅广播频道
    let mut rx = state.tx.subscribe();

    // 用户信息（初始状态）
    let mut user_info: Option<User> = None;

    // 启动消息广播任务
    let broadcast_task = {
        let user_id = user_id.clone();
        tokio::spawn(async move {
            while let Ok(msg) = rx.recv().await {
                // 不向发送者广播自己的消息
                if msg.user_id == user_id {
                    continue;
                }

                let message_text = serde_json::to_string(&msg).unwrap_or_else(|_| {
                    serde_json::json!({
                        "msg_type": "error",
                        "content": "消息序列化失败"
                    }).to_string()
                });

                if sender
                    .send(axum::extract::ws::Message::Text(message_text))
                    .await
                    .is_err()
                {
                    debug!("客户端 {} 连接已断开", user_id);
                    break;
                }
            }
        })
    };

    // 发送欢迎消息
    let welcome_msg = ChatMessage {
        msg_type: "system".to_string(),
        user_id: "server".to_string(),
        username: "系统".to_string(),
        content: "🎉 欢迎加入聊天室！请发送用户名进行注册。".to_string(),
        timestamp: chrono::Utc::now().to_rfc3339(),
        room: "general".to_string(),
    };

    if sender
        .send(axum::extract::ws::Message::Text(
            serde_json::to_string(&welcome_msg).unwrap(),
        ))
        .await
        .is_err()
    {
        error!("发送欢迎消息失败");
        state.active_connections.fetch_sub(1, Ordering::Relaxed);
        return;
    }

    // 消息处理循环
    while let Some(msg) = receiver.next().await {
        match msg {
            Ok(axum::extract::ws::Message::Text(text)) => {
                debug!("收到消息: {}", text);

                // 尝试解析为 JSON 消息
                if let Ok(incoming_msg) = serde_json::from_str::<serde_json::Value>(&text) {
                    if let Err(e) = handle_chat_message(incoming_msg, &state, &user_id, &mut user_info).await {
                        error!("处理消息失败: {}", e);
                        let error_msg = ChatMessage {
                            msg_type: "error".to_string(),
                            user_id: "server".to_string(),
                            username: "系统".to_string(),
                            content: format!("消息处理失败: {}", e),
                            timestamp: chrono::Utc::now().to_rfc3339(),
                            room: "general".to_string(),
                        };

                        let _ = sender
                            .send(axum::extract::ws::Message::Text(
                                serde_json::to_string(&error_msg).unwrap(),
                            ))
                            .await;
                    }
                } else {
                    // 简单文本消息处理（用于用户名注册）
                    if user_info.is_none() {
                        // 用户尚未注册，将文本作为用户名
                        let username = text.trim().to_string();
                        if !username.is_empty() && username.len() <= 20 {
                            let user = User {
                                id: user_id.clone(),
                                username: username.clone(),
                                join_time: chrono::Utc::now(),
                                room: "general".to_string(),
                            };

                            // 添加到用户列表
                            state.users.write().await.insert(user_id.clone(), user.clone());
                            user_info = Some(user);

                            // 广播用户加入消息
                            let join_msg = ChatMessage {
                                msg_type: "user_joined".to_string(),
                                user_id: user_id.clone(),
                                username: username.clone(),
                                content: format!("用户 {} 加入了聊天室", username),
                                timestamp: chrono::Utc::now().to_rfc3339(),
                                room: "general".to_string(),
                            };

                            let _ = state.tx.send(join_msg.clone());

                            // 发送注册成功消息
                            let success_msg = ChatMessage {
                                msg_type: "registration_success".to_string(),
                                user_id: "server".to_string(),
                                username: "系统".to_string(),
                                content: format!("✅ 注册成功！欢迎 {}，现在可以开始聊天了。", username),
                                timestamp: chrono::Utc::now().to_rfc3339(),
                                room: "general".to_string(),
                            };

                            let _ = sender
                                .send(axum::extract::ws::Message::Text(
                                    serde_json::to_string(&success_msg).unwrap(),
                                ))
                                .await;

                            info!("用户注册成功: {} (ID: {})", username, user_id);
                        } else {
                            let error_msg = ChatMessage {
                                msg_type: "error".to_string(),
                                user_id: "server".to_string(),
                                username: "系统".to_string(),
                                content: "❌ 用户名无效（1-20个字符）".to_string(),
                                timestamp: chrono::Utc::now().to_rfc3339(),
                                room: "general".to_string(),
                            };

                            let _ = sender
                                .send(axum::extract::ws::Message::Text(
                                    serde_json::to_string(&error_msg).unwrap(),
                                ))
                                .await;
                        }
                    } else {
                        // 已注册用户发送的简单文本消息
                        if let Some(ref user) = user_info {
                            let chat_msg = ChatMessage {
                                msg_type: "message".to_string(),
                                user_id: user_id.clone(),
                                username: user.username.clone(),
                                content: text,
                                timestamp: chrono::Utc::now().to_rfc3339(),
                                room: user.room.clone(),
                            };

                            // 广播消息
                            if let Err(_) = state.tx.send(chat_msg.clone()) {
                                warn!("广播消息失败");
                            }
                        }
                    }
                }
            }
            Ok(axum::extract::ws::Message::Close(_)) => {
                info!("用户 {} 主动断开连接", user_id);
                break;
            }
            Ok(axum::extract::ws::Message::Ping(data)) => {
                if sender
                    .send(axum::extract::ws::Message::Pong(data))
                    .await
                    .is_err()
                {
                    break;
                }
            }
            Err(e) => {
                error!("WebSocket 错误: {}", e);
                break;
            }
            _ => {}
        }
    }

    // 清理用户信息
    if let Some(user) = user_info {
        state.users.write().await.remove(&user_id);

        // 广播用户离开消息
        let leave_msg = ChatMessage {
            msg_type: "user_left".to_string(),
            user_id: user_id.clone(),
            username: user.username.clone(),
            content: format!("用户 {} 离开了聊天室", user.username),
            timestamp: chrono::Utc::now().to_rfc3339(),
            room: user.room,
        };

        let _ = state.tx.send(leave_msg);
        info!("用户离开: {} (ID: {})", user.username, user_id);
    }

    // 终止广播任务
    broadcast_task.abort();

    // 更新连接计数
    let remaining_connections = state.active_connections.fetch_sub(1, Ordering::Relaxed) - 1;
    info!("WebSocket 连接关闭，剩余连接数: {}", remaining_connections);
}

// 处理聊天消息
async fn handle_chat_message(
    incoming_msg: serde_json::Value,
    state: &AppState,
    user_id: &str,
    user_info: &mut Option<User>,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let msg_type = incoming_msg
        .get("type")
        .and_then(|v| v.as_str())
        .unwrap_or("message");

    match msg_type {
        "register" => {
            // 用户注册
            if let Some(username) = incoming_msg.get("username").and_then(|v| v.as_str()) {
                let username = username.trim().to_string();
                if !username.is_empty() && username.len() <= 20 {
                    let user = User {
                        id: user_id.to_string(),
                        username: username.clone(),
                        join_time: chrono::Utc::now(),
                        room: "general".to_string(),
                    };

                    state.users.write().await.insert(user_id.to_string(), user.clone());
                    *user_info = Some(user);

                    let join_msg = ChatMessage {
                        msg_type: "user_joined".to_string(),
                        user_id: user_id.to_string(),
                        username: username.clone(),
                        content: format!("用户 {} 加入了聊天室", username),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                        room: "general".to_string(),
                    };

                    state.tx.send(join_msg)?;
                    info!("用户注册成功: {} (ID: {})", username, user_id);
                }
            }
        }
        "message" => {
            // 普通聊天消息
            if let Some(user) = user_info {
                if let Some(content) = incoming_msg.get("content").and_then(|v| v.as_str()) {
                    let chat_msg = ChatMessage {
                        msg_type: "message".to_string(),
                        user_id: user_id.to_string(),
                        username: user.username.clone(),
                        content: content.to_string(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                        room: user.room.clone(),
                    };

                    state.tx.send(chat_msg)?;
                }
            }
        }
        "typing" => {
            // 输入指示器
            if let Some(user) = user_info {
                let typing_msg = ChatMessage {
                    msg_type: "typing".to_string(),
                    user_id: user_id.to_string(),
                    username: user.username.clone(),
                    content: "正在输入...".to_string(),
                    timestamp: chrono::Utc::now().to_rfc3339(),
                    room: user.room.clone(),
                };

                state.tx.send(typing_msg)?;
            }
        }
        _ => {
            return Err("未知消息类型".into());
        }
    }

    Ok(())
}</pre>

        <p><strong>步骤 3: 创建聊天室前端页面</strong></p>
        <p><strong>创建 templates/chat.html：</strong></p>
        <pre>mkdir templates</pre>
        
        <p><strong>templates/chat.html 内容：</strong></p>
        <pre>&lt;!DOCTYPE html>
&lt;html lang="zh-CN">
&lt;head>
    &lt;meta charset="UTF-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
    &lt;title>WebSocket 聊天室&lt;/title>
    &lt;style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-container {
            width: 90%;
            max-width: 1200px;
            height: 90vh;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            overflow: hidden;
        }
        
        .sidebar {
            width: 300px;
            background: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-header {
            padding: 20px;
            background: #34495e;
            border-bottom: 1px solid #3d566e;
        }
        
        .sidebar-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .connection-status {
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
        }
        
        .status-connected {
            background: #27ae60;
        }
        
        .status-disconnected {
            background: #e74c3c;
        }
        
        .status-connecting {
            background: #f39c12;
        }
        
        .users-section {
            flex: 1;
            padding: 20px;
        }
        
        .users-title {
            margin-bottom: 15px;
            font-size: 14px;
            color: #bdc3c7;
        }
        
        .user-list {
            list-style: none;
        }
        
        .user-item {
            padding: 8px 12px;
            margin-bottom: 5px;
            background: #34495e;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .stats-section {
            padding: 20px;
            border-top: 1px solid #3d566e;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .main-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .chat-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }
        
        .chat-title {
            font-size: 20px;
            color: #495057;
            margin-bottom: 5px;
        }
        
        .chat-subtitle {
            font-size: 14px;
            color: #6c757d;
        }
        
        .messages-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f1f3f4;
        }
        
        .message {
            margin-bottom: 15px;
            max-width: 70%;
            word-wrap: break-word;
        }
        
        .message-own {
            margin-left: auto;
        }
        
        .message-bubble {
            padding: 12px 16px;
            border-radius: 18px;
            position: relative;
        }
        
        .message-own .message-bubble {
            background: #007bff;
            color: white;
        }
        
        .message-other .message-bubble {
            background: white;
            border: 1px solid #dee2e6;
        }
        
        .message-system .message-bubble {
            background: #ffeaa7;
            border: 1px solid #fdcb6e;
            text-align: center;
            font-style: italic;
            margin: 10px auto;
            max-width: 80%;
        }
        
        .message-header {
            font-size: 12px;
            margin-bottom: 4px;
            opacity: 0.7;
        }
        
        .message-content {
            font-size: 14px;
            line-height: 1.4;
        }
        
        .message-time {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 4px;
        }
        
        .typing-indicator {
            font-style: italic;
            color: #6c757d;
            font-size: 12px;
            margin-left: 20px;
            opacity: 0.8;
        }
        
        .input-section {
            padding: 20px;
            background: white;
            border-top: 1px solid #dee2e6;
        }
        
        .input-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .registration-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .registration-input {
            padding: 15px;
            border: 2px solid #007bff;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
        }
        
        .registration-button {
            padding: 15px 30px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .registration-button:hover {
            background: #0056b3;
        }
        
        .message-input {
            flex: 1;
            padding: 15px 20px;
            border: 1px solid #dee2e6;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            resize: none;
        }
        
        .send-button {
            padding: 15px 25px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .send-button:hover {
            background: #0056b3;
        }
        
        .send-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .quick-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .quick-button {
            padding: 8px 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .quick-button:hover {
            background: #495057;
        }
        
        @media (max-width: 768px) {
            .chat-container {
                width: 100%;
                height: 100vh;
                border-radius: 0;
            }
            
            .sidebar {
                display: none;
            }
        }
    &lt;/style>
&lt;/head>
&lt;body>
    &lt;div class="chat-container">
        &lt;div class="sidebar">
            &lt;div class="sidebar-header">
                &lt;div class="sidebar-title">💬 聊天室&lt;/div>
                &lt;div id="connectionStatus" class="connection-status status-disconnected">未连接&lt;/div>
            &lt;/div>
            
            &lt;div class="users-section">
                &lt;div class="users-title">在线用户 (&lt;span id="userCount">0&lt;/span>)&lt;/div>
                &lt;ul id="userList" class="user-list">&lt;/ul>
            &lt;/div>
            
            &lt;div class="stats-section">
                &lt;div class="stat-item">
                    &lt;span>连接数:&lt;/span>
                    &lt;span id="connectionCount">0&lt;/span>
                &lt;/div>
                &lt;div class="stat-item">
                    &lt;span>消息数:&lt;/span>
                    &lt;span id="messageCount">0&lt;/span>
                &lt;/div>
                &lt;div class="stat-item">
                    &lt;span>在线时间:&lt;/span>
                    &lt;span id="onlineTime">00:00&lt;/span>
                &lt;/div>
            &lt;/div>
        &lt;/div>
        
        &lt;div class="main-chat">
            &lt;div class="chat-header">
                &lt;div class="chat-title">🌟 WebSocket 聊天室&lt;/div>
                &lt;div class="chat-subtitle">实时通信演示&lt;/div>
            &lt;/div>
            
            &lt;div id="messagesContainer" class="messages-container">
                &lt;div id="typingIndicator" class="typing-indicator" style="display: none;">&lt;/div>
            &lt;/div>
            
            &lt;div class="input-section">
                &lt;div id="registrationForm" class="registration-container">
                    &lt;input type="text" id="usernameInput" class="registration-input" 
                           placeholder="请输入您的用户名..." maxlength="20">
                    &lt;button id="registerButton" class="registration-button">🚀 加入聊天室&lt;/button>
                &lt;/div>
                
                &lt;div id="chatForm" class="input-container" style="display: none;">
                    &lt;div class="quick-actions">
                        &lt;button class="quick-button" onclick="sendQuickMessage('👋 大家好！')">👋 打招呼&lt;/button>
                        &lt;button class="quick-button" onclick="sendQuickMessage('😄 哈哈哈')">😄 开心&lt;/button>
                        &lt;button class="quick-button" onclick="sendQuickMessage('👍 赞一个')">👍 点赞&lt;/button>
                        &lt;button class="quick-button" onclick="sendQuickMessage('🤔 有趣...')">🤔 思考&lt;/button>
                    &lt;/div>
                    &lt;textarea id="messageInput" class="message-input" 
                             placeholder="输入消息..." rows="1">&lt;/textarea>
                    &lt;button id="sendButton" class="send-button" disabled>📤 发送&lt;/button>
                &lt;/div>
            &lt;/div>
        &lt;/div>
    &lt;/div>

    &lt;script>
        class ChatRoom {
            constructor() {
                this.ws = null;
                this.username = '';
                this.isRegistered = false;
                this.messageCount = 0;
                this.startTime = null;
                this.users = new Map();
                
                this.initElements();
                this.bindEvents();
                this.connect();
            }
            
            initElements() {
                this.elements = {
                    connectionStatus: document.getElementById('connectionStatus'),
                    userList: document.getElementById('userList'),
                    userCount: document.getElementById('userCount'),
                    connectionCount: document.getElementById('connectionCount'),
                    messageCount: document.getElementById('messageCount'),
                    onlineTime: document.getElementById('onlineTime'),
                    messagesContainer: document.getElementById('messagesContainer'),
                    typingIndicator: document.getElementById('typingIndicator'),
                    registrationForm: document.getElementById('registrationForm'),
                    chatForm: document.getElementById('chatForm'),
                    usernameInput: document.getElementById('usernameInput'),
                    registerButton: document.getElementById('registerButton'),
                    messageInput: document.getElementById('messageInput'),
                    sendButton: document.getElementById('sendButton')
                };
            }
            
            bindEvents() {
                this.elements.registerButton.addEventListener('click', () => this.register());
                this.elements.usernameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.register();
                });
                
                this.elements.sendButton.addEventListener('click', () => this.sendMessage());
                this.elements.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
                
                this.elements.messageInput.addEventListener('input', () => {
                    this.elements.sendButton.disabled = !this.elements.messageInput.value.trim();
                });
                
                // 自动调整输入框高度
                this.elements.messageInput.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 100) + 'px';
                });
            }
            
            connect() {
                const wsUrl = `ws://${window.location.host}/ws`;
                this.updateConnectionStatus('connecting', '连接中...');
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    this.updateConnectionStatus('connected', '已连接');
                    this.startTime = Date.now();
                    this.startTimer();
                    this.addSystemMessage('✅ 连接成功！');
                };
                
                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (e) {
                        console.error('消息解析失败:', e);
                    }
                };
                
                this.ws.onclose = (event) => {
                    this.updateConnectionStatus('disconnected', '未连接');
                    this.addSystemMessage(`❌ 连接关闭 (代码: ${event.code})`);
                    this.stopTimer();
                };
                
                this.ws.onerror = (error) => {
                    this.updateConnectionStatus('disconnected', '连接错误');
                    this.addSystemMessage('💥 连接出错');
                    console.error('WebSocket 错误:', error);
                };
            }
            
            register() {
                const username = this.elements.usernameInput.value.trim();
                if (!username) {
                    alert('请输入用户名');
                    return;
                }
                
                if (username.length > 20) {
                    alert('用户名不能超过20个字符');
                    return;
                }
                
                this.username = username;
                this.sendWebSocketMessage({
                    type: 'register',
                    username: username
                });
            }
            
            sendMessage() {
                const content = this.elements.messageInput.value.trim();
                if (!content || !this.isRegistered) return;
                
                this.sendWebSocketMessage({
                    type: 'message',
                    content: content
                });
                
                this.elements.messageInput.value = '';
                this.elements.messageInput.style.height = 'auto';
                this.elements.sendButton.disabled = true;
            }
            
            sendQuickMessage(message) {
                if (!this.isRegistered) return;
                
                this.sendWebSocketMessage({
                    type: 'message',
                    content: message
                });
            }
            
            sendWebSocketMessage(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                }
            }
            
            handleMessage(message) {
                switch (message.msg_type) {
                    case 'system':
                        this.addSystemMessage(message.content);
                        break;
                    case 'registration_success':
                        this.isRegistered = true;
                        this.elements.registrationForm.style.display = 'none';
                        this.elements.chatForm.style.display = 'block';
                        this.addSystemMessage(message.content);
                        this.updateUserList();
                        break;
                    case 'message':
                        this.addChatMessage(message);
                        this.messageCount++;
                        this.elements.messageCount.textContent = this.messageCount;
                        break;
                    case 'user_joined':
                    case 'user_left':
                        this.addSystemMessage(message.content);
                        this.updateUserList();
                        break;
                    case 'typing':
                        this.showTypingIndicator(message.username);
                        break;
                    case 'error':
                        this.addSystemMessage(`❌ ${message.content}`);
                        break;
                }
            }
            
            addSystemMessage(content) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message message-system';
                messageDiv.innerHTML = `
                    &lt;div class="message-bubble">
                        &lt;div class="message-content">${this.escapeHtml(content)}&lt;/div>
                        &lt;div class="message-time">${new Date().toLocaleTimeString()}&lt;/div>
                    &lt;/div>
                `;
                
                this.elements.messagesContainer.appendChild(messageDiv);
                this.scrollToBottom();
            }
            
            addChatMessage(message) {
                const isOwn = message.username === this.username;
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isOwn ? 'message-own' : 'message-other'}`;
                
                messageDiv.innerHTML = `
                    &lt;div class="message-bubble">
                        ${!isOwn ? `&lt;div class="message-header">${this.escapeHtml(message.username)}&lt;/div>` : ''}
                        &lt;div class="message-content">${this.escapeHtml(message.content)}&lt;/div>
                        &lt;div class="message-time">${new Date(message.timestamp).toLocaleTimeString()}&lt;/div>
                    &lt;/div>
                `;
                
                this.elements.messagesContainer.appendChild(messageDiv);
                this.scrollToBottom();
            }
            
            showTypingIndicator(username) {
                if (username === this.username) return;
                
                this.elements.typingIndicator.textContent = `${username} 正在输入...`;
                this.elements.typingIndicator.style.display = 'block';
                
                clearTimeout(this.typingTimeout);
                this.typingTimeout = setTimeout(() => {
                    this.elements.typingIndicator.style.display = 'none';
                }, 3000);
            }
            
            async updateUserList() {
                try {
                    const response = await fetch('/api/users');
                    const users = await response.json();
                    
                    this.elements.userList.innerHTML = '';
                    this.elements.userCount.textContent = users.length;
                    
                    users.forEach(user => {
                        const li = document.createElement('li');
                        li.className = 'user-item';
                        li.textContent = `👤 ${user.username}`;
                        this.elements.userList.appendChild(li);
                    });
                } catch (e) {
                    console.error('获取用户列表失败:', e);
                }
            }
            
            updateConnectionStatus(status, text) {
                this.elements.connectionStatus.className = `connection-status status-${status}`;
                this.elements.connectionStatus.textContent = text;
            }
            
            startTimer() {
                this.timer = setInterval(() => {
                    if (this.startTime) {
                        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                        const minutes = Math.floor(elapsed / 60);
                        const seconds = elapsed % 60;
                        this.elements.onlineTime.textContent = 
                            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                }, 1000);
            }
            
            stopTimer() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
            }
            
            scrollToBottom() {
                this.elements.messagesContainer.scrollTop = this.elements.messagesContainer.scrollHeight;
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }
        
        // 页面加载完成后启动聊天室
        document.addEventListener('DOMContentLoaded', () => {
            window.chatRoom = new ChatRoom();
        });
        
        // 全局快速消息函数
        function sendQuickMessage(message) {
            if (window.chatRoom) {
                window.chatRoom.sendQuickMessage(message);
            }
        }
    &lt;/script>
&lt;/body>
&lt;/html></pre>

        <p><strong>步骤 4: 创建命令行客户端</strong></p>
        <p><strong>创建 src/client.rs：</strong></p>
        <pre>use futures_util::{SinkExt, StreamExt};
use serde_json;
use std::io::{self, Write};
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("💬 WebSocket 聊天室客户端");
    println!("============================");

    let url = "ws://127.0.0.1:3000/ws";
    println!("🔗 连接到聊天服务器: {}", url);

    let (ws_stream, _) = connect_async(url).await?;
    println!("✅ 连接成功！");

    let (mut write, mut read) = ws_stream.split();

    // 启动接收消息的任务
    let read_handle = tokio::spawn(async move {
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    if let Ok(chat_msg) = serde_json::from_str::<serde_json::Value>(&text) {
                        print_chat_message(&chat_msg);
                    } else {
                        println!("📩 {}", text);
                    }
                }
                Ok(Message::Close(_)) => {
                    println!("\n👋 服务器关闭了连接");
                    break;
                }
                Err(e) => {
                    println!("\n❌ 接收消息错误: {}", e);
                    break;
                }
                _ => {}
            }
        }
    });

    // 用户注册流程
    println!("\n请输入您的用户名:");
    print!("👤 用户名: ");
    io::stdout().flush().unwrap();

    let mut username = String::new();
    io::stdin().read_line(&mut username).unwrap();
    let username = username.trim();

    if username.is_empty() {
        println!("❌ 用户名不能为空");
        return Ok(());
    }

    // 发送注册消息
    let register_msg = serde_json::json!({
        "type": "register",
        "username": username
    });

    write
        .send(Message::Text(serde_json::to_string(&register_msg).unwrap()))
        .await?;

    println!("📝 注册消息已发送，等待服务器确认...");
    println!("💡 输入消息并按回车发送，输入 '/quit' 退出");
    println!("📚 特殊命令:");
    println!("  /users  - 显示在线用户");
    println!("  /stats  - 显示服务器统计");
    println!("  /help   - 显示帮助");
    println!("\n开始聊天:");

    // 消息发送循环
    loop {
        print!("💬 {} > ", username);
        io::stdout().flush().unwrap();

        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();

        if input == "/quit" {
            break;
        }

        if input.is_empty() {
            continue;
        }

        // 处理特殊命令
        match input {
            "/users" => {
                println!("📋 正在获取用户列表...");
                continue;
            }
            "/stats" => {
                println!("📊 正在获取服务器统计...");
                continue;
            }
            "/help" => {
                println!("📚 可用命令:");
                println!("  /users  - 显示在线用户");
                println!("  /stats  - 显示服务器统计");
                println!("  /quit   - 退出聊天室");
                println!("  /help   - 显示此帮助");
                continue;
            }
            _ => {}
        }

        // 发送普通消息
        let chat_msg = serde_json::json!({
            "type": "message",
            "content": input
        });

        if write
            .send(Message::Text(serde_json::to_string(&chat_msg).unwrap()))
            .await
            .is_err()
        {
            println!("❌ 发送消息失败");
            break;
        }
    }

    println!("👋 正在退出聊天室...");
    let _ = write.send(Message::Close(None)).await;
    read_handle.abort();

    Ok(())
}

fn print_chat_message(msg: &serde_json::Value) {
    let msg_type = msg.get("msg_type").and_then(|v| v.as_str()).unwrap_or("");
    let username = msg.get("username").and_then(|v| v.as_str()).unwrap_or("");
    let content = msg.get("content").and_then(|v| v.as_str()).unwrap_or("");
    let timestamp = msg
        .get("timestamp")
        .and_then(|v| v.as_str())
        .and_then(|s| chrono::DateTime::parse_from_rfc3339(s).ok())
        .map(|dt| dt.format("%H:%M:%S").to_string())
        .unwrap_or_else(|| chrono::Local::now().format("%H:%M:%S").to_string());

    match msg_type {
        "system" => {
            println!("\n🔔 [{}] {}", timestamp, content);
        }
        "registration_success" => {
            println!("\n✅ [{}] {}", timestamp, content);
        }
        "message" => {
            println!("\n💬 [{}] {}: {}", timestamp, username, content);
        }
        "user_joined" => {
            println!("\n📥 [{}] {}", timestamp, content);
        }
        "user_left" => {
            println!("\n📤 [{}] {}", timestamp, content);
        }
        "typing" => {
            print!("\r⌨️  {} 正在输入...", username);
            io::stdout().flush().unwrap();
            // 不换行，让用户输入提示符覆盖
        }
        "error" => {
            println!("\n❌ [{}] 错误: {}", timestamp, content);
        }
        _ => {
            println!("\n📩 [{}] {}: {}", timestamp, username, content);
        }
    }

    // 重新显示输入提示符（除了 typing 消息）
    if msg_type != "typing" {
        print!("💬 > ");
        io::stdout().flush().unwrap();
    }
}</pre>

        <p><strong>运行和测试：</strong></p>
        <pre># 运行服务器
cargo run --bin server

# 在多个终端运行客户端测试多用户聊天
cargo run --bin client

# 或在浏览器中访问 http://localhost:3000</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>实现私聊功能（用户之间一对一消息）</li>
            <li>添加多房间支持（用户可以加入不同的聊天房间）</li>
            <li>实现消息历史记录（新用户加入时显示最近的聊天记录）</li>
            <li>添加用户角色系统（管理员、普通用户等）</li>
            <li>实现消息过滤和敏感词检测</li>
            <li>添加文件上传和图片分享功能</li>
            <li>实现用户在线状态指示器</li>
            <li>添加消息已读回执功能</li>
        </ul>

        <pre>📁 项目结构：
day17_websocket_chat/
├── src/
│   ├── main.rs
│   └── client.rs
├── templates/
│   └── chat.html
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-18</strong></p>
        <h2>Day 18 - 连接鉴权机制</h2>
        <p>你将在连接建立时提取查询参数（如 `?token=abc123`），并检查该 token 是否在授权列表中，拒绝未授权连接。</p>
        <p>🔗 <a href="https://docs.rs/axum/latest/axum/extract/struct.Query.html" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 创建项目并配置依赖</strong></p>
        <pre>cargo new day18_websocket_auth
cd day18_websocket_auth</pre>

        <p><strong>配置 Cargo.toml：</strong></p>
        <pre>[package]
name = "day18_websocket_auth"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
futures-util = "0.3"
tokio-tungstenite = "0.20"
jsonwebtoken = "9.2"
base64 = "0.21"
sha2 = "0.10"
hex = "0.4"

[[bin]]
name = "server"
path = "src/main.rs"

[[bin]]
name = "client"
path = "src/client.rs"

[[bin]]
name = "token_generator"
path = "src/token_generator.rs"</pre>

        <p><strong>步骤 2: 实现认证WebSocket服务器</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocket, WebSocketUpgrade, Query, State},
    http::StatusCode,
    response::{Html, IntoResponse, Response},
    routing::get,
    Router,
};
use futures_util::{SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use std::{
    collections::{HashMap, HashSet},
    net::SocketAddr,
    sync::{atomic::{AtomicUsize, Ordering}, Arc},
    time::{SystemTime, UNIX_EPOCH},
};
use tokio::{net::TcpListener, sync::RwLock};
use tower::ServiceBuilder;
use tower_http::cors::CorsLayer;
use tracing::{debug, error, info, warn};
use uuid::Uuid;

// 认证查询参数
#[derive(Debug, Deserialize)]
pub struct AuthQuery {
    token: Option<String>,
    user_id: Option<String>,
    permissions: Option<String>,
}

// JWT Claims
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,     // 用户ID
    pub name: String,    // 用户名
    pub permissions: Vec<String>, // 权限列表
    pub exp: usize,      // 过期时间
    pub iat: usize,      // 签发时间
    pub iss: String,     // 签发者
}

// 用户信息
#[derive(Debug, Clone, Serialize)]
pub struct AuthenticatedUser {
    pub id: String,
    pub name: String,
    pub permissions: Vec<String>,
    pub token: String,
    pub connected_at: chrono::DateTime<chrono::Utc>,
    pub last_activity: chrono::DateTime<chrono::Utc>,
}

// 应用状态
#[derive(Clone)]
pub struct AppState {
    pub jwt_secret: String,
    pub valid_tokens: Arc<RwLock<HashSet<String>>>,
    pub connected_users: Arc<RwLock<HashMap<String, AuthenticatedUser>>>,
    pub connection_count: Arc<AtomicUsize>,
    pub blocked_ips: Arc<RwLock<HashSet<String>>>,
}

impl AppState {
    pub fn new() -> Self {
        let mut valid_tokens = HashSet::new();
        
        // 预设一些有效的简单token用于测试
        valid_tokens.insert("admin_token_123".to_string());
        valid_tokens.insert("user_token_456".to_string());
        valid_tokens.insert("guest_token_789".to_string());
        valid_tokens.insert("developer_token_000".to_string());
        
        Self {
            jwt_secret: "your_super_secret_jwt_key_here_make_it_long_and_secure".to_string(),
            valid_tokens: Arc::new(RwLock::new(valid_tokens)),
            connected_users: Arc::new(RwLock::new(HashMap::new())),
            connection_count: Arc::new(AtomicUsize::new(0)),
            blocked_ips: Arc::new(RwLock::new(HashSet::new())),
        }
    }
    
    // 验证简单token
    pub async fn validate_simple_token(&self, token: &str) -> Option<AuthenticatedUser> {
        let tokens = self.valid_tokens.read().await;
        if tokens.contains(token) {
            let (user_id, name, permissions) = match token {
                "admin_token_123" => ("admin_001", "管理员", vec!["admin", "read", "write", "delete"]),
                "user_token_456" => ("user_001", "普通用户", vec!["read", "write"]),
                "guest_token_789" => ("guest_001", "访客", vec!["read"]),
                "developer_token_000" => ("dev_001", "开发者", vec!["admin", "debug", "read", "write"]),
                _ => ("unknown", "未知用户", vec!["read"]),
            };
            
            Some(AuthenticatedUser {
                id: user_id.to_string(),
                name: name.to_string(),
                permissions: permissions.into_iter().map(String::from).collect(),
                token: token.to_string(),
                connected_at: chrono::Utc::now(),
                last_activity: chrono::Utc::now(),
            })
        } else {
            None
        }
    }
    
    // 验证JWT token
    pub fn validate_jwt_token(&self, token: &str) -> Option<AuthenticatedUser> {
        use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
        
        let validation = Validation::new(Algorithm::HS256);
        match decode::<Claims>(
            token,
            &DecodingKey::from_secret(self.jwt_secret.as_ref()),
            &validation,
        ) {
            Ok(token_data) => {
                let claims = token_data.claims;
                
                // 检查token是否过期
                let now = SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_secs() as usize;
                
                if claims.exp < now {
                    warn!("JWT token 已过期: {}", claims.sub);
                    return None;
                }
                
                Some(AuthenticatedUser {
                    id: claims.sub,
                    name: claims.name,
                    permissions: claims.permissions,
                    token: token.to_string(),
                    connected_at: chrono::Utc::now(),
                    last_activity: chrono::Utc::now(),
                })
            }
            Err(e) => {
                warn!("JWT token 验证失败: {}", e);
                None
            }
        }
    }
    
    // 检查IP是否被封禁
    pub async fn is_ip_blocked(&self, ip: &str) -> bool {
        let blocked_ips = self.blocked_ips.read().await;
        blocked_ips.contains(ip)
    }
    
    // 封禁IP
    pub async fn block_ip(&self, ip: String) {
        let mut blocked_ips = self.blocked_ips.write().await;
        blocked_ips.insert(ip);
    }
}

#[tokio::main]
async fn main() {
    // 初始化日志
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .with_level(true)
        .init();

    // 创建应用状态
    let state = AppState::new();

    // 构建应用路由
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .route("/api/users", get(get_connected_users))
        .route("/api/stats", get(get_auth_stats))
        .route("/api/generate-token", get(generate_simple_token))
        .route("/api/generate-jwt", get(generate_jwt_token))
        .layer(ServiceBuilder::new().layer(CorsLayer::permissive()))
        .with_state(state);

    // 启动服务器
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!("🚀 WebSocket 认证服务器启动在 http://{}", addr);
    info!("🔐 WebSocket 端点: ws://{}/ws?token=YOUR_TOKEN", addr);
    info!("🌐 测试页面: http://{}/", addr);
    info!("🔑 生成Token: http://{}/api/generate-token", addr);

    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// 主页处理器
async fn index_handler() -> Html<&'static str> {
    Html(include_str!("../templates/auth.html"))
}

// 获取已连接用户列表
async fn get_connected_users(State(state): State<AppState>) -> axum::Json<Vec<AuthenticatedUser>> {
    let users = state.connected_users.read().await;
    let user_list: Vec<AuthenticatedUser> = users.values().cloned().collect();
    axum::Json(user_list)
}

// 获取认证统计信息
async fn get_auth_stats(State(state): State<AppState>) -> axum::Json<serde_json::Value> {
    let users = state.connected_users.read().await;
    let valid_tokens = state.valid_tokens.read().await;
    let blocked_ips = state.blocked_ips.read().await;
    
    let stats = serde_json::json!({
        "active_connections": state.connection_count.load(Ordering::Relaxed),
        "authenticated_users": users.len(),
        "valid_tokens": valid_tokens.len(),
        "blocked_ips": blocked_ips.len(),
        "server_time": chrono::Utc::now().to_rfc3339(),
        "auth_enabled": true
    });
    axum::Json(stats)
}

// 生成简单测试token
async fn generate_simple_token(State(state): State<AppState>) -> impl IntoResponse {
    let new_token = format!("test_token_{}", Uuid::new_v4().to_string()[..8].to_string());
    
    // 添加到有效token列表
    state.valid_tokens.write().await.insert(new_token.clone());
    info!("生成新的测试token: {}", new_token);
    
    axum::Json(serde_json::json!({
        "token": new_token,
        "type": "simple",
        "expires": "never",
        "permissions": ["read"]
    }))
}

// 生成JWT token
async fn generate_jwt_token(Query(params): Query<HashMap<String, String>>, State(state): State<AppState>) -> impl IntoResponse {
    use jsonwebtoken::{encode, EncodingKey, Header};
    
    let user_id = params.get("user_id").unwrap_or(&format!("user_{}", Uuid::new_v4().to_string()[..8].to_string())).clone();
    let name = params.get("name").unwrap_or(&format!("User_{}", &user_id[..8])).clone();
    let permissions_str = params.get("permissions").unwrap_or("read").clone();
    let permissions: Vec<String> = permissions_str.split(',').map(String::from).collect();
    
    let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as usize;
    let exp = now + 3600; // 1小时后过期
    
    let claims = Claims {
        sub: user_id.clone(),
        name: name.clone(),
        permissions: permissions.clone(),
        exp,
        iat: now,
        iss: "websocket-auth-server".to_string(),
    };
    
    match encode(&Header::default(), &claims, &EncodingKey::from_secret(state.jwt_secret.as_ref())) {
        Ok(token) => {
            info!("生成新的JWT token for user: {}", user_id);
            axum::Json(serde_json::json!({
                "token": token,
                "type": "jwt",
                "user_id": user_id,
                "name": name,
                "permissions": permissions,
                "expires_at": chrono::Utc::now() + chrono::Duration::seconds(3600),
                "expires_in": 3600
            }))
        }
        Err(e) => {
            error!("JWT token 生成失败: {}", e);
            axum::Json(serde_json::json!({
                "error": "Failed to generate JWT token",
                "message": e.to_string()
            }))
        }
    }
}

// WebSocket 升级处理器（带认证）
async fn websocket_handler(
    ws: WebSocketUpgrade,
    Query(auth_query): Query<AuthQuery>,
    State(state): State<AppState>,
) -> Response {
    // 检查是否提供了token
    let token = match auth_query.token {
        Some(token) if !token.is_empty() => token,
        _ => {
            warn!("WebSocket连接被拒绝: 缺少token");
            return (StatusCode::UNAUTHORIZED, "Missing or empty token").into_response();
        }
    };

    // 验证token（先尝试简单token，再尝试JWT）
    let authenticated_user = if let Some(user) = state.validate_simple_token(&token).await {
        user
    } else if let Some(user) = state.validate_jwt_token(&token) {
        user
    } else {
        warn!("WebSocket连接被拒绝: 无效token: {}", token);
        return (StatusCode::UNAUTHORIZED, "Invalid token").into_response();
    };

    // 检查权限（至少需要read权限）
    if !authenticated_user.permissions.contains(&"read".to_string()) {
        warn!("WebSocket连接被拒绝: 权限不足: {}", authenticated_user.id);
        return (StatusCode::FORBIDDEN, "Insufficient permissions").into_response();
    }

    let current_connections = state.connection_count.fetch_add(1, Ordering::Relaxed) + 1;
    info!("✅ 认证成功，用户 {} ({}) 连接 WebSocket (当前连接数: {})", 
          authenticated_user.name, authenticated_user.id, current_connections);

    // 添加到已连接用户列表
    state.connected_users.write().await.insert(
        authenticated_user.id.clone(), 
        authenticated_user.clone()
    );

    ws.on_upgrade(move |socket| handle_authenticated_websocket(socket, authenticated_user, state))
}

// 处理已认证的 WebSocket 连接
async fn handle_authenticated_websocket(
    socket: WebSocket,
    user: AuthenticatedUser,
    state: AppState,
) {
    let (mut sender, mut receiver) = socket.split();
    let user_id = user.id.clone();

    // 发送欢迎消息
    let welcome_msg = serde_json::json!({
        "type": "auth_success",
        "message": format!("🎉 欢迎 {}！认证成功，连接已建立。", user.name),
        "user": {
            "id": user.id,
            "name": user.name,
            "permissions": user.permissions,
            "connected_at": user.connected_at.to_rfc3339()
        },
        "server_time": chrono::Utc::now().to_rfc3339()
    });

    if sender
        .send(axum::extract::ws::Message::Text(
            serde_json::to_string(&welcome_msg).unwrap(),
        ))
        .await
        .is_err()
    {
        error!("发送欢迎消息失败: {}", user_id);
        cleanup_user_connection(&state, &user_id).await;
        return;
    }

    // 消息处理循环
    while let Some(msg) = receiver.next().await {
        match msg {
            Ok(axum::extract::ws::Message::Text(text)) => {
                debug!("用户 {} 发送消息: {}", user_id, text);

                // 更新最后活动时间
                if let Some(mut user_info) = state.connected_users.write().await.get_mut(&user_id) {
                    user_info.last_activity = chrono::Utc::now();
                }

                // 解析消息
                if let Ok(incoming_msg) = serde_json::from_str::<serde_json::Value>(&text) {
                    if let Err(e) = handle_authenticated_message(incoming_msg, &user, &state, &mut sender).await {
                        error!("处理认证消息失败: {}", e);
                    }
                } else {
                    // 简单文本消息
                    let response = serde_json::json!({
                        "type": "message_received",
                        "user_id": user_id,
                        "user_name": user.name,
                        "content": text,
                        "timestamp": chrono::Utc::now().to_rfc3339(),
                        "permissions": user.permissions
                    });

                    let _ = sender
                        .send(axum::extract::ws::Message::Text(
                            serde_json::to_string(&response).unwrap(),
                        ))
                        .await;
                }
            }
            Ok(axum::extract::ws::Message::Close(_)) => {
                info!("用户 {} 主动断开连接", user_id);
                break;
            }
            Ok(axum::extract::ws::Message::Ping(data)) => {
                if sender
                    .send(axum::extract::ws::Message::Pong(data))
                    .await
                    .is_err()
                {
                    break;
                }
            }
            Err(e) => {
                error!("WebSocket 错误，用户 {}: {}", user_id, e);
                break;
            }
            _ => {}
        }
    }

    // 清理连接
    cleanup_user_connection(&state, &user_id).await;
    info!("用户 {} 连接已关闭", user_id);
}

// 处理已认证用户的消息
async fn handle_authenticated_message(
    msg: serde_json::Value,
    user: &AuthenticatedUser,
    state: &AppState,
    sender: &mut futures_util::stream::SplitSink<WebSocket, axum::extract::ws::Message>,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let msg_type = msg.get("type").and_then(|v| v.as_str()).unwrap_or("unknown");

    match msg_type {
        "ping" => {
            let response = serde_json::json!({
                "type": "pong",
                "user_id": user.id,
                "server_time": chrono::Utc::now().to_rfc3339()
            });
            sender
                .send(axum::extract::ws::Message::Text(
                    serde_json::to_string(&response)?,
                ))
                .await?;
        }
        "get_user_info" => {
            let response = serde_json::json!({
                "type": "user_info",
                "user": {
                    "id": user.id,
                    "name": user.name,
                    "permissions": user.permissions,
                    "connected_at": user.connected_at.to_rfc3339(),
                    "last_activity": user.last_activity.to_rfc3339()
                }
            });
            sender
                .send(axum::extract::ws::Message::Text(
                    serde_json::to_string(&response)?,
                ))
                .await?;
        }
        "get_stats" => {
            // 需要admin权限
            if !user.permissions.contains(&"admin".to_string()) {
                let error_response = serde_json::json!({
                    "type": "error",
                    "message": "权限不足：需要admin权限才能查看统计信息",
                    "required_permission": "admin"
                });
                sender
                    .send(axum::extract::ws::Message::Text(
                        serde_json::to_string(&error_response)?,
                    ))
                    .await?;
                return Ok(());
            }

            let users = state.connected_users.read().await;
            let response = serde_json::json!({
                "type": "stats",
                "data": {
                    "connected_users": users.len(),
                    "total_connections": state.connection_count.load(Ordering::Relaxed),
                    "users": users.values().collect::<Vec<_>>()
                }
            });
            sender
                .send(axum::extract::ws::Message::Text(
                    serde_json::to_string(&response)?,
                ))
                .await?;
        }
        "admin_action" => {
            // 需要admin权限
            if !user.permissions.contains(&"admin".to_string()) {
                let error_response = serde_json::json!({
                    "type": "error",
                    "message": "权限不足：需要admin权限",
                    "required_permission": "admin"
                });
                sender
                    .send(axum::extract::ws::Message::Text(
                        serde_json::to_string(&error_response)?,
                    ))
                    .await?;
                return Ok(());
            }

            let action = msg.get("action").and_then(|v| v.as_str()).unwrap_or("");
            match action {
                "list_users" => {
                    let users = state.connected_users.read().await;
                    let response = serde_json::json!({
                        "type": "admin_response",
                        "action": "list_users",
                        "data": users.values().collect::<Vec<_>>()
                    });
                    sender
                        .send(axum::extract::ws::Message::Text(
                            serde_json::to_string(&response)?,
                        ))
                        .await?;
                }
                "server_info" => {
                    let response = serde_json::json!({
                        "type": "admin_response",
                        "action": "server_info",
                        "data": {
                            "server_start_time": chrono::Utc::now().to_rfc3339(),
                            "active_connections": state.connection_count.load(Ordering::Relaxed),
                            "jwt_enabled": true,
                            "auth_required": true
                        }
                    });
                    sender
                        .send(axum::extract::ws::Message::Text(
                            serde_json::to_string(&response)?,
                        ))
                        .await?;
                }
                _ => {
                    let error_response = serde_json::json!({
                        "type": "error",
                        "message": format!("未知的管理员操作: {}", action)
                    });
                    sender
                        .send(axum::extract::ws::Message::Text(
                            serde_json::to_string(&error_response)?,
                        ))
                        .await?;
                }
            }
        }
        _ => {
            let response = serde_json::json!({
                "type": "echo",
                "original_message": msg,
                "user_id": user.id,
                "user_name": user.name,
                "timestamp": chrono::Utc::now().to_rfc3339()
            });
            sender
                .send(axum::extract::ws::Message::Text(
                    serde_json::to_string(&response)?,
                ))
                .await?;
        }
    }

    Ok(())
}

// 清理用户连接
async fn cleanup_user_connection(state: &AppState, user_id: &str) {
    state.connected_users.write().await.remove(user_id);
    let remaining_connections = state.connection_count.fetch_sub(1, Ordering::Relaxed) - 1;
    info!("清理用户连接: {}, 剩余连接数: {}", user_id, remaining_connections);
}</pre>

        <p><strong>步骤 3: 创建认证测试页面</strong></p>
        <p><strong>创建 templates/auth.html：</strong></p>
        <pre>mkdir templates</pre>
        
        <p><strong>templates/auth.html 内容：</strong></p>
        <pre>&lt;!DOCTYPE html>
&lt;html lang="zh-CN">
&lt;head>
    &lt;meta charset="UTF-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
    &lt;title>WebSocket 认证测试&lt;/title>
    &lt;style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 16px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 600px;
        }
        
        .auth-panel {
            padding: 30px;
            border-right: 1px solid #eee;
        }
        
        .test-panel {
            padding: 30px;
            background: #f8f9fa;
        }
        
        .section-title {
            font-size: 20px;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            margin: 5px;
        }
        
        .btn-primary { background: #3498db; color: white; }
        .btn-success { background: #27ae60; color: white; }
        .btn-warning { background: #f39c12; color: white; }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-secondary { background: #95a5a6; color: white; }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: bold;
            text-align: center;
        }
        
        .status-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .status-error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status-info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        
        .user-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        
        .user-info h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .user-info .info-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .permissions {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        .permission-tag {
            background: #3498db;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        
        .messages-container {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: white;
            font-family: 'Consolas', monospace;
            font-size: 12px;
        }
        
        .message {
            margin: 8px 0;
            padding: 8px;
            border-radius: 4px;
            word-wrap: break-word;
        }
        
        .message-sent { background: #e3f2fd; border-left: 4px solid #2196f3; }
        .message-received { background: #f1f8e9; border-left: 4px solid #4caf50; }
        .message-system { background: #fff3e0; border-left: 4px solid #ff9800; }
        .message-error { background: #ffebee; border-left: 4px solid #f44336; }
        
        .quick-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .token-display {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 11px;
            word-break: break-all;
            margin: 10px 0;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .auth-panel {
                border-right: none;
                border-bottom: 1px solid #eee;
            }
        }
    &lt;/style>
&lt;/head>
&lt;body>
    &lt;div class="container">
        &lt;div class="header">
            &lt;h1>🔐 WebSocket 认证系统测试&lt;/h1>
            &lt;p>测试基于Token和JWT的WebSocket连接认证机制&lt;/p>
        &lt;/div>
        
        &lt;div class="main-content">
            &lt;div class="auth-panel">
                &lt;div class="section-title">🎫 认证配置&lt;/div>
                
                &lt;div class="form-group">
                    &lt;label>认证方式:&lt;/label>
                    &lt;select id="authType">
                        &lt;option value="simple">简单Token&lt;/option>
                        &lt;option value="jwt">JWT Token&lt;/option>
                    &lt;/select>
                &lt;/div>
                
                &lt;div class="form-group">
                    &lt;label>Token:&lt;/label>
                    &lt;input type="text" id="tokenInput" placeholder="输入或生成认证Token">
                &lt;/div>
                
                &lt;div class="quick-actions">
                    &lt;button class="btn btn-success" onclick="generateToken()">🔑 生成Token&lt;/button>
                    &lt;button class="btn btn-primary" onclick="connectWebSocket()">🔗 连接&lt;/button>
                    &lt;button class="btn btn-danger" onclick="disconnect()" disabled id="disconnectBtn">❌ 断开&lt;/button>
                &lt;/div>
                
                &lt;div class="form-group">
                    &lt;label>预设Token (点击使用):&lt;/label>
                    &lt;div class="quick-actions">
                        &lt;button class="btn btn-secondary" onclick="usePresetToken('admin_token_123')">👑 管理员&lt;/button>
                        &lt;button class="btn btn-secondary" onclick="usePresetToken('user_token_456')">👤 普通用户&lt;/button>
                        &lt;button class="btn btn-secondary" onclick="usePresetToken('guest_token_789')">👥 访客&lt;/button>
                    &lt;/div>
                &lt;/div>
                
                &lt;div id="connectionStatus" class="status status-warning">未连接&lt;/div>
                
                &lt;div id="userInfo" class="user-info" style="display: none;">
                    &lt;h4>👤 用户信息&lt;/h4>
                    &lt;div class="info-item">
                        &lt;span>用户ID:&lt;/span>
                        &lt;span id="userId">-&lt;/span>
                    &lt;/div>
                    &lt;div class="info-item">
                        &lt;span>用户名:&lt;/span>
                        &lt;span id="userName">-&lt;/span>
                    &lt;/div>
                    &lt;div class="info-item">
                        &lt;span>连接时间:&lt;/span>
                        &lt;span id="connectedAt">-&lt;/span>
                    &lt;/div>
                    &lt;div class="permissions" id="userPermissions">&lt;/div>
                &lt;/div>
            &lt;/div>
            
            &lt;div class="test-panel">
                &lt;div class="section-title">🧪 功能测试&lt;/div>
                
                &lt;div class="quick-actions">
                    &lt;button class="btn btn-primary" onclick="sendMessage('ping')">🏓 Ping测试&lt;/button>
                    &lt;button class="btn btn-primary" onclick="sendMessage('get_user_info')">👤 获取用户信息&lt;/button>
                    &lt;button class="btn btn-warning" onclick="sendMessage('get_stats')">📊 获取统计(需Admin)&lt;/button>
                    &lt;button class="btn btn-danger" onclick="sendAdminAction('list_users')">👥 列出用户(需Admin)&lt;/button>
                &lt;/div>
                
                &lt;div class="form-group">
                    &lt;label>自定义消息:&lt;/label>
                    &lt;div style="display: flex; gap: 10px;">
                        &lt;input type="text" id="customMessage" placeholder="输入JSON消息或文本" style="flex: 1;">
                        &lt;button class="btn btn-primary" onclick="sendCustomMessage()">📤 发送&lt;/button>
                    &lt;/div>
                &lt;/div>
                
                &lt;div class="form-group">
                    &lt;label>消息日志:&lt;/label>
                    &lt;div class="messages-container" id="messagesContainer">&lt;/div>
                &lt;/div>
                
                &lt;div class="quick-actions">
                    &lt;button class="btn btn-secondary" onclick="clearMessages()">🗑️ 清空日志&lt;/button>
                    &lt;button class="btn btn-secondary" onclick="exportLogs()">💾 导出日志&lt;/button>
                &lt;/div>
            &lt;/div>
        &lt;/div>
    &lt;/div>

    &lt;script>
        let ws = null;
        let messageCount = 0;

        function addMessage(content, type = 'system') {
            const container = document.getElementById('messagesContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message message-${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            messageDiv.innerHTML = `&lt;strong>[${timestamp}]&lt;/strong> ${content}`;
            
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            messageCount++;
        }

        function updateStatus(text, className) {
            const status = document.getElementById('connectionStatus');
            status.textContent = text;
            status.className = `status status-${className}`;
        }

        function updateUserInfo(user) {
            const userInfo = document.getElementById('userInfo');
            const userId = document.getElementById('userId');
            const userName = document.getElementById('userName');
            const connectedAt = document.getElementById('connectedAt');
            const permissions = document.getElementById('userPermissions');
            
            userId.textContent = user.id;
            userName.textContent = user.name;
            connectedAt.textContent = new Date(user.connected_at).toLocaleString();
            
            permissions.innerHTML = '';
            user.permissions.forEach(perm => {
                const tag = document.createElement('span');
                tag.className = 'permission-tag';
                tag.textContent = perm;
                permissions.appendChild(tag);
            });
            
            userInfo.style.display = 'block';
        }

        async function generateToken() {
            const authType = document.getElementById('authType').value;
            const tokenInput = document.getElementById('tokenInput');
            
            try {
                let url = '/api/generate-token';
                if (authType === 'jwt') {
                    url = '/api/generate-jwt?user_id=test_user&name=测试用户&permissions=read,write';
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.token) {
                    tokenInput.value = data.token;
                    addMessage(`生成${authType.toUpperCase()}Token成功: ${data.token.substring(0, 50)}...`, 'system');
                    
                    if (authType === 'jwt') {
                        addMessage(`Token信息: 用户=${data.name}, 权限=${data.permissions.join(',')}, 过期时间=${new Date(data.expires_at).toLocaleString()}`, 'system');
                    }
                } else {
                    addMessage(`生成Token失败: ${data.error || '未知错误'}`, 'error');
                }
            } catch (error) {
                addMessage(`生成Token时发生错误: ${error.message}`, 'error');
            }
        }

        function usePresetToken(token) {
            document.getElementById('tokenInput').value = token;
            document.getElementById('authType').value = 'simple';
            addMessage(`使用预设Token: ${token}`, 'system');
        }

        function connectWebSocket() {
            const token = document.getElementById('tokenInput').value.trim();
            
            if (!token) {
                addMessage('请输入Token或点击"生成Token"', 'error');
                return;
            }
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                addMessage('WebSocket已经连接！', 'system');
                return;
            }
            
            const wsUrl = `ws://${window.location.host}/ws?token=${encodeURIComponent(token)}`;
            addMessage(`尝试连接: ${wsUrl}`, 'system');
            updateStatus('连接中...', 'warning');
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function(event) {
                updateStatus('已连接并认证', 'success');
                addMessage('WebSocket连接成功，等待认证确认...', 'system');
                document.getElementById('disconnectBtn').disabled = false;
            };
            
            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    handleMessage(message);
                } catch (e) {
                    addMessage(`收到消息: ${event.data}`, 'received');
                }
            };
            
            ws.onclose = function(event) {
                updateStatus(`连接关闭 (${event.code})`, 'error');
                addMessage(`WebSocket连接关闭: ${event.code} - ${event.reason || '无原因'}`, 'system');
                document.getElementById('disconnectBtn').disabled = true;
                document.getElementById('userInfo').style.display = 'none';
            };
            
            ws.onerror = function(error) {
                updateStatus('连接错误', 'error');
                addMessage('WebSocket连接出错，可能是认证失败', 'error');
                console.error('WebSocket错误:', error);
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        function handleMessage(message) {
            switch (message.type) {
                case 'auth_success':
                    addMessage(message.message, 'system');
                    updateUserInfo(message.user);
                    break;
                case 'pong':
                    addMessage(`Pong响应: ${message.server_time}`, 'received');
                    break;
                case 'user_info':
                    addMessage('用户信息更新', 'received');
                    updateUserInfo(message.user);
                    break;
                case 'stats':
                    addMessage(`服务器统计: 连接用户=${message.data.connected_users}名, 总连接=${message.data.total_connections}次`, 'received');
                    break;
                case 'admin_response':
                    if (message.action === 'list_users') {
                        const users = message.data.map(u => `${u.name}(${u.id})`).join(', ');
                        addMessage(`在线用户列表: ${users}`, 'received');
                    } else {
                        addMessage(`管理员操作响应: ${JSON.stringify(message.data, null, 2)}`, 'received');
                    }
                    break;
                case 'error':
                    addMessage(`错误: ${message.message}`, 'error');
                    break;
                case 'echo':
                    addMessage(`Echo响应: ${JSON.stringify(message.original_message)}`, 'received');
                    break;
                default:
                    addMessage(`收到消息: ${JSON.stringify(message, null, 2)}`, 'received');
            }
        }

        function sendMessage(type) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('WebSocket未连接', 'error');
                return;
            }
            
            const message = { type: type };
            ws.send(JSON.stringify(message));
            addMessage(`发送: ${JSON.stringify(message)}`, 'sent');
        }

        function sendAdminAction(action) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('WebSocket未连接', 'error');
                return;
            }
            
            const message = { 
                type: 'admin_action', 
                action: action 
            };
            ws.send(JSON.stringify(message));
            addMessage(`发送管理员操作: ${JSON.stringify(message)}`, 'sent');
        }

        function sendCustomMessage() {
            const input = document.getElementById('customMessage');
            const content = input.value.trim();
            
            if (!content) return;
            
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('WebSocket未连接', 'error');
                return;
            }
            
            try {
                // 尝试解析为JSON
                const message = JSON.parse(content);
                ws.send(JSON.stringify(message));
                addMessage(`发送JSON: ${content}`, 'sent');
            } catch (e) {
                // 作为纯文本发送
                ws.send(content);
                addMessage(`发送文本: ${content}`, 'sent');
            }
            
            input.value = '';
        }

        function clearMessages() {
            document.getElementById('messagesContainer').innerHTML = '';
            messageCount = 0;
        }

        function exportLogs() {
            const messages = document.getElementById('messagesContainer').innerHTML;
            const blob = new Blob([messages], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `websocket_auth_logs_${new Date().getTime()}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 页面加载时的初始化
        document.addEventListener('DOMContentLoaded', function() {
            addMessage('WebSocket认证测试页面已加载', 'system');
            addMessage('请选择认证方式，输入Token或生成新Token，然后点击连接', 'system');
            
            // 绑定回车键发送
            document.getElementById('customMessage').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendCustomMessage();
                }
            });
        });
    &lt;/script>
&lt;/body>
&lt;/html></pre>

        <p><strong>步骤 4: 创建Token生成工具</strong></p>
        <p><strong>创建 src/token_generator.rs：</strong></p>
        <pre>use jsonwebtoken::{encode, EncodingKey, Header};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,     // 用户ID
    name: String,    // 用户名
    permissions: Vec<String>, // 权限列表
    exp: usize,      // 过期时间
    iat: usize,      // 签发时间
    iss: String,     // 签发者
}

fn main() {
    println!("🔑 WebSocket Token 生成工具");
    println!("============================");

    let secret = "your_super_secret_jwt_key_here_make_it_long_and_secure";

    // 生成不同权限的测试用户
    let test_users = vec![
        ("admin_001", "系统管理员", vec!["admin", "read", "write", "delete", "debug"]),
        ("user_001", "普通用户", vec!["read", "write"]),
        ("guest_001", "访客用户", vec!["read"]),
        ("dev_001", "开发者", vec!["admin", "debug", "read", "write"]),
        ("moderator_001", "版主", vec!["read", "write", "moderate"]),
    ];

    println!("生成的JWT Tokens:");
    println!();

    for (user_id, name, permissions) in test_users {
        match generate_jwt_token(user_id, name, permissions, secret, 3600) {
            Ok(token) => {
                println!("用户: {} ({})", name, user_id);
                println!("Token: {}", token);
                println!("权限: {:?}", permissions);
                println!("有效期: 1小时");
                println!("测试URL: ws://localhost:3000/ws?token={}", token);
                println!("{}","-".repeat(80));
            }
            Err(e) => {
                eprintln!("生成Token失败 {}: {}", user_id, e);
            }
        }
    }

    // 生成简单Token
    println!();
    println!("预设简单Tokens:");
    println!();
    
    let simple_tokens = vec![
        ("admin_token_123", "管理员Token", vec!["admin", "read", "write", "delete"]),
        ("user_token_456", "用户Token", vec!["read", "write"]),
        ("guest_token_789", "访客Token", vec!["read"]),
        ("developer_token_000", "开发者Token", vec!["admin", "debug", "read", "write"]),
    ];

    for (token, desc, permissions) in simple_tokens {
        println!("Token: {}", token);
        println!("描述: {}", desc);
        println!("权限: {:?}", permissions);
        println!("测试URL: ws://localhost:3000/ws?token={}", token);
        println!("{}","-".repeat(80));
    }

    // 生成自定义Token
    println!();
    println!("🎯 生成自定义Token:");
    
    print!("请输入用户名 (默认: custom_user): ");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
    let user_name = input.trim();
    let user_name = if user_name.is_empty() { "custom_user" } else { user_name };

    print!("请输入权限列表，用逗号分隔 (默认: read,write): ");
    input.clear();
    std::io::stdin().read_line(&mut input).unwrap();
    let permissions_str = input.trim();
    let permissions_str = if permissions_str.is_empty() { "read,write" } else { permissions_str };
    let permissions: Vec<String> = permissions_str.split(',').map(|s| s.trim().to_string()).collect();

    print!("请输入有效期(秒) (默认: 3600): ");
    input.clear();
    std::io::stdin().read_line(&mut input).unwrap();
    let expires_in = input.trim().parse::<usize>().unwrap_or(3600);

    let user_id = format!("custom_{}", Uuid::new_v4().to_string()[..8].to_string());

    match generate_jwt_token(&user_id, user_name, permissions.clone(), secret, expires_in) {
        Ok(token) => {
            println!();
            println!("✅ 自定义Token生成成功!");
            println!("用户ID: {}", user_id);
            println!("用户名: {}", user_name);
            println!("权限: {:?}", permissions);
            println!("有效期: {}秒", expires_in);
            println!("Token: {}", token);
            println!("测试URL: ws://localhost:3000/ws?token={}", token);
        }
        Err(e) => {
            eprintln!("❌ 生成自定义Token失败: {}", e);
        }
    }
}

fn generate_jwt_token(
    user_id: &str,
    name: &str,
    permissions: Vec<&str>,
    secret: &str,
    expires_in: usize,
) -> Result<String, jsonwebtoken::errors::Error> {
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() as usize;

    let claims = Claims {
        sub: user_id.to_string(),
        name: name.to_string(),
        permissions: permissions.into_iter().map(String::from).collect(),
        exp: now + expires_in,
        iat: now,
        iss: "websocket-auth-server".to_string(),
    };

    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_ref()))
}</pre>

        <p><strong>步骤 5: 创建认证客户端</strong></p>
        <p><strong>创建 src/client.rs：</strong></p>
        <pre>use futures_util::{SinkExt, StreamExt};
use serde_json;
use std::io::{self, Write};
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🔐 WebSocket 认证客户端");
    println!("========================");

    // 获取认证Token
    print!("请输入认证Token: ");
    io::stdout().flush().unwrap();
    let mut token = String::new();
    io::stdin().read_line(&mut token).unwrap();
    let token = token.trim();

    if token.is_empty() {
        println!("❌ Token不能为空");
        println!("💡 提示：可以使用以下预设Token:");
        println!("   - admin_token_123 (管理员权限)");
        println!("   - user_token_456 (普通用户权限)");
        println!("   - guest_token_789 (访客权限)");
        println!("   - 或运行 cargo run --bin token_generator 生成JWT Token");
        return Ok(());
    }

    let url = format!("ws://127.0.0.1:3000/ws?token={}", urlencoding::encode(token));
    println!("🔗 连接到: {}", url);

    let (ws_stream, response) = connect_async(&url).await?;
    println!("✅ WebSocket连接成功!");
    println!("📋 服务器响应状态: {}", response.status());

    let (mut write, mut read) = ws_stream.split();

    // 启动接收消息的任务
    let read_handle = tokio::spawn(async move {
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    if let Ok(json_msg) = serde_json::from_str::<serde_json::Value>(&text) {
                        print_json_message(&json_msg);
                    } else {
                        println!("📩 文本消息: {}", text);
                    }
                }
                Ok(Message::Binary(data)) => {
                    println!("📦 二进制消息: {} 字节", data.len());
                }
                Ok(Message::Close(close_frame)) => {
                    println!("👋 服务器关闭连接: {:?}", close_frame);
                    break;
                }
                Ok(Message::Ping(_)) => {
                    println!("🏓 收到Ping");
                }
                Ok(Message::Pong(_)) => {
                    println!("🏓 收到Pong");
                }
                Err(e) => {
                    println!("❌ 接收消息错误: {}", e);
                    break;
                }
            }
        }
    });

    // 显示帮助信息
    println!();
    println!("💡 可用命令:");
    println!("   ping                    - 发送ping测试");
    println!("   info                    - 获取用户信息");
    println!("   stats                   - 获取服务器统计 (需要admin权限)");
    println!("   admin list_users        - 列出所有在线用户 (需要admin权限)");
    println!("   admin server_info       - 获取服务器信息 (需要admin权限)");
    println!("   json {{\"key\":\"value\"}}   - 发送JSON消息");
    println!("   quit                    - 退出客户端");
    println!();

    // 消息发送循环
    loop {
        print!("🔐 > ");
        io::stdout().flush().unwrap();

        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        let input = input.trim();

        if input == "quit" || input == "exit" {
            break;
        }

        if input.is_empty() {
            continue;
        }

        // 处理命令
        let message = match input {
            "ping" => {
                serde_json::json!({ "type": "ping" })
            }
            "info" => {
                serde_json::json!({ "type": "get_user_info" })
            }
            "stats" => {
                serde_json::json!({ "type": "get_stats" })
            }
            _ if input.starts_with("admin ") => {
                let action = &input[6..];
                serde_json::json!({
                    "type": "admin_action",
                    "action": action
                })
            }
            _ if input.starts_with("json ") => {
                let json_str = &input[5..];
                match serde_json::from_str::<serde_json::Value>(json_str) {
                    Ok(json_val) => json_val,
                    Err(e) => {
                        println!("❌ JSON解析失败: {}", e);
                        continue;
                    }
                }
            }
            _ => {
                // 普通文本消息
                serde_json::json!({
                    "type": "text_message",
                    "content": input
                })
            }
        };

        if write
            .send(Message::Text(serde_json::to_string(&message).unwrap()))
            .await
            .is_err()
        {
            println!("❌ 发送消息失败");
            break;
        }

        println!("📤 已发送: {}", serde_json::to_string(&message).unwrap());
    }

    println!("👋 正在关闭连接...");
    let _ = write.send(Message::Close(None)).await;
    read_handle.abort();

    Ok(())
}

fn print_json_message(msg: &serde_json::Value) {
    let msg_type = msg.get("type").and_then(|v| v.as_str()).unwrap_or("unknown");
    let timestamp = chrono::Local::now().format("%H:%M:%S").to_string();

    match msg_type {
        "auth_success" => {
            println!("\n✅ [{}] {}", timestamp, msg.get("message").and_then(|v| v.as_str()).unwrap_or("认证成功"));
            if let Some(user) = msg.get("user") {
                println!("👤 用户信息:");
                println!("   ID: {}", user.get("id").and_then(|v| v.as_str()).unwrap_or("N/A"));
                println!("   姓名: {}", user.get("name").and_then(|v| v.as_str()).unwrap_or("N/A"));
                if let Some(permissions) = user.get("permissions").and_then(|v| v.as_array()) {
                    let perms: Vec<String> = permissions.iter()
                        .filter_map(|p| p.as_str())
                        .map(String::from)
                        .collect();
                    println!("   权限: {:?}", perms);
                }
                println!("   连接时间: {}", user.get("connected_at").and_then(|v| v.as_str()).unwrap_or("N/A"));
            }
        }
        "pong" => {
            println!("🏓 [{}] Pong响应", timestamp);
        }
        "user_info" => {
            println!("👤 [{}] 用户信息更新:", timestamp);
            if let Some(user) = msg.get("user") {
                println!("   {}", serde_json::to_string_pretty(user).unwrap_or_default());
            }
        }
        "stats" => {
            println!("📊 [{}] 服务器统计:", timestamp);
            if let Some(data) = msg.get("data") {
                println!("   {}", serde_json::to_string_pretty(data).unwrap_or_default());
            }
        }
        "admin_response" => {
            let action = msg.get("action").and_then(|v| v.as_str()).unwrap_or("unknown");
            println!("👑 [{}] 管理员操作响应 ({}):", timestamp, action);
            if let Some(data) = msg.get("data") {
                println!("   {}", serde_json::to_string_pretty(data).unwrap_or_default());
            }
        }
        "error" => {
            let error_msg = msg.get("message").and_then(|v| v.as_str()).unwrap_or("未知错误");
            println!("❌ [{}] 错误: {}", timestamp, error_msg);
            if let Some(required_perm) = msg.get("required_permission") {
                println!("   需要权限: {}", required_perm.as_str().unwrap_or("unknown"));
            }
        }
        "echo" => {
            println!("🔄 [{}] Echo响应:", timestamp);
            println!("   {}", serde_json::to_string_pretty(msg).unwrap_or_default());
        }
        _ => {
            println!("📩 [{}] 收到消息 ({}):", timestamp, msg_type);
            println!("   {}", serde_json::to_string_pretty(msg).unwrap_or_default());
        }
    }

    print!("\n🔐 > ");
    io::stdout().flush().unwrap();
}</pre>

        <p><strong>运行和测试：</strong></p>
        <pre># 1. 运行服务器
cargo run --bin server

# 2. 生成测试Token (可选)
cargo run --bin token_generator

# 3. 运行客户端测试
cargo run --bin client

# 4. 或在浏览器中访问测试页面
# http://localhost:3000</pre>

        <p><strong>认证测试场景：</strong></p>
        <pre># 测试场景1: 使用有效的简单Token
ws://localhost:3000/ws?token=admin_token_123

# 测试场景2: 使用无效Token (应该被拒绝)
ws://localhost:3000/ws?token=invalid_token

# 测试场景3: 不提供Token (应该被拒绝)
ws://localhost:3000/ws

# 测试场景4: 使用JWT Token
# 先运行 token_generator 生成JWT，然后使用生成的Token连接

# 测试场景5: 权限测试
# 使用 guest_token_789 连接，然后尝试执行需要admin权限的操作</pre>

        <p><strong>实践任务：</strong></p>
        <ul>
            <li>实现基于IP的连接限制和黑名单功能</li>
            <li>添加Token刷新机制（在Token快过期时自动刷新）</li>
            <li>实现基于角色的权限控制（RBAC）</li>
            <li>添加连接审计日志（记录所有连接尝试和权限检查）</li>
            <li>实现动态权限管理（运行时添加/删除用户权限）</li>
            <li>添加Token撤销机制（黑名单失效的Token）</li>
            <li>实现多因素认证（2FA）支持</li>
            <li>添加连接速率限制和防暴力破解机制</li>
        </ul>

        <pre>📁 项目结构：
day18_websocket_auth/
├── src/
│   ├── main.rs
│   ├── client.rs
│   └── token_generator.rs
├── templates/
│   └── auth.html
├── Cargo.toml
└── .gitignore</pre>
    
        <p class="date"><strong>🗓️ 2025-08-19</strong></p>
        <h2>Day 19 - 构建日志系统：tracing 日志输出</h2>
        <p>今天你将学习并实现 Rust 中强大的 tracing 日志系统。你将配置结构化日志输出，添加日志等级控制，并在 WebSocket 服务中使用 tracing 来监控连接状态、消息处理和错误追踪。</p>
        
        <p><strong>🎯 今日目标</strong></p>
        <ul>
            <li>理解 tracing 与传统 log 的区别</li>
            <li>配置 tracing_subscriber 日志格式化</li>
            <li>使用不同日志等级记录信息</li>
            <li>添加结构化字段和上下文追踪</li>
            <li>实现生产环境日志配置</li>
        </ul>

        <p>🔗 <a href="https://docs.rs/tracing/latest/tracing/" target="_blank">阅读对应官方文档</a></p>

        <p><strong>步骤 1: 项目设置</strong></p>
        <pre>📁 项目结构：
day19_websocket_logging/
├── src/
│   ├── main.rs
│   ├── server.rs
│   └── client.rs
├── static/
│   └── index.html
├── Cargo.toml
└── logs/
    └── app.log</pre>

        <p><strong>Cargo.toml 配置：</strong></p>
        <pre>[package]
name = "websocket-logging"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.21"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["fs", "cors"] }

# Tracing dependencies
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["json", "env-filter"] }
tracing-appender = "0.2"
anyhow = "1.0"
chrono = { version = "0.4", features = ["serde"] }</pre>

        <p><strong>步骤 2: 创建主服务器 (src/main.rs)</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocketUpgrade, State},
    http::StatusCode,
    response::{Html, Response},
    routing::get,
    Router,
};
use std::{collections::HashMap, net::SocketAddr, sync::Arc};
use tokio::sync::{broadcast, RwLock};
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{debug, error, info, instrument, warn, Span};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use uuid::Uuid;

mod server;
use server::{handle_websocket, AppState, ConnectedClient};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 初始化日志系统
    init_tracing()?;
    
    info!("🚀 启动 WebSocket 日志服务器");
    
    // 创建应用状态
    let (tx, _rx) = broadcast::channel(1000);
    let state = Arc::new(AppState {
        clients: RwLock::new(HashMap::new()),
        tx,
    });
    
    // 创建路由
    let app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .route("/health", get(health_handler))
        .route("/metrics", get(metrics_handler))
        .nest_service("/static", ServeDir::new("static"))
        .with_state(state)
        .layer(CorsLayer::permissive());
    
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    info!(address = %addr, "服务器启动完成");
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;
    
    Ok(())
}

/// 初始化 tracing 日志系统
fn init_tracing() -> anyhow::Result<()> {
    // 创建日志目录
    std::fs::create_dir_all("logs")?;
    
    // 文件 appender
    let file_appender = tracing_appender::rolling::daily("logs", "app.log");
    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);
    
    // 环境过滤器，支持通过环境变量控制日志等级
    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| "info,axum=debug,tower_http=debug".into());
    
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_target(true)
                .with_thread_ids(true)
                .with_line_number(true)
                .with_file(true)
                .compact()
        )
        .with(
            tracing_subscriber::fmt::layer()
                .with_writer(non_blocking)
                .with_ansi(false)
                .json()
        )
        .with(env_filter)
        .init();
    
    info!("📝 日志系统初始化完成");
    Ok(())
}

#[instrument(name = "websocket_upgrade")]
async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<Arc<AppState>>,
) -> Response {
    let client_id = Uuid::new_v4();
    info!(client_id = %client_id, "新的 WebSocket 连接请求");
    
    ws.on_upgrade(move |socket| {
        let span = tracing::info_span!("websocket_connection", client_id = %client_id);
        async move {
            if let Err(e) = handle_websocket(socket, state, client_id).await {
                error!(client_id = %client_id, error = %e, "WebSocket 连接处理失败");
            }
        }
        .instrument(span)
    })
}

async fn index_handler() -> Html<&'static str> {
    debug!("提供主页");
    Html(include_str!("../static/index.html"))
}

#[instrument]
async fn health_handler(State(state): State<Arc<AppState>>) -> Result<String, StatusCode> {
    let clients = state.clients.read().await;
    let client_count = clients.len();
    debug!(client_count, "健康检查");
    
    Ok(format!("{{\"status\":\"healthy\",\"clients\":{}}}", client_count))
}

#[instrument]
async fn metrics_handler(State(state): State<Arc<AppState>>) -> Result<String, StatusCode> {
    let clients = state.clients.read().await;
    let active_connections = clients.len();
    let total_messages: u64 = clients.values().map(|c| c.message_count).sum();
    
    info!(
        active_connections,
        total_messages,
        "指标请求"
    );
    
    Ok(format!(
        "{{\"active_connections\":{},\"total_messages\":{}}}",
        active_connections, total_messages
    ))
}</pre>

        <p><strong>步骤 3: WebSocket 处理器 (src/server.rs)</strong></p>
        <pre>use axum::extract::ws::{Message, WebSocket};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, time::Instant};
use tokio::sync::{broadcast, RwLock};
use tracing::{debug, error, info, instrument, warn};
use uuid::Uuid;

#[derive(Debug, Clone)]
pub struct ConnectedClient {
    pub id: Uuid,
    pub name: String,
    pub connected_at: Instant,
    pub message_count: u64,
}

pub struct AppState {
    pub clients: RwLock<HashMap<Uuid, ConnectedClient>>,
    pub tx: broadcast::Sender<BroadcastMessage>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    pub message_type: String,
    pub content: String,
    pub sender: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub struct BroadcastMessage {
    pub sender_id: Uuid,
    pub message: ChatMessage,
}

#[instrument(skip(socket, state))]
pub async fn handle_websocket(
    mut socket: WebSocket,
    state: std::sync::Arc<AppState>,
    client_id: Uuid,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    info!(client_id = %client_id, "WebSocket 连接建立");
    
    // 发送欢迎消息
    let welcome_msg = ChatMessage {
        message_type: "system".to_string(),
        content: format!("欢迎连接！您的 ID: {}", client_id),
        sender: Some("系统".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    if let Err(e) = socket.send(Message::Text(serde_json::to_string(&welcome_msg)?)).await {
        error!(client_id = %client_id, error = %e, "发送欢迎消息失败");
        return Err(e.into());
    }
    
    // 注册客户端
    let client = ConnectedClient {
        id: client_id,
        name: format!("用户-{}", &client_id.to_string()[..8]),
        connected_at: Instant::now(),
        message_count: 0,
    };
    
    {
        let mut clients = state.clients.write().await;
        clients.insert(client_id, client.clone());
        info!(
            client_id = %client_id,
            client_name = %client.name,
            total_clients = clients.len(),
            "客户端注册成功"
        );
    }
    
    // 广播新用户加入
    let join_msg = ChatMessage {
        message_type: "join".to_string(),
        content: format!("{} 加入了聊天室", client.name),
        sender: Some("系统".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    let broadcast_msg = BroadcastMessage {
        sender_id: client_id,
        message: join_msg,
    };
    
    if let Err(e) = state.tx.send(broadcast_msg) {
        warn!(client_id = %client_id, error = %e, "广播加入消息失败");
    }
    
    // 创建广播接收器
    let mut rx = state.tx.subscribe();
    let state_clone = state.clone();
    
    // 启动消息广播任务
    let broadcast_task = tokio::spawn(async move {
        while let Ok(broadcast_msg) = rx.recv().await {
            // 不向发送者回显消息
            if broadcast_msg.sender_id == client_id {
                continue;
            }
            
            debug!(
                client_id = %client_id,
                sender_id = %broadcast_msg.sender_id,
                message_type = %broadcast_msg.message.message_type,
                "转发广播消息"
            );
            
            let msg_json = match serde_json::to_string(&broadcast_msg.message) {
                Ok(json) => json,
                Err(e) => {
                    error!(error = %e, "序列化广播消息失败");
                    continue;
                }
            };
            
            if let Err(e) = socket.send(Message::Text(msg_json)).await {
                error!(
                    client_id = %client_id,
                    error = %e,
                    "发送广播消息失败，连接可能已断开"
                );
                break;
            }
        }
    });
    
    // 处理客户端消息
    let mut message_count = 0u64;
    while let Some(msg) = socket.recv().await {
        match msg {
            Ok(Message::Text(text)) => {
                message_count += 1;
                debug!(
                    client_id = %client_id,
                    message_count,
                    text_length = text.len(),
                    "收到文本消息"
                );
                
                match serde_json::from_str::<ChatMessage>(&text) {
                    Ok(mut chat_msg) => {
                        chat_msg.sender = Some(client.name.clone());
                        chat_msg.timestamp = chrono::Utc::now();
                        
                        info!(
                            client_id = %client_id,
                            sender = %chat_msg.sender.as_ref().unwrap(),
                            message_type = %chat_msg.message_type,
                            content_length = chat_msg.content.len(),
                            "处理聊天消息"
                        );
                        
                        let broadcast_msg = BroadcastMessage {
                            sender_id: client_id,
                            message: chat_msg,
                        };
                        
                        if let Err(e) = state.tx.send(broadcast_msg) {
                            error!(
                                client_id = %client_id,
                                error = %e,
                                "广播消息失败"
                            );
                        } else {
                            // 更新客户端消息计数
                            if let Ok(mut clients) = state.clients.write().await.try_write() {
                                if let Some(client) = clients.get_mut(&client_id) {
                                    client.message_count += 1;
                                }
                            }
                        }
                    }
                    Err(e) => {
                        warn!(
                            client_id = %client_id,
                            error = %e,
                            raw_text = %text,
                            "消息 JSON 解析失败"
                        );
                        
                        let error_msg = ChatMessage {
                            message_type: "error".to_string(),
                            content: "消息格式错误".to_string(),
                            sender: Some("系统".to_string()),
                            timestamp: chrono::Utc::now(),
                        };
                        
                        let _ = socket.send(Message::Text(
                            serde_json::to_string(&error_msg)?
                        )).await;
                    }
                }
            }
            Ok(Message::Binary(data)) => {
                debug!(
                    client_id = %client_id,
                    data_length = data.len(),
                    "收到二进制消息"
                );
                
                let response = format!("收到 {} 字节二进制数据", data.len());
                let echo_msg = ChatMessage {
                    message_type: "binary_ack".to_string(),
                    content: response,
                    sender: Some("系统".to_string()),
                    timestamp: chrono::Utc::now(),
                };
                
                let _ = socket.send(Message::Text(
                    serde_json::to_string(&echo_msg)?
                )).await;
            }
            Ok(Message::Close(frame)) => {
                info!(
                    client_id = %client_id,
                    close_frame = ?frame,
                    "客户端主动关闭连接"
                );
                break;
            }
            Err(e) => {
                error!(
                    client_id = %client_id,
                    error = %e,
                    "WebSocket 消息接收错误"
                );
                break;
            }
            _ => {
                debug!(client_id = %client_id, "收到其他类型消息");
            }
        }
    }
    
    // 清理工作
    broadcast_task.abort();
    
    // 从客户端列表中移除
    {
        let mut clients = state.clients.write().await;
        if let Some(removed_client) = clients.remove(&client_id) {
            info!(
                client_id = %client_id,
                client_name = %removed_client.name,
                session_duration = ?removed_client.connected_at.elapsed(),
                total_messages = removed_client.message_count,
                remaining_clients = clients.len(),
                "客户端断开连接，清理完成"
            );
        }
    }
    
    // 广播用户离开消息
    let leave_msg = ChatMessage {
        message_type: "leave".to_string(),
        content: format!("{} 离开了聊天室", client.name),
        sender: Some("系统".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    let broadcast_msg = BroadcastMessage {
        sender_id: client_id,
        message: leave_msg,
    };
    
    let _ = state.tx.send(broadcast_msg);
    
    Ok(())
}</pre>

        <p><strong>步骤 4: 命令行测试客户端 (src/client.rs)</strong></p>
        <pre>use serde_json::json;
use std::io::{self, Write};
use tokio_tungstenite::{connect_async, tungstenite::Message};
use tracing::{error, info};
use url::Url;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 简单的控制台日志
    tracing_subscriber::fmt()
        .with_env_filter("info")
        .init();
    
    let url = Url::parse("ws://127.0.0.1:3000/ws")?;
    info!("连接到 WebSocket 服务器: {}", url);
    
    let (ws_stream, _) = connect_async(url).await?;
    info!("WebSocket 连接建立成功！");
    
    let (mut write, mut read) = ws_stream.split();
    
    // 启动消息接收任务
    let read_task = tokio::spawn(async move {
        use futures_util::StreamExt;
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&text) {
                        if let Some(content) = parsed.get("content") {
                            if let Some(sender) = parsed.get("sender") {
                                println!("[{}] {}", sender, content);
                            } else {
                                println!("{}", content);
                            }
                        } else {
                            println!("收到消息: {}", text);
                        }
                    } else {
                        println!("收到消息: {}", text);
                    }
                }
                Ok(Message::Close(_)) => {
                    info!("服务器关闭连接");
                    break;
                }
                Err(e) => {
                    error!("接收消息错误: {}", e);
                    break;
                }
                _ => {}
            }
        }
    });
    
    // 主输入循环
    println!("WebSocket 聊天客户端");
    println!("输入消息并按回车发送，输入 'quit' 退出");
    println!("---");
    
    loop {
        print!("> ");
        io::stdout().flush()?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let input = input.trim();
        
        if input == "quit" {
            info!("用户请求退出");
            break;
        }
        
        if input.is_empty() {
            continue;
        }
        
        let message = json!({
            "message_type": "chat",
            "content": input,
            "sender": null,
            "timestamp": chrono::Utc::now()
        });
        
        use futures_util::SinkExt;
        if let Err(e) = write.send(Message::Text(message.to_string())).await {
            error!("发送消息失败: {}", e);
            break;
        }
    }
    
    read_task.abort();
    info!("客户端退出");
    Ok(())
}</pre>

        <p><strong>步骤 5: 前端测试页面 (static/index.html)</strong></p>
        <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;WebSocket 日志监控聊天室&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .main-content {
            display: flex;
            height: 600px;
        }
        
        .chat-area {
            flex: 2;
            display: flex;
            flex-direction: column;
            border-right: 2px solid #ecf0f1;
        }
        
        .log-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #2c3e50;
            color: #ecf0f1;
        }
        
        #messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
            border-bottom: 2px solid #ecf0f1;
        }
        
        #logs {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #34495e;
        }
        
        .input-area {
            padding: 15px;
            background: white;
            border-top: 1px solid #ecf0f1;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
        }
        
        #messageInput {
            flex: 1;
            padding: 12px;
            border: 2px solid #ecf0f1;
            border-radius: 5px;
            font-size: 14px;
        }
        
        #messageInput:focus {
            outline: none;
            border-color: #3498db;
        }
        
        button {
            padding: 12px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover:not(:disabled) {
            background: #2980b9;
        }
        
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        
        .status {
            padding: 10px 20px;
            background: #ecf0f1;
            border-bottom: 1px solid #bdc3c7;
            font-size: 14px;
        }
        
        .status.connected {
            background: #d5f4e6;
            color: #27ae60;
        }
        
        .status.disconnected {
            background: #fadbd8;
            color: #e74c3c;
        }
        
        .message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            line-height: 1.4;
        }
        
        .message.system {
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            font-style: italic;
        }
        
        .message.user {
            background: #e8f5e8;
            border-left: 4px solid #27ae60;
        }
        
        .message.error {
            background: #fdf2f2;
            border-left: 4px solid #e74c3c;
        }
        
        .message.join {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        
        .message.leave {
            background: #f4f4f4;
            border-left: 4px solid #6c757d;
        }
        
        .message-meta {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px solid #2c3e50;
        }
        
        .log-entry.info { color: #3498db; }
        .log-entry.warn { color: #f39c12; }
        .log-entry.error { color: #e74c3c; }
        .log-entry.debug { color: #95a5a6; }
        
        .controls {
            padding: 15px 20px;
            background: #34495e;
            border-bottom: 1px solid #2c3e50;
        }
        
        .controls button {
            margin-right: 10px;
            font-size: 12px;
            padding: 8px 12px;
        }
        
        .controls .clear {
            background: #e74c3c;
        }
        
        .controls .clear:hover {
            background: #c0392b;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;📊 WebSocket 日志监控聊天室&lt;/h1&gt;
            &lt;p&gt;实时消息 + 结构化日志监控&lt;/p&gt;
        &lt;/div&gt;
        
        &lt;div class="status" id="status"&gt;
            🔴 未连接
        &lt;/div&gt;
        
        &lt;div class="main-content"&gt;
            &lt;div class="chat-area"&gt;
                &lt;div id="messages"&gt;&lt;/div&gt;
                &lt;div class="input-area"&gt;
                    &lt;div class="input-group"&gt;
                        &lt;input 
                            type="text" 
                            id="messageInput" 
                            placeholder="输入消息..." 
                            disabled
                        &gt;
                        &lt;button id="sendButton" disabled&gt;发送&lt;/button&gt;
                        &lt;button id="connectButton"&gt;连接&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class="log-area"&gt;
                &lt;div class="controls"&gt;
                    &lt;button onclick="clearLogs()" class="clear"&gt;清空日志&lt;/button&gt;
                    &lt;button onclick="toggleLogLevel()"&gt;切换等级&lt;/button&gt;
                    &lt;button onclick="exportLogs()"&gt;导出日志&lt;/button&gt;
                &lt;/div&gt;
                &lt;div id="logs"&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        let ws = null;
        let isConnected = false;
        let logLevel = 'info';
        let logEntries = [];
        
        const statusEl = document.getElementById('status');
        const messagesEl = document.getElementById('messages');
        const logsEl = document.getElementById('logs');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const connectButton = document.getElementById('connectButton');
        
        function log(level, message, data = null) {
            const timestamp = new Date().toISOString();
            const entry = {
                timestamp,
                level,
                message,
                data: data ? JSON.stringify(data, null, 2) : null
            };
            
            logEntries.push(entry);
            
            const logEl = document.createElement('div');
            logEl.className = `log-entry ${level}`;
            logEl.innerHTML = `
                &lt;strong&gt;[${timestamp.substring(11, 23)}]&lt;/strong&gt; 
                &lt;span class="level"&gt;${level.toUpperCase()}&lt;/span&gt; 
                ${message}
                ${data ? `&lt;br&gt;&lt;pre style="margin: 5px 0; font-size: 10px;"&gt;${JSON.stringify(data, null, 2)}&lt;/pre&gt;` : ''}
            `;
            
            logsEl.appendChild(logEl);
            logsEl.scrollTop = logsEl.scrollHeight;
            
            // 限制日志条数
            while (logsEl.children.length > 1000) {
                logsEl.removeChild(logsEl.firstChild);
            }
        }
        
        function updateStatus(status, connected) {
            isConnected = connected;
            statusEl.textContent = status;
            statusEl.className = `status ${connected ? 'connected' : 'disconnected'}`;
            
            messageInput.disabled = !connected;
            sendButton.disabled = !connected;
            connectButton.textContent = connected ? '断开' : '连接';
        }
        
        function addMessage(type, content, sender = null, timestamp = null) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            
            const time = timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
            
            messageEl.innerHTML = `
                &lt;div&gt;${content}&lt;/div&gt;
                &lt;div class="message-meta"&gt;
                    ${sender ? `👤 ${sender} • ` : ''}⏰ ${time}
                &lt;/div&gt;
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function connect() {
            if (isConnected) {
                disconnect();
                return;
            }
            
            log('info', '尝试连接 WebSocket 服务器...');
            
            try {
                ws = new WebSocket('ws://localhost:3000/ws');
                
                ws.onopen = function(event) {
                    log('info', 'WebSocket 连接建立成功', { 
                        url: ws.url,
                        readyState: ws.readyState 
                    });
                    updateStatus('🟢 已连接', true);
                    addMessage('system', '连接成功！欢迎使用聊天室');
                };
                
                ws.onmessage = function(event) {
                    log('debug', '收到服务器消息', { 
                        data: event.data,
                        size: event.data.length 
                    });
                    
                    try {
                        const message = JSON.parse(event.data);
                        
                        addMessage(
                            message.message_type || 'user',
                            message.content,
                            message.sender,
                            message.timestamp
                        );
                        
                        log('info', `处理消息: ${message.message_type}`, {
                            sender: message.sender,
                            content_length: message.content.length
                        });
                        
                    } catch (e) {
                        log('error', '解析消息 JSON 失败', { 
                            raw: event.data,
                            error: e.message 
                        });
                        addMessage('error', `消息解析错误: ${event.data}`);
                    }
                };
                
                ws.onclose = function(event) {
                    log('warn', 'WebSocket 连接关闭', {
                        code: event.code,
                        reason: event.reason,
                        wasClean: event.wasClean
                    });
                    updateStatus('🔴 连接断开', false);
                    addMessage('system', `连接断开 (代码: ${event.code})`);
                };
                
                ws.onerror = function(error) {
                    log('error', 'WebSocket 连接错误', { error: error.toString() });
                    updateStatus('🔴 连接错误', false);
                    addMessage('error', '连接发生错误');
                };
                
            } catch (e) {
                log('error', 'WebSocket 初始化失败', { error: e.message });
                updateStatus('🔴 连接失败', false);
            }
        }
        
        function disconnect() {
            if (ws) {
                log('info', '主动断开 WebSocket 连接');
                ws.close();
                ws = null;
            }
            updateStatus('🔴 未连接', false);
        }
        
        function sendMessage() {
            if (!isConnected || !ws) {
                log('warn', '尝试发送消息但连接未建立');
                return;
            }
            
            const content = messageInput.value.trim();
            if (!content) return;
            
            const message = {
                message_type: 'chat',
                content: content,
                sender: null,
                timestamp: new Date().toISOString()
            };
            
            try {
                ws.send(JSON.stringify(message));
                log('info', '发送消息', { 
                    content_length: content.length,
                    message_type: 'chat' 
                });
                
                messageInput.value = '';
            } catch (e) {
                log('error', '发送消息失败', { error: e.message });
                addMessage('error', '消息发送失败');
            }
        }
        
        function clearLogs() {
            logsEl.innerHTML = '';
            logEntries = [];
            log('info', '日志已清空');
        }
        
        function toggleLogLevel() {
            const levels = ['debug', 'info', 'warn', 'error'];
            const currentIndex = levels.indexOf(logLevel);
            logLevel = levels[(currentIndex + 1) % levels.length];
            log('info', `日志等级切换为: ${logLevel.toUpperCase()}`);
        }
        
        function exportLogs() {
            const logsJson = JSON.stringify(logEntries, null, 2);
            const blob = new Blob([logsJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `websocket_logs_${new Date().toISOString().slice(0, 19)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('info', '日志已导出', { entries: logEntries.length });
        }
        
        // 事件监听
        connectButton.addEventListener('click', connect);
        sendButton.addEventListener('click', sendMessage);
        
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        // 页面加载完成
        log('info', '页面加载完成，准备就绪');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

        <p><strong>步骤 6: 运行和测试</strong></p>
        <pre># 启动服务器（支持环境变量控制日志等级）
RUST_LOG=debug cargo run --bin websocket-logging

# 在另一个终端启动命令行客户端
cargo run --bin client

# 或在浏览器访问
open http://localhost:3000</pre>

        <p><strong>步骤 7: 日志等级测试</strong></p>
        <pre># 不同等级的日志输出测试
RUST_LOG=error cargo run    # 只显示错误
RUST_LOG=warn cargo run     # 显示警告和错误
RUST_LOG=info cargo run     # 显示信息、警告和错误（默认）
RUST_LOG=debug cargo run    # 显示所有日志
RUST_LOG=trace cargo run    # 显示最详细的日志

# 模块级别控制
RUST_LOG=websocket_logging=debug,axum=info cargo run</pre>

        <p><strong>🎯 今日收获</strong></p>
        <ul>
            <li>✅ 学会使用 tracing 进行结构化日志记录</li>
            <li>✅ 配置文件和控制台双重日志输出</li>
            <li>✅ 使用环境变量控制日志等级</li>
            <li>✅ 在 WebSocket 应用中添加上下文追踪</li>
            <li>✅ 实现生产环境日志轮转和归档</li>
            <li>✅ 通过 instrument 宏简化日志标记</li>
            <li>✅ 理解日志与监控的重要性</li>
        </ul>

        <p><strong>💡 扩展练习</strong></p>
        <ul>
            <li>添加 Prometheus 指标导出</li>
            <li>集成 OpenTelemetry 分布式追踪</li>
            <li>实现日志聚合和检索功能</li>
            <li>添加性能监控和报警机制</li>
        </ul>
    
        <p class="date"><strong>🗓️ 2025-08-20</strong></p>
        <h2>Day 20 - 构建 release 版本并创建 Dockerfile</h2>
        <p>今天你将学习如何使用 Docker 容器化 Rust WebSocket 应用。你将创建多阶段 Dockerfile 来优化镜像大小，配置生产环境参数，并掌握 Docker 构建和部署的最佳实践。</p>
        
        <p><strong>🎯 今日目标</strong></p>
        <ul>
            <li>创建多阶段 Dockerfile 优化镜像大小</li>
            <li>配置生产环境的 Rust 构建</li>
            <li>设置容器运行时环境变量</li>
            <li>实现健康检查和监控端点</li>
            <li>掌握 Docker 安全最佳实践</li>
        </ul>

        <p>🔗 <a href="https://docs.docker.com/build/building/multi-stage/" target="_blank">阅读对应官方文档</a></p>

        <p><strong>步骤 1: 项目设置</strong></p>
        <pre>📁 项目结构：
day20_docker_websocket/
├── src/
│   ├── main.rs
│   ├── server.rs
│   └── config.rs
├── static/
│   └── index.html
├── docker/
│   ├── Dockerfile
│   ├── docker-compose.yml
│   └── .dockerignore
├── scripts/
│   ├── build.sh
│   └── run.sh
├── Cargo.toml
├── .env.example
└── README.md</pre>

        <p><strong>步骤 2: 优化的 Cargo.toml</strong></p>
        <pre>[package]
name = "websocket-docker"
version = "0.1.0"
edition = "2021"
authors = ["Your Name &lt;your.email@example.com&gt;"]
description = "Production-ready WebSocket server with Docker deployment"

[dependencies]
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["fs", "cors"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["json", "env-filter"] }
anyhow = "1.0"
chrono = { version = "0.4", features = ["serde"] }
clap = { version = "4.0", features = ["derive", "env"] }
dotenvy = "0.15"

# 优化 release 构建
[profile.release]
lto = true              # Link Time Optimization
codegen-units = 1       # 单线程编译优化
panic = "abort"         # 减少二进制大小
strip = true            # 移除调试符号</pre>

        <p><strong>步骤 3: 配置管理 (src/config.rs)</strong></p>
        <pre>use clap::Parser;
use std::net::SocketAddr;

#[derive(Parser, Debug, Clone)]
#[command(name = "websocket-server")]
#[command(about = "Production WebSocket server with Docker support")]
pub struct Config {
    /// Server bind address
    #[arg(long, env = "BIND_ADDR", default_value = "0.0.0.0:3000")]
    pub bind_addr: SocketAddr,
    
    /// Log level
    #[arg(long, env = "LOG_LEVEL", default_value = "info")]
    pub log_level: String,
    
    /// Maximum number of concurrent connections
    #[arg(long, env = "MAX_CONNECTIONS", default_value = "1000")]
    pub max_connections: usize,
    
    /// Broadcast channel capacity
    #[arg(long, env = "CHANNEL_CAPACITY", default_value = "1000")]
    pub channel_capacity: usize,
    
    /// Enable metrics endpoint
    #[arg(long, env = "ENABLE_METRICS", default_value = "true")]
    pub enable_metrics: bool,
    
    /// Static files directory
    #[arg(long, env = "STATIC_DIR", default_value = "static")]
    pub static_dir: String,
    
    /// Application environment
    #[arg(long, env = "APP_ENV", default_value = "production")]
    pub environment: String,
}

impl Config {
    pub fn from_env() -> anyhow::Result<Self> {
        // 加载 .env 文件（如果存在）
        let _ = dotenvy::dotenv();
        
        let config = Self::parse();
        
        tracing::info!(
            bind_addr = %config.bind_addr,
            log_level = %config.log_level,
            max_connections = config.max_connections,
            environment = %config.environment,
            "配置加载完成"
        );
        
        Ok(config)
    }
    
    pub fn is_production(&self) -> bool {
        self.environment == "production"
    }
}</pre>

        <p><strong>步骤 4: 生产环境主程序 (src/main.rs)</strong></p>
        <pre>use axum::{
    extract::{ws::WebSocketUpgrade, State},
    http::StatusCode,
    response::{Html, Json, Response},
    routing::get,
    Router,
};
use std::{collections::HashMap, sync::Arc, time::Duration};
use tokio::{signal, sync::{broadcast, RwLock}};
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{error, info, warn};
use uuid::Uuid;

mod config;
mod server;

use config::Config;
use server::{handle_websocket, AppState, ConnectedClient};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 加载配置
    let config = Config::from_env()?;
    
    // 初始化日志系统
    init_tracing(&config)?;
    
    info!("🚀 启动生产环境 WebSocket 服务器");
    info!("版本: {}", env!("CARGO_PKG_VERSION"));
    info!("构建时间: {}", env!("BUILD_TIMESTAMP"));
    
    // 创建应用状态
    let (tx, _rx) = broadcast::channel(config.channel_capacity);
    let state = Arc::new(AppState {
        clients: RwLock::new(HashMap::new()),
        tx,
        config: config.clone(),
        start_time: std::time::Instant::now(),
    });
    
    // 创建路由
    let mut app = Router::new()
        .route("/", get(index_handler))
        .route("/ws", get(websocket_handler))
        .route("/health", get(health_handler))
        .route("/ready", get(readiness_handler));
    
    // 可选的指标端点
    if config.enable_metrics {
        app = app.route("/metrics", get(metrics_handler));
    }
    
    // 静态文件服务
    if tokio::fs::metadata(&config.static_dir).await.is_ok() {
        app = app.nest_service("/static", ServeDir::new(&config.static_dir));
        info!("启用静态文件服务: {}", config.static_dir);
    }
    
    app = app
        .with_state(state.clone())
        .layer(CorsLayer::permissive());
    
    // 启动服务器
    info!(address = %config.bind_addr, "服务器启动完成");
    
    let listener = tokio::net::TcpListener::bind(config.bind_addr).await?;
    
    // 优雅关闭处理
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await?;
    
    info!("服务器优雅关闭完成");
    Ok(())
}

/// 初始化生产环境日志系统
fn init_tracing(config: &Config) -> anyhow::Result<()> {
    use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
    
    let env_filter = EnvFilter::try_from_default_env()
        .or_else(|_| EnvFilter::try_new(&config.log_level))?;
    
    if config.is_production() {
        // 生产环境：JSON 格式日志
        tracing_subscriber::registry()
            .with(
                tracing_subscriber::fmt::layer()
                    .json()
                    .with_target(true)
                    .with_current_span(false)
                    .with_span_list(false)
                    .with_ansi(false)
            )
            .with(env_filter)
            .init();
    } else {
        // 开发环境：可读性更好的格式
        tracing_subscriber::registry()
            .with(
                tracing_subscriber::fmt::layer()
                    .compact()
                    .with_target(true)
                    .with_line_number(true)
            )
            .with(env_filter)
            .init();
    }
    
    info!("📝 日志系统初始化完成");
    Ok(())
}

async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<Arc<AppState>>,
) -> Response {
    let client_id = Uuid::new_v4();
    
    // 检查连接数限制
    {
        let clients = state.clients.read().await;
        if clients.len() >= state.config.max_connections {
            warn!(
                client_id = %client_id,
                current_connections = clients.len(),
                max_connections = state.config.max_connections,
                "拒绝连接：达到最大连接数限制"
            );
            return (StatusCode::SERVICE_UNAVAILABLE, "服务器繁忙").into_response();
        }
    }
    
    info!(client_id = %client_id, "新的 WebSocket 连接请求");
    
    ws.on_upgrade(move |socket| async move {
        if let Err(e) = handle_websocket(socket, state, client_id).await {
            error!(client_id = %client_id, error = %e, "WebSocket 连接处理失败");
        }
    })
}

async fn index_handler() -> Html<&'static str> {
    Html(include_str!("../static/index.html"))
}

/// 健康检查端点
async fn health_handler(State(state): State<Arc<AppState>>) -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now(),
        "uptime_seconds": state.start_time.elapsed().as_secs(),
        "version": env!("CARGO_PKG_VERSION")
    }))
}

/// 就绪检查端点（Kubernetes readiness probe）
async fn readiness_handler(State(state): State<Arc<AppState>>) -> Result<Json<serde_json::Value>, StatusCode> {
    let clients = state.clients.read().await;
    let connection_count = clients.len();
    
    // 检查服务是否就绪
    if connection_count < state.config.max_connections {
        Ok(Json(serde_json::json!({
            "status": "ready",
            "connections": connection_count,
            "max_connections": state.config.max_connections,
            "timestamp": chrono::Utc::now()
        })))
    } else {
        Err(StatusCode::SERVICE_UNAVAILABLE)
    }
}

/// 指标端点
async fn metrics_handler(State(state): State<Arc<AppState>>) -> Json<serde_json::Value> {
    let clients = state.clients.read().await;
    let active_connections = clients.len();
    let total_messages: u64 = clients.values().map(|c| c.message_count).sum();
    let uptime = state.start_time.elapsed().as_secs();
    
    Json(serde_json::json!({
        "active_connections": active_connections,
        "total_messages": total_messages,
        "uptime_seconds": uptime,
        "max_connections": state.config.max_connections,
        "memory_usage_mb": get_memory_usage(),
        "timestamp": chrono::Utc::now()
    }))
}

/// 获取内存使用情况
fn get_memory_usage() -> u64 {
    // 简单的内存使用估算
    #[cfg(target_os = "linux")]
    {
        if let Ok(status) = std::fs::read_to_string("/proc/self/status") {
            for line in status.lines() {
                if line.starts_with("VmRSS:") {
                    if let Some(kb_str) = line.split_whitespace().nth(1) {
                        if let Ok(kb) = kb_str.parse::<u64>() {
                            return kb / 1024; // 转换为 MB
                        }
                    }
                }
            }
        }
    }
    0
}

/// 优雅关闭信号处理
async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            info!("收到 SIGINT 信号，开始优雅关闭");
        },
        _ = terminate => {
            info!("收到 SIGTERM 信号，开始优雅关闭");
        },
    }
    
    // 给予一些时间完成当前请求
    tokio::time::sleep(Duration::from_secs(1)).await;
}</pre>

        <p><strong>步骤 5: 更新的服务器逻辑 (src/server.rs)</strong></p>
        <pre>use axum::extract::ws::{Message, WebSocket};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, time::Instant};
use tokio::sync::{broadcast, RwLock};
use tracing::{debug, error, info, warn};
use uuid::Uuid;

use crate::config::Config;

#[derive(Debug, Clone)]
pub struct ConnectedClient {
    pub id: Uuid,
    pub name: String,
    pub connected_at: Instant,
    pub message_count: u64,
    pub last_activity: Instant,
}

pub struct AppState {
    pub clients: RwLock<HashMap<Uuid, ConnectedClient>>,
    pub tx: broadcast::Sender<BroadcastMessage>,
    pub config: Config,
    pub start_time: Instant,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    pub message_type: String,
    pub content: String,
    pub sender: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub struct BroadcastMessage {
    pub sender_id: Uuid,
    pub message: ChatMessage,
}

pub async fn handle_websocket(
    mut socket: WebSocket,
    state: std::sync::Arc<AppState>,
    client_id: Uuid,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    info!(
        client_id = %client_id,
        environment = %state.config.environment,
        "WebSocket 连接建立"
    );
    
    // 发送欢迎消息
    let welcome_msg = ChatMessage {
        message_type: "system".to_string(),
        content: format!(
            "欢迎连接到 {} 环境！您的 ID: {}",
            state.config.environment,
            client_id
        ),
        sender: Some("系统".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    if let Err(e) = socket.send(Message::Text(serde_json::to_string(&welcome_msg)?)).await {
        error!(client_id = %client_id, error = %e, "发送欢迎消息失败");
        return Err(e.into());
    }
    
    // 注册客户端
    let client = ConnectedClient {
        id: client_id,
        name: format!("用户-{}", &client_id.to_string()[..8]),
        connected_at: Instant::now(),
        message_count: 0,
        last_activity: Instant::now(),
    };
    
    {
        let mut clients = state.clients.write().await;
        clients.insert(client_id, client.clone());
        info!(
            client_id = %client_id,
            client_name = %client.name,
            total_clients = clients.len(),
            max_connections = state.config.max_connections,
            "客户端注册成功"
        );
    }
    
    // 广播新用户加入
    let join_msg = ChatMessage {
        message_type: "join".to_string(),
        content: format!("{} 加入了聊天室", client.name),
        sender: Some("系统".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    let _ = state.tx.send(BroadcastMessage {
        sender_id: client_id,
        message: join_msg,
    });
    
    // 创建广播接收器
    let mut rx = state.tx.subscribe();
    let state_clone = state.clone();
    
    // 启动消息广播任务
    let broadcast_task = tokio::spawn(async move {
        while let Ok(broadcast_msg) = rx.recv().await {
            if broadcast_msg.sender_id == client_id {
                continue;
            }
            
            let msg_json = match serde_json::to_string(&broadcast_msg.message) {
                Ok(json) => json,
                Err(e) => {
                    error!(error = %e, "序列化广播消息失败");
                    continue;
                }
            };
            
            if let Err(e) = socket.send(Message::Text(msg_json)).await {
                debug!(
                    client_id = %client_id,
                    error = %e,
                    "发送广播消息失败，连接可能已断开"
                );
                break;
            }
        }
    });
    
    // 处理客户端消息
    let mut message_count = 0u64;
    while let Some(msg) = socket.recv().await {
        match msg {
            Ok(Message::Text(text)) => {
                message_count += 1;
                
                // 更新活动时间
                {
                    let mut clients = state.clients.write().await;
                    if let Some(client) = clients.get_mut(&client_id) {
                        client.last_activity = Instant::now();
                        client.message_count += 1;
                    }
                }
                
                match serde_json::from_str::<ChatMessage>(&text) {
                    Ok(mut chat_msg) => {
                        chat_msg.sender = Some(client.name.clone());
                        chat_msg.timestamp = chrono::Utc::now();
                        
                        debug!(
                            client_id = %client_id,
                            sender = %chat_msg.sender.as_ref().unwrap(),
                            message_type = %chat_msg.message_type,
                            content_length = chat_msg.content.len(),
                            environment = %state.config.environment,
                            "处理聊天消息"
                        );
                        
                        let _ = state.tx.send(BroadcastMessage {
                            sender_id: client_id,
                            message: chat_msg,
                        });
                    }
                    Err(e) => {
                        warn!(
                            client_id = %client_id,
                            error = %e,
                            "消息 JSON 解析失败"
                        );
                        
                        let error_msg = ChatMessage {
                            message_type: "error".to_string(),
                            content: "消息格式错误".to_string(),
                            sender: Some("系统".to_string()),
                            timestamp: chrono::Utc::now(),
                        };
                        
                        let _ = socket.send(Message::Text(
                            serde_json::to_string(&error_msg)?
                        )).await;
                    }
                }
            }
            Ok(Message::Close(frame)) => {
                info!(
                    client_id = %client_id,
                    close_frame = ?frame,
                    "客户端主动关闭连接"
                );
                break;
            }
            Err(e) => {
                error!(
                    client_id = %client_id,
                    error = %e,
                    "WebSocket 消息接收错误"
                );
                break;
            }
            _ => {}
        }
    }
    
    // 清理工作
    broadcast_task.abort();
    
    // 从客户端列表中移除
    {
        let mut clients = state.clients.write().await;
        if let Some(removed_client) = clients.remove(&client_id) {
            info!(
                client_id = %client_id,
                client_name = %removed_client.name,
                session_duration = ?removed_client.connected_at.elapsed(),
                total_messages = removed_client.message_count,
                remaining_clients = clients.len(),
                "客户端断开连接，清理完成"
            );
        }
    }
    
    // 广播用户离开消息
    let leave_msg = ChatMessage {
        message_type: "leave".to_string(),
        content: format!("{} 离开了聊天室", client.name),
        sender: Some("系统".to_string()),
        timestamp: chrono::Utc::now(),
    };
    
    let _ = state.tx.send(BroadcastMessage {
        sender_id: client_id,
        message: leave_msg,
    });
    
    Ok(())
}</pre>

        <p><strong>步骤 6: 多阶段 Dockerfile (docker/Dockerfile)</strong></p>
        <pre># 第一阶段：构建环境
FROM rust:1.75-slim as builder

# 安装构建依赖
RUN apt-get update && apt-get install -y \
    pkg-config \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# 创建新用户避免以 root 身份运行
RUN useradd -m -u 1001 appuser

# 设置工作目录
WORKDIR /usr/src/app

# 复制 Cargo 文件先安装依赖（利用 Docker 缓存）
COPY Cargo.toml Cargo.lock ./

# 创建虚拟主文件以构建依赖
RUN mkdir src && echo "fn main() {}" > src/main.rs
RUN cargo build --release
RUN rm -f target/release/deps/websocket_docker*

# 复制源代码
COPY src ./src
COPY static ./static

# 添加构建时间戳
ARG BUILD_TIMESTAMP
ENV BUILD_TIMESTAMP=$BUILD_TIMESTAMP

# 构建应用
RUN cargo build --release

# 第二阶段：运行时环境
FROM debian:bookworm-slim as runtime

# 安装运行时依赖
RUN apt-get update && apt-get install -y \
    ca-certificates \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 创建应用用户
RUN useradd -m -u 1001 appuser

# 创建应用目录
WORKDIR /app

# 从构建阶段复制二进制文件
COPY --from=builder /usr/src/app/target/release/websocket-docker /app/websocket-docker
COPY --from=builder /usr/src/app/static /app/static

# 设置文件权限
RUN chown -R appuser:appuser /app
RUN chmod +x /app/websocket-docker

# 切换到非特权用户
USER appuser

# 暴露端口
EXPOSE 3000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# 设置环境变量
ENV RUST_LOG=info
ENV BIND_ADDR=0.0.0.0:3000
ENV APP_ENV=production

# 启动应用
CMD ["./websocket-docker"]</pre>

        <p><strong>步骤 7: Docker Compose 配置 (docker/docker-compose.yml)</strong></p>
        <pre>version: '3.8'

services:
  websocket-server:
    build:
      context: ..
      dockerfile: docker/Dockerfile
      args:
        BUILD_TIMESTAMP: ${BUILD_TIMESTAMP:-"unknown"}
    ports:
      - "3000:3000"
    environment:
      - RUST_LOG=info
      - LOG_LEVEL=info
      - MAX_CONNECTIONS=1000
      - CHANNEL_CAPACITY=1000
      - ENABLE_METRICS=true
      - APP_ENV=production
    volumes:
      - ../logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.5'
        reservations:
          memory: 128M
          cpus: '0.1'

  # 可选：添加反向代理
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - websocket-server
    restart: unless-stopped</pre>

        <p><strong>步骤 8: 构建脚本 (scripts/build.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}🐳 构建 WebSocket Docker 镜像${NC}"

# 设置构建时间戳
export BUILD_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# 获取项目信息
PROJECT_NAME="websocket-docker"
VERSION=$(grep '^version' Cargo.toml | cut -d'"' -f2)
IMAGE_NAME="${PROJECT_NAME}:${VERSION}"
LATEST_IMAGE="${PROJECT_NAME}:latest"

echo -e "${YELLOW}项目: ${PROJECT_NAME}${NC}"
echo -e "${YELLOW}版本: ${VERSION}${NC}"
echo -e "${YELLOW}构建时间: ${BUILD_TIMESTAMP}${NC}"

# 构建镜像
echo -e "${GREEN}📦 开始构建镜像...${NC}"
cd docker
docker build \
    --build-arg BUILD_TIMESTAMP="${BUILD_TIMESTAMP}" \
    -t "${IMAGE_NAME}" \
    -t "${LATEST_IMAGE}" \
    -f Dockerfile \
    ..

echo -e "${GREEN}✅ 镜像构建完成${NC}"

# 显示镜像信息
echo -e "${GREEN}📊 镜像信息:${NC}"
docker images | head -1
docker images | grep "${PROJECT_NAME}"

# 显示镜像大小
echo -e "${GREEN}💾 镜像大小比较:${NC}"
RUST_BASE_SIZE=$(docker images rust:1.75-slim --format "table {{.Size}}" | tail -1)
IMAGE_SIZE=$(docker images "${LATEST_IMAGE}" --format "table {{.Size}}" | tail -1)
echo "Rust 基础镜像: ${RUST_BASE_SIZE}"
echo "应用镜像: ${IMAGE_SIZE}"

echo -e "${GREEN}🎉 构建完成！${NC}"
echo -e "${YELLOW}运行命令: docker run -p 3000:3000 ${LATEST_IMAGE}${NC}"</pre>

        <p><strong>步骤 9: 运行脚本 (scripts/run.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# 颜色输出
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

PROJECT_NAME="websocket-docker"
IMAGE_NAME="${PROJECT_NAME}:latest"
CONTAINER_NAME="${PROJECT_NAME}-container"

echo -e "${GREEN}🚀 启动 WebSocket 容器${NC}"

# 停止并删除现有容器
if docker ps -a | grep -q "${CONTAINER_NAME}"; then
    echo -e "${YELLOW}停止现有容器...${NC}"
    docker stop "${CONTAINER_NAME}" || true
    docker rm "${CONTAINER_NAME}" || true
fi

# 创建日志目录
mkdir -p ../logs

# 启动新容器
echo -e "${GREEN}启动新容器...${NC}"
docker run -d \
    --name "${CONTAINER_NAME}" \
    -p 3000:3000 \
    -v "$(pwd)/../logs:/app/logs" \
    -e RUST_LOG=info \
    -e LOG_LEVEL=info \
    -e MAX_CONNECTIONS=1000 \
    -e APP_ENV=production \
    --restart unless-stopped \
    "${IMAGE_NAME}"

echo -e "${GREEN}✅ 容器启动成功${NC}"

# 显示容器状态
echo -e "${GREEN}📊 容器状态:${NC}"
docker ps | head -1
docker ps | grep "${CONTAINER_NAME}"

# 等待服务启动
echo -e "${YELLOW}等待服务启动...${NC}"
sleep 3

# 测试健康检查
echo -e "${GREEN}🔍 健康检查:${NC}"
if curl -f http://localhost:3000/health; then
    echo -e "${GREEN}✅ 服务健康${NC}"
else
    echo -e "${RED}❌ 服务不健康${NC}"
fi

echo -e "${GREEN}🎉 部署完成！${NC}"
echo -e "${YELLOW}访问地址: http://localhost:3000${NC}"
echo -e "${YELLOW}查看日志: docker logs -f ${CONTAINER_NAME}${NC}"</pre>

        <p><strong>步骤 10: Docker 忽略文件 (docker/.dockerignore)</strong></p>
        <pre>target/
Dockerfile
docker-compose.yml
.dockerignore
.git/
.gitignore
*.md
logs/
scripts/
.env*
docker/</pre>

        <p><strong>步骤 11: 环境变量示例 (.env.example)</strong></p>
        <pre># WebSocket 服务器配置
BIND_ADDR=0.0.0.0:3000
LOG_LEVEL=info
MAX_CONNECTIONS=1000
CHANNEL_CAPACITY=1000
ENABLE_METRICS=true
STATIC_DIR=static
APP_ENV=production

# Docker 构建配置
BUILD_TIMESTAMP=2025-08-20T10:00:00Z

# 数据库配置（可选）
# DATABASE_URL=postgresql://user:pass@localhost/websocket_db

# Redis 配置（可选）
# REDIS_URL=redis://localhost:6379</pre>

        <p><strong>步骤 12: 构建和运行</strong></p>
        <pre># 1. 设置执行权限
chmod +x scripts/build.sh scripts/run.sh

# 2. 构建 Docker 镜像
./scripts/build.sh

# 3. 运行容器
./scripts/run.sh

# 4. 或使用 Docker Compose
cd docker
docker-compose up -d

# 5. 查看日志
docker logs -f websocket-docker-container

# 6. 测试服务
curl http://localhost:3000/health
curl http://localhost:3000/metrics

# 7. 打开浏览器测试
open http://localhost:3000</pre>

        <p><strong>步骤 13: 生产环境优化</strong></p>
        <pre># 查看镜像大小
docker images websocket-docker

# 镜像安全扫描
docker scout cves websocket-docker:latest

# 性能测试
wrk -t12 -c400 -d30s http://localhost:3000/health

# 内存使用监控
docker stats websocket-docker-container

# 容器资源限制
docker run -d \
    --name websocket-production \
    -p 3000:3000 \
    --memory=256m \
    --cpus=0.5 \
    --restart=always \
    websocket-docker:latest</pre>

        <p><strong>🎯 今日收获</strong></p>
        <ul>
            <li>✅ 创建了优化的多阶段 Dockerfile</li>
            <li>✅ 实现了生产环境配置管理</li>
            <li>✅ 添加了健康检查和监控端点</li>
            <li>✅ 配置了优雅关闭机制</li>
            <li>✅ 实现了 Docker Compose 部署</li>
            <li>✅ 掌握了容器安全最佳实践</li>
            <li>✅ 优化了镜像大小和构建效率</li>
        </ul>

        <p><strong>💡 扩展练习</strong></p>
        <ul>
            <li>添加 Nginx 反向代理配置</li>
            <li>实现多容器负载均衡</li>
            <li>集成 Prometheus 监控</li>
            <li>添加日志聚合和分析</li>
        </ul>
    
        <p class="date"><strong>🗓️ 2025-08-21</strong></p>
        <h2>Day 21 - Docker 容器测试与部署验证</h2>
        <p>今天你将全面测试 Docker 化的 WebSocket 应用，包括容器运行测试、性能基准测试、负载测试、监控集成以及生产环境部署验证。你将掌握容器化应用的完整测试和部署流程。</p>
        
        <p><strong>🎯 今日目标</strong></p>
        <ul>
            <li>全面测试 Docker 容器功能</li>
            <li>进行性能和负载测试</li>
            <li>配置监控和日志收集</li>
            <li>实现自动化部署脚本</li>
            <li>验证生产环境就绪性</li>
        </ul>

        <p>🔗 <a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank">阅读对应官方文档</a></p>

        <p><strong>步骤 1: 测试项目结构</strong></p>
        <pre>📁 完整测试项目结构：
day21_docker_testing/
├── src/
│   ├── main.rs
│   ├── server.rs
│   └── config.rs
├── tests/
│   ├── integration_test.rs
│   ├── load_test.rs
│   └── docker_test.rs
├── scripts/
│   ├── test_all.sh
│   ├── benchmark.sh
│   ├── deploy.sh
│   └── monitor.sh
├── monitoring/
│   ├── prometheus.yml
│   ├── grafana/
│   │   └── dashboard.json
│   └── docker-compose.monitoring.yml
├── nginx/
│   ├── nginx.conf
│   └── ssl/
├── docker/
│   ├── Dockerfile
│   ├── docker-compose.yml
│   ├── docker-compose.prod.yml
│   └── .dockerignore
├── k8s/
│   ├── deployment.yaml
│   ├── service.yaml
│   └── ingress.yaml
└── README.md</pre>

        <p><strong>步骤 2: 集成测试套件 (tests/integration_test.rs)</strong></p>
        <pre>use std::time::Duration;
use tokio::time::timeout;
use tokio_tungstenite::{connect_async, tungstenite::Message};
use serde_json::json;
use url::Url;

#[tokio::test]
async fn test_websocket_connection() {
    let url = Url::parse("ws://127.0.0.1:3000/ws").expect("Invalid URL");
    
    let result = timeout(Duration::from_secs(5), connect_async(url)).await;
    assert!(result.is_ok(), "WebSocket 连接超时");
    
    let (ws_stream, _) = result.unwrap().expect("连接失败");
    println!("✅ WebSocket 连接测试通过");
}

#[tokio::test]
async fn test_health_endpoint() {
    let client = reqwest::Client::new();
    
    let response = client
        .get("http://127.0.0.1:3000/health")
        .timeout(Duration::from_secs(5))
        .send()
        .await
        .expect("健康检查请求失败");
    
    assert!(response.status().is_success());
    
    let health_data: serde_json::Value = response
        .json()
        .await
        .expect("解析健康检查响应失败");
    
    assert_eq!(health_data["status"], "healthy");
    println!("✅ 健康检查测试通过");
}

#[tokio::test]
async fn test_metrics_endpoint() {
    let client = reqwest::Client::new();
    
    let response = client
        .get("http://127.0.0.1:3000/metrics")
        .timeout(Duration::from_secs(5))
        .send()
        .await
        .expect("指标请求失败");
    
    assert!(response.status().is_success());
    
    let metrics: serde_json::Value = response
        .json()
        .await
        .expect("解析指标响应失败");
    
    assert!(metrics.get("active_connections").is_some());
    assert!(metrics.get("uptime_seconds").is_some());
    println!("✅ 指标端点测试通过");
}

#[tokio::test]
async fn test_message_broadcast() {
    use futures_util::{SinkExt, StreamExt};
    
    let url = Url::parse("ws://127.0.0.1:3000/ws").expect("Invalid URL");
    
    // 创建两个客户端连接
    let (ws1, _) = connect_async(url.clone()).await.expect("客户端1连接失败");
    let (ws2, _) = connect_async(url).await.expect("客户端2连接失败");
    
    let (mut write1, mut read1) = ws1.split();
    let (mut write2, mut read2) = ws2.split();
    
    // 发送测试消息
    let test_message = json!({
        "message_type": "chat",
        "content": "Hello from test!",
        "timestamp": chrono::Utc::now()
    });
    
    write1.send(Message::Text(test_message.to_string()))
        .await
        .expect("发送消息失败");
    
    // 验证客户端2收到广播消息
    let received = timeout(Duration::from_secs(3), read2.next()).await;
    assert!(received.is_ok(), "未在预期时间内收到消息");
    
    println!("✅ 消息广播测试通过");
}</pre>

        <p><strong>步骤 3: 负载测试 (tests/load_test.rs)</strong></p>
        <pre>#[cfg(test)]
mod load_tests {
    use super::*;
    use std::sync::Arc;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use tokio::time::{sleep, Duration};
    use futures_util::future::join_all;

    #[tokio::test]
    #[ignore] // 使用 cargo test -- --ignored 运行
    async fn load_test_concurrent_connections() {
        const CONCURRENT_CONNECTIONS: usize = 100;
        const MESSAGE_COUNT: usize = 10;
        
        let success_count = Arc::new(AtomicUsize::new(0));
        let error_count = Arc::new(AtomicUsize::new(0));
        
        println!("🚀 开始负载测试：{} 并发连接", CONCURRENT_CONNECTIONS);
        
        let tasks: Vec<_> = (0..CONCURRENT_CONNECTIONS)
            .map(|i| {
                let success_count = Arc::clone(&success_count);
                let error_count = Arc::clone(&error_count);
                
                tokio::spawn(async move {
                    match simulate_client(i, MESSAGE_COUNT).await {
                        Ok(_) => {
                            success_count.fetch_add(1, Ordering::Relaxed);
                            println!("✅ 客户端 {} 完成", i);
                        }
                        Err(e) => {
                            error_count.fetch_add(1, Ordering::Relaxed);
                            println!("❌ 客户端 {} 失败: {}", i, e);
                        }
                    }
                })
            })
            .collect();
        
        // 等待所有任务完成
        join_all(tasks).await;
        
        let successes = success_count.load(Ordering::Relaxed);
        let errors = error_count.load(Ordering::Relaxed);
        
        println!("📊 负载测试结果:");
        println!("   成功: {}", successes);
        println!("   失败: {}", errors);
        println!("   成功率: {:.2}%", (successes as f64 / CONCURRENT_CONNECTIONS as f64) * 100.0);
        
        // 至少 95% 成功率
        assert!(successes >= (CONCURRENT_CONNECTIONS as f64 * 0.95) as usize);
    }
    
    async fn simulate_client(client_id: usize, message_count: usize) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        use tokio_tungstenite::{connect_async, tungstenite::Message};
        use futures_util::{SinkExt, StreamExt};
        use serde_json::json;
        use url::Url;
        
        let url = Url::parse("ws://127.0.0.1:3000/ws")?;
        let (ws_stream, _) = connect_async(url).await?;
        let (mut write, mut read) = ws_stream.split();
        
        // 启动读取任务
        let read_task = tokio::spawn(async move {
            let mut received_count = 0;
            while let Some(msg) = read.next().await {
                match msg {
                    Ok(Message::Text(_)) => {
                        received_count += 1;
                        if received_count >= message_count * 2 { // 期望收到自己的消息 + 其他消息
                            break;
                        }
                    }
                    Ok(Message::Close(_)) => break,
                    Err(_) => break,
                    _ => {}
                }
            }
            received_count
        });
        
        // 发送消息
        for i in 0..message_count {
            let message = json!({
                "message_type": "chat",
                "content": format!("Load test message {} from client {}", i, client_id),
                "timestamp": chrono::Utc::now()
            });
            
            write.send(Message::Text(message.to_string())).await?;
            sleep(Duration::from_millis(100)).await; // 控制发送频率
        }
        
        // 等待接收任务完成
        let _ = tokio::time::timeout(Duration::from_secs(10), read_task).await;
        
        Ok(())
    }
    
    #[tokio::test]
    #[ignore]
    async fn stress_test_memory_usage() {
        const CONNECTION_COUNT: usize = 500;
        const TEST_DURATION: Duration = Duration::from_secs(60);
        
        println!("🧠 开始内存压力测试：{} 连接，持续 {} 秒", 
                CONNECTION_COUNT, TEST_DURATION.as_secs());
        
        let client = reqwest::Client::new();
        let start_time = std::time::Instant::now();
        
        // 记录初始内存使用
        let initial_metrics = get_server_metrics(&client).await;
        println!("📊 初始内存使用: {} MB", initial_metrics["memory_usage_mb"]);
        
        // 建立连接并持续测试
        let mut tasks = Vec::new();
        
        for i in 0..CONNECTION_COUNT {
            let task = tokio::spawn(async move {
                if let Ok(url) = url::Url::parse("ws://127.0.0.1:3000/ws") {
                    if let Ok((ws_stream, _)) = tokio_tungstenite::connect_async(url).await {
                        let (_write, mut read) = futures_util::StreamExt::split(ws_stream);
                        
                        // 保持连接活跃
                        let mut message_count = 0;
                        while message_count < 100 {
                            if let Some(Ok(_)) = read.next().await {
                                message_count += 1;
                            }
                            tokio::time::sleep(Duration::from_millis(500)).await;
                        }
                    }
                }
            });
            tasks.push(task);
            
            if i % 50 == 0 {
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
        }
        
        // 监控内存使用
        let monitor_task = tokio::spawn(async move {
            let mut max_memory = 0u64;
            while start_time.elapsed() < TEST_DURATION {
                if let Ok(metrics) = get_server_metrics(&client).await {
                    let current_memory = metrics["memory_usage_mb"].as_u64().unwrap_or(0);
                    max_memory = max_memory.max(current_memory);
                    println!("💾 当前内存使用: {} MB", current_memory);
                }
                tokio::time::sleep(Duration::from_secs(5)).await;
            }
            max_memory
        });
        
        let max_memory = monitor_task.await.unwrap();
        
        // 清理任务
        for task in tasks {
            task.abort();
        }
        
        println!("📊 压力测试结果:");
        println!("   最大内存使用: {} MB", max_memory);
        println!("   内存增长: {} MB", max_memory - initial_metrics["memory_usage_mb"].as_u64().unwrap_or(0));
        
        // 确保内存使用在合理范围内（小于512MB）
        assert!(max_memory < 512, "内存使用超出预期范围");
    }
    
    async fn get_server_metrics(client: &reqwest::Client) -> serde_json::Value {
        client
            .get("http://127.0.0.1:3000/metrics")
            .send()
            .await
            .unwrap()
            .json()
            .await
            .unwrap()
    }
}</pre>

        <p><strong>步骤 4: Docker 测试脚本 (tests/docker_test.rs)</strong></p>
        <pre>use std::process::Command;
use std::time::Duration;
use tokio::time::sleep;

#[tokio::test]
async fn test_docker_container_lifecycle() {
    let container_name = "websocket-test-container";
    let image_name = "websocket-docker:latest";
    
    // 清理可能存在的容器
    cleanup_container(container_name);
    
    // 启动容器
    println!("🐳 启动 Docker 容器...");
    let output = Command::new("docker")
        .args(&[
            "run", "-d",
            "--name", container_name,
            "-p", "3001:3000", // 使用不同端口避免冲突
            "-e", "RUST_LOG=info",
            image_name
        ])
        .output()
        .expect("启动容器失败");
    
    assert!(output.status.success(), "容器启动失败: {}", 
            String::from_utf8_lossy(&output.stderr));
    
    // 等待容器启动
    println!("⏳ 等待容器启动...");
    sleep(Duration::from_secs(5)).await;
    
    // 验证容器运行状态
    let status_output = Command::new("docker")
        .args(&["ps", "--filter", &format!("name={}", container_name), "--format", "{{.Status}}"])
        .output()
        .expect("获取容器状态失败");
    
    let status = String::from_utf8_lossy(&status_output.stdout);
    assert!(status.contains("Up"), "容器未正常运行: {}", status);
    println!("✅ 容器运行状态正常");
    
    // 测试健康检查
    let health_check = reqwest::get("http://127.0.0.1:3001/health").await;
    assert!(health_check.is_ok(), "健康检查失败");
    println!("✅ 容器健康检查通过");
    
    // 测试日志输出
    let logs_output = Command::new("docker")
        .args(&["logs", "--tail", "10", container_name])
        .output()
        .expect("获取容器日志失败");
    
    let logs = String::from_utf8_lossy(&logs_output.stdout);
    assert!(logs.contains("WebSocket"), "容器日志异常");
    println!("✅ 容器日志正常");
    
    // 清理
    cleanup_container(container_name);
    println!("🧹 容器测试完成，已清理");
}

#[tokio::test]
async fn test_docker_resource_limits() {
    let container_name = "websocket-resource-test";
    let image_name = "websocket-docker:latest";
    
    cleanup_container(container_name);
    
    // 启动带资源限制的容器
    println!("🐳 启动资源限制容器...");
    let output = Command::new("docker")
        .args(&[
            "run", "-d",
            "--name", container_name,
            "-p", "3002:3000",
            "--memory", "128m",
            "--cpus", "0.5",
            image_name
        ])
        .output()
        .expect("启动容器失败");
    
    assert!(output.status.success());
    
    sleep(Duration::from_secs(3)).await;
    
    // 检查资源使用
    let stats_output = Command::new("docker")
        .args(&["stats", "--no-stream", "--format", 
               "table {{.MemUsage}}\t{{.CPUPerc}}", container_name])
        .output()
        .expect("获取资源统计失败");
    
    let stats = String::from_utf8_lossy(&stats_output.stdout);
    println!("📊 资源使用情况:\n{}", stats);
    
    // 验证服务仍然可用
    let response = reqwest::get("http://127.0.0.1:3002/health").await;
    assert!(response.is_ok(), "资源限制下服务不可用");
    println!("✅ 资源限制测试通过");
    
    cleanup_container(container_name);
}

fn cleanup_container(container_name: &str) {
    // 停止容器
    Command::new("docker")
        .args(&["stop", container_name])
        .output()
        .ok();
    
    // 删除容器
    Command::new("docker")
        .args(&["rm", container_name])
        .output()
        .ok();
}</pre>

        <p><strong>步骤 5: 综合测试脚本 (scripts/test_all.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}🧪 开始完整的 Docker WebSocket 测试套件${NC}"

PROJECT_NAME="websocket-docker"
IMAGE_NAME="${PROJECT_NAME}:latest"
TEST_CONTAINER="${PROJECT_NAME}-test"

# 清理函数
cleanup() {
    echo -e "${YELLOW}🧹 清理测试环境...${NC}"
    docker stop "${TEST_CONTAINER}" 2>/dev/null || true
    docker rm "${TEST_CONTAINER}" 2>/dev/null || true
}

# 设置清理钩子
trap cleanup EXIT

# 1. 构建测试
echo -e "${GREEN}📦 步骤 1: 构建镜像测试${NC}"
if docker build -t "${IMAGE_NAME}" -f docker/Dockerfile . > /dev/null 2>&1; then
    echo "✅ 镜像构建成功"
else
    echo -e "${RED}❌ 镜像构建失败${NC}"
    exit 1
fi

# 2. 容器启动测试
echo -e "${GREEN}🚀 步骤 2: 容器启动测试${NC}"
docker run -d \
    --name "${TEST_CONTAINER}" \
    -p 3000:3000 \
    -e RUST_LOG=info \
    -e MAX_CONNECTIONS=100 \
    "${IMAGE_NAME}"

# 等待服务启动
echo "⏳ 等待服务启动..."
sleep 5

# 验证容器状态
if docker ps | grep -q "${TEST_CONTAINER}"; then
    echo "✅ 容器启动成功"
else
    echo -e "${RED}❌ 容器启动失败${NC}"
    docker logs "${TEST_CONTAINER}"
    exit 1
fi

# 3. 健康检查测试
echo -e "${GREEN}🔍 步骤 3: 健康检查测试${NC}"
max_attempts=10
attempt=1

while [ $attempt -le $max_attempts ]; do
    if curl -f -s http://localhost:3000/health > /dev/null; then
        echo "✅ 健康检查通过"
        break
    elif [ $attempt -eq $max_attempts ]; then
        echo -e "${RED}❌ 健康检查失败${NC}"
        docker logs "${TEST_CONTAINER}"
        exit 1
    else
        echo "⏳ 健康检查尝试 $attempt/$max_attempts..."
        sleep 2
        ((attempt++))
    fi
done

# 4. API 端点测试
echo -e "${GREEN}🌐 步骤 4: API 端点测试${NC}"

# 健康检查端点
health_response=$(curl -s http://localhost:3000/health)
if echo "$health_response" | grep -q "healthy"; then
    echo "✅ 健康检查端点正常"
else
    echo -e "${RED}❌ 健康检查端点异常${NC}"
    echo "响应: $health_response"
    exit 1
fi

# 指标端点
metrics_response=$(curl -s http://localhost:3000/metrics)
if echo "$metrics_response" | grep -q "active_connections"; then
    echo "✅ 指标端点正常"
else
    echo -e "${RED}❌ 指标端点异常${NC}"
    echo "响应: $metrics_response"
    exit 1
fi

# 就绪检查端点
ready_response=$(curl -s http://localhost:3000/ready)
if echo "$ready_response" | grep -q "ready"; then
    echo "✅ 就绪检查端点正常"
else
    echo -e "${RED}❌ 就绪检查端点异常${NC}"
    echo "响应: $ready_response"
    exit 1
fi

# 5. WebSocket 连接测试
echo -e "${GREEN}🔌 步骤 5: WebSocket 连接测试${NC}"
# 使用 wscat 或 websocat 进行测试（如果可用）
if command -v websocat > /dev/null 2>&1; then
    timeout 5s bash -c '
        echo "{\"message_type\":\"chat\",\"content\":\"test message\"}" | \
        websocat ws://localhost:3000/ws 2>/dev/null | \
        head -n 1 > /tmp/ws_test_output
    ' || true
    
    if [ -s /tmp/ws_test_output ]; then
        echo "✅ WebSocket 连接测试通过"
        rm -f /tmp/ws_test_output
    else
        echo -e "${YELLOW}⚠️  WebSocket 测试跳过（需要 websocat 工具）${NC}"
    fi
else
    echo -e "${YELLOW}⚠️  WebSocket 测试跳过（需要 websocat 工具）${NC}"
fi

# 6. 资源使用测试
echo -e "${GREEN}📊 步骤 6: 资源使用测试${NC}"
docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" "${TEST_CONTAINER}"

# 获取内存使用（MB）
memory_usage=$(docker stats --no-stream --format "{{.MemUsage}}" "${TEST_CONTAINER}" | cut -d'/' -f1 | sed 's/MiB//' | sed 's/ //')
if (( $(echo "$memory_usage < 200" | bc -l) )); then
    echo "✅ 内存使用正常: ${memory_usage}MB"
else
    echo -e "${YELLOW}⚠️  内存使用较高: ${memory_usage}MB${NC}"
fi

# 7. 日志检查
echo -e "${GREEN}📝 步骤 7: 日志检查${NC}"
log_output=$(docker logs "${TEST_CONTAINER}" 2>&1)

if echo "$log_output" | grep -q "WebSocket 服务器"; then
    echo "✅ 启动日志正常"
else
    echo -e "${RED}❌ 启动日志异常${NC}"
    echo "$log_output"
    exit 1
fi

if echo "$log_output" | grep -q "ERROR\|PANIC"; then
    echo -e "${YELLOW}⚠️  发现错误日志:${NC}"
    echo "$log_output" | grep -E "ERROR|PANIC"
else
    echo "✅ 无错误日志"
fi

# 8. 负载测试（可选）
if [ "${1:-}" = "--load-test" ]; then
    echo -e "${GREEN}🚛 步骤 8: 负载测试${NC}"
    
    # 使用 ab (Apache Bench) 进行简单负载测试
    if command -v ab > /dev/null 2>&1; then
        echo "执行 100 个并发请求到健康检查端点..."
        ab -n 1000 -c 10 -q http://localhost:3000/health | grep -E "Requests per second|Time per request|Transfer rate"
        echo "✅ 负载测试完成"
    else
        echo -e "${YELLOW}⚠️  负载测试跳过（需要 apache2-utils）${NC}"
    fi
fi

# 9. 安全检查
echo -e "${GREEN}🔒 步骤 9: 安全检查${NC}"

# 检查容器是否以非 root 用户运行
user_info=$(docker exec "${TEST_CONTAINER}" whoami 2>/dev/null || echo "unknown")
if [ "$user_info" != "root" ]; then
    echo "✅ 容器使用非 root 用户运行: $user_info"
else
    echo -e "${YELLOW}⚠️  容器以 root 用户运行${NC}"
fi

# 检查端口暴露
exposed_ports=$(docker port "${TEST_CONTAINER}")
echo "📡 暴露的端口: $exposed_ports"

# 10. 镜像分析
echo -e "${GREEN}🔍 步骤 10: 镜像分析${NC}"
image_size=$(docker images "${IMAGE_NAME}" --format "{{.Size}}")
echo "💾 镜像大小: $image_size"

# 显示镜像层信息
echo "📋 镜像层信息:"
docker history "${IMAGE_NAME}" --format "table {{.CreatedBy}}\t{{.Size}}" | head -10

# 完成
echo -e "${GREEN}🎉 所有测试完成！${NC}"
echo -e "${BLUE}测试总结:${NC}"
echo "   - 镜像构建: ✅ 通过"
echo "   - 容器启动: ✅ 通过"
echo "   - 健康检查: ✅ 通过"
echo "   - API 端点: ✅ 通过"
echo "   - 资源使用: ✅ 正常"
echo "   - 日志检查: ✅ 通过"
echo "   - 安全检查: ✅ 通过"
echo ""
echo -e "${GREEN}Docker WebSocket 应用已准备好部署！${NC}"</pre>

        <p><strong>步骤 6: 性能基准测试 (scripts/benchmark.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# 颜色输出
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}📊 WebSocket 服务性能基准测试${NC}"

# 配置参数
CONTAINER_NAME="websocket-benchmark"
IMAGE_NAME="websocket-docker:latest"
TEST_PORT="3000"
RESULTS_DIR="benchmark_results"

# 创建结果目录
mkdir -p "${RESULTS_DIR}"
timestamp=$(date +"%Y%m%d_%H%M%S")

cleanup() {
    echo -e "${YELLOW}🧹 清理测试环境...${NC}"
    docker stop "${CONTAINER_NAME}" 2>/dev/null || true
    docker rm "${CONTAINER_NAME}" 2>/dev/null || true
}

trap cleanup EXIT

# 启动测试容器
echo -e "${GREEN}🚀 启动测试容器...${NC}"
docker run -d \
    --name "${CONTAINER_NAME}" \
    -p "${TEST_PORT}:3000" \
    -e RUST_LOG=warn \
    -e MAX_CONNECTIONS=2000 \
    "${IMAGE_NAME}"

echo "⏳ 等待服务启动..."
sleep 3

# 验证服务可用
if ! curl -f -s "http://localhost:${TEST_PORT}/health" > /dev/null; then
    echo "❌ 服务启动失败"
    exit 1
fi

echo "✅ 服务启动成功"

# 1. HTTP 端点性能测试
echo -e "${GREEN}🌐 HTTP 端点性能测试${NC}"

if command -v ab > /dev/null 2>&1; then
    echo "测试健康检查端点..."
    ab -n 10000 -c 100 -q "http://localhost:${TEST_PORT}/health" > "${RESULTS_DIR}/health_benchmark_${timestamp}.txt"
    
    echo "测试指标端点..."
    ab -n 5000 -c 50 -q "http://localhost:${TEST_PORT}/metrics" > "${RESULTS_DIR}/metrics_benchmark_${timestamp}.txt"
    
    # 显示关键指标
    echo "📊 健康检查端点结果:"
    grep -E "Requests per second|Time per request|Transfer rate" "${RESULTS_DIR}/health_benchmark_${timestamp}.txt"
    
    echo "📊 指标端点结果:"
    grep -E "Requests per second|Time per request|Transfer rate" "${RESULTS_DIR}/metrics_benchmark_${timestamp}.txt"
else
    echo -e "${YELLOW}⚠️  跳过 HTTP 性能测试（需要 apache2-utils）${NC}"
fi

# 2. WebSocket 连接性能测试
echo -e "${GREEN}🔌 WebSocket 连接性能测试${NC}"

# 创建 Node.js WebSocket 压力测试脚本
cat > "${RESULTS_DIR}/ws_stress_test.js" << 'EOF'
const WebSocket = require('ws');
const { performance } = require('perf_hooks');

const WS_URL = 'ws://localhost:3000/ws';
const CONCURRENT_CONNECTIONS = 500;
const MESSAGES_PER_CONNECTION = 10;
const CONNECTION_DELAY = 2; // ms between connections

let totalConnections = 0;
let successfulConnections = 0;
let totalMessages = 0;
let connectionTimes = [];
let messageTimes = [];

async function createConnection(id) {
    return new Promise((resolve) => {
        const startTime = performance.now();
        const ws = new WebSocket(WS_URL);
        let messagesSent = 0;
        let messagesReceived = 0;
        
        ws.on('open', () => {
            const connectionTime = performance.now() - startTime;
            connectionTimes.push(connectionTime);
            successfulConnections++;
            
            // 发送测试消息
            const sendMessage = () => {
                if (messagesSent < MESSAGES_PER_CONNECTION) {
                    const msgStartTime = performance.now();
                    const message = JSON.stringify({
                        message_type: 'chat',
                        content: `Test message ${messagesSent} from client ${id}`,
                        timestamp: new Date().toISOString()
                    });
                    
                    ws.send(message);
                    messagesSent++;
                    
                    setTimeout(sendMessage, 10);
                } else {
                    setTimeout(() => ws.close(), 100);
                }
            };
            
            sendMessage();
        });
        
        ws.on('message', (data) => {
            const msgTime = performance.now();
            messagesReceived++;
            totalMessages++;
        });
        
        ws.on('close', () => {
            resolve({
                id,
                messagesSent,
                messagesReceived,
                connectionTime: connectionTimes[connectionTimes.length - 1]
            });
        });
        
        ws.on('error', (error) => {
            console.error(`Client ${id} error:`, error.message);
            resolve({ id, error: error.message });
        });
    });
}

async function runTest() {
    console.log(`🚀 启动 ${CONCURRENT_CONNECTIONS} 个并发 WebSocket 连接`);
    console.log(`📝 每个连接发送 ${MESSAGES_PER_CONNECTION} 条消息`);
    
    const startTime = performance.now();
    const promises = [];
    
    for (let i = 0; i < CONCURRENT_CONNECTIONS; i++) {
        promises.push(createConnection(i));
        totalConnections++;
        
        if (i % 50 === 0) {
            await new Promise(resolve => setTimeout(resolve, CONNECTION_DELAY));
        }
    }
    
    const results = await Promise.all(promises);
    const endTime = performance.now();
    const totalTime = endTime - startTime;
    
    // 计算统计信息
    const avgConnectionTime = connectionTimes.reduce((a, b) => a + b, 0) / connectionTimes.length;
    const minConnectionTime = Math.min(...connectionTimes);
    const maxConnectionTime = Math.max(...connectionTimes);
    
    console.log('\n📊 测试结果:');
    console.log(`   总连接数: ${totalConnections}`);
    console.log(`   成功连接: ${successfulConnections}`);
    console.log(`   连接成功率: ${(successfulConnections / totalConnections * 100).toFixed(2)}%`);
    console.log(`   总消息数: ${totalMessages}`);
    console.log(`   测试时长: ${(totalTime / 1000).toFixed(2)} 秒`);
    console.log(`   连接/秒: ${(successfulConnections / (totalTime / 1000)).toFixed(2)}`);
    console.log(`   消息/秒: ${(totalMessages / (totalTime / 1000)).toFixed(2)}`);
    console.log(`   平均连接时间: ${avgConnectionTime.toFixed(2)} ms`);
    console.log(`   最小连接时间: ${minConnectionTime.toFixed(2)} ms`);
    console.log(`   最大连接时间: ${maxConnectionTime.toFixed(2)} ms`);
    
    // 保存结果到文件
    const report = {
        timestamp: new Date().toISOString(),
        config: {
            concurrent_connections: CONCURRENT_CONNECTIONS,
            messages_per_connection: MESSAGES_PER_CONNECTION
        },
        results: {
            total_connections: totalConnections,
            successful_connections: successfulConnections,
            success_rate: successfulConnections / totalConnections * 100,
            total_messages: totalMessages,
            test_duration_ms: totalTime,
            connections_per_second: successfulConnections / (totalTime / 1000),
            messages_per_second: totalMessages / (totalTime / 1000),
            avg_connection_time_ms: avgConnectionTime,
            min_connection_time_ms: minConnectionTime,
            max_connection_time_ms: maxConnectionTime
        }
    };
    
    console.log('\n💾 保存结果到 ws_benchmark_results.json');
    require('fs').writeFileSync('ws_benchmark_results.json', JSON.stringify(report, null, 2));
}

runTest().catch(console.error);
EOF

# 运行 WebSocket 压力测试（如果 Node.js 可用）
if command -v node > /dev/null 2>&1; then
    if npm list ws > /dev/null 2>&1 || npm install ws > /dev/null 2>&1; then
        echo "执行 WebSocket 压力测试..."
        cd "${RESULTS_DIR}"
        node ws_stress_test.js
        cd ..
        echo "✅ WebSocket 压力测试完成"
    else
        echo -e "${YELLOW}⚠️  跳过 WebSocket 压力测试（需要 ws npm 包）${NC}"
    fi
else
    echo -e "${YELLOW}⚠️  跳过 WebSocket 压力测试（需要 Node.js）${NC}"
fi

# 3. 资源监控
echo -e "${GREEN}📊 资源使用监控${NC}"

# 监控 30 秒的资源使用
echo "监控容器资源使用 30 秒..."
for i in {1..6}; do
    docker stats --no-stream --format "{{.CPUPerc}},{{.MemUsage}}" "${CONTAINER_NAME}" >> "${RESULTS_DIR}/resource_usage_${timestamp}.csv"
    sleep 5
done

echo "📊 资源使用统计:"
echo "CPU 使用率:"
awk -F',' '{sum+=$1; count++} END {print "   平均: " sum/count "%"}' "${RESULTS_DIR}/resource_usage_${timestamp}.csv"

echo "内存使用:"
tail -1 "${RESULTS_DIR}/resource_usage_${timestamp}.csv" | awk -F',' '{print "   当前: " $2}'

# 4. 生成测试报告
echo -e "${GREEN}📋 生成测试报告${NC}"

cat > "${RESULTS_DIR}/benchmark_report_${timestamp}.md" << EOF
# WebSocket 服务性能基准测试报告

**测试时间**: $(date)
**测试版本**: ${IMAGE_NAME}
**测试配置**: Docker 容器运行

## 测试环境
- 容器名称: ${CONTAINER_NAME}
- 测试端口: ${TEST_PORT}
- 系统信息: $(uname -a)

## HTTP 端点性能
$([ -f "${RESULTS_DIR}/health_benchmark_${timestamp}.txt" ] && echo "### 健康检查端点" && grep -E "Requests per second|Time per request|Transfer rate" "${RESULTS_DIR}/health_benchmark_${timestamp}.txt" || echo "HTTP 性能测试未执行")

## WebSocket 性能
$([ -f "${RESULTS_DIR}/ws_benchmark_results.json" ] && echo "### WebSocket 连接测试" && cat "${RESULTS_DIR}/ws_benchmark_results.json" | jq -r '.results | to_entries[] | "- \(.key): \(.value)"' || echo "WebSocket 性能测试未执行")

## 资源使用
- 测试期间平均 CPU 使用率: $(awk -F',' '{sum+=$1; count++} END {print sum/count "%"}' "${RESULTS_DIR}/resource_usage_${timestamp}.csv")
- 测试结束时内存使用: $(tail -1 "${RESULTS_DIR}/resource_usage_${timestamp}.csv" | awk -F',' '{print $2}')

## 结论
$(if [ -f "${RESULTS_DIR}/ws_benchmark_results.json" ]; then
    success_rate=$(cat "${RESULTS_DIR}/ws_benchmark_results.json" | jq -r '.results.success_rate')
    if (( $(echo "$success_rate > 95" | bc -l) )); then
        echo "✅ 性能测试通过 - 连接成功率: ${success_rate}%"
    else
        echo "⚠️ 性能需要优化 - 连接成功率: ${success_rate}%"
    fi
else
    echo "基础功能测试通过，WebSocket 性能测试未执行"
fi)
EOF

echo "✅ 测试报告已保存到: ${RESULTS_DIR}/benchmark_report_${timestamp}.md"

echo -e "${GREEN}🎉 性能基准测试完成！${NC}"
echo "📁 所有结果文件保存在: ${RESULTS_DIR}/"
ls -la "${RESULTS_DIR}/"</pre>

        <p><strong>步骤 7: 生产部署脚本 (scripts/deploy.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}🚀 WebSocket 服务生产环境部署${NC}"

# 配置参数
PROJECT_NAME="websocket-docker"
IMAGE_NAME="${PROJECT_NAME}:latest"
PROD_CONTAINER="${PROJECT_NAME}-prod"
BACKUP_CONTAINER="${PROJECT_NAME}-backup"

# 环境检查
check_requirements() {
    echo -e "${GREEN}🔍 检查部署要求...${NC}"
    
    # 检查 Docker
    if ! command -v docker > /dev/null 2>&1; then
        echo -e "${RED}❌ Docker 未安装${NC}"
        exit 1
    fi
    
    # 检查镜像存在
    if ! docker images | grep -q "${PROJECT_NAME}"; then
        echo -e "${RED}❌ 镜像 ${IMAGE_NAME} 不存在${NC}"
        echo "请先运行: ./scripts/build.sh"
        exit 1
    fi
    
    # 检查端口占用
    if netstat -tuln 2>/dev/null | grep -q ":3000 "; then
        echo -e "${YELLOW}⚠️  端口 3000 已被占用${NC}"
        echo "正在检查是否为当前服务..."
        
        if docker ps | grep -q "${PROD_CONTAINER}"; then
            echo "发现现有生产容器，将进行滚动更新"
        else
            echo -e "${RED}❌ 端口被其他服务占用${NC}"
            exit 1
        fi
    fi
    
    echo "✅ 环境检查通过"
}

# 健康检查函数
wait_for_health() {
    local container_name=$1
    local max_attempts=30
    local attempt=1
    
    echo "⏳ 等待服务健康检查..."
    
    while [ $attempt -le $max_attempts ]; do
        if curl -f -s http://localhost:3000/health > /dev/null 2>&1; then
            echo "✅ 服务健康检查通过"
            return 0
        fi
        
        if [ $attempt -eq $max_attempts ]; then
            echo -e "${RED}❌ 服务健康检查失败${NC}"
            echo "容器日志:"
            docker logs --tail 20 "$container_name"
            return 1
        fi
        
        echo "尝试 $attempt/$max_attempts - 等待服务启动..."
        sleep 2
        ((attempt++))
    done
}

# 备份当前容器
backup_current_container() {
    if docker ps | grep -q "${PROD_CONTAINER}"; then
        echo -e "${YELLOW}📦 备份当前生产容器...${NC}"
        
        # 停止备份容器（如果存在）
        docker stop "${BACKUP_CONTAINER}" 2>/dev/null || true
        docker rm "${BACKUP_CONTAINER}" 2>/dev/null || true
        
        # 创建当前容器的备份
        docker commit "${PROD_CONTAINER}" "${PROJECT_NAME}:backup"
        echo "✅ 容器备份完成"
    fi
}

# 滚动更新部署
rolling_update() {
    echo -e "${GREEN}🔄 执行滚动更新部署...${NC}"
    
    # 启动新容器
    echo "启动新版本容器..."
    docker run -d \
        --name "${PROD_CONTAINER}-new" \
        -p 3001:3000 \
        -e RUST_LOG=info \
        -e LOG_LEVEL=info \
        -e MAX_CONNECTIONS=2000 \
        -e CHANNEL_CAPACITY=2000 \
        -e ENABLE_METRICS=true \
        -e APP_ENV=production \
        -v "${PWD}/logs:/app/logs" \
        --restart unless-stopped \
        "${IMAGE_NAME}"
    
    # 等待新容器健康
    if ! wait_for_health "${PROD_CONTAINER}-new"; then
        echo -e "${RED}❌ 新容器启动失败，回滚${NC}"
        docker stop "${PROD_CONTAINER}-new" 2>/dev/null || true
        docker rm "${PROD_CONTAINER}-new" 2>/dev/null || true
        exit 1
    fi
    
    # 切换流量
    echo "切换流量到新容器..."
    if docker ps | grep -q "${PROD_CONTAINER}"; then
        docker stop "${PROD_CONTAINER}"
        docker rm "${PROD_CONTAINER}"
    fi
    
    # 更新端口映射
    docker stop "${PROD_CONTAINER}-new"
    docker commit "${PROD_CONTAINER}-new" "${PROJECT_NAME}:current"
    docker rm "${PROD_CONTAINER}-new"
    
    # 启动最终生产容器
    docker run -d \
        --name "${PROD_CONTAINER}" \
        -p 3000:3000 \
        -e RUST_LOG=info \
        -e LOG_LEVEL=info \
        -e MAX_CONNECTIONS=2000 \
        -e CHANNEL_CAPACITY=2000 \
        -e ENABLE_METRICS=true \
        -e APP_ENV=production \
        -v "${PWD}/logs:/app/logs" \
        --restart unless-stopped \
        "${PROJECT_NAME}:current"
    
    # 最终健康检查
    if ! wait_for_health "${PROD_CONTAINER}"; then
        echo -e "${RED}❌ 最终部署失败${NC}"
        exit 1
    fi
    
    echo "✅ 滚动更新完成"
}

# 全新部署
fresh_deploy() {
    echo -e "${GREEN}🆕 执行全新部署...${NC}"
    
    # 创建日志目录
    mkdir -p logs
    
    # 启动生产容器
    docker run -d \
        --name "${PROD_CONTAINER}" \
        -p 3000:3000 \
        -e RUST_LOG=info \
        -e LOG_LEVEL=info \
        -e MAX_CONNECTIONS=2000 \
        -e CHANNEL_CAPACITY=2000 \
        -e ENABLE_METRICS=true \
        -e APP_ENV=production \
        -v "${PWD}/logs:/app/logs" \
        --restart unless-stopped \
        "${IMAGE_NAME}"
    
    if ! wait_for_health "${PROD_CONTAINER}"; then
        echo -e "${RED}❌ 部署失败${NC}"
        exit 1
    fi
    
    echo "✅ 全新部署完成"
}

# 部署后验证
post_deploy_verification() {
    echo -e "${GREEN}🔍 部署后验证...${NC}"
    
    # API 端点测试
    echo "测试 API 端点..."
    
    # 健康检查
    if curl -f -s http://localhost:3000/health | grep -q "healthy"; then
        echo "✅ 健康检查端点正常"
    else
        echo -e "${RED}❌ 健康检查端点异常${NC}"
        exit 1
    fi
    
    # 指标端点
    if curl -f -s http://localhost:3000/metrics | grep -q "active_connections"; then
        echo "✅ 指标端点正常"
    else
        echo -e "${RED}❌ 指标端点异常${NC}"
        exit 1
    fi
    
    # WebSocket 测试（如果工具可用）
    if command -v websocat > /dev/null 2>&1; then
        echo "测试 WebSocket 连接..."
        timeout 3s bash -c '
            echo "{\"message_type\":\"chat\",\"content\":\"deployment test\"}" | \
            websocat ws://localhost:3000/ws 2>/dev/null | \
            head -n 1 > /tmp/deploy_ws_test
        ' || true
        
        if [ -s /tmp/deploy_ws_test ]; then
            echo "✅ WebSocket 连接正常"
            rm -f /tmp/deploy_ws_test
        else
            echo -e "${YELLOW}⚠️  WebSocket 测试未通过${NC}"
        fi
    fi
    
    # 资源检查
    echo "检查资源使用..."
    docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" "${PROD_CONTAINER}"
    
    # 容器信息
    echo "容器信息:"
    docker ps --filter "name=${PROD_CONTAINER}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
    
    echo "✅ 部署验证完成"
}

# 生成部署报告
generate_deploy_report() {
    local deploy_time=$(date)
    local container_id=$(docker ps --filter "name=${PROD_CONTAINER}" --format "{{.ID}}")
    local image_id=$(docker inspect "${PROD_CONTAINER}" --format "{{.Image}}")
    
    cat > "deploy_report_$(date +%Y%m%d_%H%M%S).md" << EOF
# WebSocket 服务部署报告

**部署时间**: ${deploy_time}
**容器 ID**: ${container_id}
**镜像 ID**: ${image_id}

## 部署配置
- 容器名称: ${PROD_CONTAINER}
- 端口映射: 3000:3000
- 环境变量:
  - RUST_LOG=info
  - MAX_CONNECTIONS=2000
  - APP_ENV=production

## 验证结果
- 健康检查: ✅ 通过
- 指标端点: ✅ 通过
- 容器状态: ✅ 运行中

## 访问信息
- 服务地址: http://localhost:3000
- WebSocket: ws://localhost:3000/ws
- 健康检查: http://localhost:3000/health
- 服务指标: http://localhost:3000/metrics

## 运维命令
\`\`\`bash
# 查看日志
docker logs -f ${PROD_CONTAINER}

# 查看资源使用
docker stats ${PROD_CONTAINER}

# 重启服务
docker restart ${PROD_CONTAINER}

# 停止服务
docker stop ${PROD_CONTAINER}
\`\`\`
EOF

    echo "📋 部署报告已保存"
}

# 主部署流程
main() {
    echo -e "${BLUE}开始生产环境部署流程${NC}"
    
    # 1. 环境检查
    check_requirements
    
    # 2. 备份现有容器
    backup_current_container
    
    # 3. 选择部署方式
    if docker ps | grep -q "${PROD_CONTAINER}"; then
        rolling_update
    else
        fresh_deploy
    fi
    
    # 4. 部署后验证
    post_deploy_verification
    
    # 5. 生成报告
    generate_deploy_report
    
    echo -e "${GREEN}🎉 生产环境部署完成！${NC}"
    echo -e "${BLUE}服务访问地址: http://localhost:3000${NC}"
    echo -e "${BLUE}WebSocket 地址: ws://localhost:3000/ws${NC}"
    echo -e "${YELLOW}查看日志: docker logs -f ${PROD_CONTAINER}${NC}"
}

# 清理函数
cleanup_failed_deploy() {
    echo -e "${YELLOW}🧹 清理失败的部署...${NC}"
    docker stop "${PROD_CONTAINER}-new" 2>/dev/null || true
    docker rm "${PROD_CONTAINER}-new" 2>/dev/null || true
}

# 设置错误处理
trap cleanup_failed_deploy ERR

# 执行主流程
main "$@"</pre>

        <p><strong>步骤 8: 监控配置 (monitoring/prometheus.yml)</strong></p>
        <pre>global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

scrape_configs:
  - job_name: 'websocket-server'
    static_configs:
      - targets: ['host.docker.internal:3000']
    metrics_path: '/metrics'
    scrape_interval: 10s
    scrape_timeout: 5s

  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']</pre>

        <p><strong>步骤 9: Docker Compose 监控 (monitoring/docker-compose.monitoring.yml)</strong></p>
        <pre>version: '3.8'

services:
  websocket-server:
    image: websocket-docker:latest
    container_name: websocket-prod
    ports:
      - "3000:3000"
    environment:
      - RUST_LOG=info
      - MAX_CONNECTIONS=2000
      - ENABLE_METRICS=true
      - APP_ENV=production
    volumes:
      - ../logs:/app/logs
    restart: unless-stopped
    networks:
      - monitoring

  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    restart: unless-stopped
    networks:
      - monitoring

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin123
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana:/etc/grafana/provisioning
    restart: unless-stopped
    networks:
      - monitoring

  nginx:
    image: nginx:alpine
    container_name: websocket-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ../nginx/nginx.conf:/etc/nginx/nginx.conf
      - ../nginx/ssl:/etc/nginx/ssl
    depends_on:
      - websocket-server
    restart: unless-stopped
    networks:
      - monitoring

volumes:
  prometheus_data:
  grafana_data:

networks:
  monitoring:
    driver: bridge</pre>

        <p><strong>步骤 10: 运行完整测试</strong></p>
        <pre># 1. 赋予脚本执行权限
chmod +x scripts/*.sh

# 2. 构建镜像
./scripts/build.sh

# 3. 运行完整测试套件
./scripts/test_all.sh

# 4. 运行性能基准测试
./scripts/benchmark.sh

# 5. 部署到生产环境
./scripts/deploy.sh

# 6. 启动监控栈
cd monitoring
docker-compose -f docker-compose.monitoring.yml up -d

# 7. 验证部署
curl http://localhost:3000/health
curl http://localhost:3000/metrics
curl http://localhost:9090  # Prometheus
curl http://localhost:3001  # Grafana

# 8. 查看服务状态
docker ps
docker logs websocket-prod

# 9. 运行 Rust 集成测试
cargo test --test integration_test
cargo test --test docker_test

# 10. 运行负载测试（需要安装 apache2-utils）
sudo apt-get install apache2-utils  # Ubuntu/Debian
# 或
brew install apache2-utils  # macOS

./scripts/test_all.sh --load-test</pre>

        <p><strong>🎯 今日收获</strong></p>
        <ul>
            <li>✅ 完成了全面的 Docker 容器测试</li>
            <li>✅ 实现了自动化的集成测试套件</li>
            <li>✅ 配置了性能基准测试和负载测试</li>
            <li>✅ 建立了生产环境部署流程</li>
            <li>✅ 集成了监控和日志收集系统</li>
            <li>✅ 验证了容器的生产就绪性</li>
            <li>✅ 掌握了 Docker 化应用的完整测试方法</li>
        </ul>

        <p><strong>💡 扩展练习</strong></p>
        <ul>
            <li>集成 Kubernetes 部署和测试</li>
            <li>添加分布式追踪系统</li>
            <li>实现自动化 CI/CD 流水线</li>
            <li>配置高可用负载均衡</li>
        </ul>
    
        <p class="date"><strong>🗓️ 2025-08-22</strong></p>
        <h2>Day 22 - Kubernetes 部署与服务配置</h2>
        <p>今天你将学习如何将 Docker 化的 WebSocket 应用部署到 Kubernetes 集群。你将编写完整的 Kubernetes 清单文件，包括 Deployment、Service、Ingress 等资源，并掌握 K8s 的核心概念和最佳实践。</p>
        
        <p><strong>🎯 今日目标</strong></p>
        <ul>
            <li>编写 Kubernetes Deployment 清单</li>
            <li>配置 Service 和 Ingress 资源</li>
            <li>实现健康检查和资源限制</li>
            <li>设置环境变量和配置管理</li>
            <li>掌握 K8s 部署和管理命令</li>
        </ul>

        <p>🔗 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank">阅读对应官方文档</a></p>

        <p><strong>步骤 1: Kubernetes 项目结构</strong></p>
        <pre>📁 完整 K8s 项目结构：
day22_kubernetes_websocket/
├── k8s/
│   ├── namespace.yaml
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── ingress.yaml
│   ├── configmap.yaml
│   ├── secret.yaml
│   ├── hpa.yaml
│   ├── networkpolicy.yaml
│   └── rbac.yaml
├── scripts/
│   ├── deploy.sh
│   ├── undeploy.sh
│   ├── update.sh
│   └── monitor.sh
├── monitoring/
│   ├── servicemonitor.yaml
│   └── grafana-dashboard.json
├── docker/
│   └── Dockerfile
├── src/
│   ├── main.rs
│   ├── server.rs
│   └── config.rs
└── README.md</pre>

        <p><strong>步骤 2: 命名空间配置 (k8s/namespace.yaml)</strong></p>
        <pre>apiVersion: v1
kind: Namespace
metadata:
  name: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/component: namespace
    environment: production
  annotations:
    description: "WebSocket 服务应用命名空间"
    contact: "your-team@example.com"
---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: websocket-quota
  namespace: websocket-app
spec:
  hard:
    requests.cpu: "2"
    requests.memory: 4Gi
    limits.cpu: "4"
    limits.memory: 8Gi
    pods: "10"
    services: "5"
    persistentvolumeclaims: "2"
---
apiVersion: v1
kind: LimitRange
metadata:
  name: websocket-limits
  namespace: websocket-app
spec:
  limits:
  - default:
      cpu: "500m"
      memory: "512Mi"
    defaultRequest:
      cpu: "100m"
      memory: "128Mi"
    type: Container</pre>

        <p><strong>步骤 3: ConfigMap 配置 (k8s/configmap.yaml)</strong></p>
        <pre>apiVersion: v1
kind: ConfigMap
metadata:
  name: websocket-config
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: config
data:
  # 应用配置
  RUST_LOG: "info"
  LOG_LEVEL: "info"
  MAX_CONNECTIONS: "2000"
  CHANNEL_CAPACITY: "2000"
  ENABLE_METRICS: "true"
  APP_ENV: "production"
  BIND_ADDR: "0.0.0.0:3000"
  
  # 服务器配置
  server.toml: |
    [server]
    bind_addr = "0.0.0.0:3000"
    max_connections = 2000
    channel_capacity = 2000
    
    [logging]
    level = "info"
    format = "json"
    enable_file_logging = true
    
    [metrics]
    enabled = true
    port = 9090
    
    [health]
    endpoint = "/health"
    check_interval = "30s"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: nginx
    app.kubernetes.io/component: config
data:
  nginx.conf: |
    events {
        worker_connections 1024;
    }
    
    http {
        upstream websocket_backend {
            server websocket-service:3000;
        }
        
        map $http_upgrade $connection_upgrade {
            default upgrade;
            '' close;
        }
        
        server {
            listen 80;
            server_name _;
            
            # WebSocket 代理
            location /ws {
                proxy_pass http://websocket_backend;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection $connection_upgrade;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                
                proxy_connect_timeout 60s;
                proxy_send_timeout 60s;
                proxy_read_timeout 60s;
            }
            
            # HTTP 代理
            location / {
                proxy_pass http://websocket_backend;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
            
            # 健康检查
            location /nginx-health {
                access_log off;
                return 200 "healthy\n";
                add_header Content-Type text/plain;
            }
        }
    }</pre>

        <p><strong>步骤 4: Secret 配置 (k8s/secret.yaml)</strong></p>
        <pre>apiVersion: v1
kind: Secret
metadata:
  name: websocket-secrets
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: secret
type: Opaque
data:
  # Base64 编码的密钥 (echo -n 'your-secret-key' | base64)
  JWT_SECRET: eW91ci1zZWNyZXQta2V5
  DATABASE_URL: cG9zdGdyZXNxbDovL3VzZXI6cGFzc0Bsb2NhbGhvc3QvZGI=
  REDIS_URL: cmVkaXM6Ly9sb2NhbGhvc3Q6NjM3OS8w
---
apiVersion: v1
kind: Secret
metadata:
  name: tls-secret
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: tls
type: kubernetes.io/tls
data:
  # 使用 openssl 生成的证书 (base64 编码)
  tls.crt: LS0tLS1CRUdJTi...
  tls.key: LS0tLS1CRUdJTi...</pre>

        <p><strong>步骤 5: Deployment 配置 (k8s/deployment.yaml)</strong></p>
        <pre>apiVersion: apps/v1
kind: Deployment
metadata:
  name: websocket-server
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/component: server
    app.kubernetes.io/part-of: websocket-app
    environment: production
  annotations:
    deployment.kubernetes.io/revision: "1"
    description: "WebSocket 服务器部署"
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app.kubernetes.io/name: websocket-server
      app.kubernetes.io/component: server
  template:
    metadata:
      labels:
        app.kubernetes.io/name: websocket-server
        app.kubernetes.io/version: "1.0.0"
        app.kubernetes.io/component: server
        app.kubernetes.io/part-of: websocket-app
        environment: production
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "3000"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: websocket-service-account
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        runAsGroup: 1001
        fsGroup: 1001
      containers:
      - name: websocket-server
        image: websocket-docker:latest
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 3000
          protocol: TCP
        env:
        # ConfigMap 环境变量
        - name: RUST_LOG
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: RUST_LOG
        - name: LOG_LEVEL
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: LOG_LEVEL
        - name: MAX_CONNECTIONS
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: MAX_CONNECTIONS
        - name: CHANNEL_CAPACITY
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: CHANNEL_CAPACITY
        - name: ENABLE_METRICS
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: ENABLE_METRICS
        - name: APP_ENV
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: APP_ENV
        - name: BIND_ADDR
          valueFrom:
            configMapKeyRef:
              name: websocket-config
              key: BIND_ADDR
        # Secret 环境变量
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: websocket-secrets
              key: JWT_SECRET
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: websocket-secrets
              key: DATABASE_URL
              optional: true
        # Pod 信息
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: http
            scheme: HTTP
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: http
            scheme: HTTP
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          successThreshold: 1
          failureThreshold: 2
        startupProbe:
          httpGet:
            path: /health
            port: http
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 30
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
          readOnly: true
        - name: logs-volume
          mountPath: /app/logs
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: false
          capabilities:
            drop:
            - ALL
      - name: nginx-sidecar
        image: nginx:alpine
        ports:
        - name: nginx-http
          containerPort: 80
          protocol: TCP
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi
        livenessProbe:
          httpGet:
            path: /nginx-health
            port: nginx-http
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /nginx-health
            port: nginx-http
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
          readOnly: true
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
            add:
            - CHOWN
            - SETUID
            - SETGID
      volumes:
      - name: config-volume
        configMap:
          name: websocket-config
          items:
          - key: server.toml
            path: server.toml
      - name: nginx-config
        configMap:
          name: nginx-config
      - name: logs-volume
        emptyDir: {}
      terminationGracePeriodSeconds: 30
      restartPolicy: Always
      dnsPolicy: ClusterFirst</pre>

        <p><strong>步骤 6: Service 配置 (k8s/service.yaml)</strong></p>
        <pre>apiVersion: v1
kind: Service
metadata:
  name: websocket-service
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: nlb
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp
spec:
  type: ClusterIP
  selector:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: server
  ports:
  - name: http
    port: 3000
    targetPort: http
    protocol: TCP
  - name: nginx
    port: 80
    targetPort: nginx-http
    protocol: TCP
  sessionAffinity: None
---
apiVersion: v1
kind: Service
metadata:
  name: websocket-headless
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: headless-service
spec:
  type: ClusterIP
  clusterIP: None
  selector:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: server
  ports:
  - name: http
    port: 3000
    targetPort: http
    protocol: TCP
---
apiVersion: v1
kind: Service
metadata:
  name: websocket-nodeport
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: nodeport-service
spec:
  type: NodePort
  selector:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: server
  ports:
  - name: http
    port: 3000
    targetPort: http
    protocol: TCP
    nodePort: 30000
  - name: nginx
    port: 80
    targetPort: nginx-http
    protocol: TCP
    nodePort: 30080</pre>

        <p><strong>步骤 7: Ingress 配置 (k8s/ingress.yaml)</strong></p>
        <pre>apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: websocket-ingress
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    
    # WebSocket 支持
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/websocket-services: websocket-service
    
    # 会话亲和性
    nginx.ingress.kubernetes.io/affinity: cookie
    nginx.ingress.kubernetes.io/affinity-mode: persistent
    nginx.ingress.kubernetes.io/session-cookie-name: "websocket-server"
    nginx.ingress.kubernetes.io/session-cookie-expires: "86400"
    nginx.ingress.kubernetes.io/session-cookie-max-age: "86400"
    
    # 速率限制
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    
    # CORS
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-origin: "*"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization"
spec:
  tls:
  - hosts:
    - websocket.example.com
    - api.websocket.example.com
    secretName: tls-secret
  rules:
  - host: websocket.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: websocket-service
            port:
              number: 80
      - path: /ws
        pathType: Prefix
        backend:
          service:
            name: websocket-service
            port:
              number: 3000
  - host: api.websocket.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: websocket-service
            port:
              number: 3000
---
# 备用 Ingress（用于内部访问）
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: websocket-internal-ingress
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: internal-ingress
  annotations:
    kubernetes.io/ingress.class: nginx-internal
    nginx.ingress.kubernetes.io/whitelist-source-range: "10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
spec:
  rules:
  - host: websocket-internal.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: websocket-service
            port:
              number: 3000</pre>

        <p><strong>步骤 8: HPA 自动伸缩 (k8s/hpa.yaml)</strong></p>
        <pre>apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: websocket-hpa
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: websocket-server
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: websocket_active_connections
      target:
        type: AverageValue
        averageValue: "500"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
      - type: Pods
        value: 2
        periodSeconds: 60
      selectPolicy: Max</pre>

        <p><strong>步骤 9: RBAC 权限配置 (k8s/rbac.yaml)</strong></p>
        <pre>apiVersion: v1
kind: ServiceAccount
metadata:
  name: websocket-service-account
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: serviceaccount
automountServiceAccountToken: true
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: websocket-role
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: role
rules:
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: websocket-rolebinding
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: rolebinding
subjects:
- kind: ServiceAccount
  name: websocket-service-account
  namespace: websocket-app
roleRef:
  kind: Role
  name: websocket-role
  apiGroup: rbac.authorization.k8s.io</pre>

        <p><strong>步骤 10: 网络策略 (k8s/networkpolicy.yaml)</strong></p>
        <pre>apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: websocket-network-policy
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: networkpolicy
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/name: websocket-server
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # 允许来自 Ingress Controller 的流量
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 3000
    - protocol: TCP
      port: 80
  # 允许来自同命名空间的流量
  - from:
    - namespaceSelector:
        matchLabels:
          name: websocket-app
    ports:
    - protocol: TCP
      port: 3000
  # 允许来自监控系统的流量
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    ports:
    - protocol: TCP
      port: 3000
  egress:
  # 允许 DNS 查询
  - to: []
    ports:
    - protocol: UDP
      port: 53
  # 允许访问外部数据库（如果需要）
  - to: []
    ports:
    - protocol: TCP
      port: 5432  # PostgreSQL
    - protocol: TCP
      port: 6379  # Redis
  # 允许 HTTPS 出站流量
  - to: []
    ports:
    - protocol: TCP
      port: 443</pre>

        <p><strong>步骤 11: 部署脚本 (scripts/deploy.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}🚀 Kubernetes WebSocket 应用部署${NC}"

# 配置参数
NAMESPACE="websocket-app"
APP_NAME="websocket-server"
IMAGE_TAG="${1:-latest}"
KUBECTL_TIMEOUT="300s"

# 检查工具
check_prerequisites() {
    echo -e "${GREEN}🔍 检查部署前提条件...${NC}"
    
    # 检查 kubectl
    if ! command -v kubectl > /dev/null 2>&1; then
        echo -e "${RED}❌ kubectl 未安装${NC}"
        exit 1
    fi
    
    # 检查集群连接
    if ! kubectl cluster-info > /dev/null 2>&1; then
        echo -e "${RED}❌ 无法连接到 Kubernetes 集群${NC}"
        exit 1
    fi
    
    # 检查 Docker 镜像
    if [[ "${Image_TAG}" != "latest" ]] && ! docker images | grep -q "websocket-docker:${IMAGE_TAG}"; then
        echo -e "${YELLOW}⚠️  镜像 websocket-docker:${IMAGE_TAG} 不存在本地${NC}"
        echo "将使用远程镜像或构建新镜像"
    fi
    
    echo "✅ 前提条件检查通过"
}

# 创建命名空间
create_namespace() {
    echo -e "${GREEN}📦 创建命名空间...${NC}"
    
    if kubectl get namespace "${NAMESPACE}" > /dev/null 2>&1; then
        echo "命名空间 ${NAMESPACE} 已存在"
    else
        kubectl apply -f k8s/namespace.yaml
        echo "✅ 命名空间创建完成"
    fi
}

# 应用 ConfigMap 和 Secret
apply_configs() {
    echo -e "${GREEN}⚙️  应用配置...${NC}"
    
    kubectl apply -f k8s/configmap.yaml
    kubectl apply -f k8s/secret.yaml
    
    echo "✅ 配置应用完成"
}

# 应用 RBAC
apply_rbac() {
    echo -e "${GREEN}🔐 应用 RBAC 配置...${NC}"
    
    kubectl apply -f k8s/rbac.yaml
    
    echo "✅ RBAC 配置完成"
}

# 部署应用
deploy_application() {
    echo -e "${GREEN}🚀 部署应用...${NC}"
    
    # 更新镜像标签（如果指定了）
    if [[ "${IMAGE_TAG}" != "latest" ]]; then
        sed -i.bak "s|websocket-docker:latest|websocket-docker:${IMAGE_TAG}|g" k8s/deployment.yaml
    fi
    
    kubectl apply -f k8s/deployment.yaml
    kubectl apply -f k8s/service.yaml
    
    # 等待部署完成
    echo "⏳ 等待部署完成..."
    kubectl wait --for=condition=available --timeout="${KUBECTL_TIMEOUT}" \
        deployment/"${APP_NAME}" -n "${NAMESPACE}"
    
    echo "✅ 应用部署完成"
    
    # 恢复原始文件（如果修改了）
    if [[ -f k8s/deployment.yaml.bak ]]; then
        mv k8s/deployment.yaml.bak k8s/deployment.yaml
    fi
}

# 应用 Ingress
apply_ingress() {
    echo -e "${GREEN}🌐 配置 Ingress...${NC}"
    
    # 检查 Ingress Controller 是否存在
    if kubectl get ingressclass nginx > /dev/null 2>&1; then
        kubectl apply -f k8s/ingress.yaml
        echo "✅ Ingress 配置完成"
    else
        echo -e "${YELLOW}⚠️  Nginx Ingress Controller 未安装，跳过 Ingress 配置${NC}"
        echo "可使用以下命令安装:"
        echo "kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml"
    fi
}

# 应用网络策略
apply_network_policy() {
    echo -e "${GREEN}🔒 应用网络策略...${NC}"
    
    # 检查集群是否支持网络策略
    if kubectl get crd networkpolicies.networking.k8s.io > /dev/null 2>&1; then
        kubectl apply -f k8s/networkpolicy.yaml
        echo "✅ 网络策略配置完成"
    else
        echo -e "${YELLOW}⚠️  集群不支持网络策略，跳过配置${NC}"
    fi
}

# 应用 HPA
apply_hpa() {
    echo -e "${GREEN}📈 配置自动伸缩...${NC}"
    
    # 检查 Metrics Server
    if kubectl get deployment metrics-server -n kube-system > /dev/null 2>&1; then
        kubectl apply -f k8s/hpa.yaml
        echo "✅ HPA 配置完成"
    else
        echo -e "${YELLOW}⚠️  Metrics Server 未安装，跳过 HPA 配置${NC}"
        echo "可使用以下命令安装:"
        echo "kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml"
    fi
}

# 验证部署
verify_deployment() {
    echo -e "${GREEN}🔍 验证部署状态...${NC}"
    
    # 检查 Pod 状态
    echo "Pod 状态:"
    kubectl get pods -n "${NAMESPACE}" -l app.kubernetes.io/name="${APP_NAME}"
    
    # 检查 Service 状态
    echo -e "\nService 状态:"
    kubectl get services -n "${NAMESPACE}"
    
    # 检查 Ingress 状态
    echo -e "\nIngress 状态:"
    kubectl get ingress -n "${NAMESPACE}" 2>/dev/null || echo "无 Ingress 配置"
    
    # 检查 HPA 状态
    echo -e "\nHPA 状态:"
    kubectl get hpa -n "${NAMESPACE}" 2>/dev/null || echo "无 HPA 配置"
    
    # 获取访问信息
    echo -e "\n${BLUE}🌐 访问信息:${NC}"
    
    # NodePort 访问
    NODEPORT=$(kubectl get service websocket-nodeport -n "${NAMESPACE}" -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "N/A")
    if [[ "${NODEPORT}" != "N/A" ]]; then
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null || \
                 kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
        echo "NodePort 访问: http://${NODE_IP}:${NODEPORT}"
    fi
    
    # Ingress 访问
    INGRESS_IP=$(kubectl get ingress websocket-ingress -n "${NAMESPACE}" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
    if [[ -n "${INGRESS_IP}" ]]; then
        echo "Ingress 访问: http://${INGRESS_IP}"
    fi
    
    # 端口转发访问
    echo -e "\n${YELLOW}💡 临时访问命令:${NC}"
    echo "kubectl port-forward -n ${NAMESPACE} service/websocket-service 8080:3000"
    echo "然后访问: http://localhost:8080"
}

# 健康检查
health_check() {
    echo -e "${GREEN}🏥 执行健康检查...${NC}"
    
    # 端口转发进行健康检查
    kubectl port-forward -n "${NAMESPACE}" service/websocket-service 8080:3000 > /dev/null 2>&1 &
    PORT_FORWARD_PID=$!
    
    sleep 3
    
    if curl -f -s http://localhost:8080/health > /dev/null 2>&1; then
        echo "✅ 健康检查通过"
    else
        echo -e "${YELLOW}⚠️  健康检查失败，请检查 Pod 日志${NC}"
    fi
    
    # 清理端口转发
    kill $PORT_FORWARD_PID 2>/dev/null || true
}

# 显示有用的命令
show_useful_commands() {
    echo -e "\n${BLUE}📋 有用的管理命令:${NC}"
    
    cat << EOF
# 查看 Pod 日志
kubectl logs -f deployment/${APP_NAME} -n ${NAMESPACE}

# 查看所有资源
kubectl get all -n ${NAMESPACE}

# 描述部署状态
kubectl describe deployment ${APP_NAME} -n ${NAMESPACE}

# 扩缩容
kubectl scale deployment ${APP_NAME} --replicas=5 -n ${NAMESPACE}

# 查看事件
kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp'

# 进入 Pod
kubectl exec -it deployment/${APP_NAME} -n ${NAMESPACE} -- /bin/sh

# 端口转发
kubectl port-forward -n ${NAMESPACE} service/websocket-service 8080:3000

# 查看资源使用
kubectl top pods -n ${NAMESPACE}

# 删除部署
kubectl delete -f k8s/ --ignore-not-found=true
EOF
}

# 主函数
main() {
    echo -e "${BLUE}开始 Kubernetes 部署流程${NC}"
    
    check_prerequisites
    create_namespace
    apply_configs
    apply_rbac
    deploy_application
    apply_ingress
    apply_network_policy
    apply_hpa
    verify_deployment
    health_check
    show_useful_commands
    
    echo -e "\n${GREEN}🎉 Kubernetes 部署完成！${NC}"
}

# 错误处理
cleanup_on_error() {
    echo -e "${RED}❌ 部署过程中出现错误${NC}"
    echo "查看详细信息:"
    kubectl get events -n "${NAMESPACE}" --sort-by='.lastTimestamp' | tail -10
}

trap cleanup_on_error ERR

# 执行主函数
main "$@"</pre>

        <p><strong>步骤 12: 部署和管理</strong></p>
        <pre># 1. 准备部署环境
chmod +x scripts/*.sh

# 2. 检查 Kubernetes 集群
kubectl cluster-info
kubectl get nodes

# 3. 构建和推送镜像（如果需要）
docker build -t websocket-docker:v1.0.0 -f docker/Dockerfile .
docker tag websocket-docker:v1.0.0 your-registry/websocket-docker:v1.0.0
docker push your-registry/websocket-docker:v1.0.0

# 4. 执行部署
./scripts/deploy.sh v1.0.0

# 5. 验证部署
kubectl get all -n websocket-app
kubectl get pods -n websocket-app -w

# 6. 测试服务
kubectl port-forward -n websocket-app service/websocket-service 8080:3000 &
curl http://localhost:8080/health
curl http://localhost:8080/metrics

# 7. 查看日志
kubectl logs -f deployment/websocket-server -n websocket-app

# 8. 扩缩容测试
kubectl scale deployment websocket-server --replicas=5 -n websocket-app
kubectl get hpa -n websocket-app -w

# 9. 滚动更新
kubectl set image deployment/websocket-server websocket-server=websocket-docker:v1.0.1 -n websocket-app
kubectl rollout status deployment/websocket-server -n websocket-app

# 10. 故障排查
kubectl describe pod <pod-name> -n websocket-app
kubectl get events -n websocket-app --sort-by='.lastTimestamp'</pre>

        <p><strong>🎯 今日收获</strong></p>
        <ul>
            <li>✅ 编写了完整的 Kubernetes 部署清单</li>
            <li>✅ 配置了 Deployment、Service、Ingress 等核心资源</li>
            <li>✅ 实现了健康检查、资源限制和自动伸缩</li>
            <li>✅ 设置了 RBAC、网络策略等安全配置</li>
            <li>✅ 创建了自动化部署和管理脚本</li>
            <li>✅ 掌握了 K8s 应用的完整生命周期管理</li>
            <li>✅ 理解了云原生应用的部署最佳实践</li>
        </ul>

        <p><strong>💡 扩展练习</strong></p>
        <ul>
            <li>配置 PersistentVolume 持久化存储</li>
            <li>实现多环境配置管理</li>
            <li>添加 Prometheus ServiceMonitor</li>
            <li>配置 Pod 反亲和性规则</li>
        </ul>
    
        <p class="date"><strong>🗓️ 2025-08-23</strong></p>
        <h2>Day 23 - ConfigMap 动态配置管理</h2>
        <p>今天你将深入学习 Kubernetes ConfigMap 的高级用法，实现应用配置的动态管理和热更新。你将学会创建多环境配置、配置文件热重载、以及配置变更的自动化管理。</p>
        
        <p><strong>🎯 今日目标</strong></p>
        <ul>
            <li>掌握 ConfigMap 的创建和管理方法</li>
            <li>实现配置文件的热重载机制</li>
            <li>配置多环境参数管理</li>
            <li>实现配置变更的自动化部署</li>
            <li>学习配置安全和版本控制</li>
        </ul>

        <p>🔗 <a href="https://kubernetes.io/docs/concepts/configuration/configmap/" target="_blank">阅读对应官方文档</a></p>

        <p><strong>步骤 1: 动态配置项目结构</strong></p>
        <pre>📁 配置管理项目结构：
day23_configmap_management/
├── configs/
│   ├── base/
│   │   ├── app-config.yaml
│   │   ├── nginx.conf
│   │   └── logging.toml
│   ├── environments/
│   │   ├── dev/
│   │   │   ├── app-config.yaml
│   │   │   └── overrides.env
│   │   ├── staging/
│   │   │   ├── app-config.yaml
│   │   │   └── overrides.env
│   │   └── prod/
│   │       ├── app-config.yaml
│   │       └── overrides.env
│   └── secrets/
│       ├── dev-secrets.yaml
│       ├── staging-secrets.yaml
│       └── prod-secrets.yaml
├── k8s/
│   ├── base/
│   │   ├── configmap.yaml
│   │   ├── deployment.yaml
│   │   └── service.yaml
│   ├── overlays/
│   │   ├── dev/
│   │   ├── staging/
│   │   └── prod/
│   └── configmap-watcher.yaml
├── scripts/
│   ├── update-config.sh
│   ├── deploy-config.sh
│   ├── validate-config.sh
│   └── watch-config.sh
├── src/
│   ├── main.rs
│   ├── config.rs
│   ├── watcher.rs
│   └── reload.rs
├── Cargo.toml
└── README.md</pre>

        <p><strong>步骤 2: 增强的配置管理 (src/config.rs)</strong></p>
        <pre>use clap::Parser;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, fs, net::SocketAddr, path::Path, sync::Arc, time::Duration};
use tokio::sync::RwLock;
use tracing::{error, info, warn};

#[derive(Parser, Debug, Clone)]
#[command(name = "websocket-server")]
pub struct Config {
    #[arg(long, env = "CONFIG_FILE", default_value = "/app/config/app-config.yaml")]
    pub config_file: String,
    
    #[arg(long, env = "WATCH_CONFIG", default_value = "true")]
    pub watch_config: bool,
    
    #[arg(long, env = "RELOAD_INTERVAL", default_value = "30")]
    pub reload_interval: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub server: ServerConfig,
    pub logging: LoggingConfig,
    pub metrics: MetricsConfig,
    pub websocket: WebSocketConfig,
    pub features: FeatureFlags,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub bind_addr: SocketAddr,
    pub max_connections: usize,
    pub read_timeout: u64,
    pub write_timeout: u64,
    pub idle_timeout: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoggingConfig {
    pub level: String,
    pub format: String,
    pub enable_file_logging: bool,
    pub file_path: Option<String>,
    pub rotation: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricsConfig {
    pub enabled: bool,
    pub bind_addr: SocketAddr,
    pub path: String,
    pub namespace: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebSocketConfig {
    pub channel_capacity: usize,
    pub message_size_limit: usize,
    pub ping_interval: u64,
    pub pong_timeout: u64,
    pub close_timeout: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FeatureFlags {
    pub enable_auth: bool,
    pub enable_rate_limiting: bool,
    pub enable_metrics: bool,
    pub enable_tracing: bool,
    pub debug_mode: bool,
}

impl Default for AppConfig {
    fn default() -> Self {
        Self {
            server: ServerConfig {
                bind_addr: "0.0.0.0:3000".parse().unwrap(),
                max_connections: 1000,
                read_timeout: 30,
                write_timeout: 30,
                idle_timeout: 300,
            },
            logging: LoggingConfig {
                level: "info".to_string(),
                format: "json".to_string(),
                enable_file_logging: true,
                file_path: Some("/app/logs/app.log".to_string()),
                rotation: "daily".to_string(),
            },
            metrics: MetricsConfig {
                enabled: true,
                bind_addr: "0.0.0.0:9090".parse().unwrap(),
                path: "/metrics".to_string(),
                namespace: "websocket".to_string(),
            },
            websocket: WebSocketConfig {
                channel_capacity: 1000,
                message_size_limit: 64 * 1024, // 64KB
                ping_interval: 30,
                pong_timeout: 10,
                close_timeout: 5,
            },
            features: FeatureFlags {
                enable_auth: true,
                enable_rate_limiting: true,
                enable_metrics: true,
                enable_tracing: true,
                debug_mode: false,
            },
        }
    }
}

pub struct ConfigManager {
    config: Arc<RwLock<AppConfig>>,
    config_file: String,
    reload_callbacks: Vec<Box<dyn Fn(&AppConfig) + Send + Sync>>,
}

impl ConfigManager {
    pub fn new(config_file: String) -> anyhow::Result<Self> {
        let config = Self::load_config(&config_file)?;
        
        Ok(Self {
            config: Arc::new(RwLock::new(config)),
            config_file,
            reload_callbacks: Vec::new(),
        })
    }
    
    pub async fn get_config(&self) -> AppConfig {
        self.config.read().await.clone()
    }
    
    pub fn load_config(config_file: &str) -> anyhow::Result<AppConfig> {
        if !Path::new(config_file).exists() {
            warn!("配置文件不存在: {}, 使用默认配置", config_file);
            return Ok(AppConfig::default());
        }
        
        let content = fs::read_to_string(config_file)?;
        let mut config: AppConfig = serde_yaml::from_str(&content)?;
        
        // 从环境变量覆盖配置
        Self::override_from_env(&mut config);
        
        info!("配置文件加载成功: {}", config_file);
        Ok(config)
    }
    
    fn override_from_env(config: &mut AppConfig) {
        // 服务器配置
        if let Ok(addr) = std::env::var("BIND_ADDR") {
            if let Ok(socket_addr) = addr.parse() {
                config.server.bind_addr = socket_addr;
            }
        }
        
        if let Ok(max_conn) = std::env::var("MAX_CONNECTIONS") {
            if let Ok(value) = max_conn.parse() {
                config.server.max_connections = value;
            }
        }
        
        // 日志配置
        if let Ok(level) = std::env::var("LOG_LEVEL") {
            config.logging.level = level;
        }
        
        if let Ok(format) = std::env::var("LOG_FORMAT") {
            config.logging.format = format;
        }
        
        // WebSocket 配置
        if let Ok(capacity) = std::env::var("CHANNEL_CAPACITY") {
            if let Ok(value) = capacity.parse() {
                config.websocket.channel_capacity = value;
            }
        }
        
        // 功能开关
        if let Ok(auth) = std::env::var("ENABLE_AUTH") {
            config.features.enable_auth = auth.parse().unwrap_or(true);
        }
        
        if let Ok(metrics) = std::env::var("ENABLE_METRICS") {
            config.features.enable_metrics = metrics.parse().unwrap_or(true);
        }
        
        if let Ok(debug) = std::env::var("DEBUG_MODE") {
            config.features.debug_mode = debug.parse().unwrap_or(false);
        }
    }
    
    pub async fn reload_config(&self) -> anyhow::Result<bool> {
        let new_config = Self::load_config(&self.config_file)?;
        let mut current_config = self.config.write().await;
        
        // 检查配置是否有变化
        let config_changed = !self.configs_equal(&*current_config, &new_config);
        
        if config_changed {
            info!("检测到配置变化，重新加载配置");
            *current_config = new_config.clone();
            
            // 执行回调函数
            for callback in &self.reload_callbacks {
                callback(&new_config);
            }
            
            info!("配置重载完成");
        } else {
            info!("配置无变化，跳过重载");
        }
        
        Ok(config_changed)
    }
    
    fn configs_equal(&self, a: &AppConfig, b: &AppConfig) -> bool {
        // 简单的配置比较，实际项目中可能需要更复杂的比较逻辑
        serde_json::to_string(a).unwrap() == serde_json::to_string(b).unwrap()
    }
    
    pub fn add_reload_callback<F>(&mut self, callback: F) 
    where
        F: Fn(&AppConfig) + Send + Sync + 'static,
    {
        self.reload_callbacks.push(Box::new(callback));
    }
    
    pub async fn start_config_watcher(&self, interval: Duration) {
        let config_file = self.config_file.clone();
        let config = self.config.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(interval);
            let mut last_modified = None;
            
            loop {
                interval.tick().await;
                
                match fs::metadata(&config_file) {
                    Ok(metadata) => {
                        let modified = metadata.modified().ok();
                        
                        if last_modified.is_none() {
                            last_modified = modified;
                            continue;
                        }
                        
                        if modified != last_modified {
                            info!("检测到配置文件变化: {}", config_file);
                            last_modified = modified;
                            
                            match Self::load_config(&config_file) {
                                Ok(new_config) => {
                                    let mut current_config = config.write().await;
                                    *current_config = new_config;
                                    info!("配置自动重载完成");
                                }
                                Err(e) => {
                                    error!("配置重载失败: {}", e);
                                }
                            }
                        }
                    }
                    Err(e) => {
                        warn!("无法读取配置文件元数据: {}", e);
                    }
                }
            }
        });
    }
}</pre>

        <p><strong>步骤 3: 配置文件示例 (configs/base/app-config.yaml)</strong></p>
        <pre>server:
  bind_addr: "0.0.0.0:3000"
  max_connections: 2000
  read_timeout: 30
  write_timeout: 30
  idle_timeout: 300

logging:
  level: "info"
  format: "json"
  enable_file_logging: true
  file_path: "/app/logs/app.log"
  rotation: "daily"

metrics:
  enabled: true
  bind_addr: "0.0.0.0:9090"
  path: "/metrics"
  namespace: "websocket"

websocket:
  channel_capacity: 2000
  message_size_limit: 65536  # 64KB
  ping_interval: 30
  pong_timeout: 10
  close_timeout: 5

features:
  enable_auth: true
  enable_rate_limiting: true
  enable_metrics: true
  enable_tracing: true
  debug_mode: false</pre>

        <p><strong>步骤 4: 环境特定配置 (configs/environments/prod/app-config.yaml)</strong></p>
        <pre>server:
  bind_addr: "0.0.0.0:3000"
  max_connections: 5000
  read_timeout: 60
  write_timeout: 60
  idle_timeout: 600

logging:
  level: "warn"
  format: "json"
  enable_file_logging: true
  file_path: "/app/logs/websocket-prod.log"
  rotation: "hourly"

metrics:
  enabled: true
  bind_addr: "0.0.0.0:9090"
  path: "/metrics"
  namespace: "websocket_prod"

websocket:
  channel_capacity: 5000
  message_size_limit: 131072  # 128KB
  ping_interval: 45
  pong_timeout: 15
  close_timeout: 10

features:
  enable_auth: true
  enable_rate_limiting: true
  enable_metrics: true
  enable_tracing: false
  debug_mode: false</pre>

        <p><strong>步骤 5: 多环境 ConfigMap (k8s/base/configmap.yaml)</strong></p>
        <pre>apiVersion: v1
kind: ConfigMap
metadata:
  name: websocket-base-config
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: config
    config.kubernetes.io/type: base
data:
  app-config.yaml: |
    server:
      bind_addr: "0.0.0.0:3000"
      max_connections: 2000
      read_timeout: 30
      write_timeout: 30
      idle_timeout: 300
    
    logging:
      level: "info"
      format: "json"
      enable_file_logging: true
      file_path: "/app/logs/app.log"
      rotation: "daily"
    
    metrics:
      enabled: true
      bind_addr: "0.0.0.0:9090"
      path: "/metrics"
      namespace: "websocket"
    
    websocket:
      channel_capacity: 2000
      message_size_limit: 65536
      ping_interval: 30
      pong_timeout: 10
      close_timeout: 5
    
    features:
      enable_auth: true
      enable_rate_limiting: true
      enable_metrics: true
      enable_tracing: true
      debug_mode: false

  nginx.conf: |
    events {
        worker_connections 1024;
    }
    
    http {
        include /etc/nginx/mime.types;
        default_type application/octet-stream;
        
        # 日志格式
        log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                       '$status $body_bytes_sent "$http_referer" '
                       '"$http_user_agent" "$http_x_forwarded_for"';
        
        access_log /var/log/nginx/access.log main;
        error_log /var/log/nginx/error.log warn;
        
        # 性能优化
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 65;
        types_hash_max_size 2048;
        
        # Gzip 压缩
        gzip on;
        gzip_vary on;
        gzip_min_length 1024;
        gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
        
        upstream websocket_backend {
            server localhost:3000;
            keepalive 32;
        }
        
        map $http_upgrade $connection_upgrade {
            default upgrade;
            '' close;
        }
        
        server {
            listen 80;
            server_name _;
            
            # 健康检查
            location /nginx-health {
                access_log off;
                return 200 "healthy\n";
                add_header Content-Type text/plain;
            }
            
            # WebSocket 升级
            location /ws {
                proxy_pass http://websocket_backend;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection $connection_upgrade;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                
                # WebSocket 特定设置
                proxy_connect_timeout 60s;
                proxy_send_timeout 60s;
                proxy_read_timeout 60s;
                proxy_buffering off;
            }
            
            # HTTP API
            location / {
                proxy_pass http://websocket_backend;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                
                # 缓存设置
                proxy_cache_bypass $http_upgrade;
                proxy_no_cache $http_upgrade;
            }
        }
    }

  logging.toml: |
    [appenders.stdout]
    kind = "console"
    
    [appenders.file]
    kind = "rolling_file"
    path = "/app/logs/app.log"
    
    [appenders.file.policy]
    kind = "time"
    pattern = "%Y%m%d"
    
    [loggers.websocket]
    level = "info"
    appenders = ["stdout", "file"]
    additive = false
    
    [root]
    level = "info"
    appenders = ["stdout"]

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: websocket-env-config
  namespace: websocket-app
  labels:
    app.kubernetes.io/name: websocket-server
    app.kubernetes.io/component: env-config
data:
  # 基础环境变量
  RUST_LOG: "info"
  LOG_LEVEL: "info"
  LOG_FORMAT: "json"
  ENABLE_METRICS: "true"
  ENABLE_AUTH: "true"
  DEBUG_MODE: "false"
  
  # 服务器配置
  BIND_ADDR: "0.0.0.0:3000"
  MAX_CONNECTIONS: "2000"
  READ_TIMEOUT: "30"
  WRITE_TIMEOUT: "30"
  IDLE_TIMEOUT: "300"
  
  # WebSocket 配置
  CHANNEL_CAPACITY: "2000"
  MESSAGE_SIZE_LIMIT: "65536"
  PING_INTERVAL: "30"
  PONG_TIMEOUT: "10"
  CLOSE_TIMEOUT: "5"
  
  # 配置文件路径
  CONFIG_FILE: "/app/config/app-config.yaml"
  WATCH_CONFIG: "true"
  RELOAD_INTERVAL: "30"</pre>

        <p><strong>步骤 6: 配置更新脚本 (scripts/update-config.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}🔧 ConfigMap 动态更新工具${NC}"

# 配置参数
NAMESPACE="${NAMESPACE:-websocket-app}"
CONFIG_NAME="${CONFIG_NAME:-websocket-base-config}"
ENV_CONFIG_NAME="${ENV_CONFIG_NAME:-websocket-env-config}"
ENVIRONMENT="${ENVIRONMENT:-dev}"
DRY_RUN="${DRY_RUN:-false}"

# 显示用法
usage() {
    cat << EOF
用法: $0 [选项]

选项:
    -n, --namespace NAMESPACE       Kubernetes 命名空间 (默认: websocket-app)
    -c, --config CONFIG_NAME        ConfigMap 名称 (默认: websocket-base-config)
    -e, --environment ENVIRONMENT   环境名称 (dev/staging/prod, 默认: dev)
    -d, --dry-run                   仅显示将要执行的操作，不实际执行
    -h, --help                      显示帮助信息

示例:
    $0 -e prod                      更新生产环境配置
    $0 -n my-app -c my-config       更新指定命名空间和配置
    $0 -d -e staging                预览 staging 环境配置更新
EOF
}

# 解析命令行参数
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -c|--config)
            CONFIG_NAME="$2"
            shift 2
            ;;
        -e|--environment)
            ENVIRONMENT="$2"
            shift 2
            ;;
        -d|--dry-run)
            DRY_RUN="true"
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "未知选项: $1"
            usage
            exit 1
            ;;
    esac
done

# 验证环境
validate_environment() {
    case $ENVIRONMENT in
        dev|staging|prod)
            echo -e "${GREEN}✅ 环境验证通过: $ENVIRONMENT${NC}"
            ;;
        *)
            echo -e "${RED}❌ 不支持的环境: $ENVIRONMENT${NC}"
            echo "支持的环境: dev, staging, prod"
            exit 1
            ;;
    esac
}

# 检查前提条件
check_prerequisites() {
    echo -e "${GREEN}🔍 检查前提条件...${NC}"
    
    # 检查 kubectl
    if ! command -v kubectl > /dev/null 2>&1; then
        echo -e "${RED}❌ kubectl 未安装${NC}"
        exit 1
    fi
    
    # 检查集群连接
    if ! kubectl cluster-info > /dev/null 2>&1; then
        echo -e "${RED}❌ 无法连接到 Kubernetes 集群${NC}"
        exit 1
    fi
    
    # 检查命名空间
    if ! kubectl get namespace "$NAMESPACE" > /dev/null 2>&1; then
        echo -e "${RED}❌ 命名空间不存在: $NAMESPACE${NC}"
        exit 1
    fi
    
    # 检查配置文件
    local config_file="configs/environments/${ENVIRONMENT}/app-config.yaml"
    if [[ ! -f "$config_file" ]]; then
        echo -e "${RED}❌ 配置文件不存在: $config_file${NC}"
        exit 1
    fi
    
    echo "✅ 前提条件检查通过"
}

# 验证配置文件
validate_config() {
    echo -e "${GREEN}🔍 验证配置文件...${NC}"
    
    local config_file="configs/environments/${ENVIRONMENT}/app-config.yaml"
    
    # 检查 YAML 语法
    if command -v yq > /dev/null 2>&1; then
        if ! yq eval . "$config_file" > /dev/null 2>&1; then
            echo -e "${RED}❌ 配置文件 YAML 语法错误: $config_file${NC}"
            exit 1
        fi
        echo "✅ YAML 语法验证通过"
    else
        echo -e "${YELLOW}⚠️  yq 未安装，跳过 YAML 语法检查${NC}"
    fi
    
    # 检查必需字段
    local required_fields=(
        ".server.bind_addr"
        ".server.max_connections"
        ".logging.level"
        ".websocket.channel_capacity"
    )
    
    if command -v yq > /dev/null 2>&1; then
        for field in "${required_fields[@]}"; do
            if ! yq eval "$field" "$config_file" > /dev/null 2>&1; then
                echo -e "${RED}❌ 缺少必需字段: $field${NC}"
                exit 1
            fi
        done
        echo "✅ 必需字段验证通过"
    fi
}

# 创建或更新 ConfigMap
update_configmap() {
    echo -e "${GREEN}🔄 更新 ConfigMap...${NC}"
    
    local config_file="configs/environments/${ENVIRONMENT}/app-config.yaml"
    local nginx_config="configs/base/nginx.conf"
    local logging_config="configs/base/logging.toml"
    
    # 构建 kubectl 命令
    local kubectl_cmd="kubectl create configmap $CONFIG_NAME"
    kubectl_cmd+=" --from-file=app-config.yaml=$config_file"
    
    if [[ -f "$nginx_config" ]]; then
        kubectl_cmd+=" --from-file=nginx.conf=$nginx_config"
    fi
    
    if [[ -f "$logging_config" ]]; then
        kubectl_cmd+=" --from-file=logging.toml=$logging_config"
    fi
    
    kubectl_cmd+=" --namespace=$NAMESPACE"
    kubectl_cmd+=" --dry-run=client -o yaml"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${BLUE}📋 将要执行的操作 (dry-run):${NC}"
        echo "$kubectl_cmd"
        echo ""
        eval "$kubectl_cmd"
    else
        # 应用配置
        eval "$kubectl_cmd" | kubectl apply -f -
        echo "✅ ConfigMap 更新完成"
    fi
}

# 更新环境变量 ConfigMap
update_env_configmap() {
    echo -e "${GREEN}🔄 更新环境变量 ConfigMap...${NC}"
    
    local env_file="configs/environments/${ENVIRONMENT}/overrides.env"
    
    if [[ -f "$env_file" ]]; then
        local kubectl_cmd="kubectl create configmap $ENV_CONFIG_NAME"
        kubectl_cmd+=" --from-env-file=$env_file"
        kubectl_cmd+=" --namespace=$NAMESPACE"
        kubectl_cmd+=" --dry-run=client -o yaml"
        
        if [[ "$DRY_RUN" == "true" ]]; then
            echo -e "${BLUE}📋 环境变量 ConfigMap (dry-run):${NC}"
            eval "$kubectl_cmd"
        else
            eval "$kubectl_cmd" | kubectl apply -f -
            echo "✅ 环境变量 ConfigMap 更新完成"
        fi
    else
        echo -e "${YELLOW}⚠️  环境变量文件不存在: $env_file${NC}"
    fi
}

# 滚动重启部署
restart_deployment() {
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${BLUE}📋 将要重启的部署 (dry-run):${NC}"
        kubectl get deployments -n "$NAMESPACE" -l app.kubernetes.io/name=websocket-server
        return
    fi
    
    echo -e "${GREEN}🔄 重启相关部署...${NC}"
    
    # 添加配置变更注解以触发滚动更新
    local timestamp=$(date -u +"%Y%m%dT%H%M%SZ")
    
    kubectl patch deployment websocket-server -n "$NAMESPACE" -p \
        "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"config.kubernetes.io/last-updated\":\"$timestamp\"}}}}}"
    
    # 等待部署完成
    kubectl rollout status deployment/websocket-server -n "$NAMESPACE" --timeout=300s
    
    echo "✅ 部署重启完成"
}

# 验证配置生效
verify_config() {
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${BLUE}📋 配置验证将在实际部署后执行${NC}"
        return
    fi
    
    echo -e "${GREEN}🔍 验证配置生效...${NC}"
    
    # 等待 Pod 就绪
    sleep 10
    
    # 检查 Pod 状态
    local pod_name=$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/name=websocket-server -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
    
    if [[ -n "$pod_name" ]]; then
        echo "检查 Pod: $pod_name"
        
        # 检查配置文件是否挂载正确
        if kubectl exec "$pod_name" -n "$NAMESPACE" -- test -f /app/config/app-config.yaml > /dev/null 2>&1; then
            echo "✅ 配置文件挂载成功"
        else
            echo -e "${YELLOW}⚠️  配置文件挂载检查失败${NC}"
        fi
        
        # 检查服务健康状态
        if kubectl exec "$pod_name" -n "$NAMESPACE" -- wget -q --spider http://localhost:3000/health > /dev/null 2>&1; then
            echo "✅ 服务健康检查通过"
        else
            echo -e "${YELLOW}⚠️  服务健康检查失败${NC}"
        fi
    else
        echo -e "${YELLOW}⚠️  未找到运行中的 Pod${NC}"
    fi
}

# 显示配置差异
show_config_diff() {
    echo -e "${GREEN}📊 配置变更对比...${NC}"
    
    local current_config="/tmp/current-config.yaml"
    local new_config="configs/environments/${ENVIRONMENT}/app-config.yaml"
    
    # 获取当前配置
    if kubectl get configmap "$CONFIG_NAME" -n "$NAMESPACE" -o jsonpath='{.data.app-config\.yaml}' > "$current_config" 2>/dev/null; then
        echo "当前配置 vs 新配置:"
        
        if command -v diff > /dev/null 2>&1; then
            diff -u "$current_config" "$new_config" || true
        else
            echo "diff 命令不可用，无法显示差异"
        fi
        
        rm -f "$current_config"
    else
        echo "无法获取当前配置，可能是首次部署"
    fi
}

# 生成配置报告
generate_report() {
    local report_file="config-update-report-$(date +%Y%m%d-%H%M%S).md"
    
    cat > "$report_file" << EOF
# ConfigMap 更新报告

**更新时间**: $(date)
**环境**: $ENVIRONMENT
**命名空间**: $NAMESPACE
**ConfigMap**: $CONFIG_NAME

## 更新内容

### 配置文件
- 应用配置: configs/environments/${ENVIRONMENT}/app-config.yaml
- Nginx 配置: configs/base/nginx.conf
- 日志配置: configs/base/logging.toml

### 环境变量
$(if [[ -f "configs/environments/${ENVIRONMENT}/overrides.env" ]]; then
    echo "- 环境变量覆盖: configs/environments/${ENVIRONMENT}/overrides.env"
else
    echo "- 无环境变量覆盖文件"
fi)

## 执行结果

$(if [[ "$DRY_RUN" == "true" ]]; then
    echo "✅ Dry-run 模式，未实际执行更新"
else
    echo "✅ 配置更新成功完成"
fi)

## 验证结果

$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/name=websocket-server -o wide 2>/dev/null || echo "Pod 状态检查失败")

EOF
    
    echo -e "${GREEN}📋 配置报告已生成: $report_file${NC}"
}

# 主函数
main() {
    echo -e "${BLUE}开始 ConfigMap 更新流程${NC}"
    echo "环境: $ENVIRONMENT"
    echo "命名空间: $NAMESPACE"
    echo "ConfigMap: $CONFIG_NAME"
    echo ""
    
    validate_environment
    check_prerequisites
    validate_config
    show_config_diff
    update_configmap
    update_env_configmap
    
    if [[ "$DRY_RUN" != "true" ]]; then
        restart_deployment
        verify_config
    fi
    
    generate_report
    
    echo -e "\n${GREEN}🎉 ConfigMap 更新流程完成！${NC}"
}

# 错误处理
cleanup_on_error() {
    echo -e "${RED}❌ 更新过程中出现错误${NC}"
    echo "请检查以下内容:"
    echo "1. 配置文件语法是否正确"
    echo "2. Kubernetes 集群连接是否正常"
    echo "3. 命名空间和资源是否存在"
}

trap cleanup_on_error ERR

# 执行主函数
main "$@"</pre>

        <p><strong>步骤 7: 配置验证脚本 (scripts/validate-config.sh)</strong></p>
        <pre>#!/bin/bash
set -e

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}🔍 配置文件验证工具${NC}"

# 验证单个配置文件
validate_config_file() {
    local config_file="$1"
    local env_name="$2"
    
    echo -e "${GREEN}📋 验证配置文件: $config_file${NC}"
    
    if [[ ! -f "$config_file" ]]; then
        echo -e "${RED}❌ 配置文件不存在: $config_file${NC}"
        return 1
    fi
    
    # YAML 语法检查
    if command -v yq > /dev/null 2>&1; then
        if ! yq eval . "$config_file" > /dev/null 2>&1; then
            echo -e "${RED}❌ YAML 语法错误${NC}"
            return 1
        fi
        echo "✅ YAML 语法正确"
    else
        echo -e "${YELLOW}⚠️  yq 未安装，跳过 YAML 语法检查${NC}"
    fi
    
    # 字段验证
    local errors=0
    
    # 必需字段检查
    local required_fields=(
        ".server.bind_addr"
        ".server.max_connections"
        ".logging.level"
        ".websocket.channel_capacity"
        ".features.enable_auth"
    )
    
    for field in "${required_fields[@]}"; do
        if command -v yq > /dev/null 2>&1; then
            if ! yq eval "$field" "$config_file" > /dev/null 2>&1; then
                echo -e "${RED}❌ 缺少必需字段: $field${NC}"
                ((errors++))
            fi
        fi
    done
    
    # 值范围检查
    if command -v yq > /dev/null 2>&1; then
        local max_conn=$(yq eval '.server.max_connections' "$config_file" 2>/dev/null)
        if [[ "$max_conn" =~ ^[0-9]+$ ]]; then
            if [[ $max_conn -lt 1 || $max_conn -gt 100000 ]]; then
                echo -e "${YELLOW}⚠️  max_connections 值可能不合理: $max_conn${NC}"
            fi
        fi
        
        local log_level=$(yq eval '.logging.level' "$config_file" 2>/dev/null)
        case "$log_level" in
            trace|debug|info|warn|error)
                ;;
            *)
                echo -e "${YELLOW}⚠️  不支持的日志级别: $log_level${NC}"
                ;;
        esac
    fi
    
    if [[ $errors -eq 0 ]]; then
        echo -e "${GREEN}✅ 配置文件验证通过: $env_name${NC}"
        return 0
    else
        echo -e "${RED}❌ 配置文件验证失败: $env_name (错误数: $errors)${NC}"
        return 1
    fi
}

# 验证所有环境配置
validate_all_configs() {
    echo -e "${GREEN}🔍 验证所有环境配置...${NC}"
    
    local total_errors=0
    local environments=("dev" "staging" "prod")
    
    for env in "${environments[@]}"; do
        local config_file="configs/environments/$env/app-config.yaml"
        
        if ! validate_config_file "$config_file" "$env"; then
            ((total_errors++))
        fi
        echo ""
    done
    
    # 验证基础配置
    if [[ -f "configs/base/app-config.yaml" ]]; then
        if ! validate_config_file "configs/base/app-config.yaml" "base"; then
            ((total_errors++))
        fi
    fi
    
    if [[ $total_errors -eq 0 ]]; then
        echo -e "${GREEN}🎉 所有配置文件验证通过！${NC}"
        return 0
    else
        echo -e "${RED}❌ 配置验证失败，发现 $total_errors 个错误${NC}"
        return 1
    fi
}

# 配置差异对比
compare_configs() {
    local env1="$1"
    local env2="$2"
    
    echo -e "${GREEN}📊 配置差异对比: $env1 vs $env2${NC}"
    
    local config1="configs/environments/$env1/app-config.yaml"
    local config2="configs/environments/$env2/app-config.yaml"
    
    if [[ ! -f "$config1" ]]; then
        echo -e "${RED}❌ 配置文件不存在: $config1${NC}"
        return 1
    fi
    
    if [[ ! -f "$config2" ]]; then
        echo -e "${RED}❌ 配置文件不存在: $config2${NC}"
        return 1
    fi
    
    if command -v diff > /dev/null 2>&1; then
        echo "差异详情:"
        diff -u "$config1" "$config2" || true
    else
        echo -e "${YELLOW}⚠️  diff 命令不可用${NC}"
    fi
}

# 生成配置文档
generate_config_docs() {
    echo -e "${GREEN}📋 生成配置文档...${NC}"
    
    local doc_file="CONFIG_DOCS.md"
    
    cat > "$doc_file" << 'EOF'
# WebSocket 服务配置文档

## 配置文件结构

### 服务器配置 (server)

| 字段 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| bind_addr | string | "0.0.0.0:3000" | 服务器绑定地址 |
| max_connections | number | 2000 | 最大并发连接数 |
| read_timeout | number | 30 | 读取超时时间(秒) |
| write_timeout | number | 30 | 写入超时时间(秒) |
| idle_timeout | number | 300 | 空闲超时时间(秒) |

### 日志配置 (logging)

| 字段 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| level | string | "info" | 日志级别 (trace/debug/info/warn/error) |
| format | string | "json" | 日志格式 (json/text) |
| enable_file_logging | boolean | true | 是否启用文件日志 |
| file_path | string | "/app/logs/app.log" | 日志文件路径 |
| rotation | string | "daily" | 日志轮转策略 |

### WebSocket 配置 (websocket)

| 字段 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| channel_capacity | number | 2000 | 广播通道容量 |
| message_size_limit | number | 65536 | 消息大小限制(字节) |
| ping_interval | number | 30 | Ping 间隔时间(秒) |
| pong_timeout | number | 10 | Pong 超时时间(秒) |
| close_timeout | number | 5 | 关闭超时时间(秒) |

### 功能开关 (features)

| 字段 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| enable_auth | boolean | true | 启用身份验证 |
| enable_rate_limiting | boolean | true | 启用速率限制 |
| enable_metrics | boolean | true | 启用指标收集 |
| enable_tracing | boolean | true | 启用链路追踪 |
| debug_mode | boolean | false | 启用调试模式 |

## 环境差异

EOF

    # 添加环境配置对比
    echo "### 开发环境 (dev)" >> "$doc_file"
    if [[ -f "configs/environments/dev/app-config.yaml" ]] && command -v yq > /dev/null 2>&1; then
        echo '```yaml' >> "$doc_file"
        yq eval '.' "configs/environments/dev/app-config.yaml" >> "$doc_file"
        echo '```' >> "$doc_file"
    fi
    
    echo "### 生产环境 (prod)" >> "$doc_file"
    if [[ -f "configs/environments/prod/app-config.yaml" ]] && command -v yq > /dev/null 2>&1; then
        echo '```yaml' >> "$doc_file"
        yq eval '.' "configs/environments/prod/app-config.yaml" >> "$doc_file"
        echo '```' >> "$doc_file"
    fi
    
    echo -e "${GREEN}✅ 配置文档已生成: $doc_file${NC}"
}

# 主函数
main() {
    case "${1:-validate}" in
        validate)
            validate_all_configs
            ;;
        compare)
            if [[ $# -lt 3 ]]; then
                echo "用法: $0 compare <env1> <env2>"
                exit 1
            fi
            compare_configs "$2" "$3"
            ;;
        docs)
            generate_config_docs
            ;;
        single)
            if [[ $# -lt 2 ]]; then
                echo "用法: $0 single <config-file>"
                exit 1
            fi
            validate_config_file "$2" "$(basename "$2")"
            ;;
        *)
            echo "用法: $0 {validate|compare|docs|single}"
            echo ""
            echo "命令:"
            echo "  validate     验证所有环境配置"
            echo "  compare      比较两个环境配置"
            echo "  docs         生成配置文档"
            echo "  single       验证单个配置文件"
            exit 1
            ;;
    esac
}

main "$@"</pre>

        <p><strong>步骤 8: 运行和测试</strong></p>
        <pre># 1. 验证配置文件
chmod +x scripts/*.sh
./scripts/validate-config.sh

# 2. 生成配置文档
./scripts/validate-config.sh docs

# 3. 比较不同环境配置
./scripts/validate-config.sh compare dev prod

# 4. 更新开发环境配置（dry-run）
./scripts/update-config.sh -e dev -d

# 5. 实际更新开发环境配置
./scripts/update-config.sh -e dev

# 6. 更新生产环境配置
./scripts/update-config.sh -e prod -n websocket-prod

# 7. 验证 ConfigMap 创建
kubectl get configmaps -n websocket-app
kubectl describe configmap websocket-base-config -n websocket-app

# 8. 测试配置热重载
kubectl exec deployment/websocket-server -n websocket-app -- \
  cat /app/config/app-config.yaml

# 9. 更新配置并验证重载
echo "修改配置文件后重新应用..."
./scripts/update-config.sh -e dev

# 10. 监控配置变更
kubectl logs -f deployment/websocket-server -n websocket-app | grep -i config</pre>

        <p><strong>🎯 今日收获</strong></p>
        <ul>
            <li>✅ 掌握了 ConfigMap 的高级用法和管理</li>
            <li>✅ 实现了配置文件的动态热重载机制</li>
            <li>✅ 建立了多环境配置管理体系</li>
            <li>✅ 创建了配置验证和差异对比工具</li>
            <li>✅ 实现了配置变更的自动化部署</li>
            <li>✅ 学会了配置安全和版本控制最佳实践</li>
            <li>✅ 建立了完整的配置管理工作流</li>
        </ul>

        <p><strong>💡 扩展练习</strong></p>
        <ul>
            <li>集成配置中心（如 Consul、etcd）</li>
            <li>实现配置加密和解密</li>
            <li>添加配置变更审计日志</li>
            <li>实现蓝绿部署配置切换</li>
        </ul>
    
        <p class="date"><strong>🗓️ 2025-08-24</strong></p>
        <h2>Day 24 - minikube 启动与访问测试</h2>
        <p>今天你将学习如何使用 Minikube 在本地环境中创建 Kubernetes 集群，并验证之前创建的 WebSocket 服务在 Kubernetes 环境中的运行情况。这是从本地开发过渡到 Kubernetes 的重要一步。</p>
        
        <h3>🎯 学习目标</h3>
        <ul>
            <li>安装和配置 Minikube 本地 Kubernetes 环境</li>
            <li>部署 WebSocket 服务到 Minikube 集群</li>
            <li>学习服务暴露和访问的多种方式</li>
            <li>掌握本地 Kubernetes 集群的调试技巧</li>
            <li>验证服务的可用性和性能</li>
        </ul>

        <h3>📁 项目结构</h3>
        <pre>day24_minikube_testing/
├── src/
│   ├── main.rs
│   ├── server.rs
│   ├── config.rs
│   └── health.rs
├── k8s/
│   ├── namespace.yaml
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── ingress.yaml
│   └── configmap.yaml
├── scripts/
│   ├── setup-minikube.sh
│   ├── deploy.sh
│   ├── test-service.sh
│   ├── cleanup.sh
│   └── monitoring.sh
├── tests/
│   ├── integration_test.rs
│   └── load_test.rs
├── web/
│   └── test-client.html
├── configs/
│   ├── minikube.yaml
│   └── local.yaml
├── Dockerfile
├── Cargo.toml
├── .dockerignore
└── README.md</pre>

        <h3>🚀 实现步骤</h3>

        <h4>步骤 1: 创建优化的 WebSocket 服务</h4>
        <p><strong>Cargo.toml:</strong></p>
        <pre><code>[package]
name = "websocket-minikube"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["ws", "macros"] }
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.21"
futures-util = "0.3"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
anyhow = "1.0"
clap = { version = "4.0", features = ["derive"] }
config = "0.14"
notify = "6.0"</code></pre>

        <p><strong>src/main.rs:</strong></p>
        <pre><code>use axum::{
    extract::{ws::WebSocketUpgrade, State},
    response::Response,
    routing::{get, post},
    Json, Router,
};
use std::{collections::HashMap, net::SocketAddr, sync::Arc};
use tokio::sync::RwLock;
use tower_http::{cors::CorsLayer, trace::TraceLayer};
use tracing::{info, warn};
use uuid::Uuid;

mod config;
mod health;
mod server;

use config::ConfigManager;
use health::{HealthStatus, ReadinessStatus};
use server::{AppState, ClientInfo};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 初始化日志
    tracing_subscriber::fmt()
        .with_env_filter(std::env::var("RUST_LOG").unwrap_or_else(|_| "info".into()))
        .init();

    info!("🚀 Starting WebSocket Server for Minikube");

    // 初始化配置管理器
    let config_manager = ConfigManager::new("configs/local.yaml").await?;
    let config = config_manager.get_config().await;
    
    info!("📋 Configuration loaded: {:?}", config);

    // 创建应用状态
    let app_state = Arc::new(AppState {
        clients: RwLock::new(HashMap::new()),
        health: RwLock::new(HealthStatus::healthy()),
        readiness: RwLock::new(ReadinessStatus::ready()),
        config_manager,
        metrics: Default::default(),
    });

    // 启动配置热重载
    let state_clone = app_state.clone();
    tokio::spawn(async move {
        if let Err(e) = state_clone.config_manager.start_hot_reload().await {
            warn!("配置热重载失败: {}", e);
        }
    });

    // 创建路由
    let app = create_app(app_state);

    // 启动服务器
    let addr = SocketAddr::from(([0, 0, 0, 0], config.server.port));
    info!("🎯 Server listening on {}", addr);
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}

fn create_app(state: Arc<AppState>) -> Router {
    Router::new()
        .route("/ws", get(websocket_handler))
        .route("/health", get(health_handler))
        .route("/ready", get(readiness_handler))
        .route("/metrics", get(metrics_handler))
        .route("/clients", get(clients_handler))
        .route("/config", get(config_handler))
        .route("/config/reload", post(reload_config_handler))
        .with_state(state)
        .layer(CorsLayer::permissive())
        .layer(TraceLayer::new_for_http())
}

async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<Arc<AppState>>,
) -> Response {
    let client_id = Uuid::new_v4();
    info!("🔗 New WebSocket connection attempt: {}", client_id);
    
    ws.on_upgrade(move |socket| server::handle_websocket(socket, state, client_id))
}

async fn health_handler(State(state): State<Arc<AppState>>) -> Json<HealthStatus> {
    Json(state.health.read().await.clone())
}

async fn readiness_handler(State(state): State<Arc<AppState>>) -> Json<ReadinessStatus> {
    Json(state.readiness.read().await.clone())
}

async fn metrics_handler(State(state): State<Arc<AppState>>) -> Json<serde_json::Value> {
    let clients = state.clients.read().await;
    let metrics = serde_json::json!({
        "connected_clients": clients.len(),
        "total_connections": state.metrics.total_connections.load(std::sync::atomic::Ordering::Relaxed),
        "messages_sent": state.metrics.messages_sent.load(std::sync::atomic::Ordering::Relaxed),
        "messages_received": state.metrics.messages_received.load(std::sync::atomic::Ordering::Relaxed),
        "uptime_seconds": state.metrics.start_time.elapsed().as_secs(),
    });
    Json(metrics)
}

async fn clients_handler(State(state): State<Arc<AppState>>) -> Json<Vec<ClientInfo>> {
    let clients = state.clients.read().await;
    let client_list: Vec<ClientInfo> = clients.values().cloned().collect();
    Json(client_list)
}

async fn config_handler(State(state): State<Arc<AppState>>) -> Json<config::AppConfig> {
    Json(state.config_manager.get_config().await)
}

async fn reload_config_handler(State(state): State<Arc<AppState>>) -> Json<serde_json::Value> {
    match state.config_manager.reload_config().await {
        Ok(_) => Json(serde_json::json!({"status": "success", "message": "配置重载成功"})),
        Err(e) => Json(serde_json::json!({"status": "error", "message": format!("配置重载失败: {}", e)})),
    }
}</code></pre>

        <h4>步骤 2: Minikube 设置脚本</h4>
        <p><strong>scripts/setup-minikube.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "🚀 Setting up Minikube for WebSocket Server Testing"

# 检查 Minikube 是否已安装
if ! command -v minikube &> /dev/null; then
    echo "❌ Minikube not found. Please install Minikube first."
    echo "📋 Installation guide: https://minikube.sigs.k8s.io/docs/start/"
    exit 1
fi

# 检查 kubectl 是否已安装
if ! command -v kubectl &> /dev/null; then
    echo "❌ kubectl not found. Please install kubectl first."
    exit 1
fi

echo "✅ Prerequisites check passed"

# 启动 Minikube
echo "🔄 Starting Minikube cluster..."
minikube start \
    --driver=docker \
    --cpus=2 \
    --memory=4096 \
    --disk-size=20g \
    --kubernetes-version=v1.28.0 \
    --addons=ingress,metrics-server,dashboard

echo "⏳ Waiting for cluster to be ready..."
kubectl wait --for=condition=ready nodes --all --timeout=300s

# 启用必要的插件
echo "🔧 Enabling Minikube addons..."
minikube addons enable ingress
minikube addons enable metrics-server
minikube addons enable dashboard

# 配置 Docker 环境
echo "🐳 Configuring Docker environment..."
eval $(minikube docker-env)

# 构建 Docker 镜像
echo "🏗️ Building WebSocket server image..."
docker build -t websocket-server:local .

# 验证集群状态
echo "📊 Cluster status:"
kubectl cluster-info
echo ""
kubectl get nodes
echo ""
kubectl get pods -A

echo "✅ Minikube setup completed successfully!"
echo "🌐 Dashboard URL: $(minikube dashboard --url)"
echo "📝 Use 'kubectl get pods -A' to check all pods"
echo "🔗 Use 'minikube service --all' to see all services"</code></pre>

        <h4>步骤 3: Kubernetes 部署配置</h4>
        <p><strong>k8s/namespace.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: Namespace
metadata:
  name: websocket-app
  labels:
    name: websocket-app
    environment: local
    managed-by: minikube</code></pre>

        <p><strong>k8s/configmap.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: websocket-config
  namespace: websocket-app
data:
  config.yaml: |
    server:
      port: 3000
      host: "0.0.0.0"
      max_connections: 1000
      heartbeat_interval: 30
      read_timeout: 60
      write_timeout: 60
    
    websocket:
      max_frame_size: 65536
      max_message_size: 1048576
      compression: true
      ping_interval: 30
      pong_timeout: 10
    
    logging:
      level: "info"
      format: "json"
      output: "stdout"
    
    metrics:
      enabled: true
      port: 9090
      path: "/metrics"</code></pre>

        <p><strong>k8s/deployment.yaml:</strong></p>
        <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: websocket-server
  namespace: websocket-app
  labels:
    app: websocket-server
    version: v1
spec:
  replicas: 2
  selector:
    matchLabels:
      app: websocket-server
  template:
    metadata:
      labels:
        app: websocket-server
        version: v1
    spec:
      containers:
      - name: websocket-server
        image: websocket-server:local
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
          name: websocket
        - containerPort: 9090
          name: metrics
        env:
        - name: RUST_LOG
          value: "info"
        - name: CONFIG_PATH
          value: "/app/config/config.yaml"
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
          failureThreshold: 3
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: config-volume
        configMap:
          name: websocket-config</code></pre>

        <p><strong>k8s/service.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: Service
metadata:
  name: websocket-service
  namespace: websocket-app
  labels:
    app: websocket-server
spec:
  type: NodePort
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30000
    name: websocket
  - port: 9090
    targetPort: 9090
    nodePort: 30090
    name: metrics
  selector:
    app: websocket-server</code></pre>

        <h4>步骤 4: 部署和测试脚本</h4>
        <p><strong>scripts/deploy.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "🚀 Deploying WebSocket Server to Minikube"

# 确保使用 Minikube 的 Docker 环境
eval $(minikube docker-env)

# 构建最新的镜像
echo "🏗️ Building Docker image..."
docker build -t websocket-server:local . --no-cache

# 应用 Kubernetes 配置
echo "📦 Applying Kubernetes manifests..."
kubectl apply -f k8s/namespace.yaml
kubectl apply -f k8s/configmap.yaml
kubectl apply -f k8s/deployment.yaml
kubectl apply -f k8s/service.yaml

# 等待部署完成
echo "⏳ Waiting for deployment to be ready..."
kubectl rollout status deployment/websocket-server -n websocket-app --timeout=300s

# 等待 Pod 准备就绪
echo "⏳ Waiting for pods to be ready..."
kubectl wait --for=condition=ready pod -l app=websocket-server -n websocket-app --timeout=300s

# 显示部署状态
echo "📊 Deployment status:"
kubectl get pods -n websocket-app -o wide
echo ""
kubectl get services -n websocket-app
echo ""

# 获取服务访问信息
MINIKUBE_IP=$(minikube ip)
SERVICE_PORT=$(kubectl get service websocket-service -n websocket-app -o jsonpath='{.spec.ports[0].nodePort}')
METRICS_PORT=$(kubectl get service websocket-service -n websocket-app -o jsonpath='{.spec.ports[1].nodePort}')

echo "✅ Deployment completed successfully!"
echo ""
echo "🌐 Service Access Information:"
echo "   WebSocket URL: ws://$MINIKUBE_IP:$SERVICE_PORT/ws"
echo "   Health Check: http://$MINIKUBE_IP:$SERVICE_PORT/health"
echo "   Metrics: http://$MINIKUBE_IP:$METRICS_PORT/metrics"
echo ""
echo "📝 Useful commands:"
echo "   kubectl logs -f deployment/websocket-server -n websocket-app"
echo "   kubectl exec -it deployment/websocket-server -n websocket-app -- /bin/bash"
echo "   minikube service websocket-service -n websocket-app"</code></pre>

        <p><strong>scripts/test-service.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "🧪 Testing WebSocket Service in Minikube"

# 获取服务信息
MINIKUBE_IP=$(minikube ip)
SERVICE_PORT=$(kubectl get service websocket-service -n websocket-app -o jsonpath='{.spec.ports[0].nodePort}')
METRICS_PORT=$(kubectl get service websocket-service -n websocket-app -o jsonpath='{.spec.ports[1].nodePort}')

BASE_URL="http://$MINIKUBE_IP:$SERVICE_PORT"
METRICS_URL="http://$MINIKUBE_IP:$METRICS_PORT"

echo "🔍 Testing endpoints..."
echo "Base URL: $BASE_URL"

# 测试健康检查
echo "🏥 Testing health endpoint..."
if curl -s "$BASE_URL/health" | jq .; then
    echo "✅ Health check passed"
else
    echo "❌ Health check failed"
    exit 1
fi

# 测试就绪性检查
echo "🚦 Testing readiness endpoint..."
if curl -s "$BASE_URL/ready" | jq .; then
    echo "✅ Readiness check passed"
else
    echo "❌ Readiness check failed"
    exit 1
fi

# 测试指标端点
echo "📊 Testing metrics endpoint..."
if curl -s "$BASE_URL/metrics" | jq .; then
    echo "✅ Metrics endpoint accessible"
else
    echo "❌ Metrics endpoint failed"
fi

# 测试客户端列表
echo "👥 Testing clients endpoint..."
if curl -s "$BASE_URL/clients" | jq .; then
    echo "✅ Clients endpoint accessible"
else
    echo "❌ Clients endpoint failed"
fi

# WebSocket 连接测试
echo "🔌 Testing WebSocket connection..."
timeout 10s websocat "ws://$MINIKUBE_IP:$SERVICE_PORT/ws" <<< "Hello from test!" | head -5 || {
    echo "⚠️ WebSocket test requires 'websocat' tool"
    echo "Install with: cargo install websocat"
}

# 负载测试
echo "⚡ Running simple load test..."
echo "Sending 10 concurrent requests..."
for i in {1..10}; do
    curl -s "$BASE_URL/health" > /dev/null &
done
wait

echo "✅ All tests completed!"
echo ""
echo "🌐 Service URLs:"
echo "   WebSocket: ws://$MINIKUBE_IP:$SERVICE_PORT/ws"
echo "   Dashboard: http://$MINIKUBE_IP:$SERVICE_PORT"
echo "   Health: $BASE_URL/health"
echo "   Metrics: $BASE_URL/metrics"</code></pre>

        <h4>步骤 5: 监控和调试脚本</h4>
        <p><strong>scripts/monitoring.sh:</strong></p>
        <pre><code>#!/bin/bash

echo "📊 WebSocket Server Monitoring Dashboard"
echo "======================================="

# 获取服务信息
MINIKUBE_IP=$(minikube ip)
SERVICE_PORT=$(kubectl get service websocket-service -n websocket-app -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "N/A")

if [ "$SERVICE_PORT" = "N/A" ]; then
    echo "❌ Service not found. Please deploy first."
    exit 1
fi

BASE_URL="http://$MINIKUBE_IP:$SERVICE_PORT"

# 显示基本信息
echo "🌐 Service Information:"
echo "   Minikube IP: $MINIKUBE_IP"
echo "   Service Port: $SERVICE_PORT"
echo "   Base URL: $BASE_URL"
echo ""

# 监控循环
while true; do
    clear
    echo "📊 WebSocket Server Real-time Monitoring"
    echo "======================================="
    echo "⏰ Time: $(date)"
    echo ""
    
    # Pod 状态
    echo "🏠 Pod Status:"
    kubectl get pods -n websocket-app -o wide
    echo ""
    
    # 服务状态
    echo "🌐 Service Status:"
    kubectl get services -n websocket-app
    echo ""
    
    # 健康状态
    echo "🏥 Health Status:"
    if HEALTH=$(curl -s "$BASE_URL/health" 2>/dev/null); then
        echo "$HEALTH" | jq .
    else
        echo "❌ Health check failed"
    fi
    echo ""
    
    # 指标信息
    echo "📈 Metrics:"
    if METRICS=$(curl -s "$BASE_URL/metrics" 2>/dev/null); then
        echo "$METRICS" | jq .
    else
        echo "❌ Metrics unavailable"
    fi
    echo ""
    
    # 连接的客户端
    echo "👥 Connected Clients:"
    if CLIENTS=$(curl -s "$BASE_URL/clients" 2>/dev/null); then
        echo "$CLIENTS" | jq .
    else
        echo "❌ Client information unavailable"
    fi
    echo ""
    
    # 资源使用情况
    echo "💻 Resource Usage:"
    kubectl top pods -n websocket-app 2>/dev/null || echo "❌ Metrics server not available"
    echo ""
    
    echo "Press Ctrl+C to exit monitoring..."
    sleep 5
done</code></pre>

        <h4>步骤 6: 测试客户端</h4>
        <p><strong>web/test-client.html:</strong></p>
        <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;WebSocket Minikube Test Client&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .status {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
        }
        .status-item {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            min-width: 120px;
        }
        .connected { background-color: #d4edda; color: #155724; }
        .disconnected { background-color: #f8d7da; color: #721c24; }
        .pending { background-color: #fff3cd; color: #856404; }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .connect-btn { background-color: #28a745; color: white; }
        .disconnect-btn { background-color: #dc3545; color: white; }
        .test-btn { background-color: #007bff; color: white; }
        .clear-btn { background-color: #6c757d; color: white; }
        button:hover { opacity: 0.8; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .message-area {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .input-section, .log-section {
            flex: 1;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
        }
        .log {
            height: 400px;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .metrics {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .metric-item {
            background: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;🚀 WebSocket Minikube Test Client&lt;/h1&gt;
            &lt;p&gt;测试部署在 Minikube 中的 WebSocket 服务&lt;/p&gt;
        &lt;/div&gt;

        &lt;div class="status"&gt;
            &lt;div id="connectionStatus" class="status-item disconnected"&gt;
                &lt;strong&gt;连接状态&lt;/strong&gt;&lt;br&gt;
                &lt;span id="statusText"&gt;未连接&lt;/span&gt;
            &lt;/div&gt;
            &lt;div id="messageCount" class="status-item pending"&gt;
                &lt;strong&gt;消息计数&lt;/strong&gt;&lt;br&gt;
                &lt;span id="countText"&gt;发送: 0 | 接收: 0&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div&gt;
            &lt;label for="serverUrl"&gt;WebSocket 服务器 URL:&lt;/label&gt;
            &lt;input type="text" id="serverUrl" 
                   value="ws://192.168.49.2:30000/ws" 
                   placeholder="ws://minikube-ip:port/ws"&gt;
        &lt;/div&gt;

        &lt;div class="controls"&gt;
            &lt;button id="connectBtn" class="connect-btn"&gt;🔌 连接&lt;/button&gt;
            &lt;button id="disconnectBtn" class="disconnect-btn" disabled&gt;🔌 断开&lt;/button&gt;
            &lt;button id="pingBtn" class="test-btn" disabled&gt;📡 发送 Ping&lt;/button&gt;
            &lt;button id="testBtn" class="test-btn" disabled&gt;🧪 压力测试&lt;/button&gt;
            &lt;button id="clearBtn" class="clear-btn"&gt;🗑️ 清空日志&lt;/button&gt;
            &lt;button id="metricsBtn" class="test-btn"&gt;📊 获取指标&lt;/button&gt;
        &lt;/div&gt;

        &lt;div class="message-area"&gt;
            &lt;div class="input-section"&gt;
                &lt;h3&gt;💬 发送消息&lt;/h3&gt;
                &lt;input type="text" id="messageInput" 
                       placeholder="输入要发送的消息..." 
                       disabled&gt;
                &lt;button id="sendBtn" class="test-btn" disabled&gt;📤 发送&lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="log-section"&gt;
                &lt;h3&gt;📋 连接日志&lt;/h3&gt;
                &lt;div id="log" class="log"&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="metrics"&gt;
            &lt;h3&gt;📊 服务器指标&lt;/h3&gt;
            &lt;div id="metricsGrid" class="metric-grid"&gt;
                &lt;div class="metric-item"&gt;
                    &lt;strong&gt;连接的客户端&lt;/strong&gt;&lt;br&gt;
                    &lt;span id="connectedClients"&gt;-&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="metric-item"&gt;
                    &lt;strong&gt;总连接数&lt;/strong&gt;&lt;br&gt;
                    &lt;span id="totalConnections"&gt;-&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="metric-item"&gt;
                    &lt;strong&gt;已发送消息&lt;/strong&gt;&lt;br&gt;
                    &lt;span id="messagesSent"&gt;-&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="metric-item"&gt;
                    &lt;strong&gt;已接收消息&lt;/strong&gt;&lt;br&gt;
                    &lt;span id="messagesReceived"&gt;-&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="metric-item"&gt;
                    &lt;strong&gt;运行时间&lt;/strong&gt;&lt;br&gt;
                    &lt;span id="uptime"&gt;-&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        class WebSocketTestClient {
            constructor() {
                this.ws = null;
                this.sentCount = 0;
                this.receivedCount = 0;
                this.initializeElements();
                this.bindEvents();
                this.updateMinikubeUrl();
            }

            initializeElements() {
                this.elements = {
                    serverUrl: document.getElementById('serverUrl'),
                    connectBtn: document.getElementById('connectBtn'),
                    disconnectBtn: document.getElementById('disconnectBtn'),
                    pingBtn: document.getElementById('pingBtn'),
                    testBtn: document.getElementById('testBtn'),
                    clearBtn: document.getElementById('clearBtn'),
                    metricsBtn: document.getElementById('metricsBtn'),
                    messageInput: document.getElementById('messageInput'),
                    sendBtn: document.getElementById('sendBtn'),
                    log: document.getElementById('log'),
                    statusText: document.getElementById('statusText'),
                    countText: document.getElementById('countText'),
                    connectionStatus: document.getElementById('connectionStatus')
                };
            }

            bindEvents() {
                this.elements.connectBtn.onclick = () => this.connect();
                this.elements.disconnectBtn.onclick = () => this.disconnect();
                this.elements.pingBtn.onclick = () => this.sendPing();
                this.elements.testBtn.onclick = () => this.runStressTest();
                this.elements.clearBtn.onclick = () => this.clearLog();
                this.elements.metricsBtn.onclick = () => this.fetchMetrics();
                this.elements.sendBtn.onclick = () => this.sendMessage();
                
                this.elements.messageInput.onkeypress = (e) => {
                    if (e.key === 'Enter') this.sendMessage();
                };
            }

            async updateMinikubeUrl() {
                try {
                    // 尝试自动获取 Minikube IP
                    const response = await fetch('/api/minikube-info');
                    if (response.ok) {
                        const info = await response.json();
                        this.elements.serverUrl.value = `ws://${info.ip}:${info.port}/ws`;
                    }
                } catch (e) {
                    this.log('⚠️ 无法自动获取 Minikube 信息，请手动输入 URL');
                }
            }

            connect() {
                const url = this.elements.serverUrl.value.trim();
                if (!url) {
                    this.log('❌ 请输入 WebSocket URL');
                    return;
                }

                this.log(`🔌 正在连接到: ${url}`);
                this.updateConnectionStatus('connecting', '连接中...');

                try {
                    this.ws = new WebSocket(url);
                    
                    this.ws.onopen = () => {
                        this.log('✅ WebSocket 连接成功!');
                        this.updateConnectionStatus('connected', '已连接');
                        this.setControlsState(true);
                    };

                    this.ws.onmessage = (event) => {
                        this.receivedCount++;
                        this.updateCounters();
                        this.log(`📥 收到消息: ${event.data}`);
                    };

                    this.ws.onclose = (event) => {
                        this.log(`🔌 连接关闭: ${event.code} - ${event.reason}`);
                        this.updateConnectionStatus('disconnected', '未连接');
                        this.setControlsState(false);
                    };

                    this.ws.onerror = (error) => {
                        this.log(`❌ 连接错误: ${error}`);
                        this.updateConnectionStatus('disconnected', '连接失败');
                        this.setControlsState(false);
                    };

                } catch (error) {
                    this.log(`❌ 创建连接失败: ${error.message}`);
                    this.updateConnectionStatus('disconnected', '连接失败');
                }
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                    this.log('🔌 主动断开连接');
                }
            }

            sendMessage() {
                const message = this.elements.messageInput.value.trim();
                if (!message) return;

                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(message);
                    this.sentCount++;
                    this.updateCounters();
                    this.log(`📤 发送消息: ${message}`);
                    this.elements.messageInput.value = '';
                } else {
                    this.log('❌ 连接未建立，无法发送消息');
                }
            }

            sendPing() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const pingMsg = `ping-${Date.now()}`;
                    this.ws.send(pingMsg);
                    this.sentCount++;
                    this.updateCounters();
                    this.log(`📡 发送 Ping: ${pingMsg}`);
                } else {
                    this.log('❌ 连接未建立，无法发送 Ping');
                }
            }

            async runStressTest() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    this.log('❌ 连接未建立，无法进行压力测试');
                    return;
                }

                this.log('⚡ 开始压力测试...');
                const startTime = Date.now();
                const messageCount = 100;

                for (let i = 0; i < messageCount; i++) {
                    const message = `stress-test-${i}-${Date.now()}`;
                    this.ws.send(message);
                    this.sentCount++;
                    
                    // 每 10 条消息等待一小段时间
                    if (i % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }

                const duration = Date.now() - startTime;
                this.updateCounters();
                this.log(`⚡ 压力测试完成: 发送 ${messageCount} 条消息，耗时 ${duration}ms`);
            }

            async fetchMetrics() {
                try {
                    const baseUrl = this.elements.serverUrl.value.replace('ws://', 'http://').replace('/ws', '');
                    const response = await fetch(`${baseUrl}/metrics`);
                    
                    if (response.ok) {
                        const metrics = await response.json();
                        this.updateMetricsDisplay(metrics);
                        this.log('📊 指标更新成功');
                    } else {
                        this.log(`❌ 获取指标失败: ${response.status}`);
                    }
                } catch (error) {
                    this.log(`❌ 获取指标错误: ${error.message}`);
                }
            }

            updateMetricsDisplay(metrics) {
                document.getElementById('connectedClients').textContent = metrics.connected_clients || '-';
                document.getElementById('totalConnections').textContent = metrics.total_connections || '-';
                document.getElementById('messagesSent').textContent = metrics.messages_sent || '-';
                document.getElementById('messagesReceived').textContent = metrics.messages_received || '-';
                document.getElementById('uptime').textContent = metrics.uptime_seconds ? 
                    `${Math.floor(metrics.uptime_seconds / 60)}分${metrics.uptime_seconds % 60}秒` : '-';
            }

            updateConnectionStatus(status, text) {
                this.elements.connectionStatus.className = `status-item ${status}`;
                this.elements.statusText.textContent = text;
            }

            updateCounters() {
                this.elements.countText.textContent = `发送: ${this.sentCount} | 接收: ${this.receivedCount}`;
            }

            setControlsState(connected) {
                this.elements.connectBtn.disabled = connected;
                this.elements.disconnectBtn.disabled = !connected;
                this.elements.pingBtn.disabled = !connected;
                this.elements.testBtn.disabled = !connected;
                this.elements.messageInput.disabled = !connected;
                this.elements.sendBtn.disabled = !connected;
            }

            clearLog() {
                this.elements.log.textContent = '';
                this.sentCount = 0;
                this.receivedCount = 0;
                this.updateCounters();
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.elements.log.textContent += `[${timestamp}] ${message}\n`;
                this.elements.log.scrollTop = this.elements.log.scrollHeight;
            }
        }

        // 初始化客户端
        const client = new WebSocketTestClient();
        
        // 定期获取指标
        setInterval(() => {
            if (document.visibilityState === 'visible') {
                client.fetchMetrics();
            }
        }, 10000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

        <h3>🎯 使用步骤</h3>
        <ol>
            <li><strong>安装 Minikube:</strong></li>
            <pre><code># macOS
brew install minikube

# Ubuntu/Debian
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube</code></pre>

            <li><strong>设置和启动 Minikube:</strong></li>
            <pre><code>chmod +x scripts/*.sh
./scripts/setup-minikube.sh</code></pre>

            <li><strong>部署 WebSocket 服务:</strong></li>
            <pre><code>./scripts/deploy.sh</code></pre>

            <li><strong>测试服务:</strong></li>
            <pre><code>./scripts/test-service.sh</code></pre>

            <li><strong>监控服务:</strong></li>
            <pre><code>./scripts/monitoring.sh</code></pre>

            <li><strong>使用 Web 客户端测试:</strong></li>
            <pre><code># 在浏览器中打开
open web/test-client.html

# 或者启动本地服务器
python3 -m http.server 8080
# 然后访问 http://localhost:8080/web/test-client.html</code></pre>
        </ol>

        <h3>🔍 常用调试命令</h3>
        <pre><code># 查看 Pod 状态
kubectl get pods -n websocket-app -o wide

# 查看 Pod 日志
kubectl logs -f deployment/websocket-server -n websocket-app

# 进入 Pod 内部
kubectl exec -it deployment/websocket-server -n websocket-app -- /bin/bash

# 查看服务信息
kubectl describe service websocket-service -n websocket-app

# 端口转发到本地
kubectl port-forward service/websocket-service 8080:3000 -n websocket-app

# 使用 Minikube 服务
minikube service websocket-service -n websocket-app

# 查看 Minikube 仪表板
minikube dashboard</code></pre>

        <h3>🌟 高级功能</h3>
        <ul>
            <li><strong>多种访问方式:</strong> NodePort、port-forward、minikube service</li>
            <li><strong>健康检查:</strong> 自动健康和就绪性检查</li>
            <li><strong>指标监控:</strong> 内置指标端点和实时监控</li>
            <li><strong>配置管理:</strong> ConfigMap 热重载</li>
            <li><strong>资源限制:</strong> CPU 和内存资源管理</li>
            <li><strong>负载测试:</strong> 内置压力测试功能</li>
            <li><strong>实时监控:</strong> 自动刷新的监控仪表板</li>
        </ul>

        <h3>🎓 学习要点</h3>
        <ul>
            <li>理解 Minikube 作为本地 Kubernetes 开发环境的价值</li>
            <li>掌握 Kubernetes 服务暴露的多种方式</li>
            <li>学会使用 kubectl 进行应用管理和调试</li>
            <li>实践容器化应用的健康检查和监控</li>
            <li>体验 Kubernetes 的自动恢复和扩展能力</li>
        </ul>

        <p>🔗 <a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank">阅读对应官方文档</a></p>
    
        <p class="date"><strong>🗓️ 2025-08-25</strong></p>
        <h2>Day 25 - Helm Chart 初识（可选）</h2>
        <p>今天你将学习 Helm Chart 的创建和使用，将之前的 Kubernetes 配置转换为可重用的模板。Helm 是 Kubernetes 的包管理器，能够简化应用的部署、升级和管理过程。</p>
        
        <h3>🎯 学习目标</h3>
        <ul>
            <li>理解 Helm Chart 的概念和价值</li>
            <li>创建 WebSocket 服务的 Helm Chart</li>
            <li>学习模板语法和值文件的使用</li>
            <li>实现多环境部署配置</li>
            <li>掌握 Helm Chart 的版本管理和发布</li>
        </ul>

        <h3>📁 项目结构</h3>
        <pre>day25_helm_chart/
├── websocket-chart/
│   ├── Chart.yaml
│   ├── values.yaml
│   ├── values-dev.yaml
│   ├── values-staging.yaml
│   ├── values-prod.yaml
│   ├── templates/
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   │   ├── configmap.yaml
│   │   ├── secret.yaml
│   │   ├── ingress.yaml
│   │   ├── hpa.yaml
│   │   ├── serviceaccount.yaml
│   │   ├── rbac.yaml
│   │   ├── networkpolicy.yaml
│   │   ├── tests/
│   │   │   └── test-connection.yaml
│   │   └── NOTES.txt
│   └── charts/
├── scripts/
│   ├── install-helm.sh
│   ├── create-chart.sh
│   ├── deploy-dev.sh
│   ├── deploy-staging.sh
│   ├── deploy-prod.sh
│   ├── upgrade.sh
│   ├── rollback.sh
│   └── package.sh
├── environments/
│   ├── dev.yaml
│   ├── staging.yaml
│   └── production.yaml
├── src/
│   ├── main.rs
│   ├── server.rs
│   ├── config.rs
│   └── health.rs
├── Dockerfile
├── Cargo.toml
└── README.md</pre>

        <h3>🚀 实现步骤</h3>

        <h4>步骤 1: 安装和配置 Helm</h4>
        <p><strong>scripts/install-helm.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "🚀 Installing and Configuring Helm"

# 检查操作系统
OS=$(uname -s | tr '[:upper:]' '[:lower:]')
ARCH=$(uname -m)

case $ARCH in
    x86_64) ARCH="amd64" ;;
    aarch64) ARCH="arm64" ;;
    armv7l) ARCH="arm" ;;
esac

# 检查 Helm 是否已安装
if command -v helm &> /dev/null; then
    echo "✅ Helm is already installed: $(helm version --short)"
else
    echo "📦 Installing Helm..."
    
    # 下载并安装 Helm
    HELM_VERSION="v3.13.3"
    HELM_TAR="helm-${HELM_VERSION}-${OS}-${ARCH}.tar.gz"
    HELM_URL="https://get.helm.sh/${HELM_TAR}"
    
    echo "📥 Downloading Helm ${HELM_VERSION}..."
    curl -fsSL "${HELM_URL}" -o "/tmp/${HELM_TAR}"
    
    echo "📂 Extracting Helm..."
    tar -zxf "/tmp/${HELM_TAR}" -C /tmp
    
    echo "🔧 Installing Helm to /usr/local/bin..."
    sudo mv "/tmp/${OS}-${ARCH}/helm" /usr/local/bin/helm
    sudo chmod +x /usr/local/bin/helm
    
    echo "🗑️ Cleaning up..."
    rm -rf "/tmp/${HELM_TAR}" "/tmp/${OS}-${ARCH}"
    
    echo "✅ Helm installed successfully: $(helm version --short)"
fi

# 验证 Kubernetes 连接
echo "🔍 Verifying Kubernetes connection..."
if ! kubectl cluster-info &> /dev/null; then
    echo "❌ Kubernetes cluster not accessible. Please check your kubeconfig."
    exit 1
fi

echo "✅ Kubernetes cluster is accessible"

# 添加常用的 Helm 仓库
echo "📚 Adding popular Helm repositories..."
helm repo add stable https://charts.helm.sh/stable 2>/dev/null || true
helm repo add bitnami https://charts.bitnami.com/bitnami 2>/dev/null || true
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts 2>/dev/null || true
helm repo add grafana https://grafana.github.io/helm-charts 2>/dev/null || true

echo "🔄 Updating Helm repositories..."
helm repo update

echo "📋 Available repositories:"
helm repo list

echo "✅ Helm setup completed successfully!"</code></pre>

        <h4>步骤 2: 创建 Helm Chart</h4>
        <p><strong>websocket-chart/Chart.yaml:</strong></p>
        <pre><code>apiVersion: v2
name: websocket-server
description: A production-ready WebSocket server built with Rust and Axum
type: application
version: 1.0.0
appVersion: "1.0.0"

home: https://github.com/your-username/websocket-server
sources:
  - https://github.com/your-username/websocket-server

maintainers:
  - name: Your Name
    email: your.email@example.com
    url: https://github.com/your-username

keywords:
  - websocket
  - rust
  - axum
  - real-time
  - server

annotations:
  category: Infrastructure
  licenses: MIT</code></pre>

        <p><strong>websocket-chart/values.yaml:</strong></p>
        <pre><code># Default values for websocket-server
# This is a YAML-formatted file.

replicaCount: 2

image:
  repository: websocket-server
  pullPolicy: IfNotPresent
  tag: "latest"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

podAnnotations: {}

podSecurityContext:
  fsGroup: 2000

securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000

service:
  type: ClusterIP
  port: 3000
  targetPort: 3000
  nodePort: 30000
  metricsPort: 9090

ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: websocket-server.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}

# WebSocket server configuration
config:
  server:
    port: 3000
    host: "0.0.0.0"
    maxConnections: 1000
    heartbeatInterval: 30
    readTimeout: 60
    writeTimeout: 60
  
  websocket:
    maxFrameSize: 65536
    maxMessageSize: 1048576
    compression: true
    pingInterval: 30
    pongTimeout: 10
  
  logging:
    level: "info"
    format: "json"
    output: "stdout"
  
  metrics:
    enabled: true
    port: 9090
    path: "/metrics"

# Health check configuration
healthCheck:
  enabled: true
  livenessProbe:
    httpGet:
      path: /health
      port: 3000
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  
  readinessProbe:
    httpGet:
      path: /ready
      port: 3000
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3

# Network policy
networkPolicy:
  enabled: false
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from: []
      ports:
        - protocol: TCP
          port: 3000
  egress:
    - {}

# RBAC configuration
rbac:
  create: true
  rules:
    - apiGroups: [""]
      resources: ["configmaps"]
      verbs: ["get", "list", "watch"]

# Environment-specific settings
environment: "development"

# External secrets (if using external secret management)
externalSecrets:
  enabled: false
  secretStore: ""
  secrets: []</code></pre>

        <h4>步骤 3: 创建模板文件</h4>
        <p><strong>websocket-chart/templates/deployment.yaml:</strong></p>
        <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "websocket-server.fullname" . }}
  labels:
    {{- include "websocket-server.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "websocket-server.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
        {{- with .Values.podAnnotations }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
      labels:
        {{- include "websocket-server.selectorLabels" . | nindent 8 }}
    spec:
      {{- with .Values.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      serviceAccountName: {{ include "websocket-server.serviceAccountName" . }}
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}
      containers:
        - name: {{ .Chart.Name }}
          securityContext:
            {{- toYaml .Values.securityContext | nindent 12 }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: websocket
              containerPort: {{ .Values.service.targetPort }}
              protocol: TCP
            - name: metrics
              containerPort: {{ .Values.service.metricsPort }}
              protocol: TCP
          env:
            - name: RUST_LOG
              value: {{ .Values.config.logging.level | quote }}
            - name: CONFIG_PATH
              value: "/app/config/config.yaml"
            - name: ENVIRONMENT
              value: {{ .Values.environment | quote }}
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          volumeMounts:
            - name: config-volume
              mountPath: /app/config
              readOnly: true
            - name: tmp
              mountPath: /tmp
          {{- if .Values.healthCheck.enabled }}
          livenessProbe:
            {{- toYaml .Values.healthCheck.livenessProbe | nindent 12 }}
          readinessProbe:
            {{- toYaml .Values.healthCheck.readinessProbe | nindent 12 }}
          {{- end }}
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      volumes:
        - name: config-volume
          configMap:
            name: {{ include "websocket-server.fullname" . }}-config
        - name: tmp
          emptyDir: {}
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}</code></pre>

        <p><strong>websocket-chart/templates/service.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: Service
metadata:
  name: {{ include "websocket-server.fullname" . }}
  labels:
    {{- include "websocket-server.labels" . | nindent 4 }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: websocket
      protocol: TCP
      name: websocket
      {{- if and (eq .Values.service.type "NodePort") .Values.service.nodePort }}
      nodePort: {{ .Values.service.nodePort }}
      {{- end }}
    - port: {{ .Values.service.metricsPort }}
      targetPort: metrics
      protocol: TCP
      name: metrics
  selector:
    {{- include "websocket-server.selectorLabels" . | nindent 4 }}</code></pre>

        <p><strong>websocket-chart/templates/configmap.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "websocket-server.fullname" . }}-config
  labels:
    {{- include "websocket-server.labels" . | nindent 4 }}
data:
  config.yaml: |
    server:
      port: {{ .Values.config.server.port }}
      host: {{ .Values.config.server.host | quote }}
      max_connections: {{ .Values.config.server.maxConnections }}
      heartbeat_interval: {{ .Values.config.server.heartbeatInterval }}
      read_timeout: {{ .Values.config.server.readTimeout }}
      write_timeout: {{ .Values.config.server.writeTimeout }}
    
    websocket:
      max_frame_size: {{ .Values.config.websocket.maxFrameSize }}
      max_message_size: {{ .Values.config.websocket.maxMessageSize }}
      compression: {{ .Values.config.websocket.compression }}
      ping_interval: {{ .Values.config.websocket.pingInterval }}
      pong_timeout: {{ .Values.config.websocket.pongTimeout }}
    
    logging:
      level: {{ .Values.config.logging.level | quote }}
      format: {{ .Values.config.logging.format | quote }}
      output: {{ .Values.config.logging.output | quote }}
    
    metrics:
      enabled: {{ .Values.config.metrics.enabled }}
      port: {{ .Values.config.metrics.port }}
      path: {{ .Values.config.metrics.path | quote }}
    
    environment: {{ .Values.environment | quote }}</code></pre>

        <p><strong>websocket-chart/templates/_helpers.tpl:</strong></p>
        <pre><code>{{/*
Expand the name of the chart.
*/}}
{{- define "websocket-server.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
*/}}
{{- define "websocket-server.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- if contains $name .Release.Name }}
{{- .Release.Name | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}
{{- end }}

{{/*
Create chart name and version as used by the chart label.
*/}}
{{- define "websocket-server.chart" -}}
{{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "websocket-server.labels" -}}
helm.sh/chart: {{ include "websocket-server.chart" . }}
{{ include "websocket-server.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
environment: {{ .Values.environment }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "websocket-server.selectorLabels" -}}
app.kubernetes.io/name: {{ include "websocket-server.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{/*
Create the name of the service account to use
*/}}
{{- define "websocket-server.serviceAccountName" -}}
{{- if .Values.serviceAccount.create }}
{{- default (include "websocket-server.fullname" .) .Values.serviceAccount.name }}
{{- else }}
{{- default "default" .Values.serviceAccount.name }}
{{- end }}
{{- end }}</code></pre>

        <h4>步骤 4: 环境特定的值文件</h4>
        <p><strong>websocket-chart/values-dev.yaml:</strong></p>
        <pre><code># Development environment values
environment: "development"

replicaCount: 1

image:
  tag: "dev"
  pullPolicy: Always

service:
  type: NodePort
  nodePort: 30000

ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/websocket-services: "websocket-server-dev"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
  hosts:
    - host: websocket-dev.local
      paths:
        - path: /
          pathType: Prefix

resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 50m
    memory: 64Mi

config:
  server:
    maxConnections: 100
  logging:
    level: "debug"

autoscaling:
  enabled: false

healthCheck:
  livenessProbe:
    initialDelaySeconds: 10
  readinessProbe:
    initialDelaySeconds: 5</code></pre>

        <p><strong>websocket-chart/values-staging.yaml:</strong></p>
        <pre><code># Staging environment values
environment: "staging"

replicaCount: 2

image:
  tag: "staging"
  pullPolicy: Always

service:
  type: ClusterIP

ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/websocket-services: "websocket-server-staging"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    cert-manager.io/cluster-issuer: "letsencrypt-staging"
  hosts:
    - host: websocket-staging.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: websocket-staging-tls
      hosts:
        - websocket-staging.example.com

resources:
  limits:
    cpu: 400m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

config:
  server:
    maxConnections: 500
  logging:
    level: "info"

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 5
  targetCPUUtilizationPercentage: 70

networkPolicy:
  enabled: true</code></pre>

        <p><strong>websocket-chart/values-prod.yaml:</strong></p>
        <pre><code># Production environment values
environment: "production"

replicaCount: 3

image:
  tag: "1.0.0"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP

ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/websocket-services: "websocket-server-prod"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: websocket.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: websocket-prod-tls
      hosts:
        - websocket.example.com

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 200m
    memory: 256Mi

config:
  server:
    maxConnections: 2000
  logging:
    level: "warn"
    format: "json"

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 20
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

networkPolicy:
  enabled: true

# Production-specific settings
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65534
  fsGroup: 65534

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 65534

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - websocket-server
        topologyKey: kubernetes.io/hostname</code></pre>

        <h4>步骤 5: 部署脚本</h4>
        <p><strong>scripts/deploy-dev.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "🚀 Deploying WebSocket Server to Development Environment"

CHART_NAME="websocket-server"
NAMESPACE="websocket-dev"
RELEASE_NAME="websocket-dev"

# 创建命名空间
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# 确保 Docker 镜像可用（用于 Minikube）
if command -v minikube &> /dev/null && minikube status &> /dev/null; then
    echo "🐳 Building image for Minikube..."
    eval $(minikube docker-env)
    docker build -t websocket-server:dev .
fi

# 部署 Helm Chart
echo "📦 Installing/Upgrading Helm release..."
helm upgrade --install $RELEASE_NAME ./websocket-chart \
    --namespace $NAMESPACE \
    --values ./websocket-chart/values-dev.yaml \
    --wait \
    --timeout=300s

# 显示部署状态
echo "📊 Deployment status:"
kubectl get pods -n $NAMESPACE
echo ""
kubectl get services -n $NAMESPACE
echo ""

# 等待 Pod 准备就绪
echo "⏳ Waiting for pods to be ready..."
kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=websocket-server -n $NAMESPACE --timeout=300s

# 显示访问信息
echo "✅ Development deployment completed!"
echo ""
echo "🌐 Access Information:"
if command -v minikube &> /dev/null && minikube status &> /dev/null; then
    MINIKUBE_IP=$(minikube ip)
    SERVICE_PORT=$(kubectl get service $RELEASE_NAME -n $NAMESPACE -o jsonpath='{.spec.ports[0].nodePort}')
    echo "   WebSocket URL: ws://$MINIKUBE_IP:$SERVICE_PORT/ws"
    echo "   Health Check: http://$MINIKUBE_IP:$SERVICE_PORT/health"
else
    echo "   Use: kubectl port-forward service/$RELEASE_NAME 8080:3000 -n $NAMESPACE"
    echo "   Then access: ws://localhost:8080/ws"
fi
echo ""
echo "📝 Useful commands:"
echo "   helm status $RELEASE_NAME -n $NAMESPACE"
echo "   kubectl logs -f deployment/$RELEASE_NAME -n $NAMESPACE"
echo "   helm uninstall $RELEASE_NAME -n $NAMESPACE"</code></pre>

        <p><strong>scripts/deploy-staging.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "🚀 Deploying WebSocket Server to Staging Environment"

CHART_NAME="websocket-server"
NAMESPACE="websocket-staging"
RELEASE_NAME="websocket-staging"

# 创建命名空间
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# 部署 Helm Chart
echo "📦 Installing/Upgrading Helm release..."
helm upgrade --install $RELEASE_NAME ./websocket-chart \
    --namespace $NAMESPACE \
    --values ./websocket-chart/values-staging.yaml \
    --wait \
    --timeout=300s

# 显示部署状态
echo "📊 Deployment status:"
kubectl get pods -n $NAMESPACE
echo ""
kubectl get services -n $NAMESPACE
echo ""
kubectl get ingress -n $NAMESPACE
echo ""

# 等待 Pod 准备就绪
echo "⏳ Waiting for pods to be ready..."
kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=websocket-server -n $NAMESPACE --timeout=300s

# 运行测试
echo "🧪 Running connection tests..."
helm test $RELEASE_NAME -n $NAMESPACE

echo "✅ Staging deployment completed!"
echo ""
echo "🌐 Access Information:"
echo "   WebSocket URL: wss://websocket-staging.example.com/ws"
echo "   Health Check: https://websocket-staging.example.com/health"
echo ""
echo "📝 Useful commands:"
echo "   helm status $RELEASE_NAME -n $NAMESPACE"
echo "   kubectl logs -f deployment/$RELEASE_NAME -n $NAMESPACE"
echo "   helm rollback $RELEASE_NAME -n $NAMESPACE"</code></pre>

        <h4>步骤 6: Helm Chart 测试</h4>
        <p><strong>websocket-chart/templates/tests/test-connection.yaml:</strong></p>
        <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: "{{ include "websocket-server.fullname" . }}-test-connection"
  labels:
    {{- include "websocket-server.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": test
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  restartPolicy: Never
  containers:
    - name: wget
      image: busybox:1.35
      command: ['wget']
      args: ['{{ include "websocket-server.fullname" . }}:{{ .Values.service.port }}/health']
    - name: websocket-test
      image: appropriate/curl:latest
      command: 
        - /bin/sh
        - -c
        - |
          echo "Testing health endpoint..."
          curl -f http://{{ include "websocket-server.fullname" . }}:{{ .Values.service.port }}/health
          
          echo "Testing readiness endpoint..."
          curl -f http://{{ include "websocket-server.fullname" . }}:{{ .Values.service.port }}/ready
          
          echo "Testing metrics endpoint..."
          curl -f http://{{ include "websocket-server.fullname" . }}:{{ .Values.service.port }}/metrics
          
          echo "All tests passed!"</code></pre>

        <p><strong>websocket-chart/templates/NOTES.txt:</strong></p>
        <pre><code>🎉 WebSocket Server has been deployed successfully!

Environment: {{ .Values.environment }}
Release: {{ .Release.Name }}
Namespace: {{ .Release.Namespace }}

🌐 Access Information:
{{- if .Values.ingress.enabled }}
{{- range $host := .Values.ingress.hosts }}
  {{- range .paths }}
  WebSocket URL: {{ if $.Values.ingress.tls }}wss{{ else }}ws{{ end }}://{{ $host.host }}{{ .path }}ws
  Health Check: {{ if $.Values.ingress.tls }}https{{ else }}http{{ end }}://{{ $host.host }}{{ .path }}health
  {{- end }}
{{- end }}
{{- else if contains "NodePort" .Values.service.type }}
  export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ include "websocket-server.fullname" . }})
  export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")
  WebSocket URL: ws://$NODE_IP:$NODE_PORT/ws
  Health Check: http://$NODE_IP:$NODE_PORT/health
{{- else if contains "LoadBalancer" .Values.service.type }}
  NOTE: It may take a few minutes for the LoadBalancer IP to be available.
        You can watch the status by running 'kubectl get --namespace {{ .Release.Namespace }} svc -w {{ include "websocket-server.fullname" . }}'
  export SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ include "websocket-server.fullname" . }} --template "{{"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}"}}")
  WebSocket URL: ws://$SERVICE_IP:{{ .Values.service.port }}/ws
  Health Check: http://$SERVICE_IP:{{ .Values.service.port }}/health
{{- else if contains "ClusterIP" .Values.service.type }}
  kubectl --namespace {{ .Release.Namespace }} port-forward svc/{{ include "websocket-server.fullname" . }} 8080:{{ .Values.service.port }}
  WebSocket URL: ws://127.0.0.1:8080/ws
  Health Check: http://127.0.0.1:8080/health
{{- end }}

📝 Useful Commands:
  Check status: helm status {{ .Release.Name }} -n {{ .Release.Namespace }}
  View logs: kubectl logs -f deployment/{{ include "websocket-server.fullname" . }} -n {{ .Release.Namespace }}
  Run tests: helm test {{ .Release.Name }} -n {{ .Release.Namespace }}
  
📊 Monitoring:
  Metrics: {{ if .Values.ingress.enabled }}{{ if .Values.ingress.tls }}https{{ else }}http{{ end }}://{{ (index .Values.ingress.hosts 0).host }}/metrics{{ else }}kubectl port-forward svc/{{ include "websocket-server.fullname" . }} 9090:{{ .Values.service.metricsPort }} -n {{ .Release.Namespace }}{{ end }}

🔧 Management:
  Upgrade: helm upgrade {{ .Release.Name }} ./websocket-chart -n {{ .Release.Namespace }}
  Rollback: helm rollback {{ .Release.Name }} -n {{ .Release.Namespace }}
  Uninstall: helm uninstall {{ .Release.Name }} -n {{ .Release.Namespace }}

{{- if .Values.autoscaling.enabled }}
🔄 Auto-scaling is enabled:
  Min replicas: {{ .Values.autoscaling.minReplicas }}
  Max replicas: {{ .Values.autoscaling.maxReplicas }}
  Target CPU: {{ .Values.autoscaling.targetCPUUtilizationPercentage }}%
  {{- if .Values.autoscaling.targetMemoryUtilizationPercentage }}
  Target Memory: {{ .Values.autoscaling.targetMemoryUtilizationPercentage }}%
  {{- end }}
{{- end }}</code></pre>

        <h3>🎯 使用步骤</h3>
        <ol>
            <li><strong>安装 Helm:</strong></li>
            <pre><code>chmod +x scripts/*.sh
./scripts/install-helm.sh</code></pre>

            <li><strong>验证 Chart 语法:</strong></li>
            <pre><code>helm lint ./websocket-chart
helm template websocket-dev ./websocket-chart --values ./websocket-chart/values-dev.yaml</code></pre>

            <li><strong>部署到开发环境:</strong></li>
            <pre><code>./scripts/deploy-dev.sh</code></pre>

            <li><strong>运行测试:</strong></li>
            <pre><code>helm test websocket-dev -n websocket-dev</code></pre>

            <li><strong>升级部署:</strong></li>
            <pre><code>helm upgrade websocket-dev ./websocket-chart \
    --namespace websocket-dev \
    --values ./websocket-chart/values-dev.yaml</code></pre>

            <li><strong>查看部署状态:</strong></li>
            <pre><code>helm status websocket-dev -n websocket-dev
helm history websocket-dev -n websocket-dev</code></pre>
        </ol>

        <h3>🔧 高级操作</h3>
        <pre><code># 打包 Chart
helm package ./websocket-chart

# 推送到 Chart 仓库
helm repo add my-repo https://my-chart-repo.com
helm push websocket-server-1.0.0.tgz my-repo

# 回滚到上一版本
helm rollback websocket-dev 1 -n websocket-dev

# 查看渲染后的模板
helm get manifest websocket-dev -n websocket-dev

# 验证 Chart 值
helm show values ./websocket-chart

# 调试模板
helm template websocket-dev ./websocket-chart --debug</code></pre>

        <h3>🌟 Helm Chart 特性</h3>
        <ul>
            <li><strong>模板化部署:</strong> 支持多环境配置和参数化</li>
            <li><strong>版本管理:</strong> 支持升级、回滚和历史记录</li>
            <li><strong>依赖管理:</strong> 可以包含子 Chart 和依赖项</li>
            <li><strong>钩子机制:</strong> 支持部署前后的自定义操作</li>
            <li><strong>测试集成:</strong> 内置连接和功能测试</li>
            <li><strong>安全配置:</strong> 包含 RBAC、网络策略和安全上下文</li>
            <li><strong>监控集成:</strong> 支持自动扩展和资源监控</li>
        </ul>

        <h3>🎓 学习要点</h3>
        <ul>
            <li>理解 Helm Chart 的结构和模板语法</li>
            <li>掌握多环境配置管理的最佳实践</li>
            <li>学会使用 Helm 进行应用的生命周期管理</li>
            <li>实践 Chart 的测试、打包和发布流程</li>
            <li>体验 Kubernetes 应用的标准化部署方式</li>
        </ul>

        <p>🔗 <a href="https://helm.sh/docs/chart_template_guide/" target="_blank">阅读对应官方文档</a></p>
    
        <p class="date"><strong>🗓️ 2025-08-26</strong></p>
        <h2>Day 26 - 编写项目说明 README.md</h2>
        <p>今天你将学习如何编写专业的项目文档，包括完整的 README.md 和相关文档。好的文档是开源项目成功的关键，能够帮助用户快速理解、安装和使用你的项目。</p>
        
        <h3>🎯 学习目标</h3>
        <ul>
            <li>学习 Markdown 语法和文档结构设计</li>
            <li>编写清晰、全面的项目说明文档</li>
            <li>创建用户友好的安装和使用指南</li>
            <li>制作项目演示和截图展示</li>
            <li>建立完整的项目文档体系</li>
        </ul>

        <h3>📁 项目结构</h3>
        <pre>day26_project_documentation/
├── README.md
├── docs/
│   ├── installation.md
│   ├── configuration.md
│   ├── api-reference.md
│   ├── deployment.md
│   ├── troubleshooting.md
│   ├── contributing.md
│   ├── changelog.md
│   └── examples/
│       ├── basic-usage.md
│       ├── advanced-features.md
│       └── kubernetes-deployment.md
├── assets/
│   ├── logo.png
│   ├── architecture.png
│   ├── demo.gif
│   └── screenshots/
│       ├── dashboard.png
│       ├── monitoring.png
│       └── test-client.png
├── examples/
│   ├── basic-client.js
│   ├── python-client.py
│   ├── stress-test.js
│   └── docker-compose.yml
├── scripts/
│   ├── generate-docs.sh
│   ├── update-readme.sh
│   └── create-demo.sh
├── .github/
│   ├── ISSUE_TEMPLATE/
│   │   ├── bug_report.md
│   │   └── feature_request.md
│   └── PULL_REQUEST_TEMPLATE.md
├── LICENSE
├── SECURITY.md
├── CODE_OF_CONDUCT.md
└── src/
    ├── main.rs
    ├── server.rs
    ├── config.rs
    └── health.rs</pre>

        <h3>🚀 实现步骤</h3>

        <h4>步骤 1: 主 README.md 文件</h4>
        <p><strong>README.md:</strong></p>
        <pre><code># 🚀 WebSocket Server

[![Rust](https://img.shields.io/badge/rust-1.70+-orange.svg)](https://www.rust-lang.org)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Build Status](https://github.com/your-username/websocket-server/workflows/CI/badge.svg)](https://github.com/your-username/websocket-server/actions)
[![Docker Pulls](https://img.shields.io/docker/pulls/your-username/websocket-server)](https://hub.docker.com/r/your-username/websocket-server)
[![Kubernetes](https://img.shields.io/badge/kubernetes-ready-brightgreen.svg)](https://kubernetes.io/)

A high-performance, production-ready WebSocket server built with Rust and Axum, featuring real-time messaging, comprehensive monitoring, and cloud-native deployment capabilities.

![Demo](assets/demo.gif)

## ✨ Features

- 🚀 **High Performance**: Built with Rust and Tokio for maximum concurrency
- 🔄 **Real-time Messaging**: Bi-directional WebSocket communication
- 📊 **Comprehensive Monitoring**: Built-in metrics, health checks, and observability
- ☁️ **Cloud Native**: Docker and Kubernetes ready with Helm charts
- 🔧 **Hot Configuration**: Dynamic configuration reloading without restarts
- 🛡️ **Production Ready**: Structured logging, error handling, and security features
- 📈 **Auto-scaling**: Horizontal Pod Autoscaler support
- 🌐 **Multi-environment**: Development, staging, and production configurations

## 🏗️ Architecture

![Architecture](assets/architecture.png)

The WebSocket server is designed with a modular architecture:

- **WebSocket Handler**: Manages client connections and message routing
- **Configuration Manager**: Hot-reloadable configuration system
- **Health System**: Comprehensive health and readiness checks
- **Metrics Collector**: Prometheus-compatible metrics
- **Security Layer**: Authentication, authorization, and rate limiting

## 🚀 Quick Start

### Prerequisites

- [Rust 1.70+](https://rustup.rs/)
- [Docker](https://docs.docker.com/get-docker/) (optional)
- [Kubernetes](https://kubernetes.io/docs/setup/) with [Helm](https://helm.sh/) (for production deployment)

### Local Development

1. **Clone the repository**
   ```bash
   git clone https://github.com/your-username/websocket-server.git
   cd websocket-server
   ```

2. **Install dependencies and run**
   ```bash
   cargo run
   ```

3. **Test the connection**
   ```bash
   # Open the test client
   open web/test-client.html
   
   # Or use WebSocket client
   cargo install websocat
   websocat ws://localhost:3000/ws
   ```

### Docker Deployment

```bash
# Build and run with Docker
docker build -t websocket-server .
docker run -p 3000:3000 -p 9090:9090 websocket-server

# Or use Docker Compose
docker-compose up -d
```

### Kubernetes Deployment

```bash
# Deploy with Helm
helm install websocket-server ./helm-chart \
  --namespace websocket-app \
  --create-namespace \
  --values ./helm-chart/values-prod.yaml
```

## 📖 Documentation

- [📋 Installation Guide](docs/installation.md)
- [⚙️ Configuration](docs/configuration.md)
- [🚀 Deployment Guide](docs/deployment.md)
- [📡 API Reference](docs/api-reference.md)
- [🔧 Troubleshooting](docs/troubleshooting.md)
- [🤝 Contributing](docs/contributing.md)

## 🎯 Usage Examples

### Basic WebSocket Client (JavaScript)

```javascript
const ws = new WebSocket('ws://localhost:3000/ws');

ws.onopen = () => {
    console.log('Connected to WebSocket server');
    ws.send('Hello, Server!');
};

ws.onmessage = (event) => {
    console.log('Received:', event.data);
};

ws.onclose = () => {
    console.log('Connection closed');
};
```

### Python Client Example

```python
import asyncio
import websockets
import json

async def client():
    uri = "ws://localhost:3000/ws"
    async with websockets.connect(uri) as websocket:
        # Send a message
        await websocket.send("Hello from Python!")
        
        # Receive response
        response = await websocket.recv()
        print(f"Received: {response}")

asyncio.run(client())
```

### Configuration Example

```yaml
server:
  port: 3000
  host: "0.0.0.0"
  max_connections: 1000

websocket:
  max_frame_size: 65536
  compression: true
  ping_interval: 30

logging:
  level: "info"
  format: "json"
```

## 📊 Monitoring

The server provides comprehensive monitoring capabilities:

### Health Endpoints

- `GET /health` - Basic health check
- `GET /ready` - Readiness probe for Kubernetes
- `GET /metrics` - Prometheus metrics

### Key Metrics

- `websocket_connections_total` - Total number of connections
- `websocket_messages_sent_total` - Messages sent counter
- `websocket_messages_received_total` - Messages received counter
- `websocket_connection_duration_seconds` - Connection duration histogram

### Grafana Dashboard

Import the provided Grafana dashboard from `monitoring/grafana-dashboard.json` to visualize:

- Connection statistics
- Message throughput
- Response times
- Error rates
- Resource utilization

![Monitoring Dashboard](assets/screenshots/monitoring.png)

## 🚀 Performance

### Benchmarks

| Metric | Value |
|--------|-------|
| Concurrent Connections | 10,000+ |
| Messages per Second | 100,000+ |
| Memory Usage | ~50MB (idle) |
| CPU Usage | <5% (normal load) |

### Load Testing

```bash
# Run performance tests
cargo run --release --bin load-test

# Or use the provided scripts
./scripts/load-test.sh
```

## 🛠️ Development

### Building from Source

```bash
# Debug build
cargo build

# Release build
cargo build --release

# Run tests
cargo test

# Run with logging
RUST_LOG=debug cargo run
```

### Development Workflow

1. Make your changes
2. Run tests: `cargo test`
3. Check formatting: `cargo fmt`
4. Run linter: `cargo clippy`
5. Update documentation
6. Submit a pull request

### Project Structure

```
src/
├── main.rs           # Application entry point
├── server.rs         # WebSocket server implementation
├── config.rs         # Configuration management
├── health.rs         # Health check system
└── lib.rs           # Library exports

helm-chart/          # Kubernetes Helm chart
├── templates/       # Kubernetes manifests
├── values.yaml      # Default configuration
└── Chart.yaml       # Chart metadata

docs/               # Documentation
├── api-reference.md
├── deployment.md
└── examples/

tests/              # Integration tests
├── integration_test.rs
└── load_test.rs
```

## 🐳 Docker

### Multi-stage Dockerfile

The project uses a multi-stage Docker build for optimal image size:

```dockerfile
FROM rust:1.70 as builder
# Build stage...

FROM debian:bookworm-slim
# Runtime stage...
```

### Image Variants

- `websocket-server:latest` - Latest stable release
- `websocket-server:v1.0.0` - Specific version
- `websocket-server:dev` - Development build

## ☸️ Kubernetes

### Helm Chart Features

- ConfigMap-based configuration
- Horizontal Pod Autoscaler
- Ingress with TLS support
- Network policies
- RBAC configuration
- Health checks
- Resource limits

### Deployment Environments

- **Development**: Single replica, debug logging
- **Staging**: 2 replicas, SSL termination
- **Production**: 3+ replicas, auto-scaling, monitoring

## 🔒 Security

### Security Features

- Non-root container execution
- Read-only root filesystem
- Network policies
- Resource limits
- Security contexts

### Security Scanning

```bash
# Scan for vulnerabilities
cargo audit

# Docker image scanning
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  aquasec/trivy websocket-server:latest
```

## 🤝 Contributing

We welcome contributions! Please see our [Contributing Guide](docs/contributing.md) for details.

### Quick Contribution Steps

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/amazing-feature`
3. Make your changes
4. Add tests if applicable
5. Run the test suite: `cargo test`
6. Commit your changes: `git commit -m 'Add amazing feature'`
7. Push to the branch: `git push origin feature/amazing-feature`
8. Open a Pull Request

## 📝 Changelog

See [CHANGELOG.md](docs/changelog.md) for version history and release notes.

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🆘 Support

- 📖 [Documentation](docs/)
- 🐛 [Issue Tracker](https://github.com/your-username/websocket-server/issues)
- 💬 [Discussions](https://github.com/your-username/websocket-server/discussions)
- 📧 Email: support@your-domain.com

## 🏆 Acknowledgments

- [Tokio](https://tokio.rs/) - Asynchronous runtime
- [Axum](https://github.com/tokio-rs/axum) - Web framework
- [Serde](https://serde.rs/) - Serialization framework
- [Tracing](https://tracing.rs/) - Structured logging
- The Rust community for their amazing ecosystem

## 🌟 Star History

[![Star History Chart](https://api.star-history.com/svg?repos=your-username/websocket-server&type=Date)](https://star-history.com/#your-username/websocket-server&Date)

---

**Made with ❤️ in Rust**</code></pre>

        <h4>步骤 2: 安装指南</h4>
        <p><strong>docs/installation.md:</strong></p>
        <pre><code># 📋 Installation Guide

This guide covers all the ways to install and run the WebSocket server.

## System Requirements

### Minimum Requirements
- **OS**: Linux, macOS, or Windows 10+
- **RAM**: 512MB
- **CPU**: 1 core
- **Disk**: 100MB free space

### Recommended Requirements
- **OS**: Linux (Ubuntu 20.04+ / CentOS 8+)
- **RAM**: 2GB+
- **CPU**: 2+ cores
- **Disk**: 1GB+ free space

## Installation Methods

### 1. From Source (Recommended for Development)

#### Prerequisites
```bash
# Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env

# Verify installation
rustc --version
cargo --version
```

#### Installation Steps
```bash
# Clone the repository
git clone https://github.com/your-username/websocket-server.git
cd websocket-server

# Build and install
cargo build --release

# Run the server
cargo run --release
```

### 2. Pre-built Binaries

Download pre-built binaries from the [releases page](https://github.com/your-username/websocket-server/releases).

```bash
# Linux x86_64
wget https://github.com/your-username/websocket-server/releases/latest/download/websocket-server-linux-x86_64.tar.gz
tar -xzf websocket-server-linux-x86_64.tar.gz
./websocket-server

# macOS
wget https://github.com/your-username/websocket-server/releases/latest/download/websocket-server-macos-x86_64.tar.gz
tar -xzf websocket-server-macos-x86_64.tar.gz
./websocket-server

# Windows
# Download websocket-server-windows-x86_64.zip and extract
```

### 3. Docker Installation

#### Pull from Docker Hub
```bash
docker pull your-username/websocket-server:latest
docker run -p 3000:3000 -p 9090:9090 your-username/websocket-server:latest
```

#### Build from Source
```bash
git clone https://github.com/your-username/websocket-server.git
cd websocket-server
docker build -t websocket-server .
docker run -p 3000:3000 -p 9090:9090 websocket-server
```

### 4. Package Managers

#### Homebrew (macOS)
```bash
brew tap your-username/tap
brew install websocket-server
```

#### Chocolatey (Windows)
```bash
choco install websocket-server
```

#### APT (Ubuntu/Debian)
```bash
curl -fsSL https://pkg.your-domain.com/key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/websocket-server.gpg
echo "deb [signed-by=/usr/share/keyrings/websocket-server.gpg] https://pkg.your-domain.com/apt stable main" | sudo tee /etc/apt/sources.list.d/websocket-server.list
sudo apt update
sudo apt install websocket-server
```

### 5. Kubernetes Installation

#### Using Helm (Recommended)
```bash
# Add Helm repository
helm repo add websocket-server https://charts.your-domain.com
helm repo update

# Install with default values
helm install my-websocket websocket-server/websocket-server

# Install with custom values
helm install my-websocket websocket-server/websocket-server \
  --values custom-values.yaml \
  --namespace websocket-app \
  --create-namespace
```

#### Using kubectl
```bash
# Apply Kubernetes manifests
kubectl apply -f https://raw.githubusercontent.com/your-username/websocket-server/main/k8s/
```

## Configuration

### Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `PORT` | `3000` | Server listening port |
| `HOST` | `0.0.0.0` | Server listening host |
| `RUST_LOG` | `info` | Log level |
| `CONFIG_PATH` | `config.yaml` | Configuration file path |

### Configuration File

Create a `config.yaml` file:

```yaml
server:
  port: 3000
  host: "0.0.0.0"
  max_connections: 1000

websocket:
  max_frame_size: 65536
  compression: true

logging:
  level: "info"
  format: "json"
```

## Verification

### Check Installation
```bash
# Check if server is running
curl http://localhost:3000/health

# Expected response
{"status":"healthy","timestamp":"2025-01-01T00:00:00Z"}
```

### Test WebSocket Connection
```bash
# Install websocat for testing
cargo install websocat

# Test connection
websocat ws://localhost:3000/ws
```

## Troubleshooting

### Common Issues

#### Port Already in Use
```bash
# Check what's using port 3000
lsof -i :3000

# Kill the process
kill -9 <PID>
```

#### Permission Denied
```bash
# Run with elevated privileges
sudo ./websocket-server

# Or use a different port
./websocket-server --port 8080
```

#### Firewall Issues
```bash
# Open port in firewall (Ubuntu)
sudo ufw allow 3000/tcp

# CentOS/RHEL
sudo firewall-cmd --permanent --add-port=3000/tcp
sudo firewall-cmd --reload
```

## Next Steps

- [Configuration Guide](configuration.md)
- [Deployment Guide](deployment.md)
- [API Reference](api-reference.md)
- [Examples](examples/)

## Getting Help

If you encounter issues during installation:

1. Check the [troubleshooting guide](troubleshooting.md)
2. Search [existing issues](https://github.com/your-username/websocket-server/issues)
3. Create a [new issue](https://github.com/your-username/websocket-server/issues/new) with:
   - Operating system and version
   - Installation method used
   - Error messages or logs
   - Steps to reproduce</code></pre>

        <h4>步骤 3: API 参考文档</h4>
        <p><strong>docs/api-reference.md:</strong></p>
        <pre><code># 📡 API Reference

This document provides detailed information about all the APIs available in the WebSocket server.

## WebSocket API

### Connection Endpoint

**Endpoint**: `ws://localhost:3000/ws`

Establishes a WebSocket connection to the server.

#### Connection Flow

1. **Client connects** to the WebSocket endpoint
2. **Server accepts** and assigns a unique client ID
3. **Bidirectional communication** begins
4. **Server sends welcome message** with client information

#### Example Connection (JavaScript)

```javascript
const ws = new WebSocket('ws://localhost:3000/ws');

ws.onopen = function(event) {
    console.log('Connected to WebSocket server');
};

ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    console.log('Received:', data);
};

ws.onclose = function(event) {
    console.log('Connection closed:', event.code, event.reason);
};

ws.onerror = function(error) {
    console.error('WebSocket error:', error);
};
```

### Message Format

All WebSocket messages use JSON format:

```json
{
    "type": "message_type",
    "client_id": "uuid",
    "timestamp": "2025-01-01T00:00:00Z",
    "data": {
        // Message-specific data
    }
}
```

#### Message Types

| Type | Direction | Description |
|------|-----------|-------------|
| `welcome` | Server → Client | Initial connection confirmation |
| `echo` | Server → Client | Echo response to client messages |
| `ping` | Client → Server | Heartbeat message |
| `pong` | Server → Client | Heartbeat response |
| `error` | Server → Client | Error notification |
| `disconnect` | Bidirectional | Connection termination |

#### Welcome Message

Sent when a client successfully connects:

```json
{
    "type": "welcome",
    "client_id": "550e8400-e29b-41d4-a716-446655440000",
    "timestamp": "2025-01-01T00:00:00Z",
    "data": {
        "server_version": "1.0.0",
        "max_message_size": 1048576,
        "ping_interval": 30
    }
}
```

#### Echo Message

Server echoes back client messages with metadata:

```json
{
    "type": "echo",
    "client_id": "550e8400-e29b-41d4-a716-446655440000",
    "timestamp": "2025-01-01T00:00:00Z",
    "data": {
        "original_message": "Hello, Server!",
        "message_size": 14,
        "echo_count": 1
    }
}
```

## HTTP API

### Health Check Endpoints

#### GET /health

Returns the health status of the server.

**Response:**
```json
{
    "status": "healthy",
    "timestamp": "2025-01-01T00:00:00Z",
    "uptime_seconds": 3600,
    "version": "1.0.0"
}
```

**Status Codes:**
- `200 OK` - Server is healthy
- `503 Service Unavailable` - Server is unhealthy

#### GET /ready

Returns the readiness status for Kubernetes probes.

**Response:**
```json
{
    "status": "ready",
    "timestamp": "2025-01-01T00:00:00Z",
    "checks": {
        "database": "ok",
        "external_service": "ok"
    }
}
```

**Status Codes:**
- `200 OK` - Server is ready
- `503 Service Unavailable` - Server is not ready

### Metrics Endpoint

#### GET /metrics

Returns Prometheus-compatible metrics.

**Response Format:** Prometheus text format

**Sample Response:**
```
# HELP websocket_connections_total Total number of WebSocket connections
# TYPE websocket_connections_total counter
websocket_connections_total 1234

# HELP websocket_active_connections Current number of active connections
# TYPE websocket_active_connections gauge
websocket_active_connections 45

# HELP websocket_messages_sent_total Total messages sent to clients
# TYPE websocket_messages_sent_total counter
websocket_messages_sent_total 5678

# HELP websocket_messages_received_total Total messages received from clients
# TYPE websocket_messages_received_total counter
websocket_messages_received_total 5432

# HELP websocket_connection_duration_seconds Duration of WebSocket connections
# TYPE websocket_connection_duration_seconds histogram
websocket_connection_duration_seconds_bucket{le="1"} 10
websocket_connection_duration_seconds_bucket{le="5"} 25
websocket_connection_duration_seconds_bucket{le="10"} 40
websocket_connection_duration_seconds_bucket{le="+Inf"} 45
websocket_connection_duration_seconds_sum 180.5
websocket_connection_duration_seconds_count 45
```

### Client Management Endpoints

#### GET /clients

Returns information about connected clients.

**Response:**
```json
{
    "total_clients": 2,
    "clients": [
        {
            "id": "550e8400-e29b-41d4-a716-446655440000",
            "connected_at": "2025-01-01T00:00:00Z",
            "remote_addr": "192.168.1.100:54321",
            "user_agent": "Mozilla/5.0...",
            "messages_sent": 10,
            "messages_received": 8,
            "last_activity": "2025-01-01T00:05:00Z"
        }
    ]
}
```

#### GET /clients/{client_id}

Returns information about a specific client.

**Parameters:**
- `client_id` (UUID) - The client identifier

**Response:**
```json
{
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "connected_at": "2025-01-01T00:00:00Z",
    "remote_addr": "192.168.1.100:54321",
    "user_agent": "Mozilla/5.0...",
    "messages_sent": 10,
    "messages_received": 8,
    "last_activity": "2025-01-01T00:05:00Z",
    "connection_duration_seconds": 300
}
```

### Configuration Endpoints

#### GET /config

Returns the current server configuration.

**Response:**
```json
{
    "server": {
        "port": 3000,
        "host": "0.0.0.0",
        "max_connections": 1000
    },
    "websocket": {
        "max_frame_size": 65536,
        "compression": true,
        "ping_interval": 30
    },
    "logging": {
        "level": "info",
        "format": "json"
    }
}
```

#### POST /config/reload

Reloads the server configuration from the config file.

**Response:**
```json
{
    "status": "success",
    "message": "Configuration reloaded successfully",
    "timestamp": "2025-01-01T00:00:00Z"
}
```

**Error Response:**
```json
{
    "status": "error",
    "message": "Failed to reload configuration: Invalid YAML syntax",
    "timestamp": "2025-01-01T00:00:00Z"
}
```

## Error Handling

### HTTP Error Responses

All HTTP errors follow this format:

```json
{
    "error": {
        "code": "ERROR_CODE",
        "message": "Human readable error message",
        "details": "Additional error details",
        "timestamp": "2025-01-01T00:00:00Z"
    }
}
```

### Common HTTP Status Codes

| Code | Description |
|------|-------------|
| `200` | Success |
| `400` | Bad Request |
| `404` | Not Found |
| `500` | Internal Server Error |
| `503` | Service Unavailable |

### WebSocket Error Messages

WebSocket errors are sent as JSON messages:

```json
{
    "type": "error",
    "client_id": "550e8400-e29b-41d4-a716-446655440000",
    "timestamp": "2025-01-01T00:00:00Z",
    "data": {
        "code": "MESSAGE_TOO_LARGE",
        "message": "Message exceeds maximum size limit",
        "max_size": 1048576
    }
}
```

### WebSocket Close Codes

| Code | Description |
|------|-------------|
| `1000` | Normal Closure |
| `1001` | Going Away |
| `1002` | Protocol Error |
| `1003` | Unsupported Data |
| `1006` | Abnormal Closure |
| `1009` | Message Too Big |
| `1011` | Internal Error |

## Rate Limiting

The server implements rate limiting to prevent abuse:

- **Connection Rate**: 100 connections per minute per IP
- **Message Rate**: 1000 messages per minute per connection
- **HTTP Rate**: 1000 requests per minute per IP

Rate limit headers are included in HTTP responses:

```
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 999
X-RateLimit-Reset: 1640995200
```

## Authentication (Future Feature)

The server is designed to support authentication in future versions:

### JWT Token Authentication

```javascript
const ws = new WebSocket('ws://localhost:3000/ws', [], {
    headers: {
        'Authorization': 'Bearer your-jwt-token'
    }
});
```

### API Key Authentication

```bash
curl -H "X-API-Key: your-api-key" http://localhost:3000/metrics
```

## Client Libraries

### Official Client Libraries

- **JavaScript/TypeScript**: `@websocket-server/client`
- **Python**: `websocket-server-client`
- **Go**: `github.com/your-username/websocket-server-go`
- **Rust**: `websocket-server-client`

### Community Libraries

- **Java**: `websocket-server-java` (community maintained)
- **C#**: `WebSocketServer.Client` (community maintained)

## Examples

See the [examples directory](../examples/) for complete client implementations in various languages.

## Changelog

API changes are documented in the [changelog](changelog.md) with proper versioning.

## Support

For API-related questions:
- Create an issue on [GitHub](https://github.com/your-username/websocket-server/issues)
- Join our [Discord community](https://discord.gg/your-invite)
- Email: api-support@your-domain.com</code></pre>

        <h4>步骤 4: 贡献指南</h4>
        <p><strong>docs/contributing.md:</strong></p>
        <pre><code># 🤝 Contributing to WebSocket Server

Thank you for your interest in contributing to WebSocket Server! This guide will help you get started with contributing to the project.

## Table of Contents

- [Code of Conduct](#code-of-conduct)
- [Getting Started](#getting-started)
- [Development Setup](#development-setup)
- [How to Contribute](#how-to-contribute)
- [Pull Request Process](#pull-request-process)
- [Coding Standards](#coding-standards)
- [Testing](#testing)
- [Documentation](#documentation)
- [Community](#community)

## Code of Conduct

This project and everyone participating in it is governed by our [Code of Conduct](../CODE_OF_CONDUCT.md). By participating, you are expected to uphold this code.

## Getting Started

### Ways to Contribute

- 🐛 **Bug Reports**: Help us identify and fix bugs
- ✨ **Feature Requests**: Suggest new features or improvements
- 📝 **Documentation**: Improve or translate our documentation
- 💻 **Code**: Implement features, fix bugs, or improve performance
- 🧪 **Testing**: Write tests or test new features
- 🎨 **Design**: Improve UI/UX of our web interfaces
- 📢 **Outreach**: Write blog posts, speak at conferences, or spread the word

### Good First Issues

Look for issues labeled `good first issue` for beginner-friendly contributions:
- https://github.com/your-username/websocket-server/labels/good%20first%20issue

## Development Setup

### Prerequisites

- [Rust 1.70+](https://rustup.rs/)
- [Git](https://git-scm.com/)
- [Docker](https://docs.docker.com/get-docker/) (optional)

### Setup Steps

1. **Fork and Clone**
   ```bash
   # Fork the repository on GitHub, then clone your fork
   git clone https://github.com/YOUR-USERNAME/websocket-server.git
   cd websocket-server
   
   # Add upstream remote
   git remote add upstream https://github.com/your-username/websocket-server.git
   ```

2. **Install Dependencies**
   ```bash
   # Install Rust toolchain
   rustup install stable
   rustup default stable
   
   # Install development tools
   rustup component add clippy rustfmt
   cargo install cargo-watch cargo-audit
   ```

3. **Build and Test**
   ```bash
   # Build the project
   cargo build
   
   # Run tests
   cargo test
   
   # Start development server
   cargo run
   ```

4. **Verify Setup**
   ```bash
   # Check health endpoint
   curl http://localhost:3000/health
   
   # Run linter
   cargo clippy
   
   # Check formatting
   cargo fmt --check
   ```

## How to Contribute

### Reporting Bugs

Before creating bug reports, please check the [existing issues](https://github.com/your-username/websocket-server/issues) to avoid duplicates.

**How to Submit a Bug Report:**

1. Use the [bug report template](../.github/ISSUE_TEMPLATE/bug_report.md)
2. Provide detailed steps to reproduce
3. Include relevant logs and error messages
4. Specify your environment (OS, Rust version, etc.)

**Good Bug Report Example:**

```
**Bug**: WebSocket connection drops after 30 seconds of inactivity

**Environment**:
- OS: Ubuntu 20.04
- Rust: 1.70.0
- Server version: 1.0.0

**Steps to Reproduce**:
1. Connect to ws://localhost:3000/ws
2. Don't send any messages
3. Wait 30 seconds
4. Connection drops with code 1006

**Expected**: Connection should remain open
**Actual**: Connection drops unexpectedly

**Logs**:
```
[2025-01-01T00:00:30Z ERROR] Connection timeout for client abc-123
```
```

### Suggesting Features

We welcome feature suggestions! Please:

1. Use the [feature request template](../.github/ISSUE_TEMPLATE/feature_request.md)
2. Clearly describe the feature and its benefits
3. Consider the impact on existing functionality
4. Provide examples or mockups if applicable

### Contributing Code

1. **Choose an Issue**
   - Browse [open issues](https://github.com/your-username/websocket-server/issues)
   - Comment on the issue to let others know you're working on it
   - Ask questions if anything is unclear

2. **Create a Branch**
   ```bash
   git checkout -b feature/your-feature-name
   # or
   git checkout -b fix/your-bug-fix
   ```

3. **Make Changes**
   - Write clear, self-documenting code
   - Follow our [coding standards](#coding-standards)
   - Add tests for new functionality
   - Update documentation as needed

4. **Test Your Changes**
   ```bash
   # Run all tests
   cargo test
   
   # Run integration tests
   cargo test --test integration_test
   
   # Check for security vulnerabilities
   cargo audit
   
   # Lint your code
   cargo clippy -- -D warnings
   
   # Format your code
   cargo fmt
   ```

5. **Commit Your Changes**
   ```bash
   git add .
   git commit -m "feat: add new WebSocket compression feature
   
   - Implement deflate compression for WebSocket messages
   - Add configuration option for compression level
   - Update documentation and tests"
   ```

## Pull Request Process

### Before Submitting

- [ ] Tests pass locally: `cargo test`
- [ ] Code is properly formatted: `cargo fmt`
- [ ] No linting errors: `cargo clippy`
- [ ] Documentation is updated
- [ ] Commit messages follow our convention

### Commit Message Convention

We use [Conventional Commits](https://www.conventionalcommits.org/):

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

**Types:**
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting, etc.)
- `refactor`: Code refactoring
- `test`: Adding or updating tests
- `chore`: Maintenance tasks

**Examples:**
```
feat(websocket): add message compression support

fix(config): resolve configuration reload issue

docs(api): update WebSocket API documentation

test(integration): add load testing scenarios
```

### Pull Request Template

When you create a PR, please fill out our [template](../.github/PULL_REQUEST_TEMPLATE.md):

- **Description**: What does this PR do?
- **Type of Change**: Bug fix, new feature, etc.
- **Testing**: How was this tested?
- **Checklist**: Confirm all requirements are met

### Review Process

1. **Automated Checks**: GitHub Actions will run tests and linting
2. **Code Review**: Maintainers will review your code
3. **Feedback**: Address any requested changes
4. **Approval**: Once approved, your PR will be merged

## Coding Standards

### Rust Style Guide

We follow the [Rust Style Guide](https://doc.rust-lang.org/nightly/style-guide/) with these additions:

**Code Organization:**
- Use `mod.rs` for module declarations
- Group related functionality in modules
- Keep functions under 50 lines when possible
- Use meaningful variable and function names

**Error Handling:**
- Use `Result<T, E>` for fallible operations
- Implement proper error types with `thiserror`
- Log errors at appropriate levels
- Provide helpful error messages

**Documentation:**
- Document all public APIs with doc comments
- Include examples in doc comments
- Keep comments up-to-date with code changes

**Testing:**
- Write unit tests for all public functions
- Use integration tests for end-to-end scenarios
- Aim for >80% code coverage
- Use descriptive test names

### Code Example

```rust
use anyhow::Result;
use tracing::{info, warn};

/// Manages WebSocket client connections with automatic cleanup.
/// 
/// # Examples
/// 
/// ```rust
/// let manager = ConnectionManager::new(1000);
/// let client_id = manager.add_client(socket).await?;
/// ```
pub struct ConnectionManager {
    max_connections: usize,
    clients: Arc<RwLock<HashMap<Uuid, ClientInfo>>>,
}

impl ConnectionManager {
    /// Creates a new connection manager with the specified capacity.
    pub fn new(max_connections: usize) -> Self {
        Self {
            max_connections,
            clients: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// Adds a new client connection.
    /// 
    /// Returns the assigned client ID or an error if capacity is exceeded.
    pub async fn add_client(&self, socket: WebSocket) -> Result<Uuid> {
        let mut clients = self.clients.write().await;
        
        if clients.len() >= self.max_connections {
            warn!("Maximum connections reached: {}", self.max_connections);
            return Err(anyhow::anyhow!("Connection limit exceeded"));
        }
        
        let client_id = Uuid::new_v4();
        let client_info = ClientInfo::new(socket);
        
        clients.insert(client_id, client_info);
        info!("Client connected: {}", client_id);
        
        Ok(client_id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_add_client_success() {
        let manager = ConnectionManager::new(10);
        // Test implementation...
    }
    
    #[tokio::test]
    async fn test_add_client_capacity_exceeded() {
        let manager = ConnectionManager::new(0);
        // Test implementation...
    }
}
```

## Testing

### Test Categories

1. **Unit Tests**: Test individual functions and modules
2. **Integration Tests**: Test complete workflows
3. **Load Tests**: Test performance under load
4. **Security Tests**: Test for vulnerabilities

### Running Tests

```bash
# All tests
cargo test

# Unit tests only
cargo test --lib

# Integration tests only
cargo test --test integration_test

# Load tests (requires special setup)
cargo test --release --test load_test

# Test with logging
RUST_LOG=debug cargo test

# Test coverage (requires cargo-tarpaulin)
cargo install cargo-tarpaulin
cargo tarpaulin --html
```

### Writing Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    
    #[tokio::test]
    async fn test_websocket_connection() {
        // Setup
        let server = start_test_server().await;
        let client = connect_test_client(&server.addr).await;
        
        // Test
        client.send("Hello").await.unwrap();
        let response = client.receive().await.unwrap();
        
        // Assert
        assert_eq!(response.data, "Hello");
        assert!(response.timestamp.is_some());
    }
}
```

## Documentation

### Types of Documentation

1. **Code Documentation**: Inline comments and doc comments
2. **API Documentation**: Generated from doc comments
3. **User Documentation**: README, guides, tutorials
4. **Developer Documentation**: Contributing guide, architecture docs

### Writing Documentation

- Use clear, concise language
- Include practical examples
- Keep it up-to-date with code changes
- Consider non-native English speakers

### Building Documentation

```bash
# Generate API docs
cargo doc --open

# Check documentation
cargo doc --document-private-items

# Test documentation examples
cargo test --doc
```

## Community

### Getting Help

- **Discord**: [Join our Discord](https://discord.gg/your-invite)
- **GitHub Discussions**: [Ask questions](https://github.com/your-username/websocket-server/discussions)
- **Email**: dev-support@your-domain.com

### Maintainers

- [@maintainer1](https://github.com/maintainer1) - Lead Maintainer
- [@maintainer2](https://github.com/maintainer2) - Core Developer
- [@maintainer3](https://github.com/maintainer3) - Documentation Lead

### Recognition

Contributors are recognized in:
- [Contributors list](https://github.com/your-username/websocket-server/graphs/contributors)
- [Release notes](changelog.md)
- [Hall of Fame](https://websocket-server.dev/contributors) (website)

## Questions?

Don't hesitate to ask! We're here to help:
- Create a [discussion](https://github.com/your-username/websocket-server/discussions)
- Join our [Discord](https://discord.gg/your-invite)
- Email us at contributors@your-domain.com

Thank you for contributing to WebSocket Server! 🚀</code></pre>

        <h4>步骤 5: 文档生成脚本</h4>
        <p><strong>scripts/generate-docs.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "📚 Generating Project Documentation"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if required tools are installed
check_requirements() {
    print_status "Checking requirements..."
    
    if ! command -v cargo &> /dev/null; then
        print_error "Cargo is not installed. Please install Rust."
        exit 1
    fi
    
    if ! command -v python3 &> /dev/null; then
        print_warning "Python3 not found. Some features may not work."
    fi
    
    if ! command -v node &> /dev/null; then
        print_warning "Node.js not found. Web documentation features may not work."
    fi
    
    print_success "Requirements check completed"
}

# Generate Rust API documentation
generate_api_docs() {
    print_status "Generating Rust API documentation..."
    
    # Generate documentation with all features
    cargo doc \
        --all-features \
        --no-deps \
        --document-private-items \
        --open
    
    print_success "Rust API documentation generated"
}

# Generate code coverage report
generate_coverage() {
    print_status "Generating code coverage report..."
    
    if command -v cargo-tarpaulin &> /dev/null; then
        cargo tarpaulin \
            --out Html \
            --output-dir docs/coverage \
            --exclude-files "tests/*" \
            --timeout 120
        
        print_success "Coverage report generated in docs/coverage/"
    else
        print_warning "cargo-tarpaulin not found. Install with: cargo install cargo-tarpaulin"
    fi
}

# Generate dependency tree
generate_dependency_tree() {
    print_status "Generating dependency tree..."
    
    if command -v cargo-tree &> /dev/null; then
        cargo tree --format "{p} {f}" > docs/dependencies.txt
        cargo tree --format "{p} {f}" --duplicates >> docs/dependencies.txt
        
        print_success "Dependency tree saved to docs/dependencies.txt"
    else
        print_warning "cargo-tree not found. Install with: cargo install cargo-tree"
    fi
}

# Generate security audit report
generate_security_audit() {
    print_status "Running security audit..."
    
    if command -v cargo-audit &> /dev/null; then
        cargo audit --format json > docs/security-audit.json || true
        cargo audit --format markdown > docs/security-audit.md || true
        
        print_success "Security audit saved to docs/"
    else
        print_warning "cargo-audit not found. Install with: cargo install cargo-audit"
    fi
}

# Generate performance benchmarks
generate_benchmarks() {
    print_status "Running performance benchmarks..."
    
    if [ -d "benches" ]; then
        cargo bench > docs/benchmarks.txt 2>&1 || true
        print_success "Benchmark results saved to docs/benchmarks.txt"
    else
        print_warning "No benchmarks directory found"
    fi
}

# Generate changelog from git history
generate_changelog() {
    print_status "Updating changelog..."
    
    # Check if git-cliff is available
    if command -v git-cliff &> /dev/null; then
        git-cliff --output docs/changelog.md
        print_success "Changelog updated"
    elif [ -f "CHANGELOG.md" ]; then
        cp CHANGELOG.md docs/changelog.md
        print_success "Changelog copied from root directory"
    else
        print_warning "No changelog generator found. Consider installing git-cliff"
    fi
}

# Validate all markdown files
validate_markdown() {
    print_status "Validating markdown files..."
    
    if command -v markdownlint &> /dev/null; then
        markdownlint docs/ README.md || true
        print_success "Markdown validation completed"
    else
        print_warning "markdownlint not found. Install with: npm install -g markdownlint-cli"
    fi
}

# Generate table of contents for README
update_readme_toc() {
    print_status "Updating README table of contents..."
    
    if command -v markdown-toc &> /dev/null; then
        markdown-toc -i README.md
        print_success "README table of contents updated"
    else
        print_warning "markdown-toc not found. Install with: npm install -g markdown-toc"
    fi
}

# Create documentation index
create_docs_index() {
    print_status "Creating documentation index..."
    
    cat > docs/README.md << 'EOF'
# 📚 WebSocket Server Documentation

Welcome to the WebSocket Server documentation!

## 📖 Documentation Structure

### User Documentation
- [Installation Guide](installation.md) - How to install and set up the server
- [Configuration Guide](configuration.md) - Configuration options and examples
- [Deployment Guide](deployment.md) - Production deployment instructions
- [Troubleshooting](troubleshooting.md) - Common issues and solutions

### Developer Documentation
- [API Reference](api-reference.md) - Complete API documentation
- [Contributing Guide](contributing.md) - How to contribute to the project
- [Architecture Overview](architecture.md) - System design and architecture
- [Examples](examples/) - Code examples and tutorials

### Reference
- [Changelog](changelog.md) - Version history and changes
- [Security Audit](security-audit.md) - Security vulnerability report
- [Dependencies](dependencies.txt) - Dependency tree and licenses
- [Coverage Report](coverage/) - Code coverage analysis
- [Benchmarks](benchmarks.txt) - Performance benchmark results

## 🚀 Quick Links

- [GitHub Repository](https://github.com/your-username/websocket-server)
- [Docker Hub](https://hub.docker.com/r/your-username/websocket-server)
- [Issue Tracker](https://github.com/your-username/websocket-server/issues)
- [Discussions](https://github.com/your-username/websocket-server/discussions)

## 🆘 Getting Help

- Check the [troubleshooting guide](troubleshooting.md)
- Search [existing issues](https://github.com/your-username/websocket-server/issues)
- Join our [Discord community](https://discord.gg/your-invite)
- Email: support@your-domain.com

---

Generated on $(date)
EOF
    
    print_success "Documentation index created"
}

# Generate example configurations
generate_example_configs() {
    print_status "Generating example configurations..."
    
    mkdir -p docs/examples/configs
    
    # Development configuration
    cat > docs/examples/configs/development.yaml << 'EOF'
# Development Configuration
server:
  port: 3000
  host: "0.0.0.0"
  max_connections: 100

websocket:
  max_frame_size: 65536
  max_message_size: 1048576
  compression: false
  ping_interval: 30
  pong_timeout: 10

logging:
  level: "debug"
  format: "pretty"
  output: "stdout"

metrics:
  enabled: true
  port: 9090
  path: "/metrics"

# Development-specific settings
debug:
  enable_debug_endpoints: true
  log_client_messages: true
EOF

    # Production configuration
    cat > docs/examples/configs/production.yaml << 'EOF'
# Production Configuration
server:
  port: 3000
  host: "0.0.0.0"
  max_connections: 10000

websocket:
  max_frame_size: 65536
  max_message_size: 1048576
  compression: true
  ping_interval: 30
  pong_timeout: 10

logging:
  level: "warn"
  format: "json"
  output: "stdout"

metrics:
  enabled: true
  port: 9090
  path: "/metrics"

# Production-specific settings
security:
  rate_limit_per_minute: 1000
  max_payload_size: 1048576
  enable_cors: false
EOF
    
    print_success "Example configurations generated"
}

# Main execution
main() {
    echo "🚀 WebSocket Server Documentation Generator"
    echo "============================================="
    
    # Create docs directory if it doesn't exist
    mkdir -p docs/{coverage,examples/{configs,clients},assets}
    
    # Run all generation tasks
    check_requirements
    generate_api_docs
    generate_coverage
    generate_dependency_tree
    generate_security_audit
    generate_benchmarks
    generate_changelog
    validate_markdown
    update_readme_toc
    create_docs_index
    generate_example_configs
    
    echo ""
    echo "============================================="
    print_success "Documentation generation completed!"
    echo ""
    print_status "Generated files:"
    echo "  📄 docs/README.md - Documentation index"
    echo "  📊 docs/coverage/ - Code coverage report"
    echo "  🔒 docs/security-audit.md - Security audit"
    echo "  📈 docs/benchmarks.txt - Performance benchmarks"
    echo "  📝 docs/changelog.md - Version changelog"
    echo "  🌲 docs/dependencies.txt - Dependency tree"
    echo "  ⚙️  docs/examples/configs/ - Example configurations"
    echo ""
    print_status "View the documentation:"
    echo "  🌐 Open target/doc/websocket_server/index.html for API docs"
    echo "  📖 Check docs/README.md for documentation index"
    echo ""
}

# Run main function
main "$@"</code></pre>

        <h3>🎯 使用步骤</h3>
        <ol>
            <li><strong>生成文档:</strong></li>
            <pre><code>chmod +x scripts/generate-docs.sh
./scripts/generate-docs.sh</code></pre>

            <li><strong>验证文档质量:</strong></li>
            <pre><code># 检查链接有效性
npm install -g markdown-link-check
find docs -name "*.md" -exec markdown-link-check {} \;

# 检查拼写
npm install -g cspell
cspell "docs/**/*.md" "README.md"</code></pre>

            <li><strong>预览文档:</strong></li>
            <pre><code># 使用 Python 启动本地服务器
python3 -m http.server 8080
# 访问 http://localhost:8080 查看文档

# 或使用 Node.js
npx serve .
</code></pre>
        </ol>

        <h3>🌟 文档特性</h3>
        <ul>
            <li><strong>完整性:</strong> 涵盖安装、配置、使用、部署全流程</li>
            <li><strong>多层次:</strong> 面向用户、开发者、贡献者的不同文档</li>
            <li><strong>可视化:</strong> 包含架构图、演示动图、截图展示</li>
            <li><strong>交互性:</strong> 提供代码示例和实际可运行的客户端</li>
            <li><strong>维护性:</strong> 自动化生成和验证机制</li>
            <li><strong>标准化:</strong> 遵循开源项目文档最佳实践</li>
            <li><strong>多格式:</strong> 支持 Markdown、HTML、API 文档等</li>
        </ul>

        <h3>🎓 学习要点</h3>
        <ul>
            <li>掌握技术文档的结构设计和写作技巧</li>
            <li>学会使用 Markdown 创建专业的项目文档</li>
            <li>了解开源项目文档的标准和最佳实践</li>
            <li>实践文档的自动化生成和维护流程</li>
            <li>体验用户友好的文档设计思路</li>
        </ul>

        <p>🔗 <a href="https://www.makeareadme.com/" target="_blank">阅读对应官方文档</a></p>
    
        <p class="date"><strong>🗓️ 2025-08-27</strong></p>
        <h2>Day 27 - 推送项目到 GitHub</h2>
        <p>今天你将学习如何将项目发布到 GitHub，包括 Git 仓库初始化、分支管理、CI/CD 配置和开源项目管理。这是现代软件开发不可或缺的技能，也是项目走向开源和协作的重要步骤。</p>
        
        <h3>🎯 学习目标</h3>
        <ul>
            <li>掌握 Git 版本控制和分支管理策略</li>
            <li>学会创建和管理 GitHub 仓库</li>
            <li>配置 GitHub Actions CI/CD 流水线</li>
            <li>设置项目安全和质量检查</li>
            <li>实现自动化发布和部署流程</li>
        </ul>

        <h3>📁 项目结构</h3>
        <pre>day27_github_setup/
├── .github/
│   ├── workflows/
│   │   ├── ci.yml
│   │   ├── release.yml
│   │   ├── security.yml
│   │   └── deploy.yml
│   ├── ISSUE_TEMPLATE/
│   │   ├── bug_report.md
│   │   ├── feature_request.md
│   │   └── security_issue.md
│   ├── PULL_REQUEST_TEMPLATE.md
│   ├── CODEOWNERS
│   └── dependabot.yml
├── scripts/
│   ├── setup-git.sh
│   ├── create-release.sh
│   ├── sync-fork.sh
│   └── github-setup.sh
├── docs/
│   ├── CONTRIBUTING.md
│   ├── CODE_OF_CONDUCT.md
│   ├── SECURITY.md
│   └── SUPPORT.md
├── src/
│   ├── main.rs
│   ├── server.rs
│   ├── config.rs
│   └── health.rs
├── tests/
│   ├── integration_test.rs
│   └── e2e_test.rs
├── .gitignore
├── .gitattributes
├── LICENSE
├── README.md
├── Cargo.toml
└── rust-toolchain.toml</pre>

        <h3>🚀 实现步骤</h3>

        <h4>步骤 1: Git 仓库初始化和配置</h4>
        <p><strong>scripts/setup-git.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "🚀 Setting up Git repository for WebSocket Server"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if git is installed
if ! command -v git &> /dev/null; then
    print_error "Git is not installed. Please install Git first."
    exit 1
fi

# Get user information
read -p "Enter your name for Git commits: " GIT_NAME
read -p "Enter your email for Git commits: " GIT_EMAIL
read -p "Enter your GitHub username: " GITHUB_USERNAME

# Configure Git globally if not already configured
if [ -z "$(git config --global user.name)" ]; then
    print_status "Configuring Git user information..."
    git config --global user.name "$GIT_NAME"
    git config --global user.email "$GIT_EMAIL"
    print_success "Git user configuration completed"
fi

# Configure Git settings for better experience
print_status "Configuring Git settings..."
git config --global init.defaultBranch main
git config --global pull.rebase false
git config --global core.autocrlf input
git config --global core.editor "code --wait" || git config --global core.editor "nano"
git config --global merge.conflictStyle diff3
git config --global diff.colorMoved zebra

# Initialize repository if not already a git repo
if [ ! -d ".git" ]; then
    print_status "Initializing Git repository..."
    git init
    print_success "Git repository initialized"
else
    print_warning "Already a Git repository"
fi

# Create .gitignore if it doesn't exist
if [ ! -f ".gitignore" ]; then
    print_status "Creating .gitignore file..."
    cat > .gitignore << 'EOF'
# Rust
/target/
**/*.rs.bk
*.pdb

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
*.log
logs/

# Environment variables
.env
.env.local
.env.*.local

# Node modules (for documentation tools)
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/

# Docker
.docker/

# Kubernetes
kubeconfig
*.kubeconfig

# Temporary files
*.tmp
*.temp
/tmp/

# Coverage reports
coverage/
*.profraw
tarpaulin-report.html

# Benchmarks
/benches/target/

# Documentation builds
/target/doc/
/docs/_build/

# Security
*.pem
*.key
*.crt
secrets.yaml
EOF
    print_success ".gitignore created"
fi

# Create .gitattributes for consistent line endings
if [ ! -f ".gitattributes" ]; then
    print_status "Creating .gitattributes file..."
    cat > .gitattributes << 'EOF'
# Auto detect text files and perform LF normalization
* text=auto

# Rust files
*.rs text eol=lf
*.toml text eol=lf

# Documentation
*.md text eol=lf
*.txt text eol=lf

# Scripts
*.sh text eol=lf
*.py text eol=lf
*.js text eol=lf
*.yml text eol=lf
*.yaml text eol=lf
*.json text eol=lf

# Binary files
*.png binary
*.jpg binary
*.jpeg binary
*.gif binary
*.ico binary
*.woff binary
*.woff2 binary
EOF
    print_success ".gitattributes created"
fi

# Create rust-toolchain.toml for consistent Rust version
if [ ! -f "rust-toolchain.toml" ]; then
    print_status "Creating rust-toolchain.toml..."
    cat > rust-toolchain.toml << 'EOF'
[toolchain]
channel = "stable"
components = ["rustfmt", "clippy", "rust-src"]
targets = ["x86_64-unknown-linux-gnu", "aarch64-unknown-linux-gnu"]
profile = "default"
EOF
    print_success "rust-toolchain.toml created"
fi

# Create initial commit if no commits exist
if [ -z "$(git log --oneline 2>/dev/null)" ]; then
    print_status "Creating initial commit..."
    git add .
    git commit -m "feat: initial commit

- Add WebSocket server implementation
- Configure development environment
- Add documentation and examples
- Set up CI/CD workflows

🚀 Generated with Claude Code"
    print_success "Initial commit created"
fi

# Display current status
print_status "Repository status:"
git status --short
echo ""
git log --oneline -5

print_success "Git repository setup completed!"
echo ""
print_status "Next steps:"
echo "1. Create GitHub repository: gh repo create websocket-server --public"
echo "2. Add remote: git remote add origin https://github.com/$GITHUB_USERNAME/websocket-server.git"
echo "3. Push to GitHub: git push -u origin main"</code></pre>

        <h4>步骤 2: GitHub Actions CI/CD 配置</h4>
        <p><strong>.github/workflows/ci.yml:</strong></p>
        <pre><code>name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust:
          - stable
          - beta
          - 1.70.0  # MSRV (Minimum Supported Rust Version)
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
        components: rustfmt, clippy

    - name: Cache cargo registry
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ matrix.rust }}-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-${{ matrix.rust }}-
          ${{ runner.os }}-cargo-

    - name: Check formatting
      if: matrix.rust == 'stable'
      run: cargo fmt --all -- --check

    - name: Run clippy
      if: matrix.rust == 'stable'
      run: cargo clippy --all-targets --all-features -- -D warnings

    - name: Build
      run: cargo build --verbose --all-features

    - name: Run tests
      run: cargo test --verbose --all-features
      env:
        RUST_LOG: debug

    - name: Run integration tests
      run: cargo test --test integration_test --verbose
      env:
        RUST_LOG: debug

    - name: Generate documentation
      if: matrix.rust == 'stable'
      run: cargo doc --no-deps --all-features

  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable

    - name: Install cargo-tarpaulin
      run: cargo install cargo-tarpaulin

    - name: Generate coverage report
      run: cargo tarpaulin --verbose --all-features --workspace --timeout 120 --out xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: cobertura.xml
        fail_ci_if_error: true

  audit:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable

    - name: Install cargo-audit
      run: cargo install cargo-audit

    - name: Run security audit
      run: cargo audit

  docker:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [test]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: false
        tags: websocket-server:test
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Test Docker image
      run: |
        docker run --rm -d --name test-container -p 3000:3000 websocket-server:test
        sleep 10
        curl -f http://localhost:3000/health || exit 1
        docker stop test-container</code></pre>

        <h4>步骤 3: GitHub 仓库管理脚本</h4>
        <p><strong>scripts/github-setup.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "🚀 Setting up GitHub repository and integrations"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if GitHub CLI is installed
if ! command -v gh &> /dev/null; then
    print_error "GitHub CLI (gh) is not installed."
    print_warning "Please install it from: https://github.com/cli/cli#installation"
    print_warning "Or use the web interface to create the repository manually."
    exit 1
fi

# Check if user is authenticated
if ! gh auth status &> /dev/null; then
    print_warning "Not authenticated with GitHub. Please run: gh auth login"
    exit 1
fi

# Get repository information
read -p "Enter repository name (default: websocket-server): " REPO_NAME
REPO_NAME=${REPO_NAME:-websocket-server}

read -p "Enter repository description: " REPO_DESC
read -p "Make repository public? (y/N): " IS_PUBLIC

if [[ $IS_PUBLIC =~ ^[Yy]$ ]]; then
    VISIBILITY="--public"
else
    VISIBILITY="--private"
fi

# Create GitHub repository
print_status "Creating GitHub repository: $REPO_NAME"
if gh repo create "$REPO_NAME" $VISIBILITY --description "$REPO_DESC" --clone=false; then
    print_success "Repository created successfully"
else
    print_warning "Repository might already exist or creation failed"
fi

# Get GitHub username
GITHUB_USER=$(gh api user --jq '.login')

# Add remote if not already added
if ! git remote get-url origin &> /dev/null; then
    print_status "Adding GitHub remote..."
    git remote add origin "https://github.com/$GITHUB_USER/$REPO_NAME.git"
    print_success "Remote added"
else
    print_warning "Remote origin already exists"
fi

# Push to GitHub
print_status "Pushing code to GitHub..."
git push -u origin main

# Set up repository settings
print_status "Configuring repository settings..."

# Enable vulnerability alerts
gh api repos/$GITHUB_USER/$REPO_NAME --method PATCH --field has_vulnerability_alerts=true

# Set up branch protection
print_status "Setting up branch protection rules..."
gh api repos/$GITHUB_USER/$REPO_NAME/branches/main/protection \
    --method PUT \
    --field required_status_checks='{"strict":true,"contexts":["test","coverage","audit","docker"]}' \
    --field enforce_admins=true \
    --field required_pull_request_reviews='{"required_approving_review_count":1,"dismiss_stale_reviews":true,"require_code_owner_reviews":true}' \
    --field restrictions=null \
    --field allow_force_pushes=false \
    --field allow_deletions=false || print_warning "Branch protection setup failed (might require admin permissions)"

# Create repository labels
print_status "Creating repository labels..."
labels=(
    "bug,d73a4a,Something isn't working"
    "documentation,0075ca,Improvements or additions to documentation"
    "enhancement,a2eeef,New feature or request"
    "good first issue,7057ff,Good for newcomers"
    "help wanted,008672,Extra attention is needed"
    "priority:high,b60205,High priority"
    "priority:medium,fbca04,Medium priority"
    "priority:low,0e8a16,Low priority"
    "type:feature,0052cc,New feature"
    "type:bugfix,d93f0b,Bug fix"
    "type:docs,1d76db,Documentation"
    "status:in-progress,ededed,Work in progress"
    "status:needs-review,bfd4f2,Needs review"
)

for label in "${labels[@]}"; do
    IFS=',' read -r name color description <<< "$label"
    gh label create "$name" --color "$color" --description "$description" --force
done

print_success "Repository labels created"

# Set up repository topics
print_status "Adding repository topics..."
gh repo edit --add-topic "rust,websocket,server,axum,tokio,real-time,kubernetes,docker,ci-cd"

print_success "GitHub repository setup completed!"
echo ""
print_status "Repository URL: https://github.com/$GITHUB_USER/$REPO_NAME"
print_status "Actions URL: https://github.com/$GITHUB_USER/$REPO_NAME/actions"
echo ""
print_status "Next steps:"
echo "1. Set up repository secrets for CI/CD"
echo "2. Review and customize branch protection rules"
echo "3. Create your first release: git tag v0.1.0 && git push --tags"</code></pre>

        <h4>步骤 4: 自动化发布脚本</h4>
        <p><strong>scripts/create-release.sh:</strong></p>
        <pre><code>#!/bin/bash

set -e

echo "🚀 Creating a new release for WebSocket Server"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check prerequisites
if ! command -v git &> /dev/null; then
    print_error "Git is not installed"
    exit 1
fi

if ! command -v cargo &> /dev/null; then
    print_error "Cargo is not installed"
    exit 1
fi

# Check if we're on main branch
CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "main" ]; then
    print_error "Not on main branch. Please switch to main branch first."
    exit 1
fi

# Check if working directory is clean
if [ -n "$(git status --porcelain)" ]; then
    print_error "Working directory is not clean. Please commit or stash changes."
    exit 1
fi

# Pull latest changes
print_status "Pulling latest changes from origin..."
git pull origin main

# Get current version from Cargo.toml
CURRENT_VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].version')
print_status "Current version: $CURRENT_VERSION"

# Ask for new version
echo "What type of release is this?"
echo "1) Patch (bug fixes)"
echo "2) Minor (new features, backward compatible)"
echo "3) Major (breaking changes)"
echo "4) Custom version"
read -p "Enter choice (1-4): " RELEASE_TYPE

case $RELEASE_TYPE in
    1)
        NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{$NF = $NF + 1;} 1' | sed 's/ /./g')
        ;;
    2)
        NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{$(NF-1) = $(NF-1) + 1; $NF = 0} 1' | sed 's/ /./g')
        ;;
    3)
        NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{$(NF-2) = $(NF-2) + 1; $(NF-1) = 0; $NF = 0} 1' | sed 's/ /./g')
        ;;
    4)
        read -p "Enter new version (e.g., 1.2.3): " NEW_VERSION
        ;;
    *)
        print_error "Invalid choice"
        exit 1
        ;;
esac

print_status "New version will be: $NEW_VERSION"
read -p "Continue? (y/N): " CONFIRM

if [[ ! $CONFIRM =~ ^[Yy]$ ]]; then
    print_warning "Release cancelled"
    exit 0
fi

# Update version in Cargo.toml
print_status "Updating Cargo.toml version..."
sed -i.bak "s/^version = \"$CURRENT_VERSION\"/version = \"$NEW_VERSION\"/" Cargo.toml
rm Cargo.toml.bak

# Update Cargo.lock
print_status "Updating Cargo.lock..."
cargo check --quiet

# Run tests to make sure everything works
print_status "Running tests..."
cargo test --all-features

# Generate changelog entry
print_status "Generating changelog entry..."
CHANGELOG_FILE="CHANGELOG.md"

# Get commits since last tag
LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
if [ -n "$LAST_TAG" ]; then
    COMMITS=$(git log --pretty=format:"- %s" $LAST_TAG..HEAD --reverse)
else
    COMMITS="- Initial release"
fi

# Create or update changelog
if [ ! -f "$CHANGELOG_FILE" ]; then
    echo "# Changelog" > $CHANGELOG_FILE
    echo "" >> $CHANGELOG_FILE
fi

# Add new version entry
TEMP_FILE=$(mktemp)
{
    echo "# Changelog"
    echo ""
    echo "## [v$NEW_VERSION] - $(date +%Y-%m-%d)"
    echo ""
    echo "$COMMITS"
    echo ""
    tail -n +3 "$CHANGELOG_FILE" 2>/dev/null || true
} > "$TEMP_FILE"
mv "$TEMP_FILE" "$CHANGELOG_FILE"

# Commit version bump and changelog
print_status "Committing version bump..."
git add Cargo.toml Cargo.lock $CHANGELOG_FILE
git commit -m "chore: bump version to v$NEW_VERSION

- Update version in Cargo.toml
- Update Cargo.lock
- Add changelog entry for v$NEW_VERSION

🚀 Generated with Claude Code"

# Create and push tag
print_status "Creating git tag..."
git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"

# Push changes and tag
print_status "Pushing changes to GitHub..."
git push origin main
git push origin "v$NEW_VERSION"

# Create GitHub release if CLI is available
if command -v gh &> /dev/null; then
    print_status "Creating GitHub release..."
    gh release create "v$NEW_VERSION" \
        --title "Release v$NEW_VERSION" \
        --notes-from-tag \
        --target main
    
    print_success "GitHub release created!"
else
    print_warning "GitHub CLI not found. Please create the release manually."
fi

print_success "Release v$NEW_VERSION created successfully!"
echo ""
print_status "GitHub Actions will now build and publish:"
echo "  - Release binaries for multiple platforms"
echo "  - Docker images to Docker Hub"
echo "  - Crate to crates.io (if configured)"</code></pre>

        <h4>步骤 5: Issue 和 PR 模板</h4>
        <p><strong>.github/ISSUE_TEMPLATE/bug_report.md:</strong></p>
        <pre><code>---
name: 🐛 Bug Report
about: Create a report to help us improve
title: '[BUG] '
labels: 'bug'
assignees: ''
---

## 🐛 Bug Description
A clear and concise description of what the bug is.

## 🔄 Steps to Reproduce
1. Go to '...'
2. Click on '....'
3. See error

## ✅ Expected Behavior
A clear description of what you expected to happen.

## ❌ Actual Behavior  
A clear description of what actually happened.

## 🌍 Environment
**Server Information:**
- OS: [e.g. Ubuntu 20.04, macOS 12.0]
- Rust version: [e.g. 1.70.0]
- WebSocket Server version: [e.g. 1.0.0]

**Client Information:**
- Browser/Client: [e.g. Chrome 91, Firefox 89]
- Client library: [e.g. native WebSocket, ws library]

## 📋 Logs
<details>
<summary>Server Logs</summary>

```
Paste your server logs here
```
</details>

## ✅ Checklist
- [ ] I have searched for similar issues
- [ ] I have read the documentation
- [ ] I have provided all requested information</code></pre>

        <p><strong>.github/PULL_REQUEST_TEMPLATE.md:</strong></p>
        <pre><code># 🚀 Pull Request

## 📋 Description
Brief description of the changes in this PR.

Fixes #(issue number)

## 🔄 Type of Change
- [ ] 🐛 Bug fix (non-breaking change which fixes an issue)
- [ ] ✨ New feature (non-breaking change which adds functionality)  
- [ ] 💥 Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] 📝 Documentation update
- [ ] 🧪 Test improvements

## 🧪 How Has This Been Tested?
Please describe the tests that you ran to verify your changes:

- [ ] Unit tests
- [ ] Integration tests
- [ ] Manual testing

## ✅ Checklist
**Code Quality:**
- [ ] My code follows the project's style guidelines
- [ ] I have performed a self-review of my own code
- [ ] I have run `cargo fmt` and `cargo clippy`

**Testing:**
- [ ] I have added tests that prove my fix is effective
- [ ] New and existing unit tests pass locally
- [ ] I have tested the WebSocket functionality manually

**Documentation:**
- [ ] I have updated the documentation accordingly
- [ ] I have added examples if this introduces new functionality

## 📝 Additional Notes
Any additional information for reviewers.</code></pre>

        <h3>🎯 使用步骤</h3>
        <ol>
            <li><strong>初始化 Git 仓库:</strong></li>
            <pre><code>chmod +x scripts/*.sh
./scripts/setup-git.sh</code></pre>

            <li><strong>创建 GitHub 仓库:</strong></li>
            <pre><code># 安装 GitHub CLI
brew install gh  # macOS
# 或 apt install gh  # Ubuntu

# 登录 GitHub
gh auth login

# 创建并配置仓库
./scripts/github-setup.sh</code></pre>

            <li><strong>测试 CI/CD 流水线:</strong></li>
            <pre><code># 推送代码触发 CI
git add .
git commit -m "feat: add awesome feature"
git push

# 查看 Actions 状态
gh run list</code></pre>

            <li><strong>创建发布版本:</strong></li>
            <pre><code>./scripts/create-release.sh</code></pre>

            <li><strong>管理仓库设置:</strong></li>
            <pre><code># 查看仓库信息
gh repo view

# 管理分支保护规则
gh api repos/:owner/:repo/branches/main/protection

# 管理 secrets
gh secret set DOCKER_USERNAME
gh secret set DOCKER_PASSWORD</code></pre>
        </ol>

        <h3>🌟 GitHub 集成特性</h3>
        <ul>
            <li><strong>自动化 CI/CD:</strong> 测试、构建、安全扫描全流程自动化</li>
            <li><strong>多平台构建:</strong> 支持 Linux、macOS、Windows 多架构</li>
            <li><strong>Docker 发布:</strong> 自动构建和发布 Docker 镜像</li>
            <li><strong>依赖管理:</strong> Dependabot 自动更新依赖</li>
            <li><strong>安全扫描:</strong> 自动安全漏洞检测和修复</li>
            <li><strong>代码质量:</strong> 自动代码格式化和静态分析</li>
            <li><strong>发布管理:</strong> 自动化版本发布和 changelog 生成</li>
        </ul>

        <h3>🎓 学习要点</h3>
        <ul>
            <li>掌握 Git 工作流和分支管理策略</li>
            <li>学习 GitHub Actions 的配置和使用</li>
            <li>了解开源项目的管理和协作流程</li>
            <li>实践 CI/CD 流水线的设计和优化</li>
            <li>体验现代软件开发的自动化工具链</li>
        </ul>

        <p>🔗 <a href="https://docs.github.com/en/get-started" target="_blank">阅读对应官方文档</a></p>
    
        <p class="date"><strong>🗓️ 2025-08-28</strong></p>
        <h2>Day 28 - Docker Hub 部署与容器注册表管理</h2>
        <p>掌握 Docker Hub 部署策略、自动化发布流水线、多架构镜像构建和容器注册表管理的最佳实践。</p>
        
        <h3>学习目标</h3>
        <ul>
            <li>掌握 Docker Hub 账户设置和仓库管理</li>
            <li>学习多架构 Docker 镜像构建和发布</li>
            <li>实现自动化容器发布流水线</li>
            <li>了解镜像标签策略和版本管理</li>
            <li>体验容器安全扫描和漏洞管理</li>
            <li>学习私有注册表和企业级部署策略</li>
        </ul>
        <p>🔗 <a href="https://docs.docker.com/docker-hub/" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: Docker Hub 账户设置和仓库创建</strong></p>
        <pre>📁 项目结构：
day28_docker_deployment/
├── src/
│   ├── main.rs
│   ├── websocket/
│   │   ├── mod.rs
│   │   ├── server.rs
│   │   ├── client.rs
│   │   └── message.rs
│   └── lib.rs
├── Cargo.toml
├── Dockerfile
├── Dockerfile.alpine
├── Dockerfile.distroless
├── .dockerignore
├── docker-compose.yml
├── docker-compose.prod.yml
├── scripts/
│   ├── build-multi-arch.sh
│   ├── push-to-registry.sh
│   ├── security-scan.sh
│   └── deploy-production.sh
├── .github/
│   └── workflows/
│       ├── docker-build.yml
│       ├── docker-security.yml
│       └── docker-release.yml
└── configs/
    ├── nginx.conf
    ├── docker-daemon.json
    └── registry-config.yml</pre>

        <p><strong>Docker Hub 账户配置脚本：</strong></p>
        <pre># scripts/setup-dockerhub.sh
#!/bin/bash
set -euo pipefail

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查 Docker 是否安装
if ! command -v docker &> /dev/null; then
    log_error "Docker 未安装，请先安装 Docker"
    exit 1
fi

# 检查 Docker 是否运行
if ! docker info &> /dev/null; then
    log_error "Docker 服务未运行，请启动 Docker"
    exit 1
fi

# Docker Hub 登录
log_info "配置 Docker Hub 认证..."
read -p "输入 Docker Hub 用户名: " DOCKER_USERNAME
read -s -p "输入 Docker Hub 密码或访问令牌: " DOCKER_PASSWORD
echo

# 登录到 Docker Hub
echo "$DOCKER_PASSWORD" | docker login --username "$DOCKER_USERNAME" --password-stdin

if [ $? -eq 0 ]; then
    log_info "Docker Hub 登录成功"
else
    log_error "Docker Hub 登录失败"
    exit 1
fi

# 保存配置
mkdir -p ~/.docker
cat > ~/.docker/config.json << EOF
{
    "auths": {
        "https://index.docker.io/v1/": {}
    },
    "experimental": "enabled",
    "features": {
        "buildkit": true
    }
}
EOF

# 创建 Docker Hub 仓库配置
cat > .dockerhub-config << EOF
DOCKER_USERNAME=$DOCKER_USERNAME
DOCKER_REPOSITORY=rust-websocket-server
DOCKER_REGISTRY=docker.io
IMAGE_NAME=$DOCKER_USERNAME/rust-websocket-server
EOF

log_info "Docker Hub 配置完成"
log_info "配置文件保存在: .dockerhub-config"
log_warn "请确保将 .dockerhub-config 添加到 .gitignore 中"</pre>

        <p><strong>步骤 2: 多架构 Dockerfile 优化</strong></p>
        <pre># Dockerfile - 生产级多阶段构建
# 支持 linux/amd64, linux/arm64, linux/arm/v7
FROM --platform=$BUILDPLATFORM rust:1.75-alpine AS builder

# 安装构建依赖
RUN apk add --no-cache \
    musl-dev \
    pkgconfig \
    openssl-dev \
    ca-certificates \
    git

# 设置工作目录
WORKDIR /app

# 复制 Cargo 配置
COPY Cargo.toml Cargo.lock ./

# 创建空的 src/main.rs 用于依赖缓存
RUN mkdir src && echo "fn main() {}" > src/main.rs

# 构建依赖（缓存层）
RUN cargo build --release && rm -rf src

# 复制源代码
COPY src ./src

# 构建应用
ARG TARGETPLATFORM
RUN case "$TARGETPLATFORM" in \
        "linux/amd64") TARGET="x86_64-unknown-linux-musl" ;; \
        "linux/arm64") TARGET="aarch64-unknown-linux-musl" ;; \
        "linux/arm/v7") TARGET="armv7-unknown-linux-musleabihf" ;; \
        *) echo "Unsupported platform: $TARGETPLATFORM" && exit 1 ;; \
    esac && \
    rustup target add $TARGET && \
    cargo build --release --target $TARGET && \
    cp target/$TARGET/release/rust-websocket-server /app/websocket-server

# 运行时镜像
FROM scratch

# 复制 CA 证书
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# 复制二进制文件
COPY --from=builder /app/websocket-server /websocket-server

# 创建非 root 用户
COPY --from=builder /etc/passwd /etc/passwd
USER 1000:1000

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD ["/websocket-server", "--health-check"]

# 启动应用
ENTRYPOINT ["/websocket-server"]</pre>

        <p><strong>Alpine 版本 Dockerfile：</strong></p>
        <pre># Dockerfile.alpine - 更小的镜像但有 libc 依赖
FROM rust:1.75-alpine AS builder

RUN apk add --no-cache musl-dev pkgconfig openssl-dev

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

RUN cargo build --release --target x86_64-unknown-linux-musl

FROM alpine:3.19

RUN apk add --no-cache ca-certificates && \
    adduser -D -s /bin/sh -u 1000 appuser

COPY --from=builder /app/target/x86_64-unknown-linux-musl/release/rust-websocket-server /usr/local/bin/websocket-server

USER appuser
EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD websocket-server --health-check || exit 1

CMD ["websocket-server"]</pre>

        <p><strong>Distroless 版本 Dockerfile：</strong></p>
        <pre># Dockerfile.distroless - 最小化安全镜像
FROM rust:1.75-bookworm AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

# 静态链接构建
ENV RUSTFLAGS="-C target-feature=+crt-static"
RUN cargo build --release --target x86_64-unknown-linux-gnu

FROM gcr.io/distroless/static-debian12:nonroot

COPY --from=builder /app/target/x86_64-unknown-linux-gnu/release/rust-websocket-server /websocket-server

EXPOSE 8080
USER nonroot:nonroot

ENTRYPOINT ["/websocket-server"]</pre>

        <p><strong>步骤 3: 多架构构建脚本</strong></p>
        <pre># scripts/build-multi-arch.sh
#!/bin/bash
set -euo pipefail

source .dockerhub-config

# 颜色输出
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# 版本管理
VERSION=${1:-$(date +%Y%m%d-%H%M%S)}
LATEST_TAG="latest"
VERSION_TAG="v$VERSION"

log_info "构建多架构 Docker 镜像..."
log_info "版本: $VERSION_TAG"
log_info "镜像名: $IMAGE_NAME"

# 确保 buildx 可用
docker buildx version || {
    log_error "Docker buildx 不可用，请更新 Docker"
    exit 1
}

# 创建多架构构建器
BUILDER_NAME="rust-websocket-builder"
if ! docker buildx ls | grep -q "$BUILDER_NAME"; then
    log_info "创建多架构构建器..."
    docker buildx create --name "$BUILDER_NAME" --driver docker-container --bootstrap
fi

# 使用构建器
docker buildx use "$BUILDER_NAME"

# 构建并推送多架构镜像
log_info "开始多架构构建..."

# 主镜像（scratch 基础）
docker buildx build \
    --platform linux/amd64,linux/arm64,linux/arm/v7 \
    --tag "$IMAGE_NAME:$LATEST_TAG" \
    --tag "$IMAGE_NAME:$VERSION_TAG" \
    --tag "$IMAGE_NAME:scratch-$VERSION_TAG" \
    --push \
    -f Dockerfile \
    .

# Alpine 镜像
docker buildx build \
    --platform linux/amd64,linux/arm64 \
    --tag "$IMAGE_NAME:alpine" \
    --tag "$IMAGE_NAME:alpine-$VERSION_TAG" \
    --push \
    -f Dockerfile.alpine \
    .

# Distroless 镜像
docker buildx build \
    --platform linux/amd64,linux/arm64 \
    --tag "$IMAGE_NAME:distroless" \
    --tag "$IMAGE_NAME:distroless-$VERSION_TAG" \
    --push \
    -f Dockerfile.distroless \
    .

log_info "多架构镜像构建完成！"
log_info "可用标签："
echo "  - $IMAGE_NAME:latest"
echo "  - $IMAGE_NAME:$VERSION_TAG"
echo "  - $IMAGE_NAME:alpine"
echo "  - $IMAGE_NAME:distroless"

# 显示镜像信息
log_info "验证镜像信息..."
docker buildx imagetools inspect "$IMAGE_NAME:$LATEST_TAG"</pre>

        <p><strong>步骤 4: 自动化发布流水线</strong></p>
        <pre># .github/workflows/docker-release.yml
name: Docker Release

on:
  push:
    tags:
      - 'v*'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version'
        required: true
        default: 'v1.0.0'

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write

    strategy:
      matrix:
        dockerfile:
          - { file: 'Dockerfile', tag: 'latest', platforms: 'linux/amd64,linux/arm64,linux/arm/v7' }
          - { file: 'Dockerfile.alpine', tag: 'alpine', platforms: 'linux/amd64,linux/arm64' }
          - { file: 'Dockerfile.distroless', tag: 'distroless', platforms: 'linux/amd64,linux/arm64' }

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        flavor: |
          latest=false
          suffix=-${{ matrix.dockerfile.tag }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=${{ matrix.dockerfile.tag }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ matrix.dockerfile.file }}
        platforms: ${{ matrix.dockerfile.platforms }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        provenance: true
        sbom: true

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.dockerfile.tag }}
        format: spdx-json
        output-file: sbom-${{ matrix.dockerfile.tag }}.spdx.json

    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom-${{ matrix.dockerfile.tag }}
        path: sbom-${{ matrix.dockerfile.tag }}.spdx.json

  security-scan:
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      security-events: write

    strategy:
      matrix:
        tag: ['latest', 'alpine', 'distroless']

    steps:
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.tag }}
        format: 'sarif'
        output: 'trivy-results-${{ matrix.tag }}.sarif'

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results-${{ matrix.tag }}.sarif'

  update-readme:
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
    - name: Update Docker Hub README
      uses: peter-evans/dockerhub-description@v4
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
        repository: ${{ env.IMAGE_NAME }}
        readme-filepath: ./README.md</pre>

        <p><strong>步骤 5: 安全扫描和漏洞管理</strong></p>
        <pre># scripts/security-scan.sh
#!/bin/bash
set -euo pipefail

source .dockerhub-config

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 安装 Trivy
install_trivy() {
    if ! command -v trivy &> /dev/null; then
        log_info "安装 Trivy 安全扫描工具..."
        if [[ "$OSTYPE" == "darwin"* ]]; then
            brew install trivy
        elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
        else
            log_error "不支持的操作系统"
            exit 1
        fi
    fi
}

# 扫描镜像漏洞
scan_image() {
    local image=$1
    local output_dir="security-reports"
    
    mkdir -p "$output_dir"
    
    log_info "扫描镜像: $image"
    
    # 漏洞扫描
    trivy image \
        --format json \
        --output "$output_dir/vuln-${image//\//-}.json" \
        "$image"
    
    # 生成 HTML 报告
    trivy image \
        --format template \
        --template '@contrib/html.tpl' \
        --output "$output_dir/vuln-${image//\//-}.html" \
        "$image"
    
    # 检查高危漏洞
    HIGH_VULNS=$(trivy image --format json "$image" | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")] | length')
    
    if [ "$HIGH_VULNS" -gt 0 ]; then
        log_warn "发现 $HIGH_VULNS 个高危漏洞"
        trivy image --severity HIGH,CRITICAL "$image"
    else
        log_info "未发现高危漏洞"
    fi
}

# 配置扫描
scan_configuration() {
    local dockerfile=$1
    
    log_info "扫描配置文件: $dockerfile"
    
    # Dockerfile 最佳实践检查
    trivy config \
        --format json \
        --output "security-reports/config-${dockerfile}.json" \
        "$dockerfile"
    
    # 显示配置问题
    trivy config "$dockerfile"
}

# 主扫描流程
main() {
    install_trivy
    
    log_info "开始安全扫描..."
    
    # 扫描 Dockerfile 配置
    for dockerfile in Dockerfile Dockerfile.alpine Dockerfile.distroless; do
        if [ -f "$dockerfile" ]; then
            scan_configuration "$dockerfile"
        fi
    done
    
    # 扫描构建的镜像
    IMAGES=(
        "$IMAGE_NAME:latest"
        "$IMAGE_NAME:alpine"
        "$IMAGE_NAME:distroless"
    )
    
    for image in "${IMAGES[@]}"; do
        if docker image inspect "$image" &> /dev/null; then
            scan_image "$image"
        else
            log_warn "镜像不存在: $image"
        fi
    done
    
    log_info "安全扫描完成，报告保存在 security-reports/ 目录"
}

main "$@"</pre>

        <p><strong>步骤 6: 生产部署配置</strong></p>
        <pre># docker-compose.prod.yml
version: '3.8'

services:
  websocket-server:
    image: ${DOCKER_USERNAME}/rust-websocket-server:latest
    container_name: websocket-server-prod
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      - RUST_LOG=info
      - WEBSOCKET_HOST=0.0.0.0
      - WEBSOCKET_PORT=8080
      - MAX_CONNECTIONS=1000
      - CONNECTION_TIMEOUT=300
    volumes:
      - ./logs:/app/logs:rw
      - ./configs/server.toml:/app/config.toml:ro
    networks:
      - websocket-net
    healthcheck:
      test: ["CMD", "/websocket-server", "--health-check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    read_only: true
    tmpfs:
      - /tmp:size=100M,noexec,nosuid,nodev

  nginx:
    image: nginx:alpine
    container_name: nginx-proxy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./configs/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certs:/etc/nginx/certs:ro
      - ./logs/nginx:/var/log/nginx:rw
    networks:
      - websocket-net
    depends_on:
      websocket-server:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 128M

  redis:
    image: redis:alpine
    container_name: redis-cache
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis-data:/data
    networks:
      - websocket-net
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M

  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./configs/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    networks:
      - websocket-net
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
      - '--web.enable-lifecycle'

networks:
  websocket-net:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  redis-data:
    driver: local
  prometheus-data:
    driver: local</pre>

        <p><strong>生产部署脚本：</strong></p>
        <pre># scripts/deploy-production.sh
#!/bin/bash
set -euo pipefail

source .dockerhub-config

# 环境变量
ENVIRONMENT=${1:-production}
COMPOSE_FILE="docker-compose.prod.yml"

log_info() {
    echo -e "\033[0;32m[INFO]\033[0m $1"
}

log_warn() {
    echo -e "\033[1;33m[WARN]\033[0m $1"
}

log_error() {
    echo -e "\033[0;31m[ERROR]\033[0m $1"
}

# 检查依赖
check_dependencies() {
    local deps=("docker" "docker-compose")
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            log_error "$dep 未安装"
            exit 1
        fi
    done
}

# 创建必要目录
setup_directories() {
    local dirs=("logs" "logs/nginx" "configs" "certs")
    
    for dir in "${dirs[@]}"; do
        mkdir -p "$dir"
    done
}

# 生成环境配置
generate_env_file() {
    cat > .env << EOF
# Docker 配置
DOCKER_USERNAME=$DOCKER_USERNAME
COMPOSE_PROJECT_NAME=websocket-prod

# 安全配置
REDIS_PASSWORD=$(openssl rand -base64 32)

# 服务配置
WEBSOCKET_MAX_CONNECTIONS=1000
WEBSOCKET_CONNECTION_TIMEOUT=300

# 日志配置
LOG_LEVEL=info
LOG_RETENTION_DAYS=30
EOF
    
    log_info "环境配置已生成: .env"
}

# 拉取最新镜像
pull_images() {
    log_info "拉取最新镜像..."
    docker-compose -f "$COMPOSE_FILE" pull
}

# 健康检查
health_check() {
    local service=$1
    local retries=30
    
    log_info "等待 $service 服务启动..."
    
    for i in $(seq 1 $retries); do
        if docker-compose -f "$COMPOSE_FILE" exec -T "$service" wget --quiet --tries=1 --spider http://localhost:8080/health 2>/dev/null; then
            log_info "$service 服务健康检查通过"
            return 0
        fi
        
        log_warn "健康检查失败，重试 $i/$retries"
        sleep 5
    done
    
    log_error "$service 服务启动失败"
    return 1
}

# 部署服务
deploy() {
    log_info "开始部署到 $ENVIRONMENT 环境..."
    
    # 停止旧服务
    docker-compose -f "$COMPOSE_FILE" down --remove-orphans
    
    # 清理无用镜像
    docker image prune -f
    
    # 启动服务
    docker-compose -f "$COMPOSE_FILE" up -d
    
    # 等待服务启动
    sleep 10
    
    # 健康检查
    if health_check "websocket-server"; then
        log_info "部署成功！"
        
        # 显示服务状态
        docker-compose -f "$COMPOSE_FILE" ps
        
        # 显示访问信息
        echo "===================="
        echo "服务访问信息："
        echo "WebSocket: ws://localhost:8080"
        echo "监控面板: http://localhost:9090"
        echo "===================="
    else
        log_error "部署失败"
        docker-compose -f "$COMPOSE_FILE" logs
        exit 1
    fi
}

# 主流程
main() {
    check_dependencies
    setup_directories
    generate_env_file
    pull_images
    deploy
}

# 执行主流程
main "$@"</pre>

        <p><strong>步骤 7: 私有注册表配置</strong></p>
        <pre># configs/registry-config.yml
version: 0.1
log:
  fields:
    service: registry
storage:
  cache:
    blobdescriptor: inmemory
  filesystem:
    rootdirectory: /var/lib/registry
  delete:
    enabled: true
http:
  addr: :5000
  headers:
    X-Content-Type-Options: [nosniff]
    Access-Control-Allow-Origin: ['*']
    Access-Control-Allow-Methods: ['HEAD', 'GET', 'OPTIONS', 'DELETE']
    Access-Control-Allow-Headers: ['Authorization', 'Accept', 'Cache-Control']
auth:
  htpasswd:
    realm: basic-realm
    path: /auth/htpasswd
health:
  storagedriver:
    enabled: true
    interval: 10s
    threshold: 3</pre>

        <p><strong>私有注册表部署：</strong></p>
        <pre># docker-compose.registry.yml
version: '3.8'

services:
  registry:
    image: registry:2
    container_name: private-registry
    restart: unless-stopped
    ports:
      - "5000:5000"
    environment:
      REGISTRY_CONFIG_PATH: /etc/docker/registry/config.yml
    volumes:
      - ./configs/registry-config.yml:/etc/docker/registry/config.yml:ro
      - ./auth:/auth:ro
      - registry-data:/var/lib/registry
    networks:
      - registry-net

  registry-ui:
    image: joxit/docker-registry-ui:latest
    container_name: registry-ui
    restart: unless-stopped
    ports:
      - "8081:80"
    environment:
      REGISTRY_TITLE: Private Docker Registry
      REGISTRY_URL: http://registry:5000
      DELETE_IMAGES: true
      SHOW_CONTENT_DIGEST: true
    networks:
      - registry-net
    depends_on:
      - registry

networks:
  registry-net:
    driver: bridge

volumes:
  registry-data:
    driver: local</pre>

        <p><strong>步骤 8: 监控和日志管理</strong></p>
        <pre># configs/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "rules/*.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'websocket-server'
    static_configs:
      - targets: ['websocket-server:8080']
    metrics_path: '/metrics'
    scrape_interval: 10s

  - job_name: 'docker'
    static_configs:
      - targets: ['docker-exporter:9323']

  - job_name: 'node'
    static_configs:
      - targets: ['node-exporter:9100']</pre>

        <p><strong>实践练习：</strong></p>
        <ol>
            <li><strong>基础 Docker Hub 部署</strong>
                <pre>cd day28_docker_deployment
./scripts/setup-dockerhub.sh
./scripts/build-multi-arch.sh v1.0.0</pre>
            </li>
            <li><strong>自动化安全扫描</strong>
                <pre>./scripts/security-scan.sh
cat security-reports/vuln-*.json | jq '.Results[].Vulnerabilities | length'</pre>
            </li>
            <li><strong>生产环境部署</strong>
                <pre>./scripts/deploy-production.sh production
docker-compose -f docker-compose.prod.yml logs -f</pre>
            </li>
            <li><strong>私有注册表设置</strong>
                <pre>docker-compose -f docker-compose.registry.yml up -d
docker tag rust-websocket-server:latest localhost:5000/rust-websocket-server:latest
docker push localhost:5000/rust-websocket-server:latest</pre>
            </li>
        </ol>

        <p><strong>Docker Hub 最佳实践：</strong></p>
        <ul>
            <li>使用语义化版本标签 (v1.0.0, v1.1.0)</li>
            <li>为不同用例提供多种镜像变体 (alpine, distroless)</li>
            <li>启用自动构建和安全扫描</li>
            <li>编写详细的 README 文档</li>
            <li>定期更新基础镜像和依赖</li>
            <li>使用多阶段构建减小镜像大小</li>
            <li>实施镜像签名和验证</li>
            <li>监控镜像下载和使用情况</li>
        </ul>
    
        <p class="date"><strong>🗓️ 2025-08-29</strong></p>
        <h2>Day 29 - 综合知识回顾与架构优化分析</h2>
        <p>系统回顾 Rust WebSocket 项目的完整技术栈，进行架构分析和性能优化，制定企业级部署和扩展策略。</p>
        
        <h3>学习目标</h3>
        <ul>
            <li>全面回顾 Rust 语言核心概念和最佳实践</li>
            <li>分析 WebSocket 服务架构设计和性能特征</li>
            <li>评估容器化部署和 Kubernetes 集成效果</li>
            <li>制定可观测性、安全性和可扩展性优化计划</li>
            <li>准备企业级项目部署和运维策略</li>
            <li>设计未来功能扩展和技术演进路线图</li>
        </ul>
        <p>🔗 <a href="https://doc.rust-lang.org/book/" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: Rust 语言知识点回顾</strong></p>
        <pre>📁 项目结构：
day29_knowledge_review/
├── src/
│   ├── main.rs
│   ├── lib.rs
│   ├── review/
│   │   ├── mod.rs
│   │   ├── basics.rs
│   │   ├── ownership.rs
│   │   ├── error_handling.rs
│   │   ├── async_programming.rs
│   │   ├── traits_generics.rs
│   │   └── performance.rs
│   ├── analysis/
│   │   ├── mod.rs
│   │   ├── architecture.rs
│   │   ├── performance_metrics.rs
│   │   ├── security_audit.rs
│   │   └── scalability.rs
│   └── planning/
│       ├── mod.rs
│       ├── optimization.rs
│       ├── deployment.rs
│       └── roadmap.rs
├── Cargo.toml
├── benches/
│   ├── websocket_performance.rs
│   ├── memory_usage.rs
│   └── concurrent_connections.rs
├── docs/
│   ├── architecture-review.md
│   ├── performance-analysis.md
│   ├── security-checklist.md
│   └── deployment-guide.md
├── scripts/
│   ├── review-checklist.sh
│   ├── performance-test.sh
│   ├── security-scan.sh
│   └── generate-report.sh
└── configs/
    ├── prometheus-rules.yml
    ├── grafana-dashboard.json
    └── alerting-rules.yml</pre>

        <p><strong>Rust 基础概念回顾代码：</strong></p>
        <pre># src/review/basics.rs
//! Rust 基础语法和概念回顾

use std::collections::HashMap;
use std::fmt::Display;

/// 基础语法回顾和最佳实践演示
pub struct RustBasicsReview;

impl RustBasicsReview {
    /// 变量绑定和可变性回顾
    pub fn variable_bindings_review() {
        println!("=== 变量绑定和可变性 ===");
        
        // 不可变绑定（默认）
        let immutable_value = 42;
        println!("不可变值: {}", immutable_value);
        
        // 可变绑定
        let mut mutable_value = 10;
        println!("初始可变值: {}", mutable_value);
        mutable_value += 5;
        println!("修改后可变值: {}", mutable_value);
        
        // 变量遮蔽（shadowing）
        let x = 5;
        let x = x * 2; // 遮蔽前面的 x
        let x = format!("值是 {}", x); // 改变类型
        println!("遮蔽后的值: {}", x);
        
        // 常量
        const MAX_CONNECTIONS: u32 = 1000;
        println!("最大连接数: {}", MAX_CONNECTIONS);
    }
    
    /// 数据类型回顾
    pub fn data_types_review() {
        println!("=== 数据类型回顾 ===");
        
        // 标量类型
        let integer: i32 = 42;
        let float: f64 = 3.14159;
        let boolean: bool = true;
        let character: char = '🦀';
        
        println!("整数: {}, 浮点: {}, 布尔: {}, 字符: {}", 
                integer, float, boolean, character);
        
        // 复合类型
        let tuple: (i32, f64, bool) = (500, 6.4, true);
        let array: [i32; 5] = [1, 2, 3, 4, 5];
        
        let (x, y, z) = tuple; // 元组解构
        println!("元组解构: x={}, y={}, z={}", x, y, z);
        println!("数组第一个元素: {}", array[0]);
        
        // 字符串类型
        let string_literal = "Hello"; // &str
        let owned_string = String::from("World"); // String
        let concatenated = format!("{} {}", string_literal, owned_string);
        println!("字符串连接: {}", concatenated);
    }
    
    /// 控制流回顾
    pub fn control_flow_review() {
        println!("=== 控制流回顾 ===");
        
        // if 表达式
        let number = 42;
        let result = if number % 2 == 0 {
            "偶数"
        } else {
            "奇数"
        };
        println!("{} 是 {}", number, result);
        
        // 循环
        println!("for 循环:");
        for i in 1..=5 {
            println!("  计数: {}", i);
        }
        
        println!("while 循环:");
        let mut counter = 3;
        while counter > 0 {
            println!("  倒计时: {}", counter);
            counter -= 1;
        }
        
        println!("loop 循环:");
        let mut x = 0;
        let result = loop {
            x += 1;
            if x == 3 {
                break x * 2; // loop 可以返回值
            }
        };
        println!("  loop 返回值: {}", result);
        
        // match 表达式
        let value = Some(5);
        match value {
            Some(x) if x > 3 => println!("大于 3 的值: {}", x),
            Some(x) => println!("值: {}", x),
            None => println!("没有值"),
        }
    }
    
    /// 函数和闭包回顾
    pub fn functions_closures_review() {
        println!("=== 函数和闭包回顾 ===");
        
        // 普通函数
        fn add(a: i32, b: i32) -> i32 {
            a + b // 表达式返回
        }
        
        println!("函数调用: 5 + 3 = {}", add(5, 3));
        
        // 闭包
        let multiply = |x: i32, y: i32| x * y;
        println!("闭包调用: 4 * 6 = {}", multiply(4, 6));
        
        // 捕获环境的闭包
        let factor = 10;
        let scale = |x: i32| x * factor; // 捕获 factor
        println!("环境捕获闭包: 5 * {} = {}", factor, scale(5));
        
        // 高阶函数
        let numbers = vec![1, 2, 3, 4, 5];
        let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect();
        println!("映射操作: {:?} -> {:?}", numbers, doubled);
        
        let sum: i32 = numbers.iter().fold(0, |acc, x| acc + x);
        println!("折叠操作: 数组和 = {}", sum);
    }
}</pre>

        <p><strong>步骤 2: 所有权系统深度回顾</strong></p>
        <pre># src/review/ownership.rs
//! 所有权、借用和生命周期系统回顾

use std::rc::Rc;
use std::sync::Arc;
use std::cell::RefCell;

/// 所有权系统回顾
pub struct OwnershipReview;

impl OwnershipReview {
    /// 所有权转移回顾
    pub fn ownership_transfer_review() {
        println!("=== 所有权转移回顾 ===");
        
        // 移动语义
        let s1 = String::from("Hello");
        let s2 = s1; // s1 的所有权转移给 s2
        // println!("{}", s1); // 编译错误: s1 已经失效
        println!("s2 拥有字符串: {}", s2);
        
        // 克隆
        let s3 = s2.clone(); // 深度复制
        println!("s2: {}, s3: {}", s2, s3); // 都有效
        
        // 函数参数的所有权转移
        fn take_ownership(s: String) {
            println!("函数拥有: {}", s);
        } // s 在这里被销毁
        
        let s4 = String::from("World");
        take_ownership(s4);
        // println!("{}", s4); // 编译错误: s4 已失效
        
        // 返回所有权
        fn give_ownership() -> String {
            String::from("给予所有权")
        }
        
        let s5 = give_ownership();
        println!("获得所有权: {}", s5);
    }
    
    /// 借用和引用回顾
    pub fn borrowing_references_review() {
        println!("=== 借用和引用回顾 ===");
        
        let s = String::from("Hello World");
        
        // 不可变借用
        let len = calculate_length(&s);
        println!("字符串 '{}' 的长度是 {}", s, len);
        
        fn calculate_length(s: &String) -> usize {
            s.len()
        } // s 是引用，不拥有所有权
        
        // 可变借用
        let mut s = String::from("Hello");
        change_string(&mut s);
        println!("修改后的字符串: {}", s);
        
        fn change_string(s: &mut String) {
            s.push_str(", World!");
        }
        
        // 借用规则演示
        let mut s = String::from("示例");
        let r1 = &s; // 不可变借用
        let r2 = &s; // 可以有多个不可变借用
        println!("r1: {}, r2: {}", r1, r2);
        
        // r1 和 r2 在这里不再使用
        let r3 = &mut s; // 可变借用（在不可变借用结束后）
        println!("r3: {}", r3);
    }
    
    /// 生命周期回顾
    pub fn lifetimes_review() {
        println!("=== 生命周期回顾 ===");
        
        // 生命周期注解
        fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
            if x.len() > y.len() {
                x
            } else {
                y
            }
        }
        
        let string1 = String::from("长字符串");
        let string2 = "短";
        let result = longest(string1.as_str(), string2);
        println!("更长的字符串: {}", result);
        
        // 结构体中的生命周期
        struct ImportantExcerpt<'a> {
            part: &'a str,
        }
        
        let novel = String::from("很久很久以前。在一个遥远的星系...");
        let first_sentence = novel.split('.').next().expect("找不到句号");
        let i = ImportantExcerpt {
            part: first_sentence,
        };
        println!("重要摘录: {}", i.part);
    }
    
    /// 智能指针回顾
    pub fn smart_pointers_review() {
        println!("=== 智能指针回顾 ===");
        
        // Box<T> - 堆分配
        let b = Box::new(5);
        println!("Box 中的值: {}", b);
        
        // Rc<T> - 引用计数（单线程）
        let rc_value = Rc::new(String::from("共享值"));
        let rc1 = Rc::clone(&rc_value);
        let rc2 = Rc::clone(&rc_value);
        println!("Rc 引用计数: {}", Rc::strong_count(&rc_value));
        println!("通过 rc1 访问: {}", rc1);
        println!("通过 rc2 访问: {}", rc2);
        
        // Arc<T> - 原子引用计数（多线程）
        let arc_value = Arc::new(42);
        let arc1 = Arc::clone(&arc_value);
        let arc2 = Arc::clone(&arc_value);
        println!("Arc 值: {}, 引用计数: {}", arc1, Arc::strong_count(&arc_value));
        
        // RefCell<T> - 内部可变性
        let data = RefCell::new(5);
        println!("RefCell 初始值: {}", data.borrow());
        *data.borrow_mut() = 10;
        println!("RefCell 修改后: {}", data.borrow());
        
        // Rc<RefCell<T>> 组合使用
        let shared_mutable = Rc::new(RefCell::new(vec![1, 2, 3]));
        let shared1 = Rc::clone(&shared_mutable);
        let shared2 = Rc::clone(&shared_mutable);
        
        shared1.borrow_mut().push(4);
        shared2.borrow_mut().push(5);
        
        println!("共享可变数据: {:?}", shared_mutable.borrow());
    }
}</pre>

        <p><strong>步骤 3: 异步编程回顾</strong></p>
        <pre># src/review/async_programming.rs
//! 异步编程和并发模型回顾

use std::time::Duration;
use tokio::time::{sleep, timeout};
use tokio::sync::{mpsc, Mutex, RwLock};
use tokio::task;
use futures::future::{join, join_all, select, Either};
use std::sync::Arc;

/// 异步编程回顾
pub struct AsyncProgrammingReview;

impl AsyncProgrammingReview {
    /// Future 和 async/await 回顾
    pub async fn futures_async_await_review() {
        println!("=== Future 和 async/await 回顾 ===");
        
        // 基础 async 函数
        async fn simple_async_function() -> String {
            sleep(Duration::from_millis(100)).await;
            "异步函数完成".to_string()
        }
        
        let result = simple_async_function().await;
        println!("异步结果: {}", result);
        
        // 多个异步操作并发执行
        async fn fetch_data(id: u32) -> String {
            sleep(Duration::from_millis(50 * id as u64)).await;
            format!("数据 {}", id)
        }
        
        let (data1, data2, data3) = join!(
            fetch_data(1),
            fetch_data(2),
            fetch_data(3)
        );
        
        println!("并发获取: {}, {}, {}", data1, data2, data3);
        
        // 超时处理
        let slow_operation = async {
            sleep(Duration::from_secs(2)).await;
            "慢操作完成"
        };
        
        match timeout(Duration::from_millis(500), slow_operation).await {
            Ok(result) => println!("操作完成: {}", result),
            Err(_) => println!("操作超时"),
        }
    }
    
    /// 任务和并发回顾
    pub async fn tasks_concurrency_review() {
        println!("=== 任务和并发回顾 ===");
        
        // 生成异步任务
        let task1 = task::spawn(async {
            sleep(Duration::from_millis(100)).await;
            "任务 1 完成"
        });
        
        let task2 = task::spawn(async {
            sleep(Duration::from_millis(200)).await;
            "任务 2 完成"
        });
        
        // 等待任务完成
        let (result1, result2) = join!(task1, task2);
        println!("任务结果: {:?}, {:?}", result1, result2);
        
        // 任务集合
        let tasks: Vec<_> = (1..=5)
            .map(|i| task::spawn(async move {
                sleep(Duration::from_millis(i * 50)).await;
                format!("任务 {} 完成", i)
            }))
            .collect();
        
        let results = join_all(tasks).await;
        for result in results {
            match result {
                Ok(value) => println!("任务成功: {}", value),
                Err(e) => println!("任务失败: {}", e),
            }
        }
    }
    
    /// 通道和消息传递回顾
    pub async fn channels_message_passing_review() {
        println!("=== 通道和消息传递回顾 ===");
        
        // 单发送者单接收者通道
        let (tx, mut rx) = mpsc::channel::<String>(32);
        
        // 发送者任务
        let sender_task = task::spawn(async move {
            for i in 1..=5 {
                let message = format!("消息 {}", i);
                if tx.send(message.clone()).await.is_ok() {
                    println!("发送: {}", message);
                }
                sleep(Duration::from_millis(100)).await;
            }
        });
        
        // 接收者任务
        let receiver_task = task::spawn(async move {
            while let Some(message) = rx.recv().await {
                println!("接收: {}", message);
            }
        });
        
        join!(sender_task, receiver_task);
        
        // 多发送者单接收者
        let (tx, mut rx) = mpsc::channel::<String>(32);
        
        let senders: Vec<_> = (1..=3)
            .map(|id| {
                let tx = tx.clone();
                task::spawn(async move {
                    for i in 1..=3 {
                        let message = format!("发送者 {} 消息 {}", id, i);
                        let _ = tx.send(message).await;
                        sleep(Duration::from_millis(50)).await;
                    }
                })
            })
            .collect();
        
        drop(tx); // 关闭主发送者
        
        let receiver = task::spawn(async move {
            while let Some(message) = rx.recv().await {
                println!("多发送者接收: {}", message);
            }
        });
        
        join_all(senders).await;
        receiver.await.unwrap();
    }
    
    /// 异步同步原语回顾
    pub async fn async_synchronization_review() {
        println!("=== 异步同步原语回顾 ===");
        
        // 异步 Mutex
        let data = Arc::new(Mutex::new(0));
        let mut handles = vec![];
        
        for i in 0..5 {
            let data = Arc::clone(&data);
            let handle = task::spawn(async move {
                let mut num = data.lock().await;
                *num += 1;
                println!("任务 {} 增加计数器到: {}", i, *num);
                sleep(Duration::from_millis(10)).await;
            });
            handles.push(handle);
        }
        
        join_all(handles).await;
        println!("最终计数器值: {}", *data.lock().await);
        
        // 异步 RwLock
        let data = Arc::new(RwLock::new(vec![1, 2, 3]));
        
        // 多个读取者
        let readers: Vec<_> = (0..3)
            .map(|i| {
                let data = Arc::clone(&data);
                task::spawn(async move {
                    let guard = data.read().await;
                    println!("读取者 {}: {:?}", i, *guard);
                    sleep(Duration::from_millis(100)).await;
                })
            })
            .collect();
        
        // 一个写入者
        let writer = {
            let data = Arc::clone(&data);
            task::spawn(async move {
                sleep(Duration::from_millis(150)).await;
                let mut guard = data.write().await;
                guard.push(4);
                println!("写入者添加元素: {:?}", *guard);
            })
        };
        
        join_all(readers).await;
        writer.await.unwrap();
        
        println!("最终数据: {:?}", *data.read().await);
    }
    
    /// 异步错误处理回顾
    pub async fn async_error_handling_review() {
        println!("=== 异步错误处理回顾 ===");
        
        // Result 在异步中的使用
        async fn fallible_operation(succeed: bool) -> Result<String, &'static str> {
            sleep(Duration::from_millis(100)).await;
            if succeed {
                Ok("操作成功".to_string())
            } else {
                Err("操作失败")
            }
        }
        
        // 使用 ? 操作符
        async fn chain_operations() -> Result<String, &'static str> {
            let result1 = fallible_operation(true).await?;
            let result2 = fallible_operation(true).await?;
            Ok(format!("{} -> {}", result1, result2))
        }
        
        match chain_operations().await {
            Ok(result) => println!("链式操作成功: {}", result),
            Err(e) => println!("链式操作失败: {}", e),
        }
        
        // 使用 select 处理多个 Future
        let future1 = fallible_operation(true);
        let future2 = sleep(Duration::from_millis(200));
        
        match select(Box::pin(future1), Box::pin(future2)).await {
            Either::Left((result, _)) => match result {
                Ok(value) => println!("第一个完成: {}", value),
                Err(e) => println!("第一个失败: {}", e),
            },
            Either::Right((_, _)) => println!("超时或第二个完成"),
        }
    }
}</pre>

        <p><strong>步骤 4: WebSocket 架构性能分析</strong></p>
        <pre># src/analysis/architecture.rs
//! WebSocket 服务架构分析和优化建议

use std::collections::HashMap;
use serde::{Deserialize, Serialize};

/// 架构分析报告
#[derive(Debug, Serialize, Deserialize)]
pub struct ArchitectureAnalysis {
    pub components: Vec<ComponentAnalysis>,
    pub performance_metrics: PerformanceMetrics,
    pub scalability_assessment: ScalabilityAssessment,
    pub security_evaluation: SecurityEvaluation,
    pub recommendations: Vec<OptimizationRecommendation>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ComponentAnalysis {
    pub name: String,
    pub purpose: String,
    pub strengths: Vec<String>,
    pub weaknesses: Vec<String>,
    pub dependencies: Vec<String>,
    pub complexity_score: u8, // 1-10
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PerformanceMetrics {
    pub connection_handling: ConnectionMetrics,
    pub message_throughput: ThroughputMetrics,
    pub memory_usage: MemoryMetrics,
    pub cpu_utilization: CpuMetrics,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ConnectionMetrics {
    pub max_concurrent_connections: u32,
    pub connection_establishment_time_ms: f64,
    pub connection_cleanup_time_ms: f64,
    pub heartbeat_overhead_percentage: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ThroughputMetrics {
    pub messages_per_second: u32,
    pub bytes_per_second: u64,
    pub broadcast_latency_ms: f64,
    pub unicast_latency_ms: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MemoryMetrics {
    pub base_memory_mb: u64,
    pub memory_per_connection_kb: u64,
    pub message_buffer_size_mb: u64,
    pub peak_memory_usage_mb: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CpuMetrics {
    pub idle_cpu_percentage: f64,
    pub cpu_per_connection_percentage: f64,
    pub message_processing_cpu_percentage: f64,
    pub serialization_cpu_percentage: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScalabilityAssessment {
    pub horizontal_scaling: ScalingAnalysis,
    pub vertical_scaling: ScalingAnalysis,
    pub bottlenecks: Vec<String>,
    pub scaling_recommendations: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScalingAnalysis {
    pub feasibility: String, // "Easy", "Moderate", "Difficult"
    pub limitations: Vec<String>,
    pub required_changes: Vec<String>,
    pub estimated_effort: String, // "Low", "Medium", "High"
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityEvaluation {
    pub authentication: SecurityComponent,
    pub authorization: SecurityComponent,
    pub data_protection: SecurityComponent,
    pub network_security: SecurityComponent,
    pub vulnerability_assessment: Vec<SecurityIssue>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityComponent {
    pub status: String, // "Implemented", "Partial", "Missing"
    pub strength: String, // "Strong", "Adequate", "Weak"
    pub recommendations: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityIssue {
    pub severity: String, // "Critical", "High", "Medium", "Low"
    pub description: String,
    pub impact: String,
    pub mitigation: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OptimizationRecommendation {
    pub category: String,
    pub priority: String, // "Critical", "High", "Medium", "Low"
    pub description: String,
    pub implementation_effort: String,
    pub expected_impact: String,
    pub dependencies: Vec<String>,
}

/// 架构分析器
pub struct ArchitectureAnalyzer;

impl ArchitectureAnalyzer {
    /// 执行完整的架构分析
    pub fn analyze_websocket_architecture() -> ArchitectureAnalysis {
        println!("执行 WebSocket 架构分析...");
        
        let components = Self::analyze_components();
        let performance_metrics = Self::analyze_performance();
        let scalability_assessment = Self::assess_scalability();
        let security_evaluation = Self::evaluate_security();
        let recommendations = Self::generate_recommendations();
        
        ArchitectureAnalysis {
            components,
            performance_metrics,
            scalability_assessment,
            security_evaluation,
            recommendations,
        }
    }
    
    fn analyze_components() -> Vec<ComponentAnalysis> {
        vec![
            ComponentAnalysis {
                name: "WebSocket Server Core".to_string(),
                purpose: "处理 WebSocket 连接和消息路由".to_string(),
                strengths: vec![
                    "基于 Tokio 的高性能异步 I/O".to_string(),
                    "内存高效的连接管理".to_string(),
                    "支持背压控制".to_string(),
                ],
                weaknesses: vec![
                    "单实例扩展限制".to_string(),
                    "缺少连接池管理".to_string(),
                ],
                dependencies: vec!["tokio".to_string(), "tokio-tungstenite".to_string()],
                complexity_score: 7,
            },
            ComponentAnalysis {
                name: "Message Broadcasting System".to_string(),
                purpose: "多客户端消息广播和路由".to_string(),
                strengths: vec![
                    "高效的扇出消息分发".to_string(),
                    "支持选择性广播".to_string(),
                ],
                weaknesses: vec![
                    "内存中状态管理".to_string(),
                    "缺少消息持久化".to_string(),
                ],
                dependencies: vec!["tokio::sync".to_string()],
                complexity_score: 6,
            },
            ComponentAnalysis {
                name: "Authentication & Authorization".to_string(),
                purpose: "用户身份验证和权限控制".to_string(),
                strengths: vec![
                    "JWT token 验证".to_string(),
                    "灵活的权限模型".to_string(),
                ],
                weaknesses: vec![
                    "缺少 token 刷新机制".to_string(),
                    "权限缓存策略不完善".to_string(),
                ],
                dependencies: vec!["jsonwebtoken".to_string()],
                complexity_score: 5,
            },
        ]
    }
    
    fn analyze_performance() -> PerformanceMetrics {
        PerformanceMetrics {
            connection_handling: ConnectionMetrics {
                max_concurrent_connections: 10000,
                connection_establishment_time_ms: 2.5,
                connection_cleanup_time_ms: 1.2,
                heartbeat_overhead_percentage: 3.5,
            },
            message_throughput: ThroughputMetrics {
                messages_per_second: 50000,
                bytes_per_second: 5242880, // 5 MB/s
                broadcast_latency_ms: 1.8,
                unicast_latency_ms: 0.9,
            },
            memory_usage: MemoryMetrics {
                base_memory_mb: 128,
                memory_per_connection_kb: 4,
                message_buffer_size_mb: 256,
                peak_memory_usage_mb: 512,
            },
            cpu_utilization: CpuMetrics {
                idle_cpu_percentage: 85.0,
                cpu_per_connection_percentage: 0.01,
                message_processing_cpu_percentage: 8.0,
                serialization_cpu_percentage: 4.5,
            },
        }
    }
    
    fn assess_scalability() -> ScalabilityAssessment {
        ScalabilityAssessment {
            horizontal_scaling: ScalingAnalysis {
                feasibility: "Moderate".to_string(),
                limitations: vec![
                    "需要外部状态存储".to_string(),
                    "消息路由复杂性增加".to_string(),
                ],
                required_changes: vec![
                    "实现 Redis 集群支持".to_string(),
                    "添加服务发现机制".to_string(),
                    "实现跨节点消息传递".to_string(),
                ],
                estimated_effort: "High".to_string(),
            },
            vertical_scaling: ScalingAnalysis {
                feasibility: "Easy".to_string(),
                limitations: vec![
                    "单机硬件限制".to_string(),
                    "垂直扩展成本高".to_string(),
                ],
                required_changes: vec![
                    "优化内存使用".to_string(),
                    "调整线程池大小".to_string(),
                ],
                estimated_effort: "Low".to_string(),
            },
            bottlenecks: vec![
                "消息序列化性能".to_string(),
                "广播扇出限制".to_string(),
                "单实例连接数上限".to_string(),
            ],
            scaling_recommendations: vec![
                "实现消息队列中间件".to_string(),
                "添加负载均衡器".to_string(),
                "使用微服务架构".to_string(),
            ],
        }
    }
    
    fn evaluate_security() -> SecurityEvaluation {
        SecurityEvaluation {
            authentication: SecurityComponent {
                status: "Implemented".to_string(),
                strength: "Adequate".to_string(),
                recommendations: vec![
                    "添加多因素认证".to_string(),
                    "实现 token 黑名单".to_string(),
                ],
            },
            authorization: SecurityComponent {
                status: "Partial".to_string(),
                strength: "Weak".to_string(),
                recommendations: vec![
                    "实现基于角色的访问控制".to_string(),
                    "添加细粒度权限检查".to_string(),
                ],
            },
            data_protection: SecurityComponent {
                status: "Partial".to_string(),
                strength: "Adequate".to_string(),
                recommendations: vec![
                    "启用消息加密".to_string(),
                    "实现端到端加密".to_string(),
                ],
            },
            network_security: SecurityComponent {
                status: "Implemented".to_string(),
                strength: "Strong".to_string(),
                recommendations: vec![
                    "添加 DDoS 防护".to_string(),
                    "实现速率限制".to_string(),
                ],
            },
            vulnerability_assessment: vec![
                SecurityIssue {
                    severity: "Medium".to_string(),
                    description: "缺少输入验证和消毒".to_string(),
                    impact: "潜在的注入攻击风险".to_string(),
                    mitigation: "实现严格的输入验证".to_string(),
                },
                SecurityIssue {
                    severity: "Low".to_string(),
                    description: "日志可能包含敏感信息".to_string(),
                    impact: "信息泄露风险".to_string(),
                    mitigation: "实现日志脱敏".to_string(),
                },
            ],
        }
    }
    
    fn generate_recommendations() -> Vec<OptimizationRecommendation> {
        vec![
            OptimizationRecommendation {
                category: "Performance".to_string(),
                priority: "High".to_string(),
                description: "实现消息批处理以提高吞吐量".to_string(),
                implementation_effort: "Medium".to_string(),
                expected_impact: "提升 30% 消息处理性能".to_string(),
                dependencies: vec!["消息队列重构".to_string()],
            },
            OptimizationRecommendation {
                category: "Scalability".to_string(),
                priority: "Critical".to_string(),
                description: "实现 Redis 集群支持以实现水平扩展".to_string(),
                implementation_effort: "High".to_string(),
                expected_impact: "支持无限水平扩展".to_string(),
                dependencies: vec!["Redis Cluster".to_string(), "服务发现".to_string()],
            },
            OptimizationRecommendation {
                category: "Security".to_string(),
                priority: "High".to_string(),
                description: "实现端到端消息加密".to_string(),
                implementation_effort: "Medium".to_string(),
                expected_impact: "完全保护消息隐私".to_string(),
                dependencies: vec!["密钥管理系统".to_string()],
            },
            OptimizationRecommendation {
                category: "Observability".to_string(),
                priority: "Medium".to_string(),
                description: "集成分布式追踪系统".to_string(),
                implementation_effort: "Medium".to_string(),
                expected_impact: "改善系统可观测性".to_string(),
                dependencies: vec!["Jaeger".to_string(), "OpenTelemetry".to_string()],
            },
        ]
    }
    
    /// 生成架构分析报告
    pub fn generate_report(analysis: &ArchitectureAnalysis) -> String {
        let mut report = String::new();
        
        report.push_str("# WebSocket 服务架构分析报告\n\n");
        
        report.push_str("## 组件分析\n");
        for component in &analysis.components {
            report.push_str(&format!("### {}\n", component.name));
            report.push_str(&format!("**目的**: {}\n", component.purpose));
            report.push_str(&format!("**复杂度**: {}/10\n", component.complexity_score));
            
            report.push_str("**优势**:\n");
            for strength in &component.strengths {
                report.push_str(&format!("- {}\n", strength));
            }
            
            report.push_str("**弱点**:\n");
            for weakness in &component.weaknesses {
                report.push_str(&format!("- {}\n", weakness));
            }
            report.push_str("\n");
        }
        
        report.push_str("## 性能指标\n");
        let perf = &analysis.performance_metrics;
        report.push_str(&format!("- 最大并发连接: {}\n", perf.connection_handling.max_concurrent_connections));
        report.push_str(&format!("- 消息吞吐量: {} msg/s\n", perf.message_throughput.messages_per_second));
        report.push_str(&format!("- 基础内存使用: {} MB\n", perf.memory_usage.base_memory_mb));
        report.push_str(&format!("- 空闲 CPU 使用: {:.1}%\n", perf.cpu_utilization.idle_cpu_percentage));
        
        report.push_str("\n## 扩展性评估\n");
        report.push_str(&format!("- 水平扩展可行性: {}\n", analysis.scalability_assessment.horizontal_scaling.feasibility));
        report.push_str(&format!("- 垂直扩展可行性: {}\n", analysis.scalability_assessment.vertical_scaling.feasibility));
        
        report.push_str("\n## 优化建议\n");
        for rec in &analysis.recommendations {
            report.push_str(&format!("### {} (优先级: {})\n", rec.description, rec.priority));
            report.push_str(&format!("- 实施难度: {}\n", rec.implementation_effort));
            report.push_str(&format!("- 预期影响: {}\n", rec.expected_impact));
            report.push_str("\n");
        }
        
        report
    }
}</pre>

        <p><strong>步骤 5: 性能基准测试</strong></p>
        <pre># benches/websocket_performance.rs
//! WebSocket 服务性能基准测试

use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use tokio::runtime::Runtime;
use tokio::time::{Duration, Instant};
use tokio_tungstenite::{connect_async, tungstenite::Message};
use futures::sink::SinkExt;
use futures::stream::StreamExt;
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};

/// WebSocket 性能测试结构
pub struct WebSocketBenchmark {
    runtime: Runtime,
    server_url: String,
}

impl WebSocketBenchmark {
    pub fn new() -> Self {
        Self {
            runtime: Runtime::new().unwrap(),
            server_url: "ws://localhost:8080".to_string(),
        }
    }
    
    /// 单连接消息吞吐量测试
    pub fn single_connection_throughput(&self, message_count: usize) -> Duration {
        self.runtime.block_on(async {
            let start = Instant::now();
            
            let (ws_stream, _) = connect_async(&self.server_url)
                .await
                .expect("连接失败");
            
            let (mut write, mut read) = ws_stream.split();
            
            // 发送消息任务
            let send_task = tokio::spawn(async move {
                for i in 0..message_count {
                    let message = format!("性能测试消息 {}", i);
                    write.send(Message::Text(message)).await.unwrap();
                }
            });
            
            // 接收消息任务
            let recv_task = tokio::spawn(async move {
                let mut received = 0;
                while received < message_count {
                    if let Some(msg) = read.next().await {
                        match msg {
                            Ok(Message::Text(_)) => received += 1,
                            _ => {}
                        }
                    }
                }
            });
            
            tokio::join!(send_task, recv_task);
            start.elapsed()
        })
    }
    
    /// 多连接并发测试
    pub fn concurrent_connections(&self, connection_count: usize, messages_per_connection: usize) -> Duration {
        self.runtime.block_on(async {
            let start = Instant::now();
            let counter = Arc::new(AtomicU64::new(0));
            
            let tasks: Vec<_> = (0..connection_count)
                .map(|i| {
                    let counter = Arc::clone(&counter);
                    let server_url = self.server_url.clone();
                    
                    tokio::spawn(async move {
                        let (ws_stream, _) = connect_async(&server_url)
                            .await
                            .expect("连接失败");
                        
                        let (mut write, mut read) = ws_stream.split();
                        
                        // 发送任务
                        let send_task = tokio::spawn(async move {
                            for j in 0..messages_per_connection {
                                let message = format!("连接 {} 消息 {}", i, j);
                                write.send(Message::Text(message)).await.unwrap();
                            }
                        });
                        
                        // 接收任务
                        let recv_task = tokio::spawn(async move {
                            let mut received = 0;
                            while received < messages_per_connection {
                                if let Some(msg) = read.next().await {
                                    match msg {
                                        Ok(Message::Text(_)) => {
                                            received += 1;
                                            counter.fetch_add(1, Ordering::Relaxed);
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        });
                        
                        tokio::join!(send_task, recv_task);
                    })
                })
                .collect();
            
            futures::future::join_all(tasks).await;
            
            let total_messages = counter.load(Ordering::Relaxed);
            println!("总处理消息数: {}", total_messages);
            
            start.elapsed()
        })
    }
    
    /// 消息大小性能测试
    pub fn message_size_performance(&self, message_size: usize, message_count: usize) -> Duration {
        self.runtime.block_on(async {
            let start = Instant::now();
            
            let (ws_stream, _) = connect_async(&self.server_url)
                .await
                .expect("连接失败");
            
            let (mut write, mut read) = ws_stream.split();
            
            // 生成指定大小的消息
            let large_message = "A".repeat(message_size);
            
            // 发送任务
            let send_task = tokio::spawn(async move {
                for _ in 0..message_count {
                    write.send(Message::Text(large_message.clone())).await.unwrap();
                }
            });
            
            // 接收任务
            let recv_task = tokio::spawn(async move {
                let mut received = 0;
                while received < message_count {
                    if let Some(msg) = read.next().await {
                        match msg {
                            Ok(Message::Text(_)) => received += 1,
                            _ => {}
                        }
                    }
                }
            });
            
            tokio::join!(send_task, recv_task);
            start.elapsed()
        })
    }
}

/// Criterion 基准测试函数
fn websocket_benchmarks(c: &mut Criterion) {
    let benchmark = WebSocketBenchmark::new();
    
    // 消息吞吐量测试
    let mut group = c.benchmark_group("message_throughput");
    for message_count in [100, 500, 1000, 5000].iter() {
        group.bench_with_input(
            BenchmarkId::new("single_connection", message_count),
            message_count,
            |b, &message_count| {
                b.iter(|| {
                    let duration = benchmark.single_connection_throughput(message_count);
                    black_box(duration)
                });
            },
        );
    }
    group.finish();
    
    // 并发连接测试
    let mut group = c.benchmark_group("concurrent_connections");
    for &(connections, messages) in [(10, 100), (50, 50), (100, 10)].iter() {
        group.bench_with_input(
            BenchmarkId::new("concurrent", format!("{}conn_{}msg", connections, messages)),
            &(connections, messages),
            |b, &(connections, messages)| {
                b.iter(|| {
                    let duration = benchmark.concurrent_connections(connections, messages);
                    black_box(duration)
                });
            },
        );
    }
    group.finish();
    
    // 消息大小测试
    let mut group = c.benchmark_group("message_size");
    for &(size, count) in [(1024, 100), (10240, 50), (102400, 10)].iter() {
        group.bench_with_input(
            BenchmarkId::new("size_performance", format!("{}bytes", size)),
            &(size, count),
            |b, &(size, count)| {
                b.iter(|| {
                    let duration = benchmark.message_size_performance(size, count);
                    black_box(duration)
                });
            },
        );
    }
    group.finish();
}

criterion_group!(benches, websocket_benchmarks);
criterion_main!(benches);</pre>

        <p><strong>步骤 6: 部署策略规划</strong></p>
        <pre># src/planning/deployment.rs
//! 部署策略和运维规划

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// 部署策略规划
#[derive(Debug, Serialize, Deserialize)]
pub struct DeploymentStrategy {
    pub environments: HashMap<String, EnvironmentConfig>,
    pub scaling_policies: ScalingPolicies,
    pub monitoring_setup: MonitoringSetup,
    pub backup_strategy: BackupStrategy,
    pub disaster_recovery: DisasterRecoveryPlan,
    pub maintenance_procedures: MaintenanceProcedures,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EnvironmentConfig {
    pub name: String,
    pub infrastructure: InfrastructureConfig,
    pub resources: ResourceAllocation,
    pub security: SecurityConfig,
    pub networking: NetworkConfig,
    pub dependencies: Vec<DependencyConfig>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct InfrastructureConfig {
    pub platform: String, // "Kubernetes", "Docker Swarm", "ECS", etc.
    pub region: String,
    pub availability_zones: Vec<String>,
    pub node_types: Vec<NodeType>,
    pub storage_classes: Vec<StorageClass>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NodeType {
    pub name: String,
    pub instance_type: String,
    pub cpu_cores: u32,
    pub memory_gb: u32,
    pub storage_gb: u32,
    pub network_performance: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StorageClass {
    pub name: String,
    pub storage_type: String, // "SSD", "HDD", "NVMe"
    pub iops: u32,
    pub throughput_mbps: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ResourceAllocation {
    pub websocket_server: ServiceResources,
    pub redis_cluster: ServiceResources,
    pub prometheus: ServiceResources,
    pub grafana: ServiceResources,
    pub load_balancer: ServiceResources,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ServiceResources {
    pub replicas: u32,
    pub cpu_request: String,
    pub cpu_limit: String,
    pub memory_request: String,
    pub memory_limit: String,
    pub storage_request: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScalingPolicies {
    pub horizontal_pod_autoscaler: HpaConfig,
    pub vertical_pod_autoscaler: VpaConfig,
    pub cluster_autoscaler: ClusterAutoscalerConfig,
    pub custom_metrics: Vec<CustomMetric>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct HpaConfig {
    pub enabled: bool,
    pub min_replicas: u32,
    pub max_replicas: u32,
    pub target_cpu_utilization: u32,
    pub target_memory_utilization: u32,
    pub scale_up_policies: ScalePolicies,
    pub scale_down_policies: ScalePolicies,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScalePolicies {
    pub stabilization_window_seconds: u32,
    pub select_policy: String, // "Max", "Min", "Disabled"
    pub policies: Vec<ScalePolicy>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScalePolicy {
    pub type_: String, // "Percent", "Pods"
    pub value: u32,
    pub period_seconds: u32,
}

/// 部署策略规划器
pub struct DeploymentPlanner;

impl DeploymentPlanner {
    /// 生成完整的部署策略
    pub fn create_deployment_strategy() -> DeploymentStrategy {
        println!("生成部署策略规划...");
        
        let mut environments = HashMap::new();
        
        // 开发环境配置
        environments.insert("development".to_string(), Self::create_dev_environment());
        
        // 测试环境配置
        environments.insert("staging".to_string(), Self::create_staging_environment());
        
        // 生产环境配置
        environments.insert("production".to_string(), Self::create_production_environment());
        
        DeploymentStrategy {
            environments,
            scaling_policies: Self::create_scaling_policies(),
            monitoring_setup: Self::create_monitoring_setup(),
            backup_strategy: Self::create_backup_strategy(),
            disaster_recovery: Self::create_disaster_recovery_plan(),
            maintenance_procedures: Self::create_maintenance_procedures(),
        }
    }
    
    fn create_dev_environment() -> EnvironmentConfig {
        EnvironmentConfig {
            name: "development".to_string(),
            infrastructure: InfrastructureConfig {
                platform: "Kubernetes".to_string(),
                region: "us-west-2".to_string(),
                availability_zones: vec!["us-west-2a".to_string()],
                node_types: vec![
                    NodeType {
                        name: "dev-worker".to_string(),
                        instance_type: "t3.medium".to_string(),
                        cpu_cores: 2,
                        memory_gb: 4,
                        storage_gb: 20,
                        network_performance: "Moderate".to_string(),
                    }
                ],
                storage_classes: vec![
                    StorageClass {
                        name: "gp2".to_string(),
                        storage_type: "SSD".to_string(),
                        iops: 100,
                        throughput_mbps: 250,
                    }
                ],
            },
            resources: ResourceAllocation {
                websocket_server: ServiceResources {
                    replicas: 1,
                    cpu_request: "100m".to_string(),
                    cpu_limit: "500m".to_string(),
                    memory_request: "128Mi".to_string(),
                    memory_limit: "512Mi".to_string(),
                    storage_request: None,
                },
                redis_cluster: ServiceResources {
                    replicas: 1,
                    cpu_request: "50m".to_string(),
                    cpu_limit: "200m".to_string(),
                    memory_request: "64Mi".to_string(),
                    memory_limit: "256Mi".to_string(),
                    storage_request: Some("1Gi".to_string()),
                },
                prometheus: ServiceResources {
                    replicas: 1,
                    cpu_request: "100m".to_string(),
                    cpu_limit: "300m".to_string(),
                    memory_request: "256Mi".to_string(),
                    memory_limit: "1Gi".to_string(),
                    storage_request: Some("5Gi".to_string()),
                },
                grafana: ServiceResources {
                    replicas: 1,
                    cpu_request: "50m".to_string(),
                    cpu_limit: "200m".to_string(),
                    memory_request: "128Mi".to_string(),
                    memory_limit: "512Mi".to_string(),
                    storage_request: Some("1Gi".to_string()),
                },
                load_balancer: ServiceResources {
                    replicas: 1,
                    cpu_request: "50m".to_string(),
                    cpu_limit: "100m".to_string(),
                    memory_request: "64Mi".to_string(),
                    memory_limit: "128Mi".to_string(),
                    storage_request: None,
                },
            },
            security: SecurityConfig {
                network_policies_enabled: false,
                pod_security_policies_enabled: false,
                tls_enabled: false,
                rbac_enabled: true,
                secrets_encryption: false,
            },
            networking: NetworkConfig {
                service_mesh_enabled: false,
                ingress_controller: "nginx".to_string(),
                dns_policy: "ClusterFirst".to_string(),
                network_plugin: "flannel".to_string(),
            },
            dependencies: vec![
                DependencyConfig {
                    name: "redis".to_string(),
                    version: "7.0".to_string(),
                    config_override: HashMap::new(),
                }
            ],
        }
    }
    
    fn create_production_environment() -> EnvironmentConfig {
        EnvironmentConfig {
            name: "production".to_string(),
            infrastructure: InfrastructureConfig {
                platform: "Kubernetes".to_string(),
                region: "us-west-2".to_string(),
                availability_zones: vec![
                    "us-west-2a".to_string(),
                    "us-west-2b".to_string(),
                    "us-west-2c".to_string(),
                ],
                node_types: vec![
                    NodeType {
                        name: "prod-worker".to_string(),
                        instance_type: "c5.2xlarge".to_string(),
                        cpu_cores: 8,
                        memory_gb: 16,
                        storage_gb: 100,
                        network_performance: "High".to_string(),
                    }
                ],
                storage_classes: vec![
                    StorageClass {
                        name: "gp3".to_string(),
                        storage_type: "SSD".to_string(),
                        iops: 3000,
                        throughput_mbps: 125,
                    }
                ],
            },
            resources: ResourceAllocation {
                websocket_server: ServiceResources {
                    replicas: 3,
                    cpu_request: "1000m".to_string(),
                    cpu_limit: "2000m".to_string(),
                    memory_request: "1Gi".to_string(),
                    memory_limit: "4Gi".to_string(),
                    storage_request: None,
                },
                redis_cluster: ServiceResources {
                    replicas: 3,
                    cpu_request: "500m".to_string(),
                    cpu_limit: "1000m".to_string(),
                    memory_request: "1Gi".to_string(),
                    memory_limit: "4Gi".to_string(),
                    storage_request: Some("10Gi".to_string()),
                },
                prometheus: ServiceResources {
                    replicas: 2,
                    cpu_request: "500m".to_string(),
                    cpu_limit: "1000m".to_string(),
                    memory_request: "2Gi".to_string(),
                    memory_limit: "8Gi".to_string(),
                    storage_request: Some("100Gi".to_string()),
                },
                grafana: ServiceResources {
                    replicas: 2,
                    cpu_request: "200m".to_string(),
                    cpu_limit: "500m".to_string(),
                    memory_request: "512Mi".to_string(),
                    memory_limit: "2Gi".to_string(),
                    storage_request: Some("10Gi".to_string()),
                },
                load_balancer: ServiceResources {
                    replicas: 2,
                    cpu_request: "200m".to_string(),
                    cpu_limit: "500m".to_string(),
                    memory_request: "256Mi".to_string(),
                    memory_limit: "1Gi".to_string(),
                    storage_request: None,
                },
            },
            security: SecurityConfig {
                network_policies_enabled: true,
                pod_security_policies_enabled: true,
                tls_enabled: true,
                rbac_enabled: true,
                secrets_encryption: true,
            },
            networking: NetworkConfig {
                service_mesh_enabled: true,
                ingress_controller: "istio-gateway".to_string(),
                dns_policy: "ClusterFirst".to_string(),
                network_plugin: "calico".to_string(),
            },
            dependencies: vec![
                DependencyConfig {
                    name: "redis-cluster".to_string(),
                    version: "7.0".to_string(),
                    config_override: HashMap::from([
                        ("cluster-enabled".to_string(), "yes".to_string()),
                        ("cluster-config-file".to_string(), "nodes.conf".to_string()),
                    ]),
                }
            ],
        }
    }
    
    // ... (其他辅助方法实现)
}

// 辅助结构定义
#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityConfig {
    pub network_policies_enabled: bool,
    pub pod_security_policies_enabled: bool,
    pub tls_enabled: bool,
    pub rbac_enabled: bool,
    pub secrets_encryption: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkConfig {
    pub service_mesh_enabled: bool,
    pub ingress_controller: String,
    pub dns_policy: String,
    pub network_plugin: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DependencyConfig {
    pub name: String,
    pub version: String,
    pub config_override: HashMap<String, String>,
}</pre>

        <p><strong>实践练习：</strong></p>
        <ol>
            <li><strong>知识点回顾测试</strong>
                <pre>cd day29_knowledge_review
cargo run --bin review_basics
cargo run --bin review_ownership
cargo run --bin review_async</pre>
            </li>
            <li><strong>架构分析执行</strong>
                <pre>cargo run --bin architecture_analysis > reports/architecture_report.md
cat reports/architecture_report.md</pre>
            </li>
            <li><strong>性能基准测试</strong>
                <pre>cargo bench --bench websocket_performance
cat target/criterion/report/index.html</pre>
            </li>
            <li><strong>部署策略生成</strong>
                <pre>cargo run --bin deployment_planner > deployment_strategy.json
jq '.environments.production' deployment_strategy.json</pre>
            </li>
        </ol>

        <p><strong>技术栈回顾总结：</strong></p>
        <ul>
            <li><strong>核心语言特性</strong>: 所有权、借用、生命周期、trait 系统</li>
            <li><strong>异步编程</strong>: Future、async/await、tokio 生态</li>
            <li><strong>网络编程</strong>: WebSocket 协议实现、连接管理</li>
            <li><strong>并发模型</strong>: 消息传递、共享状态、同步原语</li>
            <li><strong>错误处理</strong>: Result 类型、错误传播、错误恢复</li>
            <li><strong>性能优化</strong>: 零成本抽象、内存管理、编译器优化</li>
            <li><strong>容器化</strong>: Docker 多阶段构建、镜像优化</li>
            <li><strong>编排部署</strong>: Kubernetes、Helm Charts、服务网格</li>
            <li><strong>可观测性</strong>: 日志、指标、分布式追踪</li>
            <li><strong>安全实践</strong>: 认证授权、网络安全、容器安全</li>
        </ul>
    
        <p class="date"><strong>🗓️ 2025-08-30</strong></p>
        <h2>Day 30 - 最终项目集成与生产就绪性准备</h2>
        <p>整合所有组件构建完整的生产级 WebSocket 服务，实施企业级质量保证和发布准备流程。</p>
        
        <h3>学习目标</h3>
        <ul>
            <li>集成所有项目组件形成完整的服务系统</li>
            <li>实施企业级代码质量保证和测试覆盖</li>
            <li>完成生产环境配置和部署自动化</li>
            <li>建立监控、告警和运维管理体系</li>
            <li>执行性能压测和容量规划验证</li>
            <li>完善文档和用户指南准备发布</li>
        </ul>
        <p>🔗 <a href="https://doc.rust-lang.org/book/" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 完整项目集成架构</strong></p>
        <pre>📁 最终项目结构：
day30_production_ready/
├── src/
│   ├── main.rs
│   ├── lib.rs
│   ├── server/
│   │   ├── mod.rs
│   │   ├── websocket.rs
│   │   ├── auth.rs
│   │   ├── middleware.rs
│   │   └── handlers.rs
│   ├── client/
│   │   ├── mod.rs
│   │   ├── connection.rs
│   │   ├── manager.rs
│   │   └── pool.rs
│   ├── message/
│   │   ├── mod.rs
│   │   ├── types.rs
│   │   ├── router.rs
│   │   ├── broadcast.rs
│   │   └── persistence.rs
│   ├── config/
│   │   ├── mod.rs
│   │   ├── settings.rs
│   │   ├── validation.rs
│   │   └── environment.rs
│   ├── monitoring/
│   │   ├── mod.rs
│   │   ├── metrics.rs
│   │   ├── health.rs
│   │   ├── tracing.rs
│   │   └── alerts.rs
│   ├── storage/
│   │   ├── mod.rs
│   │   ├── redis.rs
│   │   ├── persistence.rs
│   │   └── cache.rs
│   └── utils/
│       ├── mod.rs
│       ├── crypto.rs
│       ├── validation.rs
│       └── error.rs
├── tests/
│   ├── integration/
│   │   ├── mod.rs
│   │   ├── websocket_tests.rs
│   │   ├── auth_tests.rs
│   │   ├── load_tests.rs
│   │   └── e2e_tests.rs
│   ├── unit/
│   │   ├── mod.rs
│   │   ├── message_tests.rs
│   │   ├── client_tests.rs
│   │   └── config_tests.rs
│   └── fixtures/
│       ├── test_data.json
│       ├── mock_responses.json
│       └── test_configs.toml
├── benches/
│   ├── connection_benchmark.rs
│   ├── message_throughput.rs
│   ├── memory_usage.rs
│   └── concurrent_load.rs
├── examples/
│   ├── simple_client.rs
│   ├── chat_room.rs
│   ├── broadcast_server.rs
│   └── load_generator.rs
├── docs/
│   ├── api/
│   │   ├── websocket_api.md
│   │   ├── rest_api.md
│   │   └── authentication.md
│   ├── deployment/
│   │   ├── kubernetes.md
│   │   ├── docker.md
│   │   ├── monitoring.md
│   │   └── troubleshooting.md
│   ├── development/
│   │   ├── contributing.md
│   │   ├── architecture.md
│   │   └── testing.md
│   └── user_guide/
│       ├── getting_started.md
│       ├── configuration.md
│       └── best_practices.md
├── scripts/
│   ├── build/
│   │   ├── release.sh
│   │   ├── docker-build.sh
│   │   └── cross-compile.sh
│   ├── deploy/
│   │   ├── production.sh
│   │   ├── staging.sh
│   │   └── rollback.sh
│   ├── test/
│   │   ├── integration.sh
│   │   ├── load-test.sh
│   │   └── security-test.sh
│   └── maintenance/
│       ├── backup.sh
│       ├── cleanup.sh
│       └── health-check.sh
├── k8s/
│   ├── base/
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   │   ├── configmap.yaml
│   │   └── secrets.yaml
│   ├── overlays/
│   │   ├── development/
│   │   ├── staging/
│   │   └── production/
│   └── monitoring/
│       ├── prometheus.yaml
│       ├── grafana.yaml
│       └── alertmanager.yaml
├── helm/
│   ├── Chart.yaml
│   ├── values.yaml
│   ├── templates/
│   └── charts/
├── configs/
│   ├── production.toml
│   ├── staging.toml
│   ├── development.toml
│   └── monitoring/
├── .github/
│   └── workflows/
│       ├── ci.yml
│       ├── release.yml
│       ├── security.yml
│       └── deploy.yml
├── Cargo.toml
├── Cargo.lock
├── Dockerfile
├── docker-compose.yml
├── README.md
├── CHANGELOG.md
├── LICENSE
└── SECURITY.md</pre>

        <p><strong>主服务器集成实现：</strong></p>
        <pre># src/main.rs
//! 生产级 WebSocket 服务器主入口

use std::net::SocketAddr;
use std::sync::Arc;
use tokio::signal;
use tracing::{info, error, warn};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

use day30_production_ready::{
    config::{Config, Environment},
    server::WebSocketServer,
    monitoring::{MetricsCollector, HealthChecker},
    storage::StorageManager,
    Result, AppError,
};

#[tokio::main]
async fn main() -> Result<()> {
    // 初始化日志和追踪
    init_tracing()?;
    
    info!("启动 Rust WebSocket 生产服务器");
    
    // 加载配置
    let config = Config::from_environment()?;
    info!("配置加载完成: 环境={:?}", config.environment);
    
    // 验证配置
    config.validate()?;
    info!("配置验证通过");
    
    // 初始化存储
    let storage = Arc::new(StorageManager::new(&config.storage).await?);
    info!("存储系统初始化完成");
    
    // 初始化监控
    let metrics = Arc::new(MetricsCollector::new(&config.monitoring)?);
    let health_checker = Arc::new(HealthChecker::new(storage.clone(), metrics.clone()));
    info!("监控系统初始化完成");
    
    // 创建服务器实例
    let server = WebSocketServer::new(
        config.clone(),
        storage.clone(),
        metrics.clone(),
        health_checker.clone(),
    ).await?;
    
    info!("WebSocket 服务器创建完成");
    
    // 启动健康检查服务
    let health_addr: SocketAddr = format!("{}:{}", 
        config.server.host, 
        config.server.health_port
    ).parse()?;
    
    let health_server = start_health_server(health_addr, health_checker.clone());
    
    // 启动指标服务
    let metrics_addr: SocketAddr = format!("{}:{}", 
        config.server.host, 
        config.server.metrics_port
    ).parse()?;
    
    let metrics_server = start_metrics_server(metrics_addr, metrics.clone());
    
    // 启动主 WebSocket 服务
    let main_addr: SocketAddr = format!("{}:{}", 
        config.server.host, 
        config.server.port
    ).parse()?;
    
    info!("服务器启动地址:");
    info!("  WebSocket: ws://{}", main_addr);
    info!("  健康检查: http://{}/health", health_addr);
    info!("  指标: http://{}/metrics", metrics_addr);
    
    // 优雅关闭信号处理
    let shutdown_signal = setup_shutdown_signal();
    
    // 并发运行所有服务
    tokio::select! {
        result = server.run(main_addr) => {
            match result {
                Ok(_) => info!("WebSocket 服务器正常退出"),
                Err(e) => error!("WebSocket 服务器错误: {}", e),
            }
        }
        result = health_server => {
            match result {
                Ok(_) => info!("健康检查服务器正常退出"),
                Err(e) => error!("健康检查服务器错误: {}", e),
            }
        }
        result = metrics_server => {
            match result {
                Ok(_) => info!("指标服务器正常退出"),
                Err(e) => error!("指标服务器错误: {}", e),
            }
        }
        _ = shutdown_signal => {
            info!("接收到关闭信号，开始优雅关闭...");
        }
    }
    
    // 执行清理操作
    info!("执行清理操作...");
    storage.close().await?;
    metrics.flush().await?;
    
    info!("服务器已完全关闭");
    Ok(())
}

/// 初始化追踪和日志系统
fn init_tracing() -> Result<()> {
    let env_filter = tracing_subscriber::EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| "day30_production_ready=info,tower_http=debug".into());
    
    // 控制台输出层
    let console_layer = tracing_subscriber::fmt::layer()
        .with_target(true)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true);
    
    // JSON 格式输出层（生产环境）
    let json_layer = tracing_subscriber::fmt::layer()
        .json()
        .with_current_span(false)
        .with_span_list(true);
    
    // OpenTelemetry 层
    let tracer = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(opentelemetry_otlp::new_exporter().tonic())
        .install_batch(opentelemetry::runtime::Tokio)?;
    
    let telemetry_layer = tracing_opentelemetry::layer().with_tracer(tracer);
    
    // 组合所有层
    tracing_subscriber::registry()
        .with(env_filter)
        .with(console_layer)
        .with(json_layer)
        .with(telemetry_layer)
        .init();
    
    Ok(())
}

/// 启动健康检查服务器
async fn start_health_server(
    addr: SocketAddr,
    health_checker: Arc<HealthChecker>,
) -> Result<()> {
    use axum::{
        routing::get,
        response::Json,
        http::StatusCode,
        Router,
    };
    
    let health_router = Router::new()
        .route("/health", get({
            let checker = health_checker.clone();
            move || async move {
                match checker.check_all().await {
                    Ok(status) => (StatusCode::OK, Json(status)),
                    Err(_) => (StatusCode::SERVICE_UNAVAILABLE, Json(serde_json::json!({
                        "status": "unhealthy"
                    }))),
                }
            }
        }))
        .route("/health/ready", get({
            let checker = health_checker.clone();
            move || async move {
                match checker.check_readiness().await {
                    Ok(_) => StatusCode::OK,
                    Err(_) => StatusCode::SERVICE_UNAVAILABLE,
                }
            }
        }))
        .route("/health/live", get(|| async {
            StatusCode::OK
        }));
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, health_router).await?;
    
    Ok(())
}

/// 启动指标服务器
async fn start_metrics_server(
    addr: SocketAddr,
    metrics: Arc<MetricsCollector>,
) -> Result<()> {
    use axum::{
        routing::get,
        response::Response,
        http::{StatusCode, header},
        Router,
    };
    use prometheus::{Encoder, TextEncoder};
    
    let metrics_router = Router::new()
        .route("/metrics", get({
            let metrics = metrics.clone();
            move || async move {
                let encoder = TextEncoder::new();
                let metric_families = metrics.registry().gather();
                
                match encoder.encode_to_string(&metric_families) {
                    Ok(output) => Response::builder()
                        .status(StatusCode::OK)
                        .header(header::CONTENT_TYPE, encoder.format_type())
                        .body(output)
                        .unwrap(),
                    Err(_) => Response::builder()
                        .status(StatusCode::INTERNAL_SERVER_ERROR)
                        .body("Failed to encode metrics".to_string())
                        .unwrap(),
                }
            }
        }));
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, metrics_router).await?;
    
    Ok(())
}

/// 设置优雅关闭信号处理
async fn setup_shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            info!("接收到 Ctrl+C 信号");
        },
        _ = terminate => {
            info!("接收到终止信号");
        },
    }
}</pre>

        <p><strong>步骤 2: 企业级配置管理</strong></p>
        <pre># src/config/mod.rs
//! 企业级配置管理系统

use std::path::Path;
use serde::{Deserialize, Serialize};
use config::{Config as ConfigBuilder, Environment as ConfigEnv, File};
use validator::{Validate, ValidationError};

use crate::{Result, AppError};

/// 应用程序配置
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct Config {
    /// 运行环境
    pub environment: Environment,
    
    /// 服务器配置
    #[validate]
    pub server: ServerConfig,
    
    /// 存储配置
    #[validate]
    pub storage: StorageConfig,
    
    /// 监控配置
    #[validate] 
    pub monitoring: MonitoringConfig,
    
    /// 安全配置
    #[validate]
    pub security: SecurityConfig,
    
    /// 日志配置
    #[validate]
    pub logging: LoggingConfig,
}

/// 运行环境枚举
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Environment {
    Development,
    Testing,
    Staging,
    Production,
}

/// 服务器配置
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct ServerConfig {
    /// 绑定地址
    #[validate(ip)]
    pub host: String,
    
    /// WebSocket 端口
    #[validate(range(min = 1024, max = 65535))]
    pub port: u16,
    
    /// 健康检查端口
    #[validate(range(min = 1024, max = 65535))]
    pub health_port: u16,
    
    /// 指标端口
    #[validate(range(min = 1024, max = 65535))]
    pub metrics_port: u16,
    
    /// 最大连接数
    #[validate(range(min = 1, max = 100000))]
    pub max_connections: usize,
    
    /// 连接超时（秒）
    #[validate(range(min = 30, max = 3600))]
    pub connection_timeout: u64,
    
    /// 心跳间隔（秒）
    #[validate(range(min = 10, max = 300))]
    pub heartbeat_interval: u64,
    
    /// 工作线程数
    #[validate(range(min = 1, max = 128))]
    pub worker_threads: usize,
    
    /// 启用 TLS
    pub tls_enabled: bool,
    
    /// TLS 证书路径
    pub tls_cert_path: Option<String>,
    
    /// TLS 私钥路径
    pub tls_key_path: Option<String>,
}

/// 存储配置
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct StorageConfig {
    /// Redis 配置
    #[validate]
    pub redis: RedisConfig,
    
    /// 数据库配置
    pub database: Option<DatabaseConfig>,
    
    /// 缓存配置
    #[validate]
    pub cache: CacheConfig,
}

/// Redis 配置
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct RedisConfig {
    /// Redis URL
    #[validate(url)]
    pub url: String,
    
    /// 连接池大小
    #[validate(range(min = 1, max = 100))]
    pub pool_size: u32,
    
    /// 连接超时（毫秒）
    #[validate(range(min = 100, max = 30000))]
    pub connect_timeout_ms: u64,
    
    /// 命令超时（毫秒）
    #[validate(range(min = 100, max = 30000))]
    pub command_timeout_ms: u64,
    
    /// 集群模式
    pub cluster_mode: bool,
    
    /// 集群节点
    pub cluster_nodes: Vec<String>,
}

/// 监控配置
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct MonitoringConfig {
    /// 启用指标收集
    pub metrics_enabled: bool,
    
    /// 指标收集间隔（秒）
    #[validate(range(min = 1, max = 300))]
    pub metrics_interval: u64,
    
    /// 启用分布式追踪
    pub tracing_enabled: bool,
    
    /// 追踪导出器端点
    pub tracing_endpoint: Option<String>,
    
    /// 采样率（0.0 - 1.0）
    #[validate(range(min = 0.0, max = 1.0))]
    pub tracing_sample_rate: f64,
    
    /// 启用健康检查
    pub health_check_enabled: bool,
    
    /// 健康检查间隔（秒）
    #[validate(range(min = 5, max = 300))]
    pub health_check_interval: u64,
    
    /// Prometheus 配置
    pub prometheus: PrometheusConfig,
}

/// Prometheus 配置
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct PrometheusConfig {
    /// 启用 Prometheus 指标
    pub enabled: bool,
    
    /// 指标前缀
    #[validate(length(min = 1, max = 50))]
    pub metrics_prefix: String,
    
    /// 推送网关 URL
    pub pushgateway_url: Option<String>,
    
    /// 推送间隔（秒）
    #[validate(range(min = 10, max = 3600))]
    pub push_interval: u64,
}

impl Config {
    /// 从环境变量和配置文件加载配置
    pub fn from_environment() -> Result<Self> {
        let env = std::env::var("RUST_ENV")
            .unwrap_or_else(|_| "development".to_string());
        
        let config_file = format!("configs/{}.toml", env);
        
        let mut builder = ConfigBuilder::builder()
            // 默认配置
            .add_source(File::with_name("configs/default").required(false))
            // 环境特定配置
            .add_source(File::with_name(&config_file).required(false))
            // 本地覆盖配置
            .add_source(File::with_name("configs/local").required(false))
            // 环境变量覆盖
            .add_source(
                ConfigEnv::with_prefix("WEBSOCKET")
                    .separator("__")
                    .list_separator(",")
            );
        
        let config = builder.build()?;
        let mut settings: Config = config.try_deserialize()?;
        
        // 设置环境
        settings.environment = match env.as_str() {
            "development" => Environment::Development,
            "testing" => Environment::Testing,
            "staging" => Environment::Staging,
            "production" => Environment::Production,
            _ => Environment::Development,
        };
        
        Ok(settings)
    }
    
    /// 验证配置
    pub fn validate(&self) -> Result<()> {
        // 使用 validator crate 进行验证
        self.validate()
            .map_err(|e| AppError::ConfigError(format!("配置验证失败: {}", e)))?;
        
        // 自定义验证逻辑
        self.validate_custom()?;
        
        Ok(())
    }
    
    /// 自定义验证逻辑
    fn validate_custom(&self) -> Result<()> {
        // 端口冲突检查
        let ports = vec![
            self.server.port,
            self.server.health_port,
            self.server.metrics_port,
        ];
        
        for (i, &port1) in ports.iter().enumerate() {
            for &port2 in ports.iter().skip(i + 1) {
                if port1 == port2 {
                    return Err(AppError::ConfigError(
                        format!("端口冲突: {}", port1)
                    ));
                }
            }
        }
        
        // TLS 配置检查
        if self.server.tls_enabled {
            if self.server.tls_cert_path.is_none() || self.server.tls_key_path.is_none() {
                return Err(AppError::ConfigError(
                    "启用 TLS 时必须提供证书和私钥路径".to_string()
                ));
            }
        }
        
        // 生产环境特定检查
        if self.environment == Environment::Production {
            if !self.server.tls_enabled {
                return Err(AppError::ConfigError(
                    "生产环境必须启用 TLS".to_string()
                ));
            }
            
            if self.security.jwt_secret.len() < 32 {
                return Err(AppError::ConfigError(
                    "生产环境 JWT 密钥长度必须至少 32 字符".to_string()
                ));
            }
        }
        
        Ok(())
    }
    
    /// 是否为生产环境
    pub fn is_production(&self) -> bool {
        self.environment == Environment::Production
    }
    
    /// 是否为开发环境
    pub fn is_development(&self) -> bool {
        self.environment == Environment::Development
    }
    
    /// 获取完整的 WebSocket 地址
    pub fn websocket_address(&self) -> String {
        let protocol = if self.server.tls_enabled { "wss" } else { "ws" };
        format!("{}://{}:{}", protocol, self.server.host, self.server.port)
    }
}</pre>

        <p><strong>步骤 3: 综合集成测试套件</strong></p>
        <pre># tests/integration/e2e_tests.rs
//! 端到端集成测试套件

use std::time::Duration;
use tokio::time::timeout;
use tokio_tungstenite::{connect_async, tungstenite::Message};
use futures::{SinkExt, StreamExt};
use serde_json::json;
use uuid::Uuid;

use day30_production_ready::{
    config::Config,
    server::WebSocketServer,
    test_utils::{TestEnvironment, TestClient},
};

/// 端到端测试上下文
struct E2ETestContext {
    environment: TestEnvironment,
    server_url: String,
    auth_token: String,
}

impl E2ETestContext {
    async fn new() -> Self {
        let environment = TestEnvironment::new().await;
        let config = environment.config();
        let server_url = format!("ws://{}:{}", config.server.host, config.server.port);
        let auth_token = environment.generate_test_token("test_user", vec!["user"]).await;
        
        Self {
            environment,
            server_url,
            auth_token,
        }
    }
    
    async fn create_authenticated_client(&self) -> TestClient {
        TestClient::connect(&self.server_url, &self.auth_token).await
    }
}

#[tokio::test]
async fn test_complete_chat_flow() {
    let ctx = E2ETestContext::new().await;
    
    // 创建多个客户端
    let mut client1 = ctx.create_authenticated_client().await;
    let mut client2 = ctx.create_authenticated_client().await;
    let mut client3 = ctx.create_authenticated_client().await;
    
    // 客户端1加入房间
    let join_room_msg = json!({
        "type": "join_room",
        "room": "test_room",
        "user": "user1"
    });
    
    client1.send_message(join_room_msg.to_string()).await;
    
    // 验证加入房间响应
    let response = timeout(Duration::from_secs(5), client1.receive_message())
        .await
        .expect("超时")
        .expect("接收消息失败");
    
    let response_json: serde_json::Value = serde_json::from_str(&response).unwrap();
    assert_eq!(response_json["type"], "room_joined");
    assert_eq!(response_json["room"], "test_room");
    
    // 客户端2也加入相同房间
    let join_room_msg2 = json!({
        "type": "join_room",
        "room": "test_room", 
        "user": "user2"
    });
    
    client2.send_message(join_room_msg2.to_string()).await;
    
    // 等待客户端2的加入确认
    let _response2 = timeout(Duration::from_secs(5), client2.receive_message())
        .await
        .expect("超时")
        .expect("接收消息失败");
    
    // 客户端1应该收到用户加入通知
    let user_joined = timeout(Duration::from_secs(5), client1.receive_message())
        .await
        .expect("超时")
        .expect("接收消息失败");
    
    let user_joined_json: serde_json::Value = serde_json::from_str(&user_joined).unwrap();
    assert_eq!(user_joined_json["type"], "user_joined");
    assert_eq!(user_joined_json["user"], "user2");
    
    // 客户端1发送聊天消息
    let chat_msg = json!({
        "type": "chat_message",
        "room": "test_room",
        "message": "Hello everyone!",
        "user": "user1"
    });
    
    client1.send_message(chat_msg.to_string()).await;
    
    // 客户端2应该收到聊天消息
    let received_chat = timeout(Duration::from_secs(5), client2.receive_message())
        .await
        .expect("超时")
        .expect("接收消息失败");
    
    let received_chat_json: serde_json::Value = serde_json::from_str(&received_chat).unwrap();
    assert_eq!(received_chat_json["type"], "chat_message");
    assert_eq!(received_chat_json["message"], "Hello everyone!");
    assert_eq!(received_chat_json["user"], "user1");
    
    // 测试广播消息
    let broadcast_msg = json!({
        "type": "broadcast",
        "message": "Server announcement",
        "priority": "high"
    });
    
    // 管理员发送广播（需要admin权限）
    let admin_token = ctx.environment.generate_test_token("admin", vec!["admin"]).await;
    let mut admin_client = TestClient::connect(&ctx.server_url, &admin_token).await;
    
    admin_client.send_message(broadcast_msg.to_string()).await;
    
    // 所有客户端都应该收到广播消息
    for client in [&mut client1, &mut client2, &mut client3] {
        let broadcast_received = timeout(Duration::from_secs(5), client.receive_message())
            .await
            .expect("超时")
            .expect("接收消息失败");
        
        let broadcast_json: serde_json::Value = serde_json::from_str(&broadcast_received).unwrap();
        assert_eq!(broadcast_json["type"], "broadcast");
        assert_eq!(broadcast_json["message"], "Server announcement");
    }
    
    // 测试离开房间
    let leave_room_msg = json!({
        "type": "leave_room",
        "room": "test_room",
        "user": "user1"
    });
    
    client1.send_message(leave_room_msg.to_string()).await;
    
    // 客户端2应该收到用户离开通知
    let user_left = timeout(Duration::from_secs(5), client2.receive_message())
        .await
        .expect("超时")
        .expect("接收消息失败");
    
    let user_left_json: serde_json::Value = serde_json::from_str(&user_left).unwrap();
    assert_eq!(user_left_json["type"], "user_left");
    assert_eq!(user_left_json["user"], "user1");
    
    // 清理资源
    client1.close().await;
    client2.close().await;
    client3.close().await;
    admin_client.close().await;
}

#[tokio::test]
async fn test_authentication_and_authorization() {
    let ctx = E2ETestContext::new().await;
    
    // 测试无效 token
    let result = TestClient::connect_with_invalid_token(&ctx.server_url).await;
    assert!(result.is_err(), "应该拒绝无效 token");
    
    // 测试过期 token
    let expired_token = ctx.environment.generate_expired_token("user").await;
    let result = TestClient::connect(&ctx.server_url, &expired_token).await;
    // 连接应该失败或在认证时断开
    
    // 测试权限检查
    let user_token = ctx.environment.generate_test_token("user", vec!["user"]).await;
    let mut user_client = TestClient::connect(&ctx.server_url, &user_token).await;
    
    // 普通用户尝试执行管理员操作
    let admin_action = json!({
        "type": "admin_action",
        "action": "shutdown_server"
    });
    
    user_client.send_message(admin_action.to_string()).await;
    
    // 应该收到权限错误
    let error_response = timeout(Duration::from_secs(5), user_client.receive_message())
        .await
        .expect("超时")
        .expect("接收消息失败");
    
    let error_json: serde_json::Value = serde_json::from_str(&error_response).unwrap();
    assert_eq!(error_json["type"], "error");
    assert_eq!(error_json["code"], "insufficient_permissions");
    
    user_client.close().await;
}

#[tokio::test]
async fn test_connection_limits_and_throttling() {
    let ctx = E2ETestContext::new().await;
    let max_connections = ctx.environment.config().server.max_connections;
    
    // 创建大量连接接近限制
    let mut clients = Vec::new();
    for i in 0..max_connections.min(50) { // 限制测试规模
        let token = ctx.environment.generate_test_token(
            &format!("user_{}", i), 
            vec!["user"]
        ).await;
        
        match TestClient::connect(&ctx.server_url, &token).await {
            Ok(client) => clients.push(client),
            Err(_) => break, // 达到连接限制
        }
    }
    
    println!("成功创建 {} 个连接", clients.len());
    
    // 尝试创建超出限制的连接
    let overflow_token = ctx.environment.generate_test_token("overflow_user", vec!["user"]).await;
    if clients.len() >= max_connections {
        let result = timeout(
            Duration::from_secs(10),
            TestClient::connect(&ctx.server_url, &overflow_token)
        ).await;
        
        // 连接应该被拒绝或超时
        assert!(result.is_err() || result.unwrap().is_err());
    }
    
    // 测试消息速率限制
    if let Some(client) = clients.first_mut() {
        // 快速发送大量消息
        for i in 0..100 {
            let msg = json!({
                "type": "test_message",
                "content": format!("Spam message {}", i)
            });
            
            let result = timeout(
                Duration::from_millis(100),
                client.send_message(msg.to_string())
            ).await;
            
            if result.is_err() {
                println!("在第 {} 条消息时触发速率限制", i);
                break;
            }
        }
    }
    
    // 清理所有连接
    for mut client in clients {
        client.close().await;
    }
}

#[tokio::test]
async fn test_error_handling_and_recovery() {
    let ctx = E2ETestContext::new().await;
    
    let mut client = ctx.create_authenticated_client().await;
    
    // 测试发送格式错误的消息
    client.send_raw_message("invalid json {").await;
    
    let error_response = timeout(Duration::from_secs(5), client.receive_message())
        .await
        .expect("超时")
        .expect("接收消息失败");
    
    let error_json: serde_json::Value = serde_json::from_str(&error_response).unwrap();
    assert_eq!(error_json["type"], "error");
    assert_eq!(error_json["code"], "invalid_message_format");
    
    // 测试客户端在错误后仍然可以正常通信
    let valid_msg = json!({
        "type": "ping"
    });
    
    client.send_message(valid_msg.to_string()).await;
    
    let pong_response = timeout(Duration::from_secs(5), client.receive_message())
        .await
        .expect("超时")
        .expect("接收消息失败");
    
    let pong_json: serde_json::Value = serde_json::from_str(&pong_response).unwrap();
    assert_eq!(pong_json["type"], "pong");
    
    client.close().await;
}

#[tokio::test]
async fn test_performance_under_load() {
    let ctx = E2ETestContext::new().await;
    
    // 创建多个客户端进行并发测试
    let client_count = 10;
    let messages_per_client = 100;
    
    let mut handles = Vec::new();
    
    for i in 0..client_count {
        let server_url = ctx.server_url.clone();
        let token = ctx.environment.generate_test_token(
            &format!("load_user_{}", i),
            vec!["user"]
        ).await;
        
        let handle = tokio::spawn(async move {
            let mut client = TestClient::connect(&server_url, &token).await.unwrap();
            
            let start_time = std::time::Instant::now();
            
            // 发送消息
            for j in 0..messages_per_client {
                let msg = json!({
                    "type": "load_test",
                    "client_id": i,
                    "message_id": j,
                    "timestamp": chrono::Utc::now().timestamp()
                });
                
                client.send_message(msg.to_string()).await;
                
                // 小延迟以避免过度压力
                tokio::time::sleep(Duration::from_millis(10)).await;
            }
            
            let send_duration = start_time.elapsed();
            client.close().await;
            
            (i, send_duration)
        });
        
        handles.push(handle);
    }
    
    // 等待所有客户端完成
    let results = futures::future::join_all(handles).await;
    
    let mut total_duration = Duration::ZERO;
    for result in results {
        let (client_id, duration) = result.unwrap();
        println!("客户端 {} 完成，耗时: {:?}", client_id, duration);
        total_duration = total_duration.max(duration);
    }
    
    println!("负载测试完成，总耗时: {:?}", total_duration);
    
    // 验证性能指标
    let total_messages = client_count * messages_per_client;
    let messages_per_second = total_messages as f64 / total_duration.as_secs_f64();
    
    println!("吞吐量: {:.2} 消息/秒", messages_per_second);
    
    // 基本性能要求
    assert!(messages_per_second > 100.0, "消息吞吐量过低: {:.2}", messages_per_second);
    assert!(total_duration < Duration::from_secs(60), "测试执行时间过长: {:?}", total_duration);
}</pre>

        <p><strong>步骤 4: 生产级部署自动化</strong></p>
        <pre># scripts/deploy/production.sh
#!/bin/bash
# 生产环境部署脚本

set -euo pipefail

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# 日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_step() {
    echo -e "${BLUE}[STEP]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

# 配置变量
NAMESPACE="websocket-prod"
DEPLOYMENT_NAME="websocket-server"
IMAGE_TAG=${1:-latest}
HELM_RELEASE="websocket-prod"
KUBECONFIG=${KUBECONFIG:-~/.kube/config}

# 验证工具
check_dependencies() {
    log_step "检查部署依赖..."
    
    local deps=("kubectl" "helm" "docker" "curl" "jq")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            log_error "$dep 未安装"
            exit 1
        fi
    done
    
    # 检查 Kubernetes 连接
    if ! kubectl cluster-info &> /dev/null; then
        log_error "无法连接到 Kubernetes 集群"
        exit 1
    fi
    
    log_info "所有依赖检查通过"
}

# 预部署验证
pre_deployment_checks() {
    log_step "执行预部署检查..."
    
    # 检查镜像是否存在
    local image="websocket-server:$IMAGE_TAG"
    if ! docker manifest inspect "$image" &> /dev/null; then
        log_error "镜像 $image 不存在"
        exit 1
    fi
    
    # 检查 Helm Chart
    if ! helm lint helm/websocket-server/; then
        log_error "Helm Chart 验证失败"
        exit 1
    fi
    
    # 检查集群资源
    local available_nodes=$(kubectl get nodes --no-headers | grep Ready | wc -l)
    if [ "$available_nodes" -lt 3 ]; then
        log_warn "可用节点数量较少: $available_nodes"
    fi
    
    log_info "预部署检查完成"
}

# 创建命名空间
create_namespace() {
    log_step "创建/验证命名空间..."
    
    if ! kubectl get namespace "$NAMESPACE" &> /dev/null; then
        kubectl create namespace "$NAMESPACE"
        log_info "命名空间 $NAMESPACE 已创建"
    else
        log_info "命名空间 $NAMESPACE 已存在"
    fi
    
    # 设置资源配额
    kubectl apply -f - <<EOF
apiVersion: v1
kind: ResourceQuota
metadata:
  name: websocket-quota
  namespace: $NAMESPACE
spec:
  hard:
    requests.cpu: "10"
    requests.memory: 20Gi
    limits.cpu: "20"
    limits.memory: 40Gi
    persistentvolumeclaims: "10"
    services: "5"
    secrets: "10"
    configmaps: "10"
EOF
    
    log_info "资源配额已应用"
}

# 部署 Secrets
deploy_secrets() {
    log_step "部署机密信息..."
    
    # 检查必需的环境变量
    local required_vars=("JWT_SECRET" "REDIS_PASSWORD" "TLS_CERT" "TLS_KEY")
    for var in "${required_vars[@]}"; do
        if [ -z "${!var:-}" ]; then
            log_error "环境变量 $var 未设置"
            exit 1
        fi
    done
    
    # 创建 TLS Secret
    kubectl create secret tls websocket-tls \
        --cert=<(echo "$TLS_CERT" | base64 -d) \
        --key=<(echo "$TLS_KEY" | base64 -d) \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    # 创建应用 Secret
    kubectl create secret generic websocket-secrets \
        --from-literal=jwt-secret="$JWT_SECRET" \
        --from-literal=redis-password="$REDIS_PASSWORD" \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    log_info "机密信息部署完成"
}

# 部署依赖服务
deploy_dependencies() {
    log_step "部署依赖服务..."
    
    # 部署 Redis 集群
    helm repo add bitnami https://charts.bitnami.com/bitnami
    helm repo update
    
    helm upgrade --install redis-cluster bitnami/redis-cluster \
        --namespace="$NAMESPACE" \
        --set auth.enabled=true \
        --set auth.password="$REDIS_PASSWORD" \
        --set cluster.nodes=6 \
        --set cluster.replicas=1 \
        --set persistence.enabled=true \
        --set persistence.size=10Gi \
        --set resources.requests.memory=1Gi \
        --set resources.requests.cpu=500m \
        --set resources.limits.memory=2Gi \
        --set resources.limits.cpu=1000m \
        --wait --timeout=600s
    
    # 部署 Prometheus
    helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
    helm repo update
    
    helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
        --namespace="$NAMESPACE" \
        --set prometheus.prometheusSpec.retention=30d \
        --set prometheus.prometheusSpec.storageSpec.volumeClaimTemplate.spec.resources.requests.storage=50Gi \
        --set grafana.persistence.enabled=true \
        --set grafana.persistence.size=10Gi \
        --wait --timeout=600s
    
    log_info "依赖服务部署完成"
}

# 部署主应用
deploy_application() {
    log_step "部署 WebSocket 服务..."
    
    # 准备 Helm values
    cat > /tmp/production-values.yaml <<EOF
image:
  repository: websocket-server
  tag: "$IMAGE_TAG"
  pullPolicy: Always

replicaCount: 3

resources:
  requests:
    cpu: 1000m
    memory: 1Gi
  limits:
    cpu: 2000m
    memory: 4Gi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

service:
  type: ClusterIP
  port: 8080
  targetPort: 8080

ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/websocket-services: "$DEPLOYMENT_NAME"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: ws.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: websocket-tls
      hosts:
        - ws.example.com

config:
  environment: production
  server:
    host: "0.0.0.0"
    port: 8080
    maxConnections: 10000
    tlsEnabled: true
  monitoring:
    metricsEnabled: true
    tracingEnabled: true

secrets:
  jwtSecret: "websocket-secrets"
  redisPassword: "websocket-secrets"

redis:
  enabled: false
  externalRedis:
    host: "redis-cluster"
    port: 6379
    auth: true

monitoring:
  serviceMonitor:
    enabled: true
    interval: 30s

podDisruptionBudget:
  enabled: true
  minAvailable: 2

networkPolicy:
  enabled: true
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx
      ports:
      - protocol: TCP
        port: 8080
    - from:
      - namespaceSelector:
          matchLabels:
            name: monitoring
      ports:
      - protocol: TCP
        port: 9090

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

podSecurityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
EOF
    
    # 部署应用
    helm upgrade --install "$HELM_RELEASE" helm/websocket-server/ \
        --namespace="$NAMESPACE" \
        --values=/tmp/production-values.yaml \
        --wait --timeout=600s
    
    log_info "WebSocket 服务部署完成"
}

# 部署后验证
post_deployment_verification() {
    log_step "执行部署后验证..."
    
    # 等待 Pods 就绪
    log_info "等待 Pods 就绪..."
    kubectl wait --for=condition=ready pod \
        -l app.kubernetes.io/name=websocket-server \
        --namespace="$NAMESPACE" \
        --timeout=300s
    
    # 检查服务状态
    local ready_pods=$(kubectl get pods -l app.kubernetes.io/name=websocket-server \
        --namespace="$NAMESPACE" --no-headers | grep Running | wc -l)
    log_info "就绪的 Pods 数量: $ready_pods"
    
    # 健康检查
    local service_ip=$(kubectl get service "$DEPLOYMENT_NAME" \
        --namespace="$NAMESPACE" -o jsonpath='{.spec.clusterIP}')
    
    kubectl run health-check --rm -i --restart=Never --image=curlimages/curl -- \
        curl -f "http://$service_ip:8080/health" || {
        log_error "健康检查失败"
        exit 1
    }
    
    # 检查指标端点
    kubectl run metrics-check --rm -i --restart=Never --image=curlimages/curl -- \
        curl -f "http://$service_ip:9090/metrics" || {
        log_warn "指标端点检查失败"
    }
    
    log_info "部署验证完成"
}

# 配置监控告警
setup_monitoring() {
    log_step "配置监控告警..."
    
    # 应用 Prometheus 规则
    kubectl apply -f k8s/monitoring/prometheus-rules.yaml -n "$NAMESPACE"
    
    # 配置 Grafana 仪表板
    kubectl create configmap websocket-dashboard \
        --from-file=configs/monitoring/grafana-dashboard.json \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    log_info "监控配置完成"
}

# 清理临时文件
cleanup() {
    log_step "清理临时文件..."
    rm -f /tmp/production-values.yaml
    log_info "清理完成"
}

# 主部署流程
main() {
    log_info "开始生产环境部署 - 镜像标签: $IMAGE_TAG"
    
    # 设置错误处理
    trap cleanup EXIT
    
    check_dependencies
    pre_deployment_checks
    create_namespace
    deploy_secrets
    deploy_dependencies
    deploy_application
    post_deployment_verification
    setup_monitoring
    
    log_info "生产环境部署完成！"
    log_info "访问地址: https://ws.example.com"
    log_info "监控面板: https://grafana.example.com"
    
    # 显示部署状态
    echo
    log_info "部署状态概览:"
    kubectl get all -n "$NAMESPACE"
}

# 执行主流程
main "$@"</pre>

        <p><strong>步骤 5: 运维监控和告警体系</strong></p>
        <pre># k8s/monitoring/prometheus-rules.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: websocket-server-rules
  namespace: websocket-prod
  labels:
    app: websocket-server
    prometheus: kube-prometheus
    role: alert-rules
spec:
  groups:
  - name: websocket-server.rules
    interval: 30s
    rules:
    # 连接数指标
    - record: websocket:connection_count
      expr: sum(websocket_active_connections) by (instance)
    
    - record: websocket:connection_rate
      expr: rate(websocket_connections_total[5m])
    
    # 消息处理指标
    - record: websocket:message_rate
      expr: rate(websocket_messages_total[5m])
    
    - record: websocket:message_latency_p99
      expr: histogram_quantile(0.99, rate(websocket_message_duration_seconds_bucket[5m]))
    
    # 错误率指标
    - record: websocket:error_rate
      expr: rate(websocket_errors_total[5m])
    
    # 资源使用指标
    - record: websocket:memory_usage_percent
      expr: (container_memory_working_set_bytes{container="websocket-server"} / container_spec_memory_limit_bytes{container="websocket-server"}) * 100
    
    - record: websocket:cpu_usage_percent
      expr: rate(container_cpu_usage_seconds_total{container="websocket-server"}[5m]) * 100

  - name: websocket-server.alerts
    rules:
    # 服务可用性告警
    - alert: WebSocketServerDown
      expr: up{job="websocket-server"} == 0
      for: 1m
      labels:
        severity: critical
        service: websocket-server
      annotations:
        summary: "WebSocket 服务器实例宕机"
        description: "WebSocket 服务器实例 {{ $labels.instance }} 已宕机超过1分钟"
        runbook_url: "https://docs.example.com/runbooks/websocket-server-down"
    
    # 高连接数告警
    - alert: HighConnectionCount
      expr: websocket:connection_count > 8000
      for: 5m
      labels:
        severity: warning
        service: websocket-server
      annotations:
        summary: "WebSocket 连接数过高"
        description: "实例 {{ $labels.instance }} 连接数 {{ $value }} 超过阈值"
        runbook_url: "https://docs.example.com/runbooks/high-connection-count"
    
    # 连接数接近限制告警
    - alert: ConnectionLimitApproaching
      expr: websocket:connection_count > 9500
      for: 2m
      labels:
        severity: critical
        service: websocket-server
      annotations:
        summary: "WebSocket 连接数接近限制"
        description: "实例 {{ $labels.instance }} 连接数 {{ $value }} 接近10000限制"
        runbook_url: "https://docs.example.com/runbooks/connection-limit"
    
    # 高错误率告警
    - alert: HighErrorRate
      expr: websocket:error_rate > 10
      for: 2m
      labels:
        severity: warning
        service: websocket-server  
      annotations:
        summary: "WebSocket 错误率过高"
        description: "实例 {{ $labels.instance }} 错误率 {{ $value }}/s 超过阈值"
        runbook_url: "https://docs.example.com/runbooks/high-error-rate"
    
    # 消息延迟告警
    - alert: HighMessageLatency
      expr: websocket:message_latency_p99 > 1.0
      for: 5m
      labels:
        severity: warning
        service: websocket-server
      annotations:
        summary: "WebSocket 消息延迟过高"
        description: "实例 {{ $labels.instance }} P99延迟 {{ $value }}s 超过1秒"
        runbook_url: "https://docs.example.com/runbooks/high-latency"
    
    # 内存使用告警
    - alert: HighMemoryUsage
      expr: websocket:memory_usage_percent > 85
      for: 5m
      labels:
        severity: warning
        service: websocket-server
      annotations:
        summary: "WebSocket 服务器内存使用率过高"
        description: "实例 {{ $labels.instance }} 内存使用率 {{ $value }}% 超过85%"
        runbook_url: "https://docs.example.com/runbooks/high-memory"
    
    # CPU 使用告警
    - alert: HighCPUUsage
      expr: websocket:cpu_usage_percent > 80
      for: 10m
      labels:
        severity: warning
        service: websocket-server
      annotations:
        summary: "WebSocket 服务器 CPU 使用率过高"
        description: "实例 {{ $labels.instance }} CPU使用率 {{ $value }}% 持续超过80%"
        runbook_url: "https://docs.example.com/runbooks/high-cpu"
    
    # Redis 连接告警
    - alert: RedisConnectionFailed
      expr: websocket_redis_connection_errors_total > 0
      for: 1m
      labels:
        severity: critical
        service: websocket-server
      annotations:
        summary: "Redis 连接失败"
        description: "WebSocket 服务无法连接到 Redis"
        runbook_url: "https://docs.example.com/runbooks/redis-connection"
    
    # Pod 重启告警
    - alert: PodRestartingTooOften
      expr: rate(kube_pod_container_status_restarts_total{container="websocket-server"}[1h]) * 3600 > 5
      for: 5m
      labels:
        severity: warning
        service: websocket-server
      annotations:
        summary: "Pod 重启过于频繁"
        description: "Pod {{ $labels.pod }} 在过去1小时内重启超过5次"
        runbook_url: "https://docs.example.com/runbooks/pod-restarts"
    
    # 磁盘空间告警
    - alert: DiskSpaceRunningLow
      expr: (node_filesystem_avail_bytes{mountpoint="/"} / node_filesystem_size_bytes{mountpoint="/"}) * 100 < 20
      for: 5m
      labels:
        severity: warning
        service: infrastructure
      annotations:
        summary: "磁盘空间不足"
        description: "节点 {{ $labels.instance }} 根分区剩余空间 {{ $value }}% 低于20%"
        runbook_url: "https://docs.example.com/runbooks/disk-space"</pre>

        <p><strong>实践练习：</strong></p>
        <ol>
            <li><strong>完整项目构建</strong>
                <pre>cd day30_production_ready
cargo build --release
cargo test --all
cargo bench</pre>
            </li>
            <li><strong>Docker 镜像构建</strong>
                <pre>docker build -t websocket-server:v1.0.0 .
docker run --rm -p 8080:8080 websocket-server:v1.0.0</pre>
            </li>
            <li><strong>集成测试执行</strong>
                <pre>cargo test --test integration
cargo test --test e2e_tests</pre>
            </li>
            <li><strong>生产部署</strong>
                <pre>./scripts/deploy/production.sh v1.0.0
kubectl get all -n websocket-prod</pre>
            </li>
            <li><strong>负载测试验证</strong>
                <pre>./scripts/test/load-test.sh
./scripts/test/security-test.sh</pre>
            </li>
        </ol>

        <p><strong>生产就绪检查清单：</strong></p>
        <ul>
            <li>✅ <strong>代码质量</strong>: 测试覆盖率 > 90%，静态分析通过</li>
            <li>✅ <strong>性能验证</strong>: 负载测试、内存泄漏检查、延迟分析</li>
            <li>✅ <strong>安全审计</strong>: 漏洞扫描、权限验证、加密实施</li>
            <li>✅ <strong>可观测性</strong>: 日志、指标、追踪、告警配置</li>
            <li>✅ <strong>高可用性</strong>: 多副本、健康检查、自动故障转移</li>
            <li>✅ <strong>扩展性</strong>: 水平扩展、负载均衡、资源管理</li>
            <li>✅ <strong>运维自动化</strong>: CI/CD 流水线、部署脚本、回滚策略</li>
            <li>✅ <strong>文档完整</strong>: API 文档、部署指南、故障排查手册</li>
        </ul>

        <p class="date"><strong>🗓️ 2025-08-31</strong></p>
        <h2>Day 31 - 项目验收与最终部署验证</h2>
        <p>执行全面的项目验收测试，完成最终生产部署，并建立长期运维和持续改进机制。</p>
        
        <h3>学习目标</h3>
        <ul>
            <li>执行全面的项目验收和质量评估</li>
            <li>完成最终生产环境部署和验证</li>
            <li>建立运维监控和告警体系</li>
            <li>制定持续集成和持续部署流程</li>
            <li>构建项目文档和知识传承体系</li>
            <li>规划未来技术演进和扩展路线</li>
        </ul>
        <p>🔗 <a href="https://doc.rust-lang.org/book/" target="_blank">阅读对应官方文档</a></p>
        
        <h3>详细步骤：</h3>
        <p><strong>步骤 1: 全面项目验收测试</strong></p>
        <pre>📁 验收测试项目结构：
day31_project_validation/
├── src/
│   ├── main.rs
│   ├── validation/
│   │   ├── mod.rs
│   │   ├── functional_tests.rs
│   │   ├── performance_tests.rs
│   │   ├── security_tests.rs
│   │   ├── reliability_tests.rs
│   │   └── acceptance_tests.rs
│   ├── reporting/
│   │   ├── mod.rs
│   │   ├── test_reporter.rs
│   │   ├── metrics_collector.rs
│   │   └── dashboard_generator.rs
│   └── utils/
│       ├── mod.rs
│       ├── test_client.rs
│       ├── load_generator.rs
│       └── data_generator.rs
├── tests/
│   ├── acceptance/
│   │   ├── user_stories.rs
│   │   ├── business_requirements.rs
│   │   └── integration_scenarios.rs
│   ├── performance/
│   │   ├── load_tests.rs
│   │   ├── stress_tests.rs
│   │   ├── endurance_tests.rs
│   │   └── scalability_tests.rs
│   ├── security/
│   │   ├── auth_tests.rs
│   │   ├── vulnerability_tests.rs
│   │   ├── penetration_tests.rs
│   │   └── compliance_tests.rs
│   └── reliability/
│       ├── failover_tests.rs
│       ├── recovery_tests.rs
│       ├── chaos_tests.rs
│       └── availability_tests.rs
├── scripts/
│   ├── validation/
│   │   ├── run-all-tests.sh
│   │   ├── performance-validation.sh
│   │   ├── security-audit.sh
│   │   └── compliance-check.sh
│   ├── deployment/
│   │   ├── final-deploy.sh
│   │   ├── smoke-test.sh
│   │   ├── rollback.sh
│   │   └── disaster-recovery.sh
│   └── reporting/
│       ├── generate-report.sh
│       ├── metrics-analysis.sh
│       └── dashboard-update.sh
├── configs/
│   ├── validation.toml
│   ├── performance-thresholds.yaml
│   ├── security-policies.json
│   └── acceptance-criteria.yaml
├── reports/
│   ├── validation-report.md
│   ├── performance-analysis.md
│   ├── security-audit.md
│   └── final-assessment.pdf
└── docs/
    ├── validation-plan.md
    ├── deployment-guide.md
    ├── operational-runbook.md
    └── post-deployment-checklist.md</pre>

        <p><strong>功能验收测试实现：</strong></p>
        <pre># src/validation/functional_tests.rs
//! 功能验收测试套件

use std::time::Duration;
use tokio::time::timeout;
use serde_json::json;
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::utils::{TestClient, LoadGenerator, DataGenerator};
use crate::reporting::TestReporter;

/// 功能验收测试套件
pub struct FunctionalValidationSuite {
    reporter: TestReporter,
    test_clients: Vec<TestClient>,
    load_generator: LoadGenerator,
}

impl FunctionalValidationSuite {
    pub async fn new() -> Self {
        Self {
            reporter: TestReporter::new("functional_validation").await,
            test_clients: Vec::new(),
            load_generator: LoadGenerator::new().await,
        }
    }
    
    /// 执行完整的功能验收测试
    pub async fn run_full_validation(&mut self) -> ValidationResult {
        self.reporter.start_test_suite("WebSocket 功能验收测试").await;
        
        let mut results = ValidationResult::new();
        
        // 1. 连接建立验证
        results.merge(self.test_connection_establishment().await);
        
        // 2. 身份认证验证
        results.merge(self.test_authentication_flow().await);
        
        // 3. 消息传输验证
        results.merge(self.test_message_transmission().await);
        
        // 4. 房间管理验证
        results.merge(self.test_room_management().await);
        
        // 5. 广播功能验证
        results.merge(self.test_broadcasting().await);
        
        // 6. 错误处理验证
        results.merge(self.test_error_handling().await);
        
        // 7. 资源清理验证
        results.merge(self.test_resource_cleanup().await);
        
        self.reporter.finish_test_suite(results.clone()).await;
        results
    }
    
    /// 测试连接建立功能
    async fn test_connection_establishment(&mut self) -> ValidationResult {
        self.reporter.start_test("连接建立测试").await;
        let mut result = ValidationResult::new();
        
        // 测试正常连接
        match TestClient::connect_with_valid_token().await {
            Ok(client) => {
                result.passed += 1;
                self.test_clients.push(client);
                self.reporter.log_success("正常连接建立成功").await;
            }
            Err(e) => {
                result.failed += 1;
                self.reporter.log_error(&format!("正常连接失败: {}", e)).await;
            }
        }
        
        // 测试无效认证连接
        match TestClient::connect_with_invalid_token().await {
            Err(_) => {
                result.passed += 1;
                self.reporter.log_success("无效认证正确被拒绝").await;
            }
            Ok(_) => {
                result.failed += 1;
                self.reporter.log_error("无效认证应该被拒绝").await;
            }
        }
        
        // 测试并发连接
        let concurrent_connections = 100;
        let start_time = std::time::Instant::now();
        
        let connection_tasks: Vec<_> = (0..concurrent_connections)
            .map(|i| {
                let client_id = format!("concurrent_client_{}", i);
                async move {
                    TestClient::connect_with_user_token(&client_id).await
                }
            })
            .collect();
        
        let connection_results = futures::future::join_all(connection_tasks).await;
        let successful_connections = connection_results.iter()
            .filter(|r| r.is_ok())
            .count();
        
        let connection_time = start_time.elapsed();
        
        if successful_connections >= concurrent_connections * 95 / 100 {
            result.passed += 1;
            self.reporter.log_success(&format!(
                "并发连接测试通过: {}/{} 连接成功，耗时 {:?}",
                successful_connections, concurrent_connections, connection_time
            )).await;
        } else {
            result.failed += 1;
            self.reporter.log_error(&format!(
                "并发连接测试失败: 仅 {}/{} 连接成功",
                successful_connections, concurrent_connections
            )).await;
        }
        
        result
    }
    
    /// 测试身份认证流程
    async fn test_authentication_flow(&mut self) -> ValidationResult {
        self.reporter.start_test("身份认证流程测试").await;
        let mut result = ValidationResult::new();
        
        // 测试 JWT Token 验证
        let test_cases = vec![
            ("有效 token", TestClient::generate_valid_token("test_user"), true),
            ("过期 token", TestClient::generate_expired_token("test_user"), false),
            ("无效签名", TestClient::generate_invalid_signature_token("test_user"), false),
            ("格式错误", "invalid.token.format".to_string(), false),
            ("空 token", "".to_string(), false),
        ];
        
        for (test_name, token, should_succeed) in test_cases {
            match TestClient::connect_with_token(&token).await {
                Ok(_) if should_succeed => {
                    result.passed += 1;
                    self.reporter.log_success(&format!("{} 测试通过", test_name)).await;
                }
                Err(_) if !should_succeed => {
                    result.passed += 1;
                    self.reporter.log_success(&format!("{} 正确被拒绝", test_name)).await;
                }
                Ok(_) => {
                    result.failed += 1;
                    self.reporter.log_error(&format!("{} 应该被拒绝但成功了", test_name)).await;
                }
                Err(_) => {
                    result.failed += 1;
                    self.reporter.log_error(&format!("{} 应该成功但失败了", test_name)).await;
                }
            }
        }
        
        // 测试权限验证
        let user_client = TestClient::connect_with_user_token("regular_user").await.unwrap();
        let admin_client = TestClient::connect_with_admin_token("admin_user").await.unwrap();
        
        // 普通用户尝试管理员操作
        let admin_action = json!({
            "type": "admin_shutdown",
            "reason": "maintenance"
        });
        
        user_client.send_message(admin_action.to_string()).await;
        
        if let Ok(response) = timeout(Duration::from_secs(5), user_client.receive_message()).await {
            if let Ok(response) = response {
                let response_json: serde_json::Value = serde_json::from_str(&response).unwrap();
                if response_json["type"] == "error" && response_json["code"] == "insufficient_permissions" {
                    result.passed += 1;
                    self.reporter.log_success("权限验证正确工作").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("权限验证失败").await;
                }
            }
        }
        
        // 管理员执行管理员操作
        admin_client.send_message(json!({
            "type": "admin_stats",
            "query": "connection_count"
        }).to_string()).await;
        
        if let Ok(response) = timeout(Duration::from_secs(5), admin_client.receive_message()).await {
            if let Ok(response) = response {
                let response_json: serde_json::Value = serde_json::from_str(&response).unwrap();
                if response_json["type"] == "admin_stats_response" {
                    result.passed += 1;
                    self.reporter.log_success("管理员操作正确执行").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("管理员操作执行失败").await;
                }
            }
        }
        
        self.test_clients.push(user_client);
        self.test_clients.push(admin_client);
        
        result
    }
    
    /// 测试消息传输功能
    async fn test_message_transmission(&mut self) -> ValidationResult {
        self.reporter.start_test("消息传输测试").await;
        let mut result = ValidationResult::new();
        
        let client1 = TestClient::connect_with_user_token("user1").await.unwrap();
        let client2 = TestClient::connect_with_user_token("user2").await.unwrap();
        
        // 测试文本消息传输
        let test_message = "Hello, WebSocket World! 🌍";
        let message_payload = json!({
            "type": "direct_message",
            "to": "user2",
            "content": test_message,
            "timestamp": Utc::now().timestamp()
        });
        
        client1.send_message(message_payload.to_string()).await;
        
        // 验证消息接收
        if let Ok(response) = timeout(Duration::from_secs(5), client2.receive_message()).await {
            if let Ok(received_message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&received_message).unwrap();
                if msg_json["content"] == test_message {
                    result.passed += 1;
                    self.reporter.log_success("文本消息传输成功").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("文本消息内容不匹配").await;
                }
            }
        } else {
            result.failed += 1;
            self.reporter.log_error("消息接收超时").await;
        }
        
        // 测试二进制消息传输
        let binary_data = vec![0x48, 0x65, 0x6c, 0x6c, 0x6f]; // "Hello" in bytes
        let binary_payload = json!({
            "type": "binary_message",
            "to": "user1",
            "data": base64::encode(&binary_data)
        });
        
        client2.send_message(binary_payload.to_string()).await;
        
        if let Ok(response) = timeout(Duration::from_secs(5), client1.receive_message()).await {
            if let Ok(received_message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&received_message).unwrap();
                if let Some(data_str) = msg_json["data"].as_str() {
                    if let Ok(decoded_data) = base64::decode(data_str) {
                        if decoded_data == binary_data {
                            result.passed += 1;
                            self.reporter.log_success("二进制消息传输成功").await;
                        } else {
                            result.failed += 1;
                            self.reporter.log_error("二进制消息数据不匹配").await;
                        }
                    }
                }
            }
        } else {
            result.failed += 1;
            self.reporter.log_error("二进制消息接收超时").await;
        }
        
        // 测试大消息传输
        let large_message = "A".repeat(1024 * 1024); // 1MB message
        let large_payload = json!({
            "type": "large_message",
            "to": "user2",
            "content": large_message
        });
        
        let start_time = std::time::Instant::now();
        client1.send_message(large_payload.to_string()).await;
        
        if let Ok(response) = timeout(Duration::from_secs(30), client2.receive_message()).await {
            let transmission_time = start_time.elapsed();
            if let Ok(received_message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&received_message).unwrap();
                if msg_json["content"].as_str().map(|s| s.len()) == Some(1024 * 1024) {
                    result.passed += 1;
                    self.reporter.log_success(&format!(
                        "大消息传输成功，耗时: {:?}", transmission_time
                    )).await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("大消息大小不匹配").await;
                }
            }
        } else {
            result.failed += 1;
            self.reporter.log_error("大消息传输超时").await;
        }
        
        self.test_clients.push(client1);
        self.test_clients.push(client2);
        
        result
    }
    
    /// 测试房间管理功能
    async fn test_room_management(&mut self) -> ValidationResult {
        self.reporter.start_test("房间管理测试").await;
        let mut result = ValidationResult::new();
        
        let user1 = TestClient::connect_with_user_token("room_user1").await.unwrap();
        let user2 = TestClient::connect_with_user_token("room_user2").await.unwrap();
        let user3 = TestClient::connect_with_user_token("room_user3").await.unwrap();
        
        let room_name = format!("test_room_{}", Uuid::new_v4());
        
        // 用户1创建房间
        user1.send_message(json!({
            "type": "create_room",
            "room": room_name,
            "max_users": 3
        }).to_string()).await;
        
        // 验证房间创建响应
        if let Ok(response) = timeout(Duration::from_secs(5), user1.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "room_created" {
                    result.passed += 1;
                    self.reporter.log_success("房间创建成功").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("房间创建失败").await;
                }
            }
        }
        
        // 用户2加入房间
        user2.send_message(json!({
            "type": "join_room",
            "room": room_name
        }).to_string()).await;
        
        // 验证加入房间
        let mut join_confirmed = false;
        let mut user1_notified = false;
        
        // 检查用户2的加入确认
        if let Ok(response) = timeout(Duration::from_secs(5), user2.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "room_joined" {
                    join_confirmed = true;
                }
            }
        }
        
        // 检查用户1是否收到新用户通知
        if let Ok(response) = timeout(Duration::from_secs(5), user1.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "user_joined" {
                    user1_notified = true;
                }
            }
        }
        
        if join_confirmed && user1_notified {
            result.passed += 1;
            self.reporter.log_success("房间加入功能正常").await;
        } else {
            result.failed += 1;
            self.reporter.log_error("房间加入功能异常").await;
        }
        
        // 测试房间内广播
        user1.send_message(json!({
            "type": "room_broadcast",
            "room": room_name,
            "message": "欢迎大家来到测试房间！"
        }).to_string()).await;
        
        // 验证用户2收到广播
        if let Ok(response) = timeout(Duration::from_secs(5), user2.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "room_broadcast" && msg_json["message"] == "欢迎大家来到测试房间！" {
                    result.passed += 1;
                    self.reporter.log_success("房间广播功能正常").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("房间广播内容异常").await;
                }
            }
        } else {
            result.failed += 1;
            self.reporter.log_error("房间广播接收超时").await;
        }
        
        // 测试房间人数限制
        user3.send_message(json!({
            "type": "join_room",
            "room": room_name
        }).to_string()).await;
        
        // 再尝试加入第4个用户（应该失败）
        let user4 = TestClient::connect_with_user_token("room_user4").await.unwrap();
        user4.send_message(json!({
            "type": "join_room",
            "room": room_name
        }).to_string()).await;
        
        if let Ok(response) = timeout(Duration::from_secs(5), user4.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "error" && msg_json["code"] == "room_full" {
                    result.passed += 1;
                    self.reporter.log_success("房间人数限制正常工作").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("房间人数限制失效").await;
                }
            }
        }
        
        // 测试离开房间
        user2.send_message(json!({
            "type": "leave_room",
            "room": room_name
        }).to_string()).await;
        
        // 验证用户1收到离开通知
        if let Ok(response) = timeout(Duration::from_secs(5), user1.receive_message()).await {
            if let Ok(message) = response {
                let msg_json: serde_json::Value = serde_json::from_str(&message).unwrap();
                if msg_json["type"] == "user_left" {
                    result.passed += 1;
                    self.reporter.log_success("离开房间功能正常").await;
                } else {
                    result.failed += 1;
                    self.reporter.log_error("离开房间通知异常").await;
                }
            }
        }
        
        self.test_clients.extend(vec![user1, user2, user3, user4]);
        result
    }
    
    /// 清理测试资源
    async fn cleanup(&mut self) {
        self.reporter.log_info("清理测试资源").await;
        
        for client in &mut self.test_clients {
            client.close().await;
        }
        self.test_clients.clear();
        
        self.reporter.log_info("资源清理完成").await;
    }
}

#[derive(Debug, Clone)]
pub struct ValidationResult {
    pub passed: u32,
    pub failed: u32,
    pub skipped: u32,
    pub errors: Vec<String>,
    pub warnings: Vec<String>,
    pub metrics: std::collections::HashMap<String, f64>,
}

impl ValidationResult {
    pub fn new() -> Self {
        Self {
            passed: 0,
            failed: 0,
            skipped: 0,
            errors: Vec::new(),
            warnings: Vec::new(),
            metrics: std::collections::HashMap::new(),
        }
    }
    
    pub fn merge(&mut self, other: ValidationResult) {
        self.passed += other.passed;
        self.failed += other.failed;
        self.skipped += other.skipped;
        self.errors.extend(other.errors);
        self.warnings.extend(other.warnings);
        self.metrics.extend(other.metrics);
    }
    
    pub fn success_rate(&self) -> f64 {
        let total = self.passed + self.failed;
        if total == 0 {
            0.0
        } else {
            (self.passed as f64) / (total as f64) * 100.0
        }
    }
    
    pub fn is_passing(&self) -> bool {
        self.success_rate() >= 95.0 && self.failed == 0
    }
}</pre>

        <p><strong>步骤 2: 性能压力测试</strong></p>
        <pre># src/validation/performance_tests.rs
//! 性能压力测试套件

use std::time::{Duration, Instant};
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, AtomicU32, Ordering};
use tokio::sync::Semaphore;
use futures::future::join_all;
use serde_json::json;

use crate::utils::{TestClient, LoadGenerator};
use crate::reporting::TestReporter;
use super::ValidationResult;

/// 性能测试配置
#[derive(Debug, Clone)]
pub struct PerformanceTestConfig {
    pub max_connections: u32,
    pub messages_per_second_target: u32,
    pub test_duration_seconds: u64,
    pub latency_p99_threshold_ms: u64,
    pub memory_limit_mb: u64,
    pub cpu_limit_percent: f64,
}

impl Default for PerformanceTestConfig {
    fn default() -> Self {
        Self {
            max_connections: 10000,
            messages_per_second_target: 50000,
            test_duration_seconds: 300, // 5分钟
            latency_p99_threshold_ms: 100,
            memory_limit_mb: 4096,
            cpu_limit_percent: 80.0,
        }
    }
}

/// 性能测试套件
pub struct PerformanceTestSuite {
    config: PerformanceTestConfig,
    reporter: TestReporter,
    load_generator: LoadGenerator,
}

impl PerformanceTestSuite {
    pub async fn new(config: PerformanceTestConfig) -> Self {
        Self {
            config,
            reporter: TestReporter::new("performance_validation").await,
            load_generator: LoadGenerator::new().await,
        }
    }
    
    /// 执行完整的性能测试
    pub async fn run_performance_validation(&mut self) -> ValidationResult {
        self.reporter.start_test_suite("WebSocket 性能压力测试").await;
        
        let mut results = ValidationResult::new();
        
        // 1. 连接容量测试
        results.merge(self.test_connection_capacity().await);
        
        // 2. 消息吞吐量测试
        results.merge(self.test_message_throughput().await);
        
        // 3. 延迟测试
        results.merge(self.test_latency_performance().await);
        
        // 4. 并发压力测试
        results.merge(self.test_concurrent_load().await);
        
        // 5. 内存使用测试
        results.merge(self.test_memory_usage().await);
        
        // 6. 长期稳定性测试
        results.merge(self.test_endurance().await);
        
        self.reporter.finish_test_suite(results.clone()).await;
        results
    }
    
    /// 测试连接容量
    async fn test_connection_capacity(&mut self) -> ValidationResult {
        self.reporter.start_test("连接容量测试").await;
        let mut result = ValidationResult::new();
        
        let target_connections = self.config.max_connections.min(5000); // 限制测试规模
        let batch_size = 100;
        let mut successful_connections = 0u32;
        
        self.reporter.log_info(&format!(
            "开始连接容量测试，目标连接数: {}", target_connections
        )).await;
        
        let start_time = Instant::now();
        let semaphore = Arc::new(Semaphore::new(batch_size));
        let connection_counter = Arc::new(AtomicU32::new(0));
        
        let mut connection_tasks = Vec::new();
        
        for i in 0..target_connections {
            let permit = semaphore.clone().acquire_owned().await.unwrap();
            let counter = connection_counter.clone();
            
            let task = tokio::spawn(async move {
                let _permit = permit; // 保持 permit 直到任务完成
                
                let client_id = format!("capacity_test_client_{}", i);
                match TestClient::connect_with_user_token(&client_id).await {
                    Ok(client) => {
                        counter.fetch_add(1, Ordering::Relaxed);
                        
                        // 保持连接一段时间
                        tokio::time::sleep(Duration::from_secs(30)).await;
                        
                        client.close().await;
                        true
                    }
                    Err(_) => false,
                }
            });
            
            connection_tasks.push(task);
            
            // 控制连接建立速率
            if i % batch_size == 0 {
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
        }
        
        // 等待所有连接任务完成
        let results = join_all(connection_tasks).await;
        let establishment_time = start_time.elapsed();
        
        successful_connections = results.iter()
            .filter_map(|r| r.as_ref().ok())
            .filter(|&&success| success)
            .count() as u32;
        
        let success_rate = (successful_connections as f64) / (target_connections as f64) * 100.0;
        let connections_per_second = successful_connections as f64 / establishment_time.as_secs_f64();
        
        result.metrics.insert("max_connections".to_string(), successful_connections as f64);
        result.metrics.insert("connection_success_rate".to_string(), success_rate);
        result.metrics.insert("connections_per_second".to_string(), connections_per_second);
        result.metrics.insert("establishment_time_seconds".to_string(), establishment_time.as_secs_f64());
        
        if success_rate >= 95.0 {
            result.passed += 1;
            self.reporter.log_success(&format!(
                "连接容量测试通过: {}/{} 连接成功 ({:.1}%), 建立速率: {:.1} conn/s",
                successful_connections, target_connections, success_rate, connections_per_second
            )).await;
        } else {
            result.failed += 1;
            self.reporter.log_error(&format!(
                "连接容量测试失败: 成功率 {:.1}% 低于 95%", success_rate
            )).await;
        }
        
        result
    }
    
    /// 测试消息吞吐量
    async fn test_message_throughput(&mut self) -> ValidationResult {
        self.reporter.start_test("消息吞吐量测试").await;
        let mut result = ValidationResult::new();
        
        let client_count = 100;
        let messages_per_client = 1000;
        let test_duration = Duration::from_secs(60);
        
        self.reporter.log_info(&format!(
            "开始吞吐量测试: {} 客户端，每客户端 {} 消息，持续 {} 秒",
            client_count, messages_per_client, test_duration.as_secs()
        )).await;
        
        let start_time = Instant::now();
        let message_counter = Arc::new(AtomicU64::new(0));
        let error_counter = Arc::new(AtomicU64::new(0));
        
        let mut client_tasks = Vec::new();
        
        for i in 0..client_count {
            let msg_counter = message_counter.clone();
            let err_counter = error_counter.clone();
            
            let task = tokio::spawn(async move {
                let client_id = format!("throughput_client_{}", i);
                let client = match TestClient::connect_with_user_token(&client_id).await {
                    Ok(c) => c,
                    Err(_) => {
                        err_counter.fetch_add(messages_per_client as u64, Ordering::Relaxed);
                        return;
                    }
                };
                
                let client_start = Instant::now();
                let mut sent_count = 0u64;
                
                while client_start.elapsed() < test_duration && sent_count < messages_per_client as u64 {
                    let message = json!({
                        "type": "throughput_test",
                        "client_id": i,
                        "message_id": sent_count,
                        "timestamp": chrono::Utc::now().timestamp_millis()
                    });
                    
                    match client.send_message(message.to_string()).await {
                        Ok(_) => {
                            msg_counter.fetch_add(1, Ordering::Relaxed);
                            sent_count += 1;
                        }
                        Err(_) => {
                            err_counter.fetch_add(1, Ordering::Relaxed);
                        }
                    }
                    
                    // 控制发送速率
                    tokio::time::sleep(Duration::from_micros(100)).await;
                }
                
                client.close().await;
            });
            
            client_tasks.push(task);
        }
        
        // 等待所有客户端完成
        join_all(client_tasks).await;
        
        let test_time = start_time.elapsed();
        let total_messages = message_counter.load(Ordering::Relaxed);
        let total_errors = error_counter.load(Ordering::Relaxed);
        let messages_per_second = total_messages as f64 / test_time.as_secs_f64();
        let error_rate = (total_errors as f64) / (total_messages + total_errors) as f64 * 100.0;
        
        result.metrics.insert("total_messages".to_string(), total_messages as f64);
        result.metrics.insert("messages_per_second".to_string(), messages_per_second);
        result.metrics.insert("error_rate_percent".to_string(), error_rate);
        result.metrics.insert("test_duration_seconds".to_string(), test_time.as_secs_f64());
        
        if messages_per_second >= self.config.messages_per_second_target as f64 * 0.8 && error_rate < 1.0 {
            result.passed += 1;
            self.reporter.log_success(&format!(
                "吞吐量测试通过: {:.0} msg/s (目标: {}), 错误率: {:.2}%",
                messages_per_second, self.config.messages_per_second_target, error_rate
            )).await;
        } else {
            result.failed += 1;
            self.reporter.log_error(&format!(
                "吞吐量测试失败: {:.0} msg/s 低于目标 {} 的 80%，或错误率 {:.2}% 过高",
                messages_per_second, self.config.messages_per_second_target, error_rate
            )).await;
        }
        
        result
    }
    
    /// 测试延迟性能
    async fn test_latency_performance(&mut self) -> ValidationResult {
        self.reporter.start_test("延迟性能测试").await;
        let mut result = ValidationResult::new();
        
        let client1 = TestClient::connect_with_user_token("latency_client1").await.unwrap();
        let client2 = TestClient::connect_with_user_token("latency_client2").await.unwrap();
        
        let test_count = 1000;
        let mut latencies = Vec::with_capacity(test_count);
        
        self.reporter.log_info(&format!("开始延迟测试，样本数: {}", test_count)).await;
        
        for i in 0..test_count {
            let send_time = Instant::now();
            let message_id = format!("latency_test_{}", i);
            
            let message = json!({
                "type": "echo_request",
                "message_id": message_id,
                "timestamp": chrono::Utc::now().timestamp_millis()
            });
            
            client1.send_message(message.to_string()).await;
            
            // 等待回显响应
            if let Ok(response) = tokio::time::timeout(Duration::from_secs(5), client1.receive_message()).await {
                if let Ok(response_str) = response {
                    let latency = send_time.elapsed();
                    latencies.push(latency.as_millis() as u64);
                    
                    let response_json: serde_json::Value = serde_json::from_str(&response_str).unwrap();
                    if response_json["message_id"] != message_id {
                        result.warnings.push(format!("消息 ID 不匹配: {}", i));
                    }
                } else {
                    result.warnings.push(format!("消息 {} 接收失败", i));
                }
            } else {
                result.warnings.push(format!("消息 {} 超时", i));
            }
            
            // 控制测试频率
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
        
        client1.close().await;
        client2.close().await;
        
        if latencies.is_empty() {
            result.failed += 1;
            self.reporter.log_error("延迟测试失败：没有有效的延迟样本").await;
            return result;
        }
        
        // 计算延迟统计
        latencies.sort();
        let p50 = latencies[latencies.len() * 50 / 100];
        let p95 = latencies[latencies.len() * 95 / 100];
        let p99 = latencies[latencies.len() * 99 / 100];
        let avg = latencies.iter().sum::<u64>() as f64 / latencies.len() as f64;
        let max = *latencies.last().unwrap();
        let min = *latencies.first().unwrap();
        
        result.metrics.insert("latency_p50_ms".to_string(), p50 as f64);
        result.metrics.insert("latency_p95_ms".to_string(), p95 as f64);
        result.metrics.insert("latency_p99_ms".to_string(), p99 as f64);
        result.metrics.insert("latency_avg_ms".to_string(), avg);
        result.metrics.insert("latency_max_ms".to_string(), max as f64);
        result.metrics.insert("latency_min_ms".to_string(), min as f64);
        
        if p99 <= self.config.latency_p99_threshold_ms {
            result.passed += 1;
            self.reporter.log_success(&format!(
                "延迟测试通过: P99={} ms (阈值: {} ms), P95={} ms, P50={} ms, 平均={:.1} ms",
                p99, self.config.latency_p99_threshold_ms, p95, p50, avg
            )).await;
        } else {
            result.failed += 1;
            self.reporter.log_error(&format!(
                "延迟测试失败: P99={} ms 超过阈值 {} ms",
                p99, self.config.latency_p99_threshold_ms
            )).await;
        }
        
        result
    }
}</pre>

        <p><strong>步骤 3: 最终生产部署</strong></p>
        <pre># scripts/deployment/final-deploy.sh
#!/bin/bash
# 最终生产部署脚本

set -euo pipefail

# 配置变量
NAMESPACE="websocket-production"
RELEASE_NAME="websocket-final"
IMAGE_TAG=${1:-$(git rev-parse --short HEAD)}
ENVIRONMENT="production"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_step() {
    echo -e "${BLUE}[STEP]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_success() {
    echo -e "${PURPLE}[SUCCESS]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1"
}

# 最终部署前检查
pre_deployment_validation() {
    log_step "执行最终部署前验证..."
    
    # 检查所有必需的密钥和配置
    local required_secrets=("JWT_SECRET" "REDIS_PASSWORD" "TLS_CERT" "TLS_KEY" "GRAFANA_ADMIN_PASSWORD")
    for secret in "${required_secrets[@]}"; do
        if [ -z "${!secret:-}" ]; then
            log_error "缺少必需的环境变量: $secret"
            exit 1
        fi
    done
    
    # 检查镜像可用性
    if ! docker manifest inspect "websocket-server:$IMAGE_TAG" &> /dev/null; then
        log_error "镜像 websocket-server:$IMAGE_TAG 不存在或无法访问"
        exit 1
    fi
    
    # 检查 Kubernetes 集群状态
    local ready_nodes=$(kubectl get nodes --no-headers | grep Ready | wc -l)
    if [ "$ready_nodes" -lt 3 ]; then
        log_error "集群节点数量不足，至少需要3个节点，当前: $ready_nodes"
        exit 1
    fi
    
    # 检查集群资源
    local total_cpu=$(kubectl top nodes --no-headers | awk '{sum+=$2} END {print sum}' | sed 's/m$//')
    local total_memory=$(kubectl top nodes --no-headers | awk '{sum+=$4} END {print sum}' | sed 's/Mi$//')
    
    log_info "集群资源状态: CPU=${total_cpu}m, Memory=${total_memory}Mi"
    
    if [ "${total_cpu:-0}" -lt 8000 ]; then
        log_warn "集群 CPU 资源可能不足"
    fi
    
    if [ "${total_memory:-0}" -lt 16384 ]; then
        log_warn "集群内存资源可能不足"
    fi
    
    log_info "部署前验证完成"
}

# 创建生产命名空间
create_production_namespace() {
    log_step "创建生产环境命名空间..."
    
    # 创建命名空间并设置标签
    kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | \
    kubectl label --local -f - \
        environment=production \
        tier=critical \
        monitoring=enabled \
        backup=enabled \
        -o yaml | \
    kubectl apply -f -
    
    # 设置生产级资源配额
    kubectl apply -f - <<EOF
apiVersion: v1
kind: ResourceQuota
metadata:
  name: production-quota
  namespace: $NAMESPACE
spec:
  hard:
    requests.cpu: "20"
    requests.memory: 40Gi
    limits.cpu: "40"
    limits.memory: 80Gi
    persistentvolumeclaims: "20"
    services: "10"
    secrets: "20"
    configmaps: "20"
    count/pods: "50"
---
apiVersion: v1
kind: LimitRange
metadata:
  name: production-limits
  namespace: $NAMESPACE
spec:
  limits:
  - default:
      cpu: "2"
      memory: "4Gi"
    defaultRequest:
      cpu: "500m"
      memory: "1Gi"
    type: Container
  - max:
      cpu: "8"
      memory: "16Gi"
    min:
      cpu: "100m"
      memory: "128Mi"
    type: Container
EOF
    
    log_info "生产命名空间创建完成"
}

# 部署生产级密钥管理
deploy_production_secrets() {
    log_step "部署生产级密钥..."
    
    # 创建 TLS 密钥
    kubectl create secret tls websocket-tls-prod \
        --cert=<(echo "$TLS_CERT" | base64 -d) \
        --key=<(echo "$TLS_KEY" | base64 -d) \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | \
    kubectl label --local -f - \
        environment=production \
        component=security \
        -o yaml | \
    kubectl apply -f -
    
    # 创建应用密钥
    kubectl create secret generic websocket-app-secrets \
        --from-literal=jwt-secret="$JWT_SECRET" \
        --from-literal=redis-password="$REDIS_PASSWORD" \
        --from-literal=grafana-admin-password="$GRAFANA_ADMIN_PASSWORD" \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | \
    kubectl label --local -f - \
        environment=production \
        component=application \
        -o yaml | \
    kubectl apply -f -
    
    # 创建监控密钥
    kubectl create secret generic monitoring-secrets \
        --from-literal=prometheus-admin-password="$(openssl rand -base64 32)" \
        --from-literal=alertmanager-webhook-token="$(openssl rand -base64 32)" \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | \
    kubectl label --local -f - \
        environment=production \
        component=monitoring \
        -o yaml | \
    kubectl apply -f -
    
    log_info "生产密钥部署完成"
}

# 部署生产级基础设施
deploy_production_infrastructure() {
    log_step "部署生产级基础设施..."
    
    # 部署 Redis 高可用集群
    helm repo add bitnami https://charts.bitnami.com/bitnami
    helm repo update
    
    helm upgrade --install redis-ha bitnami/redis \
        --namespace="$NAMESPACE" \
        --version="17.11.3" \
        --set architecture=replication \
        --set auth.enabled=true \
        --set auth.password="$REDIS_PASSWORD" \
        --set master.persistence.enabled=true \
        --set master.persistence.size=50Gi \
        --set master.persistence.storageClass=fast-ssd \
        --set replica.replicaCount=3 \
        --set replica.persistence.enabled=true \
        --set replica.persistence.size=50Gi \
        --set replica.persistence.storageClass=fast-ssd \
        --set master.resources.requests.memory=2Gi \
        --set master.resources.requests.cpu=1000m \
        --set master.resources.limits.memory=4Gi \
        --set master.resources.limits.cpu=2000m \
        --set replica.resources.requests.memory=1Gi \
        --set replica.resources.requests.cpu=500m \
        --set replica.resources.limits.memory=2Gi \
        --set replica.resources.limits.cpu=1000m \
        --set sentinel.enabled=true \
        --set sentinel.masterSet=websocket-redis \
        --set metrics.enabled=true \
        --set metrics.serviceMonitor.enabled=true \
        --wait --timeout=900s
    
    # 部署生产级监控栈
    helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
    helm repo update
    
    # 创建监控配置
    kubectl create configmap prometheus-config \
        --from-file=configs/monitoring/prometheus-production.yml \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    kubectl create configmap grafana-dashboards \
        --from-file=configs/monitoring/dashboards/ \
        --namespace="$NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
        --namespace="$NAMESPACE" \
        --version="48.3.1" \
        --set prometheus.prometheusSpec.retention=90d \
        --set prometheus.prometheusSpec.storageSpec.volumeClaimTemplate.spec.resources.requests.storage=200Gi \
        --set prometheus.prometheusSpec.storageSpec.volumeClaimTemplate.spec.storageClassName=fast-ssd \
        --set prometheus.prometheusSpec.resources.requests.memory=4Gi \
        --set prometheus.prometheusSpec.resources.requests.cpu=2000m \
        --set prometheus.prometheusSpec.resources.limits.memory=8Gi \
        --set prometheus.prometheusSpec.resources.limits.cpu=4000m \
        --set grafana.adminPassword="$GRAFANA_ADMIN_PASSWORD" \
        --set grafana.persistence.enabled=true \
        --set grafana.persistence.size=20Gi \
        --set grafana.persistence.storageClassName=fast-ssd \
        --set grafana.resources.requests.memory=1Gi \
        --set grafana.resources.requests.cpu=500m \
        --set grafana.resources.limits.memory=2Gi \
        --set grafana.resources.limits.cpu=1000m \
        --set grafana.sidecar.dashboards.enabled=true \
        --set grafana.sidecar.datasources.enabled=true \
        --set alertmanager.alertmanagerSpec.storage.volumeClaimTemplate.spec.resources.requests.storage=10Gi \
        --set alertmanager.alertmanagerSpec.storage.volumeClaimTemplate.spec.storageClassName=fast-ssd \
        --wait --timeout=900s
    
    log_info "生产基础设施部署完成"
}

# 部署主应用服务
deploy_websocket_application() {
    log_step "部署 WebSocket 主应用..."
    
    # 创建生产级配置
    cat > /tmp/production-final-values.yaml <<EOF
# 生产级配置
global:
  environment: production
  imageRegistry: docker.io
  storageClass: fast-ssd

image:
  repository: websocket-server
  tag: "$IMAGE_TAG"
  pullPolicy: Always

replicaCount: 5

strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 2

resources:
  requests:
    cpu: 1500m
    memory: 2Gi
  limits:
    cpu: 3000m
    memory: 8Gi

autoscaling:
  enabled: true
  minReplicas: 5
  maxReplicas: 20
  targetCPUUtilizationPercentage: 60
  targetMemoryUtilizationPercentage: 70
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60

service:
  type: ClusterIP
  port: 8080
  targetPort: 8080

ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/websocket-services: "websocket-server"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"
    nginx.ingress.kubernetes.io/upstream-hash-by: "\$remote_addr"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "1000"
    nginx.ingress.kubernetes.io/rate-limit-burst: "2000"
  hosts:
    - host: websocket.production.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: websocket-tls-prod
      hosts:
        - websocket.production.com

config:
  environment: production
  server:
    host: "0.0.0.0"
    port: 8080
    maxConnections: 50000
    connectionTimeout: 300
    heartbeatInterval: 30
    tlsEnabled: true
    workerThreads: 8
  monitoring:
    metricsEnabled: true
    tracingEnabled: true
    healthCheckEnabled: true
    tracingEndpoint: "http://jaeger-collector:14268/api/traces"
    tracingSampleRate: 0.1
  security:
    jwtExpirationHours: 24
    rateLimitEnabled: true
    rateLimitRequestsPerMinute: 1000

secrets:
  existingSecret: "websocket-app-secrets"
  jwtSecretKey: "jwt-secret"
  redisPasswordKey: "redis-password"

redis:
  enabled: false
  external:
    enabled: true
    host: "redis-ha"
    port: 6379
    auth: true
    passwordSecret: "websocket-app-secrets"
    passwordKey: "redis-password"
    sentinel:
      enabled: true
      masterSet: "websocket-redis"

monitoring:
  serviceMonitor:
    enabled: true
    interval: 15s
    scrapeTimeout: 10s
  prometheusRule:
    enabled: true

podDisruptionBudget:
  enabled: true
  minAvailable: 3

networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx
      ports:
      - protocol: TCP
        port: 8080
    - from:
      - namespaceSelector:
          matchLabels:
            name: monitoring
      ports:
      - protocol: TCP
        port: 9090
  egress:
    - to:
      - namespaceSelector:
          matchLabels:
            name: $NAMESPACE
      ports:
      - protocol: TCP
        port: 6379
    - to: []
      ports:
      - protocol: TCP
        port: 53
      - protocol: UDP
        port: 53

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

podSecurityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
    add:
    - NET_BIND_SERVICE
  readOnlyRootFilesystem: true

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - websocket-server
        topologyKey: kubernetes.io/hostname

tolerations:
- key: "dedicated"
  operator: "Equal"
  value: "websocket"
  effect: "NoSchedule"

nodeSelector:
  node-type: "compute-optimized"

persistence:
  enabled: true
  storageClass: "fast-ssd"
  size: 10Gi
  logs:
    enabled: true
    size: 20Gi

backup:
  enabled: true
  schedule: "0 2 * * *"
  retention: "30d"
EOF

    # 部署应用
    helm upgrade --install "$RELEASE_NAME" helm/websocket-server/ \
        --namespace="$NAMESPACE" \
        --values=/tmp/production-final-values.yaml \
        --wait --timeout=900s \
        --atomic
    
    log_info "WebSocket 应用部署完成"
}

# 部署后完整验证
post_deployment_comprehensive_validation() {
    log_step "执行部署后综合验证..."
    
    # 等待所有 Pods 就绪
    log_info "等待 Pods 就绪..."
    kubectl wait --for=condition=ready pod \
        -l app.kubernetes.io/name=websocket-server \
        --namespace="$NAMESPACE" \
        --timeout=600s
    
    # 检查服务状态
    local ready_pods=$(kubectl get pods -l app.kubernetes.io/name=websocket-server \
        --namespace="$NAMESPACE" --no-headers | grep Running | wc -l)
    log_info "就绪的 WebSocket Pods: $ready_pods"
    
    if [ "$ready_pods" -lt 3 ]; then
        log_error "就绪的 Pods 数量不足: $ready_pods"
        exit 1
    fi
    
    # 健康检查
    local service_ip=$(kubectl get service "$RELEASE_NAME" \
        --namespace="$NAMESPACE" -o jsonpath='{.spec.clusterIP}')
    
    log_info "执行健康检查..."
    kubectl run health-check-final --rm -i --restart=Never \
        --image=curlimages/curl:7.87.0 \
        --namespace="$NAMESPACE" -- \
        curl -f --max-time 30 "http://$service_ip:8080/health" || {
        log_error "健康检查失败"
        kubectl logs -l app.kubernetes.io/name=websocket-server --namespace="$NAMESPACE" --tail=100
        exit 1
    }
    
    # 指标检查
    log_info "验证指标端点..."
    kubectl run metrics-check-final --rm -i --restart=Never \
        --image=curlimages/curl:7.87.0 \
        --namespace="$NAMESPACE" -- \
        curl -f --max-time 30 "http://$service_ip:9090/metrics" || {
        log_warn "指标端点检查失败"
    }
    
    # WebSocket 连接测试
    log_info "执行 WebSocket 连接测试..."
    kubectl run websocket-test --rm -i --restart=Never \
        --image=alpine/wscat:v5.2.0 \
        --namespace="$NAMESPACE" -- \
        wscat -c "ws://$service_ip:8080" -x '{"type":"ping"}' || {
        log_warn "WebSocket 连接测试失败"
    }
    
    # 检查监控系统
    log_info "验证监控系统..."
    kubectl get pods -l app=prometheus --namespace="$NAMESPACE" | grep Running || {
        log_warn "Prometheus 未正常运行"
    }
    
    kubectl get pods -l app.kubernetes.io/name=grafana --namespace="$NAMESPACE" | grep Running || {
        log_warn "Grafana 未正常运行"
    }
    
    # 检查存储
    log_info "验证存储配置..."
    kubectl get pvc --namespace="$NAMESPACE" | grep Bound || {
        log_warn "存储卷绑定异常"
    }
    
    log_success "部署后验证完成"
}

# 生成部署报告
generate_deployment_report() {
    log_step "生成部署报告..."
    
    local report_file="deployment-report-$(date +%Y%m%d-%H%M%S).md"
    
    cat > "$report_file" <<EOF
# WebSocket 服务生产部署报告

## 部署信息
- **部署时间**: $(date)
- **镜像版本**: $IMAGE_TAG
- **命名空间**: $NAMESPACE
- **发布名称**: $RELEASE_NAME
- **环境**: $ENVIRONMENT

## 服务状态
\`\`\`
$(kubectl get all -n "$NAMESPACE")
\`\`\`

## Pod 详情
\`\`\`
$(kubectl get pods -l app.kubernetes.io/name=websocket-server -n "$NAMESPACE" -o wide)
\`\`\`

## 资源使用
\`\`\`
$(kubectl top pods -n "$NAMESPACE" --no-headers | head -10)
\`\`\`

## 服务端点
- **WebSocket 服务**: ws://websocket.production.com
- **健康检查**: https://websocket.production.com/health
- **指标**: https://websocket.production.com/metrics
- **Grafana 监控**: https://grafana.production.com
- **Prometheus**: https://prometheus.production.com

## 配置摘要
- **副本数**: 5 (自动扩展: 5-20)
- **资源限制**: CPU 3000m, Memory 8Gi
- **存储**: 10Gi (fast-ssd)
- **网络策略**: 已启用
- **安全上下文**: 非 root 用户

## 验证结果
- ✅ Pod 就绪检查
- ✅ 健康检查
- ✅ 指标端点
- ✅ WebSocket 连接
- ✅ 监控系统
- ✅ 存储配置

## 下一步
1. 配置外部 DNS 指向生产域名
2. 设置备份和恢复流程
3. 配置告警通知
4. 执行负载测试验证
5. 制定运维值班计划

---
报告生成时间: $(date)
EOF
    
    log_success "部署报告已生成: $report_file"
}

# 清理临时文件
cleanup_deployment() {
    log_step "清理部署临时文件..."
    
    rm -f /tmp/production-final-values.yaml
    
    log_info "清理完成"
}

# 主部署流程
main() {
    log_info "开始最终生产部署 - 版本: $IMAGE_TAG"
    
    # 设置错误处理
    trap cleanup_deployment EXIT
    
    pre_deployment_validation
    create_production_namespace
    deploy_production_secrets
    deploy_production_infrastructure
    deploy_websocket_application
    post_deployment_comprehensive_validation
    generate_deployment_report
    
    log_success "🎉 生产部署成功完成！"
    echo
    echo "========================================"
    echo "🚀 WebSocket 服务已成功部署到生产环境"
    echo "📊 访问地址: https://websocket.production.com"
    echo "📈 监控面板: https://grafana.production.com"
    echo "🔍 指标查询: https://prometheus.production.com"
    echo "========================================"
    echo
    log_info "部署状态概览:"
    kubectl get all -n "$NAMESPACE"
}

# 执行主流程
main "$@"</pre>

        <p><strong>步骤 4: 验收报告生成</strong></p>
        <pre># src/reporting/test_reporter.rs
//! 测试报告生成器

use std::collections::HashMap;
use std::fs::{self, File};
use std::io::Write;
use std::path::Path;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use serde_json;

use super::ValidationResult;

/// 测试报告器
pub struct TestReporter {
    suite_name: String,
    start_time: DateTime<Utc>,
    logs: Vec<LogEntry>,
    test_results: Vec<TestResult>,
    metrics: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogEntry {
    timestamp: DateTime<Utc>,
    level: LogLevel,
    message: String,
    context: Option<HashMap<String, String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogLevel {
    Info,
    Success,
    Warning,
    Error,
    Debug,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResult {
    name: String,
    status: TestStatus,
    duration: f64,
    error_message: Option<String>,
    metrics: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TestStatus {
    Passed,
    Failed,
    Skipped,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ValidationReport {
    metadata: ReportMetadata,
    summary: TestSummary,
    test_results: Vec<TestResult>,
    performance_metrics: HashMap<String, f64>,
    security_findings: Vec<SecurityFinding>,
    recommendations: Vec<Recommendation>,
    logs: Vec<LogEntry>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ReportMetadata {
    suite_name: String,
    generated_at: DateTime<Utc>,
    version: String,
    environment: String,
    test_duration_seconds: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TestSummary {
    total_tests: u32,
    passed: u32,
    failed: u32,
    skipped: u32,
    success_rate: f64,
    total_duration: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityFinding {
    severity: String,
    category: String,
    description: String,
    recommendation: String,
    status: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Recommendation {
    priority: String,
    category: String,
    title: String,
    description: String,
    implementation_effort: String,
    expected_impact: String,
}

impl TestReporter {
    pub async fn new(suite_name: &str) -> Self {
        Self {
            suite_name: suite_name.to_string(),
            start_time: Utc::now(),
            logs: Vec::new(),
            test_results: Vec::new(),
            metrics: HashMap::new(),
        }
    }
    
    pub async fn start_test_suite(&mut self, description: &str) {
        self.log_info(&format!("开始测试套件: {}", description)).await;
    }
    
    pub async fn start_test(&mut self, test_name: &str) {
        self.log_info(&format!("开始测试: {}", test_name)).await;
    }
    
    pub async fn log_info(&mut self, message: &str) {
        self.add_log(LogLevel::Info, message, None).await;
    }
    
    pub async fn log_success(&mut self, message: &str) {
        self.add_log(LogLevel::Success, message, None).await;
    }
    
    pub async fn log_warning(&mut self, message: &str) {
        self.add_log(LogLevel::Warning, message, None).await;
    }
    
    pub async fn log_error(&mut self, message: &str) {
        self.add_log(LogLevel::Error, message, None).await;
    }
    
    async fn add_log(&mut self, level: LogLevel, message: &str, context: Option<HashMap<String, String>>) {
        let entry = LogEntry {
            timestamp: Utc::now(),
            level,
            message: message.to_string(),
            context,
        };
        
        self.logs.push(entry);
        
        // 实时输出到控制台
        let level_str = match &self.logs.last().unwrap().level {
            LogLevel::Info => "INFO",
            LogLevel::Success => "SUCCESS",
            LogLevel::Warning => "WARN",
            LogLevel::Error => "ERROR",
            LogLevel::Debug => "DEBUG",
        };
        
        println!("[{}] {}: {}", 
                 self.logs.last().unwrap().timestamp.format("%H:%M:%S"),
                 level_str, 
                 message);
    }
    
    pub async fn finish_test_suite(&mut self, results: ValidationResult) {
        let duration = Utc::now().signed_duration_since(self.start_time);
        self.log_info(&format!(
            "测试套件完成: 通过 {}, 失败 {}, 跳过 {}, 成功率 {:.1}%, 耗时 {:.1}s",
            results.passed, results.failed, results.skipped, 
            results.success_rate(), duration.num_milliseconds() as f64 / 1000.0
        )).await;
        
        self.metrics.extend(results.metrics);
    }
    
    /// 生成完整验收报告
    pub async fn generate_validation_report(&self) -> std::io::Result<ValidationReport> {
        let total_duration = Utc::now().signed_duration_since(self.start_time);
        
        let summary = self.calculate_summary();
        let security_findings = self.generate_security_findings();
        let recommendations = self.generate_recommendations();
        
        let report = ValidationReport {
            metadata: ReportMetadata {
                suite_name: self.suite_name.clone(),
                generated_at: Utc::now(),
                version: env!("CARGO_PKG_VERSION").to_string(),
                environment: std::env::var("ENVIRONMENT").unwrap_or("test".to_string()),
                test_duration_seconds: total_duration.num_milliseconds() as f64 / 1000.0,
            },
            summary,
            test_results: self.test_results.clone(),
            performance_metrics: self.metrics.clone(),
            security_findings,
            recommendations,
            logs: self.logs.clone(),
        };
        
        Ok(report)
    }
    
    /// 生成 HTML 格式报告
    pub async fn generate_html_report(&self, output_path: &str) -> std::io::Result<()> {
        let report = self.generate_validation_report().await?;
        
        let html_content = format!(r#"
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket 服务验收报告</title>
    <style>
        body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 8px 8px 0 0; }}
        .content {{ padding: 30px; }}
        .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }}
        .metric-card {{ background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #667eea; }}
        .metric-value {{ font-size: 2em; font-weight: bold; color: #333; }}
        .metric-label {{ color: #666; margin-top: 5px; }}
        .section {{ margin: 30px 0; }}
        .section h2 {{ color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px; }}
        .test-result {{ background: #f8f9fa; margin: 10px 0; padding: 15px; border-radius: 5px; border-left: 4px solid #28a745; }}
        .test-result.failed {{ border-left-color: #dc3545; }}
        .test-result.skipped {{ border-left-color: #ffc107; }}
        .log-entry {{ font-family: monospace; margin: 5px 0; padding: 8px; background: #f8f9fa; border-radius: 4px; }}
        .log-info {{ border-left: 3px solid #17a2b8; }}
        .log-success {{ border-left: 3px solid #28a745; }}
        .log-warning {{ border-left: 3px solid #ffc107; }}
        .log-error {{ border-left: 3px solid #dc3545; }}
        .chart {{ background: white; padding: 20px; border-radius: 8px; margin: 20px 0; }}
        table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background-color: #f8f9fa; font-weight: bold; }}
        .status-passed {{ color: #28a745; font-weight: bold; }}
        .status-failed {{ color: #dc3545; font-weight: bold; }}
        .status-skipped {{ color: #ffc107; font-weight: bold; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 WebSocket 服务验收报告</h1>
            <p>测试套件: {suite_name}</p>
            <p>生成时间: {generated_at}</p>
            <p>测试环境: {environment}</p>
        </div>
        
        <div class="content">
            <div class="section">
                <h2>📊 测试概览</h2>
                <div class="summary">
                    <div class="metric-card">
                        <div class="metric-value">{total_tests}</div>
                        <div class="metric-label">总测试数</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">{passed}</div>
                        <div class="metric-label">通过</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">{failed}</div>
                        <div class="metric-label">失败</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">{success_rate:.1}%</div>
                        <div class="metric-label">成功率</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">{duration:.1}s</div>
                        <div class="metric-label">测试时长</div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2>🧪 测试结果详情</h2>
                {test_results_html}
            </div>
            
            <div class="section">
                <h2>📈 性能指标</h2>
                <table>
                    <thead>
                        <tr><th>指标名称</th><th>值</th><th>单位</th></tr>
                    </thead>
                    <tbody>
                        {performance_metrics_html}
                    </tbody>
                </table>
            </div>
            
            <div class="section">
                <h2>🔒 安全检查</h2>
                {security_findings_html}
            </div>
            
            <div class="section">
                <h2>💡 优化建议</h2>
                {recommendations_html}
            </div>
            
            <div class="section">
                <h2>📝 详细日志</h2>
                <div style="max-height: 400px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 5px;">
                    {logs_html}
                </div>
            </div>
        </div>
    </div>
</body>
</html>
"#,
            suite_name = report.metadata.suite_name,
            generated_at = report.metadata.generated_at.format("%Y-%m-%d %H:%M:%S UTC"),
            environment = report.metadata.environment,
            total_tests = report.summary.total_tests,
            passed = report.summary.passed,
            failed = report.summary.failed,
            success_rate = report.summary.success_rate,
            duration = report.summary.total_duration,
            test_results_html = self.generate_test_results_html(&report.test_results),
            performance_metrics_html = self.generate_metrics_html(&report.performance_metrics),
            security_findings_html = self.generate_security_html(&report.security_findings),
            recommendations_html = self.generate_recommendations_html(&report.recommendations),
            logs_html = self.generate_logs_html(&report.logs),
        );
        
        fs::write(output_path, html_content)?;
        Ok(())
    }
    
    fn calculate_summary(&self) -> TestSummary {
        let total = self.test_results.len() as u32;
        let passed = self.test_results.iter().filter(|r| matches!(r.status, TestStatus::Passed)).count() as u32;
        let failed = self.test_results.iter().filter(|r| matches!(r.status, TestStatus::Failed)).count() as u32;
        let skipped = self.test_results.iter().filter(|r| matches!(r.status, TestStatus::Skipped)).count() as u32;
        
        let success_rate = if total > 0 { (passed as f64 / total as f64) * 100.0 } else { 0.0 };
        let total_duration = self.test_results.iter().map(|r| r.duration).sum();
        
        TestSummary {
            total_tests: total,
            passed,
            failed,
            skipped,
            success_rate,
            total_duration,
        }
    }
    
    fn generate_security_findings(&self) -> Vec<SecurityFinding> {
        vec![
            SecurityFinding {
                severity: "High".to_string(),
                category: "Authentication".to_string(),
                description: "JWT token 验证机制已实施".to_string(),
                recommendation: "建议定期轮换 JWT 密钥".to_string(),
                status: "Resolved".to_string(),
            },
            SecurityFinding {
                severity: "Medium".to_string(),
                category: "Network".to_string(),
                description: "TLS 加密已启用".to_string(),
                recommendation: "确保使用最新的 TLS 版本".to_string(),
                status: "Resolved".to_string(),
            },
            SecurityFinding {
                severity: "Low".to_string(),
                category: "Logging".to_string(),
                description: "日志中可能包含敏感信息".to_string(),
                recommendation: "实施日志脱敏处理".to_string(),
                status: "Open".to_string(),
            },
        ]
    }
    
    fn generate_recommendations(&self) -> Vec<Recommendation> {
        vec![
            Recommendation {
                priority: "High".to_string(),
                category: "Performance".to_string(),
                title: "实施连接池管理".to_string(),
                description: "添加连接池管理以优化资源使用和性能".to_string(),
                implementation_effort: "Medium".to_string(),
                expected_impact: "提升 20% 性能，减少资源使用".to_string(),
            },
            Recommendation {
                priority: "Medium".to_string(),
                category: "Monitoring".to_string(),
                title: "增强监控指标".to_string(),
                description: "添加更详细的业务指标和用户行为分析".to_string(),
                implementation_effort: "Low".to_string(),
                expected_impact: "改善运维可视性和问题诊断能力".to_string(),
            },
            Recommendation {
                priority: "Low".to_string(),
                category: "Feature".to_string(),
                title: "实施消息持久化".to_string(),
                description: "为关键消息添加持久化存储机制".to_string(),
                implementation_effort: "High".to_string(),
                expected_impact: "提高数据可靠性和用户体验".to_string(),
            },
        ]
    }
    
    // 其他 HTML 生成方法...
    fn generate_test_results_html(&self, results: &[TestResult]) -> String {
        results.iter().map(|result| {
            let status_class = match result.status {
                TestStatus::Passed => "passed",
                TestStatus::Failed => "failed",
                TestStatus::Skipped => "skipped",
            };
            let status_text = match result.status {
                TestStatus::Passed => "✅ 通过",
                TestStatus::Failed => "❌ 失败",
                TestStatus::Skipped => "⏭️ 跳过",
            };
            
            format!(r#"
                <div class="test-result {}">
                    <strong>{}</strong> - {} ({:.2}s)
                    {}
                </div>
            "#, 
                status_class, 
                result.name, 
                status_text, 
                result.duration,
                result.error_message.as_ref().map(|e| format!("<br><em>错误: {}</em>", e)).unwrap_or_default()
            )
        }).collect()
    }
    
    fn generate_metrics_html(&self, metrics: &HashMap<String, f64>) -> String {
        metrics.iter().map(|(name, value)| {
            let (unit, formatted_value) = self.format_metric_value(name, *value);
            format!("<tr><td>{}</td><td>{}</td><td>{}</td></tr>", name, formatted_value, unit)
        }).collect()
    }
    
    fn format_metric_value(&self, name: &str, value: f64) -> (String, String) {
        if name.contains("latency") || name.contains("duration") {
            if name.contains("_ms") {
                ("ms".to_string(), format!("{:.2}", value))
            } else {
                ("s".to_string(), format!("{:.2}", value))
            }
        } else if name.contains("rate") || name.contains("per_second") {
            ("/s".to_string(), format!("{:.0}", value))
        } else if name.contains("percent") {
            ("%".to_string(), format!("{:.1}", value))
        } else if name.contains("memory") && name.contains("mb") {
            ("MB".to_string(), format!("{:.0}", value))
        } else if name.contains("connections") {
            ("count".to_string(), format!("{:.0}", value))
        } else {
            ("".to_string(), format!("{:.2}", value))
        }
    }
    
    fn generate_security_html(&self, findings: &[SecurityFinding]) -> String {
        findings.iter().map(|finding| {
            let severity_class = match finding.severity.as_str() {
                "High" => "status-failed",
                "Medium" => "status-skipped", 
                "Low" => "status-passed",
                _ => "",
            };
            
            format!(r#"
                <div class="test-result">
                    <strong class="{}">{} - {}</strong><br>
                    <em>{}</em><br>
                    <small>建议: {}</small>
                </div>
            "#, severity_class, finding.severity, finding.category, finding.description, finding.recommendation)
        }).collect()
    }
    
    fn generate_recommendations_html(&self, recommendations: &[Recommendation]) -> String {
        recommendations.iter().map(|rec| {
            format!(r#"
                <div class="test-result">
                    <strong>{} ({})</strong><br>
                    <em>{}</em><br>
                    <small>实施难度: {} | 预期影响: {}</small>
                </div>
            "#, rec.title, rec.priority, rec.description, rec.implementation_effort, rec.expected_impact)
        }).collect()
    }
    
    fn generate_logs_html(&self, logs: &[LogEntry]) -> String {
        logs.iter().map(|log| {
            let level_class = match log.level {
                LogLevel::Info => "log-info",
                LogLevel::Success => "log-success",
                LogLevel::Warning => "log-warning",
                LogLevel::Error => "log-error",
                LogLevel::Debug => "log-info",
            };
            
            format!(r#"
                <div class="log-entry {}">
                    [{}] {}
                </div>
            "#, level_class, log.timestamp.format("%H:%M:%S"), log.message)
        }).collect()
    }
}</pre>

        <p><strong>实践练习：</strong></p>
        <ol>
            <li><strong>执行全面验收测试</strong>
                <pre>cd day31_project_validation
./scripts/validation/run-all-tests.sh
cargo test --release --all</pre>
            </li>
            <li><strong>生成验收报告</strong>
                <pre>./scripts/reporting/generate-report.sh
open reports/validation-report.html</pre>
            </li>
            <li><strong>执行最终生产部署</strong>
                <pre>./scripts/deployment/final-deploy.sh v1.0.0
kubectl get all -n websocket-production</pre>
            </li>
            <li><strong>验证生产环境</strong>
                <pre>./scripts/deployment/smoke-test.sh
curl -f https://websocket.production.com/health</pre>
            </li>
            <li><strong>监控系统检查</strong>
                <pre>kubectl port-forward svc/grafana 3000:80 -n websocket-production
open http://localhost:3000</pre>
            </li>
        </ol>

        <p><strong>项目验收标准：</strong></p>
        <ul>
            <li>✅ <strong>功能完整性</strong>: 所有核心功能正常工作，测试通过率 ≥ 95%</li>
            <li>✅ <strong>性能指标</strong>: 支持 10K+ 并发连接，消息延迟 P99 ≤ 100ms</li>
            <li>✅ <strong>可靠性</strong>: 服务可用性 ≥ 99.9%，故障恢复时间 ≤ 30s</li>
            <li>✅ <strong>安全合规</strong>: 通过安全扫描，无高危漏洞</li>
            <li>✅ <strong>运维就绪</strong>: 监控告警完备，日志结构化，文档完整</li>
            <li>✅ <strong>扩展能力</strong>: 支持水平扩展，资源弹性调整</li>
            <li>✅ <strong>部署自动化</strong>: CI/CD 流水线完整，一键部署</li>
            <li>✅ <strong>代码质量</strong>: 代码覆盖率 ≥ 90%，符合最佳实践</li>
        </ul>

        <p><strong>长期运维计划：</strong></p>
        <ul>
            <li>🔄 <strong>持续监控</strong>: 7x24 监控告警，性能趋势分析</li>
            <li>🛡️ <strong>安全维护</strong>: 定期安全扫描，依赖更新管理</li>
            <li>📊 <strong>性能优化</strong>: 月度性能评估，瓶颈识别优化</li>
            <li>🔧 <strong>功能迭代</strong>: 需求收集评估，版本发布管理</li>
            <li>💾 <strong>数据备份</strong>: 自动化备份策略，灾难恢复演练</li>
            <li>📚 <strong>知识传承</strong>: 运维文档更新，团队培训计划</li>
        </ul>

    <h2 style="margin-top: 3em;">✅ 第 31 天项目验收目标</h2>
    <pre>
🎯 项目验收目标（8 月 31 日）：

你将完成一个完整的异步 WebSocket 服务，具备以下能力：

- 支持客户端通过浏览器或 CLI 工具连接并发送消息
- 支持多客户端广播，构建聊天室原型
- 每个客户端连接前进行 token 鉴权
- 日志系统采用 tracing，输出结构化日志
- 所有配置支持通过 ConfigMap 注入
- 已容器化为 docker 镜像，能部署在 Kubernetes 中
- 提供 Helm chart（可选）进行模板化部署
- 项目已上传至 GitHub，带 README 和部署说明
</pre>

    <footer style="margin-top: 3em; font-size: 0.9em; color: #999;">
        本页面由 ChatGPT Rust 项目培训专家生成，适用于个人训练、自学计划与团队培训。
    </footer>
</body>
<a href="#" id="back-to-top">Back to Top</a>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        const toc = document.querySelector("#toc ul");
        const headings = document.querySelectorAll("h2");
        headings.forEach((heading, index) => {
            const id = "day-" + (index + 1);
            heading.id = id;
            const li = document.createElement("li");
            const a = document.createElement("a");
            a.href = "#" + id;
            a.textContent = heading.textContent;
            li.appendChild(a);
            toc.appendChild(li);
        });
        const backToTopButton = document.getElementById("back-to-top");
        window.addEventListener("scroll", () => {
            if (window.pageYOffset > 300) {
                backToTopButton.style.display = "block";
            } else {
                backToTopButton.style.display = "none";
            }
        });
    });
</script>
</html>